<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>async on zhimoe</title><link>https://zhimoe.github.io/tags/async/</link><description>Recent content in async on zhimoe</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sun, 24 Sep 2023 08:47:44 +0800</lastBuildDate><atom:link href="https://zhimoe.github.io/tags/async/index.xml" rel="self" type="application/rss+xml"/><item><title>Python异步编程</title><link>https://zhimoe.github.io/post/python-async-programming/</link><pubDate>Sun, 24 Sep 2023 08:47:44 +0800</pubDate><guid>https://zhimoe.github.io/post/python-async-programming/</guid><description>&lt;p>异步编程很难，但却是最近十年所有编程语言在发力的方向。&lt;br>
在面向CPU计算的场景下，多线程基本都能吃满CPU资源。但是在IO场景下，多线程并不能解决问题，大部分时间线程都在等待IO调用的返回。&lt;br>
实际上python的&lt;a href="https://docs.python.org/3/tutorial/index.html">官方教程&lt;/a>里面并没有async编程的内容，而是在&lt;a href="https://docs.python.org/3/library/ipc.html">std lib doc中网络编程章节&lt;/a>介绍了asyncio这个lib,实际上这也是异步编程的最佳使用场景。&lt;/p>
&lt;p>此外经常会看到“Use async sparingly”,因为异步编程存在染色问题，一旦使用async，会要求你全链路全部为async，否则在block时cpu并无法让出线程资源。&lt;br>
大多数情况，如果出于性能原因不需要异步，线程通常是更简单的替代方案。&lt;/p></description></item></channel></rss>
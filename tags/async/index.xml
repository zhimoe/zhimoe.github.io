<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>async on 香取海</title><link>https://zhimoe.github.io/tags/async/</link><description>Recent content in async on 香取海</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sun, 24 Sep 2023 08:47:44 +0800</lastBuildDate><atom:link href="https://zhimoe.github.io/tags/async/index.xml" rel="self" type="application/rss+xml"/><item><title>Python 异步编程</title><link>https://zhimoe.github.io/post/python-async-programming/</link><pubDate>Sun, 24 Sep 2023 08:47:44 +0800</pubDate><guid>https://zhimoe.github.io/post/python-async-programming/</guid><description>&lt;p>异步编程很难，但却是最近十年所有编程语言在发力的方向。&lt;br>
在面向 CPU 计算的场景下，多线程基本都能吃满 CPU 资源。但是在 IO 场景下，多线程并不能解决问题，大部分时间线程都在等待 IO 调用的返回。&lt;br>
实际上 python 的&lt;a href="https://docs.python.org/3/tutorial/index.html">官方教程&lt;/a>里面并没有 async 编程的内容，而是在&lt;a href="https://docs.python.org/3/library/ipc.html">std lib doc 中网络编程章节&lt;/a>介绍了 asyncio 这个 lib，实际上这也是异步编程的最佳使用场景。&lt;/p>
&lt;p>此外经常会看到 &amp;ldquo;Use async sparingly&amp;rdquo;，因为异步编程存在染色问题，一旦使用 async，会要求你全链路全部为 async，否则在 block 时 cpu 并无法让出线程资源。&lt;br>
大多数情况，如果出于性能原因不需要异步，线程通常是更简单的替代方案。&lt;/p></description></item></channel></rss>
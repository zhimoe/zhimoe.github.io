<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on zhimoe</title><link>https://zhimoe.github.io/tags/java/</link><description>Recent content in java on zhimoe</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sat, 18 Nov 2023 09:45:54 +0800</lastBuildDate><atom:link href="https://zhimoe.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java Vector Api 和 Elasticsearch 性能提升</title><link>https://zhimoe.github.io/post/java-vector-api-with-es/</link><pubDate>Sat, 18 Nov 2023 09:45:54 +0800</pubDate><guid>https://zhimoe.github.io/post/java-vector-api-with-es/</guid><description>&lt;p>OpenJDK project panama 中一个重点功能就是 vector api，可以显著提升矩阵计算密集型程序的性能，例如在图形计算、机器学习、大规模计算（Lucene）等。&lt;/p></description></item><item><title>Java 并发 5-虚拟线程（VirtualThread）</title><link>https://zhimoe.github.io/post/java-concurrency-5-virtualthread/</link><pubDate>Wed, 13 Sep 2023 09:57:52 +0800</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-5-virtualthread/</guid><description>&lt;p>回调和反应式编程都可以实现系统吞吐量有效提升，但是这两种编程模式存在阅读、编写、调试困难的问题，所以实际项目中还是以线程池为主。但是 java 的线程是平台线程，可以理解为并行线程数最多等于 CPU 核数 (macOS 查看核数&lt;code>sysctl hw.physicalcpu hw.logicalcpu&lt;/code>)，并且存在线程内存占用大，上下文切换耗时高问题，所以在高并发请求中表现不如前面两种模式（spring reactive 和 vertx 模式并没有流行起来）。&lt;br>
&lt;a href="https://openjdk.org/jeps/444">JEP 444: Virtual Threads&lt;/a> 主要目标在优化 IO 密集型任务时创建平台线程会消耗过多内存以及线程上下文切换耗时问题。&lt;/p>
&lt;p>虚拟线程的优势：1. 和线程 API 兼容（大部分兼容）2. 降低应用内存使用，提升系统可用性，减少内存不足异常 OutOfMemoryError: unable to create new native thread 3. 提升代码可读性（相比 reactive 编程）。&lt;/p>
&lt;p>本文是 VirtualThread 快速笔记，包含 API 使用、限制和在 Spring Boot 的实际使用以及与 Kotlin 协程的对比。&lt;/p></description></item><item><title>Java 8 Lambda 笔记</title><link>https://zhimoe.github.io/post/java-lambda/</link><pubDate>Thu, 06 Aug 2020 22:49:34 +0800</pubDate><guid>https://zhimoe.github.io/post/java-lambda/</guid><description>&lt;h3 id="问题">问题&lt;/h3>
&lt;p>Java 是 OOP 语言，使用对象封装。由于函数不是一等公民，无法在方法中传递函数/方法。在 Java 8 之前，使用匿名类表示行为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">// 监听器接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">interface&lt;/span> &lt;span style="color:#3f6e75">ActionListener&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">void&lt;/span> &lt;span style="color:#000">actionPerformed&lt;/span>(&lt;span style="color:#000">ActionEvent&lt;/span> &lt;span style="color:#000">e&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">// 使用匿名类传递一个行为&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">button&lt;/span>.&lt;span style="color:#836c28">addActionListener&lt;/span>(&lt;span style="color:#a90d91">new&lt;/span> &lt;span style="color:#000">ActionListener&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">void&lt;/span> &lt;span style="color:#000">actionPerformed&lt;/span>(&lt;span style="color:#000">Event&lt;/span> &lt;span style="color:#000">e&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">System&lt;/span>.&lt;span style="color:#836c28">out&lt;/span>.&lt;span style="color:#836c28">println&lt;/span>(&lt;span style="color:#c41a16">&amp;#34;button clicked&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Java 并发 4-线程池与执行器</title><link>https://zhimoe.github.io/post/java-concurrency-4-threadpool-hierachy/</link><pubDate>Wed, 13 Jun 2018 09:57:52 +0800</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-4-threadpool-hierachy/</guid><description>&lt;h3 id="thread-pool-classes-hierarchy">thread pool classes hierarchy&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>java thread pool class hierarchy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Executor (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|---ExecutorService (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |---AbstractExecutorService (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |---ForkJoinPool (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |---ThreadPoolExecutor (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | | |---ScheduledThreadPoolExecutor (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |---DelegatedExecutorService in Executors (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |---ScheduledExecutorService (java.util.concurrent)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>java 单元测试如何 Mock 有参数的 void 方法</title><link>https://zhimoe.github.io/post/java-how-test-void-method-with-parameter/</link><pubDate>Sun, 23 Apr 2017 21:51:20 +0800</pubDate><guid>https://zhimoe.github.io/post/java-how-test-void-method-with-parameter/</guid><description>&lt;p>测试中如果遇到被测试方法调用 void 方法，在 Mockito 中改如何处理？&lt;/p></description></item><item><title>java generic</title><link>https://zhimoe.github.io/post/java-generic/</link><pubDate>Sun, 01 May 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-generic/</guid><description>&lt;h3 id="泛型">泛型&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">// 类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">class&lt;/span> &lt;span style="color:#3f6e75">Tuple&lt;/span>&lt;span style="color:#000">&amp;lt;&lt;/span>&lt;span style="color:#000">T&lt;/span>, &lt;span style="color:#000">S&lt;/span>&lt;span style="color:#000">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">private&lt;/span> &lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">first&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">private&lt;/span> &lt;span style="color:#000">S&lt;/span> &lt;span style="color:#000">second&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">// 泛型方法也可在非泛型类里面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">class&lt;/span> &lt;span style="color:#3f6e75">ArrayAlg&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">static&lt;/span> &lt;span style="color:#000">&amp;lt;&lt;/span>&lt;span style="color:#000">T&lt;/span>&lt;span style="color:#000">&amp;gt;&lt;/span> &lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">getMiddle&lt;/span>(&lt;span style="color:#000">T&lt;/span>... &lt;span style="color:#000">a&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">a&lt;/span>&lt;span style="color:#000">[&lt;/span>&lt;span style="color:#000">a&lt;/span>.&lt;span style="color:#836c28">length&lt;/span> &lt;span style="color:#000">/&lt;/span> &lt;span style="color:#000">2&lt;/span>&lt;span style="color:#000">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>IO-Java-Stream-Write-Reader</title><link>https://zhimoe.github.io/post/java-io-basic/</link><pubDate>Tue, 01 Mar 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-io-basic/</guid><description>&lt;p>上次总结了 java 中不同读写文件的方法，这次总结一下基本的 IO 流。网上的总结大部分是以 Stream 和 Reader、Writer 来介绍的。这次从封装层次来介绍。&lt;/p></description></item><item><title>Java 6/7/8 中文件读写</title><link>https://zhimoe.github.io/post/java-file-in-v678/</link><pubDate>Mon, 01 Feb 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-file-in-v678/</guid><description>&lt;p>如何在 Java 中读写文件，这里保留 Java6/7 版本，但是你永远不应该使用它们，优先使用 Path、Files、Paths 三个类。&lt;br>
资料：&lt;a href="http://www.javapractices.com/topic/TopicAction.do?Id=42">Reading and writing text files&lt;/a>&lt;/p>
&lt;h2 id="java8-最佳实践">Java8 最佳实践&lt;/h2>
&lt;p>不要用 File 对象，改用 Path 对象，该对象既表示文件路径，也表示文件文本（应该认为文件也是路径的一部分），对于以前的 File，可以 File.toPath() 得到一个 Path 对象。&lt;br>
Files 是一个静态类，操作文件内容.Paths 是静态工具类，操作文件路径，例如拼接文件路径，以前要使用平台无关的分隔符表示：File.pathSeparator、File.separator.&lt;br>
例如，构建一个文件对象：&lt;code>Path path = Paths.get(&amp;quot;~/test/&amp;quot;, &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;a.txt&amp;quot;);&lt;/code>&lt;/p></description></item><item><title>Java AOP example</title><link>https://zhimoe.github.io/post/java-aop-example/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-aop-example/</guid><description>&lt;p>Java AOP: 找到一个最简单的介绍，不怎么想翻译，直接看原文吧：&lt;br>
&lt;a href="https://www.javacodegeeks.com/2012/06/simple-introduction-to-aop.html">A Simple Introduction to AOP&lt;/a>&lt;/p>
&lt;p>注意，使用注解的方式声明切面时，增加了一个空方法去定义 Pointcut，即：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">class&lt;/span> &lt;span style="color:#3f6e75">Test&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">@Pointcut&lt;/span>(&lt;span style="color:#c41a16">&amp;#34;execution(* org.bk.inventory.service.*.*(..))&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">void&lt;/span> &lt;span style="color:#000">serviceMethods&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500">//这是一个空方法用于声明 Pointcut，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500">//后续的 @Before @Around 方法都关联这个方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Java 并发 1-线程与任务</title><link>https://zhimoe.github.io/post/java-concurrency-1-thread/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-1-thread/</guid><description>基本概念 线程：任务执行的环境，可以理解为传送带。注意任务必须在线程上面被执行。 任务：Runnable/Callable 的实现，可以理解</description></item><item><title>Java 并发 2-同步与锁</title><link>https://zhimoe.github.io/post/java-concurrency-2-control/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-2-control/</guid><description>Object.wait/notify/notifyAll 这三个方法是在 class Object 上面的，也就是所有对象都有这个方法。这里对象就是上一篇中类比的资源，可以当成一个信号量。 Object.wait() to suspend a thread（等价</description></item><item><title>Java 并发 3-ThreadLocal</title><link>https://zhimoe.github.io/post/java-concurrency-3-threadlocal/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-3-threadlocal/</guid><description>&lt;p>在通常的业务开发中，ThreadLocal 有两种典型的使用场景。&lt;/p>
&lt;p>场景 1，ThreadLocal 用作保存每个线程独享的对象，为每个线程都创建一个副本，这样每个线程都可以修改自己所拥有的副本，而不会影响其他线程的副本，确保了线程安全。&lt;/p>
&lt;p>场景 2，ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过 ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。&lt;/p></description></item><item><title>Java 动态代理</title><link>https://zhimoe.github.io/post/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid><description>&lt;h3 id="好文">好文&lt;/h3>
&lt;p>&lt;a href="http://www.ibm.com/developerworks/cn/java/j-lo-proxy1/">Java 动态代理机制分析及扩展&lt;/a>&lt;/p>
&lt;p>更深入的一篇：&lt;br>
&lt;a href="http://nemotan.github.io/2015/11/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">java 设计模式 - 动态代理模式&lt;/a>&lt;/p></description></item><item><title>Java 注解和注解处理器</title><link>https://zhimoe.github.io/post/java-annotation-processing/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-annotation-processing/</guid><description>&lt;h3 id="注解处理">注解处理&lt;/h3>
&lt;p>注解是 jdk1.5 出现的，但是自定义处理注解的功能是 1.6 才有的。Element 等关于注解源码抽象的支持类都是 1.6 出现的。&lt;/p></description></item><item><title>Java-==-and-equals</title><link>https://zhimoe.github.io/post/java--and-equal/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java--and-equal/</guid><description>&lt;p>samples code and notes on java == and equals&lt;/p></description></item><item><title>单例模式和序列化</title><link>https://zhimoe.github.io/post/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/</guid><description>&lt;p>Java 单例模式的各种写法和序列化&lt;br>
&lt;a href="http://www.hollischuang.com/archives/205">参考资料&lt;/a>&lt;/p>
&lt;h3 id="饱汉式">饱汉式&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">class&lt;/span> &lt;span style="color:#3f6e75">Singleton&lt;/span> { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">private&lt;/span> &lt;span style="color:#a90d91">static&lt;/span> &lt;span style="color:#000">Singleton&lt;/span> &lt;span style="color:#000">instance&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#a90d91">null&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">private&lt;/span> &lt;span style="color:#000">Singleton&lt;/span> (){} 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	 &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">static&lt;/span> &lt;span style="color:#000">Singleton&lt;/span> &lt;span style="color:#000">getInstance&lt;/span>() { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	 &lt;span style="color:#a90d91">if&lt;/span>(&lt;span style="color:#000">instance&lt;/span> &lt;span style="color:#000">==&lt;/span> &lt;span style="color:#a90d91">null&lt;/span>) &lt;span style="color:#000">instance&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#a90d91">new&lt;/span> &lt;span style="color:#000">Singleton&lt;/span>(); &lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">instance&lt;/span>; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#177500">//饱汉式，使用时创建&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>面试题 - 类加载过程和子类重写父类方法的调用</title><link>https://zhimoe.github.io/post/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%92%8C%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%92%8C%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</guid><description>&lt;p>最近非常火的一道携程面试题 Java&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">class&lt;/span> &lt;span style="color:#3f6e75">Base&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">private&lt;/span> &lt;span style="color:#000">String&lt;/span> &lt;span style="color:#000">baseName&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#c41a16">&amp;#34;base&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#000">Base&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">callName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">void&lt;/span> &lt;span style="color:#000">callName&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">System&lt;/span>.&lt;span style="color:#836c28">out&lt;/span>.&lt;span style="color:#836c28">println&lt;/span>(&lt;span style="color:#000">baseName&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">static&lt;/span> &lt;span style="color:#a90d91">class&lt;/span> &lt;span style="color:#3f6e75">Sub&lt;/span> &lt;span style="color:#a90d91">extends&lt;/span> &lt;span style="color:#000">Base&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">private&lt;/span> &lt;span style="color:#000">String&lt;/span> &lt;span style="color:#000">baseName&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#c41a16">&amp;#34;sub&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">void&lt;/span> &lt;span style="color:#000">callName&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">System&lt;/span>.&lt;span style="color:#836c28">out&lt;/span>.&lt;span style="color:#836c28">println&lt;/span>(&lt;span style="color:#000">baseName&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">static&lt;/span> &lt;span style="color:#a90d91">void&lt;/span> &lt;span style="color:#000">main&lt;/span>(&lt;span style="color:#000">String&lt;/span>&lt;span style="color:#000">[]&lt;/span> &lt;span style="color:#000">args&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Base&lt;/span> &lt;span style="color:#000">b&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#a90d91">new&lt;/span> &lt;span style="color:#000">Sub&lt;/span>(); &lt;span style="color:#177500">// 输出？&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Java 新手如何学习 SpringMVC 框架</title><link>https://zhimoe.github.io/post/how-do-newbie-learn-spring/</link><pubDate>Fri, 21 Aug 2015 22:02:50 +0800</pubDate><guid>https://zhimoe.github.io/post/how-do-newbie-learn-spring/</guid><description>&lt;p>知乎回答备份，&lt;a href="https://www.zhihu.com/question/21142149/answer/52383396">原答案写于 15 年&lt;/a>&lt;br>
6,404 人赞同了该回答&lt;/p></description></item></channel></rss>
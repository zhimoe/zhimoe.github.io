<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>scala on zhimoe</title>
    <link>https://zhimoe.github.io/tags/scala/</link>
    <description>Recent content in scala on zhimoe</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 02 Feb 2022 10:19:05 +0800</lastBuildDate>
    
	<atom:link href="https://zhimoe.github.io/tags/scala/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Scala Python 文件读取跳过转义字符</title>
      <link>https://zhimoe.github.io/post/scala-python-file-encoding-escape/</link>
      <pubDate>Thu, 04 Jun 2020 21:30:31 +0800</pubDate>
      
      <guid>https://zhimoe.github.io/post/scala-python-file-encoding-escape/</guid>
      <description>&lt;p&gt;在文件读取的时候，会遇到非法转义字符，导致文件按行读取失败。此时可以通过忽略转义字符来解决。本文记录了scala和python的方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>scala uniform access principle</title>
      <link>https://zhimoe.github.io/post/scala-uniform-access-principle/</link>
      <pubDate>Fri, 31 Jan 2020 18:40:10 +0800</pubDate>
      
      <guid>https://zhimoe.github.io/post/scala-uniform-access-principle/</guid>
      <description>&lt;p&gt;虽然代码写的很水,但是我对各种编程语言一直比较感兴趣. 除了工作中使用的Java之外,自己也了解Python,Groovy,Scala,Kotlin,Clojure,Go,Rust.其中Python和Scala在工作中也偶尔使用. 了解不同的编程语言语法对于编程思维的影响还是蛮有意思的.
例如, 只会Java的开发者可能没有听过模式匹配(pattern match).在我学习了Scala之后,我对模式匹配的理解就是更强更优雅的switch+if. 而在我看过rust和elixir语言中关于模式匹配之后,我对模式匹配的理解就完全不一样了.&lt;/p&gt;
&lt;p&gt;这些语言中,论说对编程思维改变最大的当属Clojure莫属. Lisp语言是一种非常优雅的语言. 这种优雅的最大特点就是Lisp(Clojure)从语法上面做到了代码即数据.即Clojure的代码形式和其数据结构list的形式是一样的(这也是lisp名字由来,LISt Processor).
这个特点的好处就是Clojure赋予了list这种数据结构强大的表达能力,可以在使用极其简练的语法在list数据结构实现复杂的逻辑.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.&amp;rdquo; —Alan Perlis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽可能的减少语法的规则,这种语法特点在Scala上面也有体现.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Highlights in Scala for Impatient 2nd</title>
      <link>https://zhimoe.github.io/post/highlights-in-scala-for-impatient-2nd/</link>
      <pubDate>Wed, 15 Jan 2020 21:42:33 +0800</pubDate>
      
      <guid>https://zhimoe.github.io/post/highlights-in-scala-for-impatient-2nd/</guid>
      <description>&lt;p&gt;key points in scala-for-impatient 2nd book, best book for java developer to use scala in a rush&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Scala Collection Tips</title>
      <link>https://zhimoe.github.io/post/scala-collection-tips/</link>
      <pubDate>Sun, 19 May 2019 16:49:14 +0800</pubDate>
      
      <guid>https://zhimoe.github.io/post/scala-collection-tips/</guid>
      <description>scala collection 提供了一整套独立于Java的高性能集合,使用上非常灵活,所以需要清楚一些常用的方法: reduce fold scan 集合的符号方法 数组,tuple 2.13的集合架构 reduce fold scan //reduce是一个二元函数,遍历整个集合 List(1, 3, 5).reduceLeft(_ + _) // == ((1+3)+5) //reduceRight start from end of the collection //also you can given initial argument List(1, 3, 5).foldLeft(&amp;#34;&amp;#34;)(_</description>
    </item>
    
    <item>
      <title>Useful Scala Code Snippets</title>
      <link>https://zhimoe.github.io/post/useful-scala-code-snippets/</link>
      <pubDate>Fri, 26 Apr 2019 07:54:00 +0800</pubDate>
      
      <guid>https://zhimoe.github.io/post/useful-scala-code-snippets/</guid>
      <description>merge two map and sum its values 多个map合并,key相同时则value相加 val map1 = Map(1 -&amp;gt; 1, 2 -&amp;gt; 2) val map2 = Map(1 -&amp;gt; 11, 3 -&amp;gt; 3) val map3 = Map(1 -&amp;gt; 111, 3 -&amp;gt; 3) val mapList = List(map1, map2, map3) val merged = mapList.reduce((m1, m2) =&amp;gt; m1 ++ m2.map { case (k, v) =&amp;gt; k -&amp;gt; (v + m1.getOrElse(k, 0)) } ) 文件读 // &amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;可以</description>
    </item>
    
    <item>
      <title>Scala Future</title>
      <link>https://zhimoe.github.io/post/scala-future/</link>
      <pubDate>Sun, 21 Apr 2019 14:36:36 +0800</pubDate>
      
      <guid>https://zhimoe.github.io/post/scala-future/</guid>
      <description>&lt;p&gt;some notes on scala future, includes:&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Pattern Matching Anonymous Function</title>
      <link>https://zhimoe.github.io/post/pattern-matching-anonymous-function/</link>
      <pubDate>Sun, 31 Mar 2019 13:10:41 +0800</pubDate>
      
      <guid>https://zhimoe.github.io/post/pattern-matching-anonymous-function/</guid>
      <description>Scala中很多使用if的地方都可以用match case来替换.常见的就是下面的这种写法: val res = msg match { case it if it.contains(&amp;#34;H&amp;#34;) =&amp;gt; &amp;#34;Hello&amp;#34; case _ =&amp;gt; &amp;#34;Other&amp;#34; } //更常见的用法是去匹配参数的模式: case class Player(name: String, score: Int) def message(player: Player) = player match { case Player(_, score) if score &amp;gt; 100000 =&amp;gt; &amp;#34;Get a job, dude!&amp;#34; case Player(name, _) =&amp;gt; &amp;#34;Hey, $name, nice to see you again!&amp;#34; } def printMessage(player: Player)</description>
    </item>
    
    <item>
      <title>Scala Type Class</title>
      <link>https://zhimoe.github.io/post/scala-type-class/</link>
      <pubDate>Sun, 31 Mar 2019 12:58:17 +0800</pubDate>
      
      <guid>https://zhimoe.github.io/post/scala-type-class/</guid>
      <description>关于scala type class非常好的文章 核心知识点 //scala没有专门的type class语法，而是借助trait + implicit + context bound来实现的， //所以很多时候识别type class比较困难。 //type class 由三部分构成 //1. type class: 即下面的Show，定义一个行</description>
    </item>
    
    <item>
      <title>Scala Implicit</title>
      <link>https://zhimoe.github.io/post/scala-implicit/</link>
      <pubDate>Sat, 30 Mar 2019 12:58:17 +0800</pubDate>
      
      <guid>https://zhimoe.github.io/post/scala-implicit/</guid>
      <description>隐式参数 //隐式参数是在调用时可以自动填充的参数， 需要在调用范围内（scope)有一个隐式变量可供填充。 def addInt(i:Int)(implicit n: Int) = i + n //需要提供一个隐式变量n implicit val sn = 1 addInt(2) // 3 //如果有两个满足类型的隐式变量，则在编译addInt(2)时报错 //scal</description>
    </item>
    
  </channel>
</rss>
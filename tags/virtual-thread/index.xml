<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>virtual thread on 新街记事</title><link>https://zhimoe.github.io/tags/virtual-thread/</link><description>Recent content in virtual thread on 新街记事</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Wed, 13 Sep 2023 09:57:52 +0800</lastBuildDate><atom:link href="https://zhimoe.github.io/tags/virtual-thread/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 并发 5-虚拟线程（VirtualThread）</title><link>https://zhimoe.github.io/post/java-concurrency-5-virtualthread/</link><pubDate>Wed, 13 Sep 2023 09:57:52 +0800</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-5-virtualthread/</guid><description>&lt;p>回调和反应式编程都可以实现系统吞吐量有效提升，但是这两种编程模式存在阅读、编写、调试困难的问题，所以实际项目中还是以线程池为主。但是 java 的线程是平台线程，可以理解为并行线程数最多等于 CPU 核数 (macOS 查看核数&lt;code>sysctl hw.physicalcpu hw.logicalcpu&lt;/code>)，并且存在线程内存占用大，上下文切换耗时高问题，所以在高并发请求中表现不如前面两种模式（spring reactive 和 vertx 模式并没有流行起来）。&lt;br>
&lt;a href="https://openjdk.org/jeps/444">JEP 444: Virtual Threads&lt;/a> 主要目标在优化 IO 密集型任务时创建平台线程会消耗过多内存以及线程上下文切换耗时问题。&lt;/p>
&lt;p>虚拟线程的优势：1. 和线程 API 兼容（大部分兼容）2. 降低应用内存使用，提升系统可用性，减少内存不足异常 OutOfMemoryError: unable to create new native thread 3. 提升代码可读性（相比 reactive 编程）。&lt;/p>
&lt;p>本文是 VirtualThread 快速笔记，包含 API 使用、限制和在 Spring Boot 的实际使用以及与 Kotlin 协程的对比。&lt;/p></description></item></channel></rss>
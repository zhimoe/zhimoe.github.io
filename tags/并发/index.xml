<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>并发 on 新街记事</title><link>https://zhimoe.github.io/tags/%E5%B9%B6%E5%8F%91/</link><description>Recent content in 并发 on 新街记事</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Wed, 13 Sep 2023 09:57:52 +0800</lastBuildDate><atom:link href="https://zhimoe.github.io/tags/%E5%B9%B6%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 并发 5-虚拟线程（VirtualThread）</title><link>https://zhimoe.github.io/post/java-concurrency-5-virtualthread/</link><pubDate>Wed, 13 Sep 2023 09:57:52 +0800</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-5-virtualthread/</guid><description>&lt;p>回调和反应式编程都可以实现系统吞吐量有效提升，但是这两种编程模式存在阅读、编写、调试困难的问题，所以实际项目中还是以线程池为主。但是 java 的线程是平台线程，可以理解为并行线程数最多等于 CPU 核数 (macOS 查看核数&lt;code>sysctl hw.physicalcpu hw.logicalcpu&lt;/code>)，并且存在线程内存占用大，上下文切换耗时高问题，所以在高并发请求中表现不如前面两种模式（spring reactive 和 vertx 模式并没有流行起来）。&lt;br>
&lt;a href="https://openjdk.org/jeps/444">JEP 444: Virtual Threads&lt;/a> 主要目标在优化 IO 密集型任务时创建平台线程会消耗过多内存以及线程上下文切换耗时问题。&lt;/p>
&lt;p>虚拟线程的优势：1. 和线程 API 兼容（大部分兼容）2. 降低应用内存使用，提升系统可用性，减少内存不足异常 OutOfMemoryError: unable to create new native thread 3. 提升代码可读性（相比 reactive 编程）。&lt;/p>
&lt;p>本文是 VirtualThread 快速笔记，包含 API 使用、限制和在 Spring Boot 的实际使用以及与 Kotlin 协程的对比。&lt;/p></description></item><item><title>Java 并发 4-线程池与执行器</title><link>https://zhimoe.github.io/post/java-concurrency-4-threadpool-hierachy/</link><pubDate>Wed, 13 Jun 2018 09:57:52 +0800</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-4-threadpool-hierachy/</guid><description>&lt;h3 id="thread-pool-classes-hierarchy">thread pool classes hierarchy&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>java thread pool class hierarchy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Executor (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|---ExecutorService (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |---AbstractExecutorService (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |---ForkJoinPool (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |---ThreadPoolExecutor (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | | |---ScheduledThreadPoolExecutor (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |---DelegatedExecutorService in Executors (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |---ScheduledExecutorService (java.util.concurrent)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Java 并发 1-线程与任务</title><link>https://zhimoe.github.io/post/java-concurrency-1-thread/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-1-thread/</guid><description>基本概念 线程：任务执行的环境，可以理解为传送带。注意任务必须在线程上面被执行。 任务：Runnable/Callable 的实现，可以理解</description></item><item><title>Java 并发 2-同步与锁</title><link>https://zhimoe.github.io/post/java-concurrency-2-control/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-2-control/</guid><description>Object.wait/notify/notifyAll 这三个方法是在 class Object 上面的，也就是所有对象都有这个方法。这里对象就是上一篇中类比的资源，可以当成一个信号量。 Object.wait() to suspend a thread（等价</description></item><item><title>Java 并发 3-ThreadLocal</title><link>https://zhimoe.github.io/post/java-concurrency-3-threadlocal/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-3-threadlocal/</guid><description>&lt;p>在通常的业务开发中，ThreadLocal 有两种典型的使用场景。&lt;/p>
&lt;p>场景 1，ThreadLocal 用作保存每个线程独享的对象，为每个线程都创建一个副本，这样每个线程都可以修改自己所拥有的副本，而不会影响其他线程的副本，确保了线程安全。&lt;/p>
&lt;p>场景 2，ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过 ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。&lt;/p></description></item></channel></rss>
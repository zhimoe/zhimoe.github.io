<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>About/关于我 on zhimoe</title><link>https://zhimoe.github.io/</link><description>Recent content in About/关于我 on zhimoe</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Wed, 01 May 2019 10:17:46 +0800</lastBuildDate><atom:link href="https://zhimoe.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Java Vector Api 和 Elasticsearch 性能提升</title><link>https://zhimoe.github.io/post/java-vector-api-with-es/</link><pubDate>Sat, 18 Nov 2023 09:45:54 +0800</pubDate><guid>https://zhimoe.github.io/post/java-vector-api-with-es/</guid><description>&lt;p>OpenJDK project panama 中一个重点功能就是 vector api，可以显著提升矩阵计算密集型程序的性能，例如在图形计算、机器学习、大规模计算（Lucene）等。&lt;/p></description></item><item><title>Python @contextlib.contextmanager 的使用</title><link>https://zhimoe.github.io/post/python-contextlib/</link><pubDate>Sun, 05 Nov 2023 21:45:24 +0800</pubDate><guid>https://zhimoe.github.io/post/python-contextlib/</guid><description>&lt;p>日常开发中使用这个注解的情况比较少，今天发现其实有一个临时环境变量设置的使用方式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">with&lt;/span> &lt;span style="color:#000">set_environ&lt;/span>(&lt;span style="color:#000">env_name&lt;/span>, &lt;span style="color:#000">value&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500"># 使用后自动清除 env_name 变量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># env_name 已失效&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>支持中文的等宽编程字体：FangSongCode</title><link>https://zhimoe.github.io/post/programming-font-fangsongcode/</link><pubDate>Sat, 28 Oct 2023 08:12:20 +0800</pubDate><guid>https://zhimoe.github.io/post/programming-font-fangsongcode/</guid><description>&lt;p>个人对于字体有严重的强迫症，在过去十年里（以后应该也会）一直在换各种编程字体，也会使用 fontforge 对字体做一些小修改，甚至在 reddit 上面看的咨询编程字体的图片可以一眼认出。&lt;br>
对于&lt;a href="https://www.programmingfonts.org/">编程等宽字体&lt;/a>，曾经用过比较久的有 Fira Code，Aurulent，TheSansMono，Go Mono，Source Code Pro，Plex Mono，Drafting Mono。也用过一些收费字体例如 MonoLisa，PragmataPro，Operator Mono，Gintronic 等。目前最喜欢的还是 Fira Code（MonoLisa第二），只是 Fira Code 个性突出，在中英文混排中看着非常显眼。&lt;/p></description></item><item><title>Python 异步编程</title><link>https://zhimoe.github.io/post/python-async-programming/</link><pubDate>Sun, 24 Sep 2023 08:47:44 +0800</pubDate><guid>https://zhimoe.github.io/post/python-async-programming/</guid><description>&lt;p>异步编程很难，但却是最近十年所有编程语言在发力的方向。&lt;br>
在面向 CPU 计算的场景下，多线程基本都能吃满 CPU 资源。但是在 IO 场景下，多线程并不能解决问题，大部分时间线程都在等待 IO 调用的返回。&lt;br>
实际上 python 的&lt;a href="https://docs.python.org/3/tutorial/index.html">官方教程&lt;/a>里面并没有 async 编程的内容，而是在&lt;a href="https://docs.python.org/3/library/ipc.html">std lib doc 中网络编程章节&lt;/a>介绍了 asyncio 这个 lib，实际上这也是异步编程的最佳使用场景。&lt;/p>
&lt;p>此外经常会看到 &amp;ldquo;Use async sparingly&amp;rdquo;，因为异步编程存在染色问题，一旦使用 async，会要求你全链路全部为 async，否则在 block 时 cpu 并无法让出线程资源。&lt;br>
大多数情况，如果出于性能原因不需要异步，线程通常是更简单的替代方案。&lt;/p></description></item><item><title>Java 并发 5-虚拟线程（VirtualThread）</title><link>https://zhimoe.github.io/post/java-concurrency-5-virtualthread/</link><pubDate>Wed, 13 Sep 2023 09:57:52 +0800</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-5-virtualthread/</guid><description>&lt;p>回调和反应式编程都可以实现系统吞吐量有效提升，但是这两种编程模式存在阅读、编写、调试困难的问题，所以实际项目中还是以线程池为主。但是 java 的线程是平台线程，可以理解为并行线程数最多等于 CPU 核数 (macOS 查看核数&lt;code>sysctl hw.physicalcpu hw.logicalcpu&lt;/code>)，并且存在线程内存占用大，上下文切换耗时高问题，所以在高并发请求中表现不如前面两种模式（spring reactive 和 vertx 模式并没有流行起来）。&lt;br>
&lt;a href="https://openjdk.org/jeps/444">JEP 444: Virtual Threads&lt;/a> 主要目标在优化 IO 密集型任务时创建平台线程会消耗过多内存以及线程上下文切换耗时问题。&lt;/p>
&lt;p>虚拟线程的优势：1. 和线程 API 兼容（大部分兼容）2. 降低应用内存使用，提升系统可用性，减少内存不足异常 OutOfMemoryError: unable to create new native thread 3. 提升代码可读性（相比 reactive 编程）。&lt;/p>
&lt;p>本文是 VirtualThread 快速笔记，包含 API 使用、限制和在 Spring Boot 的实际使用以及与 Kotlin 协程的对比。&lt;/p></description></item><item><title>Git 内部原理-对象、分支以及底层命令[翻译]</title><link>https://zhimoe.github.io/post/git-internal/</link><pubDate>Sun, 06 Aug 2023 16:06:23 +0800</pubDate><guid>https://zhimoe.github.io/post/git-internal/</guid><description>&lt;p>我们中的许多人每天都在使用 git，但是有多少人知道它的内部是怎么运作的呢？&lt;/p>
&lt;p>例如我们使用 git commit 时发生了什么？提交（commit）与提交之间保存的是什么？两次提交之间难道只是文件的差异（diff）吗？如果是，这个差异是如何编码的？还是说每次提交都会保存一个当前仓库的完整快照（snapshot）呢？我们使用 git init 时到底发生了什么？&lt;/p>
&lt;p>发现一篇非常精彩的 Git 内部原理文章&lt;a href="https://medium.com/swimm/a-visualized-intro-to-git-internals-objects-and-branches-68df85864037">Git 内部原理图解——对象、分支以及如何从零开始建仓库&lt;/a>，&lt;a href="https://www.freecodecamp.org/chinese/news/git-internals-objects-branches-create-repo/">中文翻译&lt;/a>。文章作者甚至制作了&lt;a href="https://www.youtube.com/playlist?list=PL9lx0DXCC4BNUby5H58y6s2TQVLadV8v7">配套讲解视频&lt;/a>&lt;/p></description></item><item><title>Rust Error Handling Notes</title><link>https://zhimoe.github.io/post/rust-error-handling-notes/</link><pubDate>Sat, 22 Jul 2023 21:12:50 +0800</pubDate><guid>https://zhimoe.github.io/post/rust-error-handling-notes/</guid><description>&lt;p>初学 rust 的时候，上手写代码总是遇到很多不一样的 rust 的&lt;code>Result&lt;/code>类型，不同 crate 中的函数返回的&lt;code>Result&amp;lt;T, E&amp;gt;&lt;/code>的&lt;code>E&lt;/code>都不一样，刚开始都是&lt;code>unwrap&lt;/code>或者&lt;code>expect&lt;/code>来处理。如果使用&lt;code>try!&lt;/code>或者&lt;code>?&lt;/code>的话总是编译不通过，还是对 Error 转换和处理不熟练。&lt;/p></description></item><item><title>使用 OpenPyXL 读写 excel 大文件</title><link>https://zhimoe.github.io/post/python-read-large-excel-file/</link><pubDate>Sun, 07 May 2023 19:31:45 +0800</pubDate><guid>https://zhimoe.github.io/post/python-read-large-excel-file/</guid><description>&lt;p>使用 python OpenPyXL 读写 excel 大文件时，有专门的 read_only write-only 模式来提升读写效率。&lt;/p></description></item><item><title>Kotlin Coroutine</title><link>https://zhimoe.github.io/post/kotlin-coroutine/</link><pubDate>Sun, 30 Apr 2023 11:02:29 +0800</pubDate><guid>https://zhimoe.github.io/post/kotlin-coroutine/</guid><description>&lt;pre>&lt;code>A coroutine is an instance of suspendable computation. 
&lt;/code>&lt;/pre>
&lt;p>协程是可被挂起的计算的实例。换句话说协程是一个对象，这个对象保存着一段可以切换线程的任务 + 当前执行的状态两部分信息。&lt;br>
日常涉及协程的编码，主要是描述协程的任务和管理多个协程的生命周期、异常处理等。&lt;/p>
&lt;p>Kotlin 使用堆栈帧管理要运行哪个函数以及所有局部变量。挂起协程时，系统会复制并保存当前的堆栈帧以供稍后使用。恢复时，会将堆栈帧从其保存位置复制回来，然后函数再次开始运行。即使代码可能看起来像普通的顺序阻塞请求，协程也能确保网络请求避免阻塞主线程。&lt;/p></description></item><item><title>在 macOS 通过 SSH 访问 Windows 的 WSL2 Ubuntu</title><link>https://zhimoe.github.io/post/access-into-wsl2-ubuntu-from-macos/</link><pubDate>Sun, 30 Oct 2022 14:14:59 +0800</pubDate><guid>https://zhimoe.github.io/post/access-into-wsl2-ubuntu-from-macos/</guid><description>&lt;p>配置 Windows 和 WSL2，使得能通过其他电脑远程 SSH 到 WSL2 Ubuntu。&lt;/p>
&lt;h3 id="背景">背景&lt;/h3>
&lt;p>之前的电脑配置是 LinuxMint 台式机 + M1 macbook 笔记本。使用 Linux 主要原因是命令行和 Docker. 最近由于二十大，工作 VPN 在 macOS 不让用，只能将台式机安装上 Win10，发现 docker 在 WSL2 运行非常丝滑，这样正好可以当作 macbook 的 Docker 服务器。切换到 Windows 还有一个原因就是，Linux 的桌面真的不行，最近三年各种版本的桌面使用一圈，Budgie，Gnome，Cinnamon，Xfce 这些桌面总是偶尔界面失去响应，KDE 用的不多，卡顿没遇到但是启动总是慢半秒。Win10 除了没有 Bash/Zsh，中文字体垃圾点，其他的都完胜 Linux。&lt;/p>
&lt;p>下面的教程主要参考：&lt;a href="https://jmmv.dev/2022/02/wsl-ssh-access.html">Configuring SSH access into WSL 1 and WSL 2&lt;/a>&lt;/p></description></item><item><title>云原生 Java 开发框架 Quarkus 学习笔记</title><link>https://zhimoe.github.io/post/java-quarkus-notes/</link><pubDate>Sat, 09 Jul 2022 22:14:10 +0800</pubDate><guid>https://zhimoe.github.io/post/java-quarkus-notes/</guid><description>&lt;h2 id="什么是-microprofile">什么是 MicroProfile&lt;/h2>
&lt;p>MicroProfile 是一个微服务的平台定义，目标是针对微服务架构优化企业 Java 开发。由于 JavaEE 的标准更新越来越慢，跟不上 Web 技术与 K8S 的发展，于是一组供应商（包括 Tomitribe）决定创建 MicroProfile, 这是一个优化的微服务架构平台，在 2016 年加入 Eclipse 基金会。&lt;br>
&lt;a href="https://microprofile.io/compatible/5-0/">MicroProfile&lt;/a>是一组规范，包含如 OpenTracing、OpenAPI、RestClient、Config、FaultTolerance、CDI 等一组标准。当前最新标准是 5.0. 各大 Java 厂商有很多实现，最有名的就是红帽的 Quarkus, 其他实现有 Open Liberty 和 Payara Enterprise.&lt;br>
注意 SpringBoot 不是 MicroProfile 规范实现，Boot 是独立于 MicroProfile 和 JavaEE 规范的，但是功能上大同小异，Quarkus 也提供了 Spring 注解的支持。&lt;/p></description></item><item><title>Git 的 detatched Head 模式和解决问题方法</title><link>https://zhimoe.github.io/post/git-detatched-head/</link><pubDate>Wed, 09 Mar 2022 15:49:09 +0800</pubDate><guid>https://zhimoe.github.io/post/git-detatched-head/</guid><description>&lt;p>有时候 commit 完代码后&lt;code>git push&lt;/code>会遇到下面的错误&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>To push the &lt;span style="color:#a90d91">history&lt;/span> leading to the current &lt;span style="color:#000">(&lt;/span>detached HEAD&lt;span style="color:#000">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>错误提示说当前 HEAD 没有指向任何分支，但是你记得明明有指向一个分支的&lt;/p></description></item><item><title>Scala3 缩进语法总结表</title><link>https://zhimoe.github.io/post/scala3-indent-syntax/</link><pubDate>Wed, 02 Feb 2022 10:19:05 +0800</pubDate><guid>https://zhimoe.github.io/post/scala3-indent-syntax/</guid><description>&lt;p>Scala 3 在语法上面新增了一种 Python 的缩进格式，两种格式都可以使用。但是目前部分情况还是需要使用括号。&lt;br>
个人对新语法是支持的。缩进可以极大地提供代码的可读性和整洁，最大的体会就是 SparkStreaming 的 rdd 处理代码，新手容易写出十几个}括号嵌套代码。&lt;br>
当然缺点是缩进不利于代码复制和格式化。&lt;/p>
&lt;p>下面是书本上关于 Scala3 的语法对比。注意，两个语法格式都是支持的。for 和 if 去掉小括号真的是太棒了。&lt;/p></description></item><item><title>Python Tips for Impatient Dev</title><link>https://zhimoe.github.io/post/python-tips-for-impatient-dev/</link><pubDate>Mon, 31 Jan 2022 21:45:45 +0800</pubDate><guid>https://zhimoe.github.io/post/python-tips-for-impatient-dev/</guid><description>&lt;h2 id="python-tricks">Python tricks&lt;/h2>
&lt;h3 id="f-string-的妙用">f-string 的妙用&lt;/h3>
&lt;p>py3.6 开始，推荐使用 f-string，不要使用&lt;code> %s&lt;/code>或者 &lt;code>&amp;quot;&amp;quot;.format()&lt;/code>.如果接收用户输入，使用 Template 做安全校验。&lt;br>
在 python f-string 中可以通过变量或者表达式后面加=实现打印变量名或者表达式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">print&lt;/span>(&lt;span style="color:#c41a16">f&lt;/span>&lt;span style="color:#c41a16">&amp;#39;&lt;/span>&lt;span style="color:#c41a16">{&lt;/span>&lt;span style="color:#000">v&lt;/span>&lt;span style="color:#c41a16">=}&lt;/span>&lt;span style="color:#c41a16">&amp;#39;&lt;/span>) &lt;span style="color:#177500"># 等价 print(f&amp;#39;v={v}&amp;#39;)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">print&lt;/span>(&lt;span style="color:#c41a16">f&lt;/span>&lt;span style="color:#c41a16">&amp;#39;&lt;/span>&lt;span style="color:#c41a16">{&lt;/span>(&lt;span style="color:#a90d91">len&lt;/span>(&lt;span style="color:#000">arr&lt;/span>),&lt;span style="color:#000">v&lt;/span>)&lt;span style="color:#c41a16">=}&lt;/span>&lt;span style="color:#c41a16">&amp;#39;&lt;/span>) 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>参考：调式时&lt;code>icecream&lt;/code>比&lt;code>print&lt;/code> &lt;code>log&lt;/code>更好。&lt;/p></description></item><item><title>使用 Happypack 优化 webpack 打包速度</title><link>https://zhimoe.github.io/post/ts-speed-up-angular-build/</link><pubDate>Sun, 12 Sep 2021 18:02:10 +0800</pubDate><guid>https://zhimoe.github.io/post/ts-speed-up-angular-build/</guid><description>&lt;h3 id="问题">问题&lt;/h3>
&lt;p>一个 ionic app 本地编译需要 8 分钟，提交到流水线编译耗时需要近 40 分钟，从日志看到 webpack 打包步骤耗时最严重。&lt;/p>
&lt;h3 id="排查与解决">排查与解决&lt;/h3>
&lt;p>初步判断是流水线使用的容器 CPU 性能较弱或者存储 mount 性能导致的。找流水线同事支持配置了一个纯内存编译流水线，发现还是很慢。接下来使用 webpack 的插件&lt;a href="https://www.npmjs.com/package/speed-measure-webpack-plugin">speed-measure-webpack-plugin&lt;/a>监控性能。&lt;/p></description></item><item><title>在 githook 中调用 nodejs 脚本</title><link>https://zhimoe.github.io/post/nodejs-as-githook/</link><pubDate>Sun, 22 Aug 2021 21:55:06 +0800</pubDate><guid>https://zhimoe.github.io/post/nodejs-as-githook/</guid><description>&lt;p>如何在 git hook 中调用 nodejs 脚本。主要踩坑在于不知道如何在 bash 中获取 node 脚本返回值，搜了好大一圈。&lt;/p>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>微服务模式开发中，每个小组维护自己的应用，通过一个 nginx 入口反向代理所有的子应用，向用户开放一个站点.nginx 应用中需要维护各个子应用的代理，即 ng.conf 中的 location.&lt;br>
此外，一个应用需要配置 DEV,ST,UAT,PRD 四个环境的 location.目前的做法是 www/ngconf/目录下面分为 dev、st、uat、prd 四个文件夹，在文件夹内部每个小组各自维护一个 conf 文件。&lt;br>
每增加一个应用，需要在四个文件夹中自己小组的配置文件添加配置。随着应用越来越多，以及人员流动，会发生不同文件配置相同的 location entry.&lt;br>
例如 A 应用上线一个功能需要依赖 B 应用，但是新人不知道 B 已经配置过了，所以又重复添加了一个，导致启动报错。&lt;/p></description></item><item><title>Typescript Comprehensive Cheatsheet</title><link>https://zhimoe.github.io/post/ts-comprehensive-notes/</link><pubDate>Sat, 14 Aug 2021 22:06:15 +0800</pubDate><guid>https://zhimoe.github.io/post/ts-comprehensive-notes/</guid><description>&lt;p>一份详尽的 ts 语法笔记。这周在看组里前端同事的代码，感觉完全还是在写 JS，以我有限的 JS/TS 知识，也知道可以写得更加规范一点。但是一上手开始改，还真是手生。&lt;br>
又重新过了一遍文档，做了一点笔记。&lt;/p></description></item><item><title>开源与心理健康[翻译]</title><link>https://zhimoe.github.io/post/open-source-mental-health/</link><pubDate>Thu, 08 Jul 2021 21:29:57 +0800</pubDate><guid>https://zhimoe.github.io/post/open-source-mental-health/</guid><description>&lt;p>我一位亲爱的朋友，也是高产的 Redox OS 贡献者 jD91mZM2 在 2021 年 3 月去世了，年仅 18 岁。他参与了 2018、2019 和 2020 年的 Redox OS 夏季代码活动。他在开发 Redox OS 的各个方面都做出了贡献，从内核，到 relibc，到移植程序。他的工作详细介绍可以在&lt;a href="https://www.redox-os.org/news/">Redox OS 新闻&lt;/a>中署名为 jD91mZM2 的帖子看到。&lt;br>
这个帖子可能是黑暗的、深沉的、沉重的、原始的、未经编辑的。如果你和我们中的许多人一样有自己的问题，请随时与我联系：https://twitter.com/jeremy_soller.在这种情况下，我不建议阅读这篇文章的其他内容。我的结论是，开源要成为可持续发展，还有大量的工作要做，而其中很大一部分是对社区及其成员的健康的关怀。&lt;/p></description></item><item><title>买房装修总结</title><link>https://zhimoe.github.io/post/hangzhou-house-tip/</link><pubDate>Sun, 09 May 2021 09:05:32 +0800</pubDate><guid>https://zhimoe.github.io/post/hangzhou-house-tip/</guid><description>&lt;p>简单记录一下自己买房和装修的一点经验。&lt;/p>
&lt;h2 id="买房">买房&lt;/h2>
&lt;p>自己买房比较离奇，杭州开始实行摇号的半年后，端午节在老家刷微信，看到有个红盘有 6000 多人报名，感觉买房都要开始碰运气了想到了车牌的悲剧，于是返杭后下车就去那个楼盘看了一下，小区旁边在修地铁，看了几眼沙盘，第二天就借钱登记摇号了，没想到第一次就中了。现在回想起就做梦一样。网上关于如何买房的经验特别多，例如&lt;a href="https://github.com/houshanren/hangzhou_house_knowledge">杭州房产知识扫盲&lt;/a>,&lt;a href="https://github.com/ayuer/shanghai_house_knowledge">上海买房&lt;/a>等等。这些我都没用上。这里说说自己的一些经验和踩坑。&lt;/p></description></item><item><title>Tour of Rusts Standard Library Traits[翻译]</title><link>https://zhimoe.github.io/post/rust-standard-library-traits-tour/</link><pubDate>Sun, 11 Apr 2021 21:47:02 +0800</pubDate><guid>https://zhimoe.github.io/post/rust-standard-library-traits-tour/</guid><description>&lt;p>关于 rust trait 非常好的介绍，比 rust book 详细，系统。&lt;/p></description></item><item><title>Python 如何实现一个拼写检查器[翻译]</title><link>https://zhimoe.github.io/post/python-spell-correct/</link><pubDate>Sun, 25 Oct 2020 20:01:27 +0800</pubDate><guid>https://zhimoe.github.io/post/python-spell-correct/</guid><description>&lt;p>谷歌 AI 负责人 norvig 在 07 年写的如何实现一个拼写纠正器的经典博文&lt;a href="https://norvig.com/spell-correct.html">How to Write a Spelling Corrector&lt;/a>.&lt;br>
上面的链接已经是 16 年更新过了，程序也更新到了 python3.&lt;br>
中文版的翻译 &lt;a href="https://blog.csdn.net/suixinsuiyuan33/article/details/69215082">如何实现一个拼写纠正器&lt;/a> 还是基于 07 年版本的。&lt;/p></description></item><item><title>Associated Type in Rust</title><link>https://zhimoe.github.io/post/rust-associated-types/</link><pubDate>Sun, 20 Sep 2020 20:30:41 +0800</pubDate><guid>https://zhimoe.github.io/post/rust-associated-types/</guid><description>&lt;p>Associated Type and generic diff in rust&lt;/p>
&lt;h2 id="type-outside-impl">type outside impl&lt;/h2>
&lt;p>a &lt;code>type Foo = Bar&lt;/code> outside is just type alias. most used in generic type.&lt;/p>
&lt;p>like:&lt;code> type Thunk = Box&amp;lt;dyn Fn() + Send + 'static&amp;gt;;&lt;/code>&lt;/p>
&lt;h2 id="type-inside-impl">type inside impl&lt;/h2>
&lt;p>&lt;code>type&lt;/code> in an &lt;code>impl&lt;/code> defines an associated type. associated type 可以理解为一个类型占位符，在 trait 的方法声明中使用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">pub&lt;/span> &lt;span style="color:#a90d91">trait&lt;/span> &lt;span style="color:#a90d91">Iterator&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">type&lt;/span> &lt;span style="color:#3f6e75">Item&lt;/span>; &lt;span style="color:#177500">// or type T: Display;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">fn&lt;/span> &lt;span style="color:#000">next&lt;/span>(&lt;span style="color:#000">&amp;amp;&lt;/span>&lt;span style="color:#a90d91">mut&lt;/span> &lt;span style="color:#5b269a">self&lt;/span>) -&amp;gt; &lt;span style="color:#a90d91">Option&lt;/span>&lt;span style="color:#000">&amp;lt;&lt;/span>&lt;span style="color:#5b269a">Self&lt;/span>::&lt;span style="color:#000">Item&lt;/span>&lt;span style="color:#000">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>一些英文字体推荐</title><link>https://zhimoe.github.io/post/programming-fonts/</link><pubDate>Fri, 21 Aug 2020 22:02:50 +0800</pubDate><guid>https://zhimoe.github.io/post/programming-fonts/</guid><description>&lt;p>个人对于编程字体有一点点洁癖，在尝试十几个字体后，终于使用 FontForge 和 fontline.py 动手修改制作自己的编程字体:Aurulent 和 Fira Code。&lt;/p>
&lt;h3 id="aurulent">Aurulent&lt;/h3>
&lt;p>&lt;a href="https://github.com/zhimoe/programming-fonts">字体下载&lt;/a>&lt;/p>
&lt;ol>
&lt;li>小写字母来自 Aurulent Sans Mono，其他基于 Fira Code.Aurulent Sans Mono 风格和 SourceCodePro 非常像，胖宽型，大开大合，简单却有具有设计，特别是字符 g，a，p，y，s。&lt;/li>
&lt;li>字母 r 的思路来自&lt;a href="https://www.programmingfonts.org/#gintronic">gintronic&lt;/a>. 优点是在低分辨率屏，r 的末尾不会被 hint 只剩下尖尖。&lt;/li>
&lt;li>问号？也来自 gintronic 字体，非常漂亮。&lt;/li>
&lt;/ol></description></item><item><title>如何正确地系鞋带</title><link>https://zhimoe.github.io/post/how-to-tie-shoelace/</link><pubDate>Fri, 21 Aug 2020 21:42:38 +0800</pubDate><guid>https://zhimoe.github.io/post/how-to-tie-shoelace/</guid><description>&lt;p>Ian 安全结是登山系鞋带的首选，它越穿越紧，不会松开。解鞋带轻轻一拉即开。而且对称美观，上手简单。值得每个人花十分钟学习。&lt;br>
本篇不仅给出 Ian 安全结示意图，还告诉大家如何让安全结和蝴蝶结水平对称，尽可能美观的秘诀。&lt;/p></description></item><item><title>Java 8 Lambda 笔记</title><link>https://zhimoe.github.io/post/java-lambda/</link><pubDate>Thu, 06 Aug 2020 22:49:34 +0800</pubDate><guid>https://zhimoe.github.io/post/java-lambda/</guid><description>&lt;h3 id="问题">问题&lt;/h3>
&lt;p>Java 是 OOP 语言，使用对象封装。由于函数不是一等公民，无法在方法中传递函数/方法。在 Java 8 之前，使用匿名类表示行为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">// 监听器接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">interface&lt;/span> &lt;span style="color:#3f6e75">ActionListener&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">void&lt;/span> &lt;span style="color:#000">actionPerformed&lt;/span>(&lt;span style="color:#000">ActionEvent&lt;/span> &lt;span style="color:#000">e&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">// 使用匿名类传递一个行为&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">button&lt;/span>.&lt;span style="color:#836c28">addActionListener&lt;/span>(&lt;span style="color:#a90d91">new&lt;/span> &lt;span style="color:#000">ActionListener&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">void&lt;/span> &lt;span style="color:#000">actionPerformed&lt;/span>(&lt;span style="color:#000">Event&lt;/span> &lt;span style="color:#000">e&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">System&lt;/span>.&lt;span style="color:#836c28">out&lt;/span>.&lt;span style="color:#836c28">println&lt;/span>(&lt;span style="color:#c41a16">&amp;#34;button clicked&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>基于 MDX 的 web 词典</title><link>https://zhimoe.github.io/post/python-mdict-web/</link><pubDate>Wed, 01 Jul 2020 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/python-mdict-web/</guid><description>&lt;p>Mdict 项目是一个糅合了 MDX 词典、ES 例句搜索和 AI 模型翻译的多源搜索功能 Web 词典。特别适合部署在内网中学习使用或者给孩子学习使用。&lt;br>
python 版本增加了一个机器学习模型翻译.rust 版本也有模型，但是还没来得及加。&lt;/p>
&lt;h3 id="mdict-py">mdict-py&lt;/h3>
&lt;p>&lt;a href="https://github.com/zhimoe/mdict-py">mdict-py 源码&lt;/a>&lt;/p>
&lt;p>Mdict 项目是一个糅合了 MDX 词典、ES 例句搜索和 AI 模型翻译的多源搜索功能 Web 词典。特别适合部署在内网中学习使用或者给孩子学习使用。&lt;/p>
&lt;p>特点：&lt;/p>
&lt;ol>
&lt;li>自动识别中英文选择对应 mdx 词典，目前英文词典包含牛津 8 和朗文 4，中文词典包含汉语词典 3&lt;/li>
&lt;li>英文尝试拼写纠错功能，动词时态纠错&lt;/li>
&lt;li>如果配置了中文会尝试搜索朗文的例句，模糊搜索，对于有英语基础的同学很有用&lt;/li>
&lt;li>如果配置了 AI 模型，会使用机器学习模型翻译，翻译结果比较粗糙，但是可以参考&lt;/li>
&lt;/ol></description></item><item><title>Python 4 道笔试题</title><link>https://zhimoe.github.io/post/python-interview-questions/</link><pubDate>Thu, 04 Jun 2020 21:31:01 +0800</pubDate><guid>https://zhimoe.github.io/post/python-interview-questions/</guid><description>&lt;p>4 道常见的 python 面试题和解答，以及一些 python 陷阱的链接。&lt;/p>
&lt;h2 id="问题">问题&lt;/h2>
&lt;ol>
&lt;li>题目 1&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">def&lt;/span> &lt;span style="color:#000">change&lt;/span>(&lt;span style="color:#000">v&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">v&lt;/span>[&lt;span style="color:#1c01ce">1&lt;/span>] &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#1c01ce">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">v&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">a&lt;/span> &lt;span style="color:#000">=&lt;/span> [&lt;span style="color:#1c01ce">1&lt;/span>, &lt;span style="color:#1c01ce">2&lt;/span>, &lt;span style="color:#1c01ce">3&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">print&lt;/span>(&lt;span style="color:#000">change&lt;/span>(&lt;span style="color:#000">a&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">print&lt;/span>(&lt;span style="color:#000">a&lt;/span>) 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Scala Python 文件读取跳过转义字符</title><link>https://zhimoe.github.io/post/scala-python-file-encoding-escape/</link><pubDate>Thu, 04 Jun 2020 21:30:31 +0800</pubDate><guid>https://zhimoe.github.io/post/scala-python-file-encoding-escape/</guid><description>&lt;p>在文件读取的时候，会遇到非法转义字符，导致文件按行读取失败。此时可以通过忽略转义字符来解决。本文记录了 scala 和 python 的方法。&lt;/p>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>有 50G 的服务器日志，拆分为几千个 txt 文件，编码是 utf8，使用 scala 和 python 按行处理：&lt;/p>
&lt;h3 id="scala">scala&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">def&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">args&lt;/span>&lt;span style="color:#a90d91">:&lt;/span> &lt;span style="color:#a90d91">Array&lt;/span>&lt;span style="color:#000">[&lt;/span>&lt;span style="color:#a90d91">String&lt;/span>&lt;span style="color:#000">])&lt;/span>&lt;span style="color:#a90d91">:&lt;/span> &lt;span style="color:#a90d91">Unit&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">for&lt;/span> &lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">line&lt;/span> &lt;span style="color:#a90d91">&amp;lt;-&lt;/span> &lt;span style="color:#3f6e75">Source&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">fromFile&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#c41a16">&amp;#34;./txt1.log&amp;#34;&lt;/span>&lt;span style="color:#000">,&lt;/span>&lt;span style="color:#c41a16">&amp;#34;UTF8&amp;#34;&lt;/span>&lt;span style="color:#000">).&lt;/span>&lt;span style="color:#000">getLines&lt;/span>&lt;span style="color:#000">())&lt;/span> &lt;span style="color:#000">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">line&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">contains&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#c41a16">&amp;#34;ABC&amp;#34;&lt;/span>&lt;span style="color:#000">))&lt;/span> &lt;span style="color:#000">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500">//do something 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">&lt;/span> &lt;span style="color:#000">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Matplotlib 图例中文乱码解决方案</title><link>https://zhimoe.github.io/post/python-matplotlib-chinese-garbled-solution/</link><pubDate>Fri, 01 May 2020 19:18:05 +0800</pubDate><guid>https://zhimoe.github.io/post/python-matplotlib-chinese-garbled-solution/</guid><description>&lt;p>很久以前写的一个答案，四年来一直有人评论感谢，说只有我的方法是有效的。非常意外也很高兴。也放到博客中里备份吧。&lt;br>
&lt;a href="https://www.zhihu.com/question/25404709/answer/67672003">zhihu.com&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># https://www.zhihu.com/question/25404709/answer/67672003&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">import&lt;/span> &lt;span style="color:#000">matplotlib.font_manager&lt;/span> &lt;span style="color:#a90d91">as&lt;/span> &lt;span style="color:#000">fm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># 微软雅黑，如果需要宋体，可以用 simsun.ttc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">myfont&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#000">fm&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">FontProperties&lt;/span>(&lt;span style="color:#000">fname&lt;/span>&lt;span style="color:#000">=&lt;/span>&lt;span style="color:#c41a16">&amp;#39;C:/Windows/Fonts/msyh.ttc&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># Linux 字体在&amp;#34;/usr/share/fonts/opentype/noto/NotoSansCJK-Regular.ttc&amp;#34;, &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># 需要先安装字体&amp;#34;&amp;gt;sudo apt install fonts-noto-cjk -y&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># MacOS 中文字体文件在&amp;#34;/System/Library/Fonts/PingFang.ttc&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500"># Win10,Linux 已测试，MacOS 未验证&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">import&lt;/span> &lt;span style="color:#000">matplotlib.pyplot&lt;/span> &lt;span style="color:#a90d91">as&lt;/span> &lt;span style="color:#000">plt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">plt&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">clf&lt;/span>() &lt;span style="color:#177500"># 清空画布&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">plt&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">plot&lt;/span>([&lt;span style="color:#1c01ce">1&lt;/span>, &lt;span style="color:#1c01ce">2&lt;/span>, &lt;span style="color:#1c01ce">3&lt;/span>], [&lt;span style="color:#1c01ce">4&lt;/span>, &lt;span style="color:#1c01ce">5&lt;/span>, &lt;span style="color:#1c01ce">6&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">plt&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">xlabel&lt;/span>(&lt;span style="color:#c41a16">&amp;#34;横轴&amp;#34;&lt;/span>,&lt;span style="color:#000">fontproperties&lt;/span>&lt;span style="color:#000">=&lt;/span>&lt;span style="color:#000">myfont&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">plt&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">ylabel&lt;/span>(&lt;span style="color:#c41a16">&amp;#34;纵轴&amp;#34;&lt;/span>,&lt;span style="color:#000">fontproperties&lt;/span>&lt;span style="color:#000">=&lt;/span>&lt;span style="color:#000">myfont&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">plt&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">title&lt;/span>(&lt;span style="color:#c41a16">&amp;#34;pythoner.com&amp;#34;&lt;/span>,&lt;span style="color:#000">fontproperties&lt;/span>&lt;span style="color:#000">=&lt;/span>&lt;span style="color:#000">myfont&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">plt&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">legend&lt;/span>([&lt;span style="color:#c41a16">&amp;#39;图例&amp;#39;&lt;/span>],&lt;span style="color:#000">prop&lt;/span>&lt;span style="color:#000">=&lt;/span>&lt;span style="color:#000">myfont&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">plt&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">show&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Rust Ownerships Lifetimes 教程</title><link>https://zhimoe.github.io/post/rust-ownership-lifetimes/</link><pubDate>Sat, 22 Feb 2020 15:55:13 +0800</pubDate><guid>https://zhimoe.github.io/post/rust-ownership-lifetimes/</guid><description>&lt;p>some notes on rust ownership,reference,string and &amp;amp;str, and lifetimes&lt;/p></description></item><item><title>SpringBoot 应用和 Rust 应用的 Dockerfile 最佳实践</title><link>https://zhimoe.github.io/post/dockerfile-best-practices/</link><pubDate>Mon, 03 Feb 2020 11:30:55 +0800</pubDate><guid>https://zhimoe.github.io/post/dockerfile-best-practices/</guid><description>&lt;p>记录 spring boot 和 rust 项目的 Dockerfile 的最佳实践。&lt;/p>
&lt;h2 id="spring-boot-应用-dockerfile">spring boot 应用 Dockerfile&lt;/h2>
&lt;p>spring.io 提供了一个 boot 应用的&lt;a href="https://spring.io/guides/topicals/spring-boot-docker">Dockerfile&lt;/a>指导。&lt;br>
不过有个问题，这个 Dockerfile 使用的 maven 是项目源码里面 copy 过去的。在一般企业项目中这么做显然不规范，直接使用 maven 基础镜像更合理。&lt;/p></description></item><item><title>Docker CMD ENTRYPOINT 区别</title><link>https://zhimoe.github.io/post/docker-cmd-entrypoint-diff/</link><pubDate>Sun, 02 Feb 2020 21:10:18 +0800</pubDate><guid>https://zhimoe.github.io/post/docker-cmd-entrypoint-diff/</guid><description>&lt;p>记录 docker 中 exec form 和 shell form 的区别，CMD 和 ENTRYPOINT 区别，以及最佳实践。&lt;/p>
&lt;h2 id="exec-form-vs-shell-form">exec form VS shell form&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span># exec form
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;instruction&amp;gt; [&amp;#34;executable&amp;#34;, &amp;#34;param1&amp;#34;, &amp;#34;param2&amp;#34;, ...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># shell form
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;instruction&amp;gt; &amp;lt;command&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>scala uniform access principle</title><link>https://zhimoe.github.io/post/scala-uniform-access-principle/</link><pubDate>Fri, 31 Jan 2020 18:40:10 +0800</pubDate><guid>https://zhimoe.github.io/post/scala-uniform-access-principle/</guid><description>&lt;p>虽然代码写的很水，但是我对各种编程语言一直比较感兴趣。除了工作中使用的 Java 之外，自己也了解 Python,Groovy,Scala,Kotlin,Clojure,Go,Rust.其中 Python 和 Scala 在工作中也偶尔使用。了解不同的编程语言语法对于编程思维的影响还是蛮有意思的。&lt;br>
例如，只会 Java 的开发者可能没有听过模式匹配 (pattern match).在我学习了 Scala 之后，我对模式匹配的理解就是更强更优雅的 switch+if. 而在我看过 rust 和 elixir 语言中关于模式匹配之后，我对模式匹配的理解就完全不一样了。&lt;/p></description></item><item><title>Highlights in Scala for Impatient 2nd</title><link>https://zhimoe.github.io/post/scala-for-impatient-2nd-highlights/</link><pubDate>Wed, 15 Jan 2020 21:42:33 +0800</pubDate><guid>https://zhimoe.github.io/post/scala-for-impatient-2nd-highlights/</guid><description>&lt;p>key points in scala-for-impatient 2nd book, best book for java developer to use scala in a rush.&lt;br>
scala-for-impatient 章节摘要，这本书对于 Java 开发者快速上手 Scala 帮助很大。&lt;/p>
&lt;h3 id="functions">Functions&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>• if expression has a value.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>• A block has a value — the value of its last expression.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>• The Scala for loop is like an “enhanced” Java for loop.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>• Semicolons are (mostly) optional.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>• The void type is Unit.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>• Avoid using `return` in a function.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>• Beware of missing = in a function definition.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>• Exceptions work just like in Java or C++, but you use a “pattern matching” syntax for catch.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>• Scala has no checked exceptions.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Rust Packages Crates Mod Notes</title><link>https://zhimoe.github.io/post/rust-packages-crates-mod/</link><pubDate>Sun, 12 Jan 2020 20:03:33 +0800</pubDate><guid>https://zhimoe.github.io/post/rust-packages-crates-mod/</guid><description>&lt;p>初学 rust 对于项目的 package 和 crate 的关系，module 和文件的关系有点理不清。做了一点笔记。&lt;/p>
&lt;h2 id="packages-and-crates">packages and crates&lt;/h2>
&lt;p>A Cargo.toml is a package. and must have a package name, defined in &lt;code>[package]&lt;/code> table:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#000">package&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">name&lt;/span> = &lt;span style="color:#c41a16">&amp;#34;actix-web&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>git 常用命令备忘录</title><link>https://zhimoe.github.io/post/git-useful-tips/</link><pubDate>Sun, 01 Sep 2019 21:01:06 +0800</pubDate><guid>https://zhimoe.github.io/post/git-useful-tips/</guid><description>&lt;p>记录日常开发中偶尔会遇到的但是总是记不住的 git 命令。&lt;br>
以下技巧都来自于&lt;a href="https://ohshitgit.com/">oh shit git&lt;/a> 和 &lt;a href="https://stackoverflow.com">stackoverflow&lt;/a>，版权归作者所有。&lt;/p></description></item><item><title>DevOps 能力成熟度模型</title><link>https://zhimoe.github.io/post/devops-maturity-model-checklist/</link><pubDate>Wed, 24 Jul 2019 07:58:12 +0800</pubDate><guid>https://zhimoe.github.io/post/devops-maturity-model-checklist/</guid><description>&lt;p>之前听说过 AWS 的软件工程师是需要自己写需求说明书，前后端代码，测试和上线。还有 instagram 的工程师可以做到 python 的代码提交如果合并到主分支后可以在&lt;a href="https://instagram-engineering.com/static-analysis-at-scale-an-instagram-story-8f498ab71a0c">一个小时内&lt;/a>自动部署到生产被用户使用到，感觉这个非常神奇。如果需要做到这个，对组织级与个人都有极高的 devops 能力成熟度要求。&lt;br>
上周代表 CRM 项目通过了信通院的 DevOps 三级认证。感觉提升的空间很大。专门看了一下信通院发布的成熟度模型标准。&lt;/p></description></item><item><title>Scala Collection Tips</title><link>https://zhimoe.github.io/post/scala-collection-tips/</link><pubDate>Sun, 19 May 2019 16:49:14 +0800</pubDate><guid>https://zhimoe.github.io/post/scala-collection-tips/</guid><description>&lt;p>scala collection 提供了一整套独立于 Java 的高性能集合，使用上非常灵活，所以需要清楚一些常用的方法：&lt;/p>
&lt;ul>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> reduce fold scan&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 集合的符号方法&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 数组，tuple&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 2.13 的集合架构&lt;/li>
&lt;/ul></description></item><item><title>使用 GTmetrix 对前端静态资源图片优化[翻译]</title><link>https://zhimoe.github.io/post/frontend-assets-optimize-gtmetrix/</link><pubDate>Sun, 19 May 2019 11:07:26 +0800</pubDate><guid>https://zhimoe.github.io/post/frontend-assets-optimize-gtmetrix/</guid><description>&lt;p>GTmetrix 是一个前端页面测试的网站，可以发现你的站点哪些资源加载速度较慢，并针对性的优化。本文包含如何使用 GTmetrix 优化网站图片性能。&lt;br>
source:&lt;a href="https://gtmetrix.com/blog/how-to-optimize-images-a-practical-guide/">How to Optimize Images: A Practical Guide&lt;/a>&lt;/p></description></item><item><title>Spring FactoryBean and ContextAware</title><link>https://zhimoe.github.io/post/spring-factorybean-contextaware/</link><pubDate>Thu, 16 May 2019 22:44:38 +0800</pubDate><guid>https://zhimoe.github.io/post/spring-factorybean-contextaware/</guid><description>&lt;p>理解 Spring 的 FactoryBean 和 ContextAware 接口。&lt;/p>
&lt;h2 id="factorybean">FactoryBean&lt;/h2>
&lt;p>一句话就是 FactoryBean 用于返回其他对象实例的，而不是自身类型的实例。&lt;/p></description></item><item><title>通过例子学习 Clojure</title><link>https://zhimoe.github.io/post/learn-clojure-by-example/</link><pubDate>Mon, 13 May 2019 15:22:05 +0800</pubDate><guid>https://zhimoe.github.io/post/learn-clojure-by-example/</guid><description>&lt;p>这份笔记试图打造最强的 clojure 小抄，keep refactoring it&amp;hellip;&lt;/p></description></item><item><title>理解 Elasticsearch Query DSL 中的 JSON 结构</title><link>https://zhimoe.github.io/post/elasticsearch-query-dsl/</link><pubDate>Wed, 01 May 2019 10:17:46 +0800</pubDate><guid>https://zhimoe.github.io/post/elasticsearch-query-dsl/</guid><description>&lt;p>理解 ES 搜索中 JSON DSL 有助于自己写 JSON 查询，特别是手写复杂嵌套 json。&lt;/p>
&lt;ul>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> diffs in es 2.x and es 5.x&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> query dsl&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> aggr query&lt;/li>
&lt;/ul></description></item><item><title>Useful Scala Code Snippets</title><link>https://zhimoe.github.io/post/scala-useful-snippets/</link><pubDate>Fri, 26 Apr 2019 07:54:00 +0800</pubDate><guid>https://zhimoe.github.io/post/scala-useful-snippets/</guid><description>&lt;h2 id="merge-two-map-and-sum-its-values">merge two map and sum its values&lt;/h2>
&lt;p>多个 map 合并，key 相同时则 value 相加&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">val&lt;/span> &lt;span style="color:#000">map1&lt;/span> &lt;span style="color:#a90d91">=&lt;/span> &lt;span style="color:#3f6e75">Map&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#1c01ce">1&lt;/span> &lt;span style="color:#000">-&amp;gt;&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>&lt;span style="color:#000">,&lt;/span> &lt;span style="color:#1c01ce">2&lt;/span> &lt;span style="color:#000">-&amp;gt;&lt;/span> &lt;span style="color:#1c01ce">2&lt;/span>&lt;span style="color:#000">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">val&lt;/span> &lt;span style="color:#000">map2&lt;/span> &lt;span style="color:#a90d91">=&lt;/span> &lt;span style="color:#3f6e75">Map&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#1c01ce">1&lt;/span> &lt;span style="color:#000">-&amp;gt;&lt;/span> &lt;span style="color:#1c01ce">11&lt;/span>&lt;span style="color:#000">,&lt;/span> &lt;span style="color:#1c01ce">3&lt;/span> &lt;span style="color:#000">-&amp;gt;&lt;/span> &lt;span style="color:#1c01ce">3&lt;/span>&lt;span style="color:#000">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">val&lt;/span> &lt;span style="color:#000">map3&lt;/span> &lt;span style="color:#a90d91">=&lt;/span> &lt;span style="color:#3f6e75">Map&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#1c01ce">1&lt;/span> &lt;span style="color:#000">-&amp;gt;&lt;/span> &lt;span style="color:#1c01ce">111&lt;/span>&lt;span style="color:#000">,&lt;/span> &lt;span style="color:#1c01ce">3&lt;/span> &lt;span style="color:#000">-&amp;gt;&lt;/span> &lt;span style="color:#1c01ce">3&lt;/span>&lt;span style="color:#000">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">val&lt;/span> &lt;span style="color:#000">mapList&lt;/span> &lt;span style="color:#a90d91">=&lt;/span> &lt;span style="color:#3f6e75">List&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">map1&lt;/span>&lt;span style="color:#000">,&lt;/span> &lt;span style="color:#000">map2&lt;/span>&lt;span style="color:#000">,&lt;/span> &lt;span style="color:#000">map3&lt;/span>&lt;span style="color:#000">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">val&lt;/span> &lt;span style="color:#000">merged&lt;/span> &lt;span style="color:#a90d91">=&lt;/span> &lt;span style="color:#000">mapList&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">reduce&lt;/span>&lt;span style="color:#000">((&lt;/span>&lt;span style="color:#000">m1&lt;/span>&lt;span style="color:#000">,&lt;/span> &lt;span style="color:#000">m2&lt;/span>&lt;span style="color:#000">)&lt;/span> &lt;span style="color:#a90d91">=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">m1&lt;/span> &lt;span style="color:#000">++&lt;/span> &lt;span style="color:#000">m2&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">map&lt;/span> &lt;span style="color:#000">{&lt;/span> &lt;span style="color:#a90d91">case&lt;/span> &lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">k&lt;/span>&lt;span style="color:#000">,&lt;/span> &lt;span style="color:#000">v&lt;/span>&lt;span style="color:#000">)&lt;/span> &lt;span style="color:#a90d91">=&amp;gt;&lt;/span> &lt;span style="color:#000">k&lt;/span> &lt;span style="color:#000">-&amp;gt;&lt;/span> &lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">v&lt;/span> &lt;span style="color:#000">+&lt;/span> &lt;span style="color:#000">m1&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">getOrElse&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">k&lt;/span>&lt;span style="color:#000">,&lt;/span> &lt;span style="color:#1c01ce">0&lt;/span>&lt;span style="color:#000">))&lt;/span> &lt;span style="color:#000">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Scala Future</title><link>https://zhimoe.github.io/post/scala-future/</link><pubDate>Sun, 21 Apr 2019 14:36:36 +0800</pubDate><guid>https://zhimoe.github.io/post/scala-future/</guid><description>&lt;p>some notes on scala future, includes:&lt;/p>
&lt;ul>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> future&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> executor context&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> await future result&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> callback&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> recover&lt;/li>
&lt;/ul></description></item><item><title>Spring Cache Notes</title><link>https://zhimoe.github.io/post/draft/spring-cache-notes/</link><pubDate>Thu, 18 Apr 2019 09:42:12 +0800</pubDate><guid>https://zhimoe.github.io/post/draft/spring-cache-notes/</guid><description>&lt;p>spring 的缓存一些技巧和陷阱&lt;/p></description></item><item><title>Spring Boot Notes</title><link>https://zhimoe.github.io/post/spring-boot-notes/</link><pubDate>Sun, 14 Apr 2019 18:33:22 +0800</pubDate><guid>https://zhimoe.github.io/post/spring-boot-notes/</guid><description>&lt;p>一些容易忘记的 spring boot 知识要点。&lt;/p>
&lt;blockquote>
&lt;p>注意，.yaml 和.yml 文件没任何区别。&lt;/p>
&lt;/blockquote>
&lt;h2 id="配置">配置&lt;/h2>
&lt;h2 id="springbootapplication-注解">SpringBootApplication 注解&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">@SpringBootApplication&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">// &amp;lt;=等价=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">@ComponentScan&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">@EnableAutoConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Pattern Matching Anonymous Function</title><link>https://zhimoe.github.io/post/scala-pattern-matching-anonymous-function/</link><pubDate>Sun, 31 Mar 2019 13:10:41 +0800</pubDate><guid>https://zhimoe.github.io/post/scala-pattern-matching-anonymous-function/</guid><description>&lt;p>Scala 中很多使用 if 的地方都可以用 match case 来替换。常见的就是下面的这种写法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">val&lt;/span> &lt;span style="color:#000">res&lt;/span> &lt;span style="color:#a90d91">=&lt;/span> &lt;span style="color:#000">msg&lt;/span> &lt;span style="color:#a90d91">match&lt;/span> &lt;span style="color:#000">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a90d91">case&lt;/span> &lt;span style="color:#000">it&lt;/span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">it&lt;/span>&lt;span style="color:#000">.&lt;/span>&lt;span style="color:#000">contains&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#c41a16">&amp;#34;H&amp;#34;&lt;/span>&lt;span style="color:#000">)&lt;/span> &lt;span style="color:#a90d91">=&amp;gt;&lt;/span> &lt;span style="color:#c41a16">&amp;#34;Hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a90d91">case&lt;/span> &lt;span style="color:#a90d91">_&lt;/span> &lt;span style="color:#a90d91">=&amp;gt;&lt;/span> &lt;span style="color:#c41a16">&amp;#34;Other&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">//更常见的用法是去匹配参数的模式：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">&lt;/span>&lt;span style="color:#a90d91">case&lt;/span> &lt;span style="color:#a90d91">class&lt;/span> &lt;span style="color:#3f6e75">Player&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">name&lt;/span>&lt;span style="color:#a90d91">:&lt;/span> &lt;span style="color:#a90d91">String&lt;/span>&lt;span style="color:#000">,&lt;/span> &lt;span style="color:#000">score&lt;/span>&lt;span style="color:#a90d91">:&lt;/span> &lt;span style="color:#a90d91">Int&lt;/span>&lt;span style="color:#000">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">def&lt;/span> &lt;span style="color:#000">message&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">player&lt;/span>&lt;span style="color:#a90d91">:&lt;/span> &lt;span style="color:#a90d91">Player&lt;/span>&lt;span style="color:#000">)&lt;/span> &lt;span style="color:#a90d91">=&lt;/span> &lt;span style="color:#000">player&lt;/span> &lt;span style="color:#a90d91">match&lt;/span> &lt;span style="color:#000">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">case&lt;/span> &lt;span style="color:#3f6e75">Player&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#a90d91">_&lt;/span>&lt;span style="color:#000">,&lt;/span> &lt;span style="color:#000">score&lt;/span>&lt;span style="color:#000">)&lt;/span> &lt;span style="color:#a90d91">if&lt;/span> &lt;span style="color:#000">score&lt;/span> &lt;span style="color:#000">&amp;gt;&lt;/span> &lt;span style="color:#1c01ce">100000&lt;/span> &lt;span style="color:#a90d91">=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c41a16">&amp;#34;Get a job, dude!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">case&lt;/span> &lt;span style="color:#3f6e75">Player&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">name&lt;/span>&lt;span style="color:#000">,&lt;/span> &lt;span style="color:#a90d91">_&lt;/span>&lt;span style="color:#000">)&lt;/span> &lt;span style="color:#a90d91">=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c41a16">&amp;#34;Hey, $name, nice to see you again!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">def&lt;/span> &lt;span style="color:#000">printMessage&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">player&lt;/span>&lt;span style="color:#a90d91">:&lt;/span> &lt;span style="color:#a90d91">Player&lt;/span>&lt;span style="color:#000">)&lt;/span> &lt;span style="color:#a90d91">=&lt;/span> &lt;span style="color:#000">println&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">message&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">player&lt;/span>&lt;span style="color:#000">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Scala Type Class</title><link>https://zhimoe.github.io/post/scala-type-class/</link><pubDate>Sun, 31 Mar 2019 12:58:17 +0800</pubDate><guid>https://zhimoe.github.io/post/scala-type-class/</guid><description>&lt;p>scala type class notes:&lt;br>
&lt;a href="https://scalac.io/typeclasses-in-scala">关于 scala type class 非常好的文章&lt;/a>&lt;/p></description></item><item><title>Scala 学习笔记</title><link>https://zhimoe.github.io/post/scala2-notes/</link><pubDate>Sun, 31 Mar 2019 00:11:50 +0800</pubDate><guid>https://zhimoe.github.io/post/scala2-notes/</guid><description>&lt;p>some notes on scala, includes:&lt;/p>
&lt;ul>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> setup with maven&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> import&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> == and eq&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> case class&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> for&amp;hellip;yield&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> companion object and class&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> method and function(def val)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> _ in scala&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> =&amp;gt; in scala&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> () {} in scala&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> implicit&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> string&lt;/li>
&lt;/ul></description></item><item><title>使用 redis 的 hash 优化内存使用[翻译]</title><link>https://zhimoe.github.io/post/redis-hash-optimize-memory-usage/</link><pubDate>Sun, 31 Mar 2019 00:11:50 +0800</pubDate><guid>https://zhimoe.github.io/post/redis-hash-optimize-memory-usage/</guid><description>&lt;p>使用 redis 的 hash 优化内存使用&lt;/p>
&lt;h3 id="问题和方案">问题和方案&lt;/h3>
&lt;p>场景：有 3 亿张图片放在对象存储 (DELL ECS/AMAZON EC2) 上面，现在需要保存图片的 id-&amp;gt;用户 id 的映射。最直接的思路是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">set&lt;/span> &lt;span style="color:#c41a16">&amp;#34;media:1155220&amp;#34;&lt;/span> &lt;span style="color:#c41a16">&amp;#34;user1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">set&lt;/span> &lt;span style="color:#c41a16">&amp;#34;media:1155221&amp;#34;&lt;/span> &lt;span style="color:#c41a16">&amp;#34;user2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样设计 key 之后 3 亿张图片需要 21GB 的内存，因为 redis 的 string 是线性增长的。&lt;/p></description></item><item><title>Scala 2 Implicit</title><link>https://zhimoe.github.io/post/scala-implicit/</link><pubDate>Sat, 30 Mar 2019 12:58:17 +0800</pubDate><guid>https://zhimoe.github.io/post/scala-implicit/</guid><description>&lt;h2 id="隐式参数">隐式参数&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scala" data-lang="scala">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">//隐式参数是在调用时可以自动填充的参数，需要在调用范围内（scope) 有一个隐式变量可供填充。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">&lt;/span>&lt;span style="color:#a90d91">def&lt;/span> &lt;span style="color:#000">addInt&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">i&lt;/span>&lt;span style="color:#a90d91">:&lt;/span>&lt;span style="color:#a90d91">Int&lt;/span>&lt;span style="color:#000">)(&lt;/span>&lt;span style="color:#a90d91">implicit&lt;/span> &lt;span style="color:#000">n&lt;/span>&lt;span style="color:#a90d91">:&lt;/span> &lt;span style="color:#a90d91">Int&lt;/span>&lt;span style="color:#000">)&lt;/span> &lt;span style="color:#a90d91">=&lt;/span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#000">+&lt;/span> &lt;span style="color:#000">n&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">//需要提供一个隐式变量 n
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">&lt;/span>&lt;span style="color:#a90d91">implicit&lt;/span> &lt;span style="color:#a90d91">val&lt;/span> &lt;span style="color:#000">sn&lt;/span> &lt;span style="color:#a90d91">=&lt;/span> &lt;span style="color:#1c01ce">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">addInt&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#1c01ce">2&lt;/span>&lt;span style="color:#000">)&lt;/span> &lt;span style="color:#177500">// 3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">//如果有两个满足类型的隐式变量，则在编译 addInt(2) 时报错
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">//scala 的方法中 ExecutionContext 一般作为 implicit 参数。
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>使用 travis 自动发布 markdown 到博客</title><link>https://zhimoe.github.io/post/publish-markdown-blog-by-travis/</link><pubDate>Sat, 30 Mar 2019 10:56:47 +0800</pubDate><guid>https://zhimoe.github.io/post/publish-markdown-blog-by-travis/</guid><description>&lt;p>如何使用 github pages 和 github actions 构建静态个人博客站点&lt;/p>
&lt;h3 id="update-at-2021">update at 2021&lt;/h3>
&lt;p>更新：github 开放 action 功能后，travis-ci 已经没有必要了，目前博客使用 zhimoe 仓库管理源码，使用 action 编译后将 public 目录同步到 zhimoe.github.io 仓库的 gh-pages 分支。&lt;br>
注意，由于使用了 jsdelivr 的 cdn 功能，切换分支后 theme 的相关静态文件的 path 也要修改。&lt;/p>
&lt;p>github 给个人和组织免费提供 github pages 功能。就是说如果有个 repo 的名字为 zhimoe.github.io (zhimoe 为你的 github username), 那么这个 repo 里面的 master 或者 gh-pages 分支的内容如果存在 index.html, 那么其他人可以通过 &lt;a href="https://zhimoe.github.io">https://zhimoe.github.io&lt;/a> 访问这个站点。&lt;/p></description></item><item><title>wsl-docker-environment</title><link>https://zhimoe.github.io/post/wsl-docker-environment/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/wsl-docker-environment/</guid><description>&lt;p>使用 wsl,MobaXterm,cmder,docker 打造可视化的 linux 开发环境&lt;/p>
&lt;p>离不开 Windows 的理由很多，作为后端开发需要使用 linux 的情况也很多，双系统总归是不方便，而且 linux 下的 GUI 体验也没用 Win 10 好。&lt;br>
如果使用虚拟机，那么文件交换和网络等各种问题也需要解决，对系统的内存要求也更高一些。微软为了让更多的开发人员留在 Win10 上面，开发了 WSL，目前的实际体验已经很棒，&lt;br>
今天介绍一下如何打造一个可视化的 linux 开发环境&amp;ndash;即在 Win10 启动 linux 的 GUI 软件，例如 vs code 等。在 wsl 启动 vs code 写代码可以有效避免一些 Windows 和 linux 的编码和换行问题。&lt;/p>
&lt;p>本教程分为 2 部分：&lt;/p>
&lt;ul>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 配置 wsl 可视化&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 在 wsl 使用 docker&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>以下内容中 &lt;code>wsl&lt;/code>和&lt;code>ubuntu&lt;/code>含义相同，&lt;code>console&lt;/code>和&lt;code>命令行&lt;/code>含义相同。&lt;/p>
&lt;/blockquote></description></item><item><title>Neo4j 入门</title><link>https://zhimoe.github.io/post/neo4j-intro/</link><pubDate>Sat, 01 Dec 2018 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/neo4j-intro/</guid><description>&lt;h3 id="neo4j-图数据库介绍">neo4j 图数据库介绍&lt;/h3>
&lt;p>neo4j 是目前排名最高的图数据库，分为商业和社区版本，社区版只支持单机，而且查询的运行时 (runtime) 不同 (cypher runtime:interpreted(社区版),slotted(企业版)). 数据库排名可以在 &lt;a href="https://db-engines.com/en/ranking/graph+dbms">https://db-engines.com/en/ranking/graph+dbms&lt;/a> 查看，下一代最有前景的开源图数据库是 dgraph，目前还积极开发中，生产未就绪，等他的 Java 客户端再成熟一点可以试用。&lt;/p>
&lt;p>neo4j 数据库中只有 3 个概念：Node, Relationship, Properties. Node 表示实体类别，使用 Label 区分，例如一个节点可以有 Person/Father 等多个标签，Relationship 即关系，雇佣关系，父子关系，投资关系，交易关系等。Node 和 Relationship 都可以有 Proerties，属性自身不分是属于节点还是属于关系，例如 Person 可以有属性 name，关系也可以用属性 name.你可以在 neo4j browser 左侧看到当前数据库的所有 Node Label,Relationship Type,Properties.&lt;/p></description></item><item><title>Jupyter Notebook Install New Package[翻译]</title><link>https://zhimoe.github.io/post/python-jupyter-notebook-install-new-package/</link><pubDate>Thu, 01 Nov 2018 19:04:32 +0800</pubDate><guid>https://zhimoe.github.io/post/python-jupyter-notebook-install-new-package/</guid><description>&lt;h3 id="notes">notes&lt;/h3>
&lt;p>在 pycharm 写代码中如果使用到新的 package，例如&lt;code>numpy&lt;/code>,只需要输入&lt;code>import numpy&lt;/code> 然后 ALT+ENTER 在提示中选择 install new package 即可。&lt;/p>
&lt;p>在 notebook 中，网上的教程都说是&lt;code>!pip install numpy&lt;/code>. 但是这个可能有坑。究其原因是因为：&lt;/p></description></item><item><title>Java 并发 4-线程池与执行器</title><link>https://zhimoe.github.io/post/java-concurrency-4-threadpool-hierachy/</link><pubDate>Wed, 13 Jun 2018 09:57:52 +0800</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-4-threadpool-hierachy/</guid><description>&lt;h3 id="thread-pool-classes-hierarchy">thread pool classes hierarchy&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>java thread pool class hierarchy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Executor (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|---ExecutorService (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |---AbstractExecutorService (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |---ForkJoinPool (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |---ThreadPoolExecutor (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | | |---ScheduledThreadPoolExecutor (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |---DelegatedExecutorService in Executors (java.util.concurrent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |---ScheduledExecutorService (java.util.concurrent)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Spark Basic</title><link>https://zhimoe.github.io/post/spark-basic/</link><pubDate>Sat, 31 Mar 2018 00:17:30 +0800</pubDate><guid>https://zhimoe.github.io/post/spark-basic/</guid><description>&lt;h2 id="引言">引言&lt;/h2>
&lt;p>大数据计算和普通的程序并无本质区别：数据输入=&amp;gt;计算=&amp;gt;输出和结果的持久化。这里的挑战在于计算的效率和容错性。由于数据输入巨大，计算的效率是基本的要求。为了在通用硬件上高效完成大量计算，唯一的途径就是将计算任务拆分分布式计算。这就引出了新的问题：分布式计算资源的管理（Mesos,YARN）,分布式计算失败后的恢复（容错性）（Spark RDD）,以及分布式的数据输入和保存（分布式文件 HDFS）.hadoop 生态圈就是为了解决几个问题设计的 (YARN,MapR,HDFS).只不过在计算这一环节 Spark 做的更加高效取代了 MapR.所以先看下 hadoop 的核心两个组件。&lt;/p></description></item><item><title>java 单元测试如何 Mock 有参数的 void 方法</title><link>https://zhimoe.github.io/post/java-how-test-void-method-with-parameter/</link><pubDate>Sun, 23 Apr 2017 21:51:20 +0800</pubDate><guid>https://zhimoe.github.io/post/java-how-test-void-method-with-parameter/</guid><description>&lt;p>测试中如果遇到被测试方法调用 void 方法，在 Mockito 中改如何处理？&lt;/p></description></item><item><title>java generic</title><link>https://zhimoe.github.io/post/java-generic/</link><pubDate>Sun, 01 May 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-generic/</guid><description>&lt;h3 id="泛型">泛型&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">// 类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">class&lt;/span> &lt;span style="color:#3f6e75">Tuple&lt;/span>&lt;span style="color:#000">&amp;lt;&lt;/span>&lt;span style="color:#000">T&lt;/span>, &lt;span style="color:#000">S&lt;/span>&lt;span style="color:#000">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">private&lt;/span> &lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">first&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">private&lt;/span> &lt;span style="color:#000">S&lt;/span> &lt;span style="color:#000">second&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">// 泛型方法也可在非泛型类里面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">class&lt;/span> &lt;span style="color:#3f6e75">ArrayAlg&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">static&lt;/span> &lt;span style="color:#000">&amp;lt;&lt;/span>&lt;span style="color:#000">T&lt;/span>&lt;span style="color:#000">&amp;gt;&lt;/span> &lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">getMiddle&lt;/span>(&lt;span style="color:#000">T&lt;/span>... &lt;span style="color:#000">a&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">a&lt;/span>&lt;span style="color:#000">[&lt;/span>&lt;span style="color:#000">a&lt;/span>.&lt;span style="color:#836c28">length&lt;/span> &lt;span style="color:#000">/&lt;/span> &lt;span style="color:#000">2&lt;/span>&lt;span style="color:#000">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>IO-Java-Stream-Write-Reader</title><link>https://zhimoe.github.io/post/java-io-basic/</link><pubDate>Tue, 01 Mar 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-io-basic/</guid><description>&lt;p>上次总结了 java 中不同读写文件的方法，这次总结一下基本的 IO 流。网上的总结大部分是以 Stream 和 Reader、Writer 来介绍的。这次从封装层次来介绍。&lt;/p></description></item><item><title>Java 6/7/8 中文件读写</title><link>https://zhimoe.github.io/post/java-file-in-v678/</link><pubDate>Mon, 01 Feb 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-file-in-v678/</guid><description>&lt;p>如何在 Java 中读写文件，这里保留 Java6/7 版本，但是你永远不应该使用它们，优先使用 Path、Files、Paths 三个类。&lt;br>
资料：&lt;a href="http://www.javapractices.com/topic/TopicAction.do?Id=42">Reading and writing text files&lt;/a>&lt;/p>
&lt;h2 id="java8-最佳实践">Java8 最佳实践&lt;/h2>
&lt;p>不要用 File 对象，改用 Path 对象，该对象既表示文件路径，也表示文件文本（应该认为文件也是路径的一部分），对于以前的 File，可以 File.toPath() 得到一个 Path 对象。&lt;br>
Files 是一个静态类，操作文件内容.Paths 是静态工具类，操作文件路径，例如拼接文件路径，以前要使用平台无关的分隔符表示：File.pathSeparator、File.separator.&lt;br>
例如，构建一个文件对象：&lt;code>Path path = Paths.get(&amp;quot;~/test/&amp;quot;, &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;a.txt&amp;quot;);&lt;/code>&lt;/p></description></item><item><title>Java AOP example</title><link>https://zhimoe.github.io/post/java-aop-example/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-aop-example/</guid><description>&lt;p>Java AOP: 找到一个最简单的介绍，不怎么想翻译，直接看原文吧：&lt;br>
&lt;a href="https://www.javacodegeeks.com/2012/06/simple-introduction-to-aop.html">A Simple Introduction to AOP&lt;/a>&lt;/p>
&lt;p>注意，使用注解的方式声明切面时，增加了一个空方法去定义 Pointcut，即：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">class&lt;/span> &lt;span style="color:#3f6e75">Test&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">@Pointcut&lt;/span>(&lt;span style="color:#c41a16">&amp;#34;execution(* org.bk.inventory.service.*.*(..))&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">void&lt;/span> &lt;span style="color:#000">serviceMethods&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500">//这是一个空方法用于声明 Pointcut，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500">//后续的 @Before @Around 方法都关联这个方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Java 并发 1-线程与任务</title><link>https://zhimoe.github.io/post/java-concurrency-1-thread/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-1-thread/</guid><description>基本概念 线程：任务执行的环境，可以理解为传送带。注意任务必须在线程上面被执行。 任务：Runnable/Callable 的实现，可以理解</description></item><item><title>Java 并发 2-同步与锁</title><link>https://zhimoe.github.io/post/java-concurrency-2-control/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-2-control/</guid><description>Object.wait/notify/notifyAll 这三个方法是在 class Object 上面的，也就是所有对象都有这个方法。这里对象就是上一篇中类比的资源，可以当成一个信号量。 Object.wait() to suspend a thread（等价</description></item><item><title>Java 并发 3-ThreadLocal</title><link>https://zhimoe.github.io/post/java-concurrency-3-threadlocal/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-concurrency-3-threadlocal/</guid><description>&lt;p>在通常的业务开发中，ThreadLocal 有两种典型的使用场景。&lt;/p>
&lt;p>场景 1，ThreadLocal 用作保存每个线程独享的对象，为每个线程都创建一个副本，这样每个线程都可以修改自己所拥有的副本，而不会影响其他线程的副本，确保了线程安全。&lt;/p>
&lt;p>场景 2，ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过 ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。&lt;/p></description></item><item><title>Java 动态代理</title><link>https://zhimoe.github.io/post/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid><description>&lt;h3 id="好文">好文&lt;/h3>
&lt;p>&lt;a href="http://www.ibm.com/developerworks/cn/java/j-lo-proxy1/">Java 动态代理机制分析及扩展&lt;/a>&lt;/p>
&lt;p>更深入的一篇：&lt;br>
&lt;a href="http://nemotan.github.io/2015/11/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">java 设计模式 - 动态代理模式&lt;/a>&lt;/p></description></item><item><title>Java 注解和注解处理器</title><link>https://zhimoe.github.io/post/java-annotation-processing/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java-annotation-processing/</guid><description>&lt;h3 id="注解处理">注解处理&lt;/h3>
&lt;p>注解是 jdk1.5 出现的，但是自定义处理注解的功能是 1.6 才有的。Element 等关于注解源码抽象的支持类都是 1.6 出现的。&lt;/p></description></item><item><title>Java-==-and-equals</title><link>https://zhimoe.github.io/post/java--and-equal/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java--and-equal/</guid><description>&lt;p>samples code and notes on java == and equals&lt;/p></description></item><item><title>单例模式和序列化</title><link>https://zhimoe.github.io/post/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/</guid><description>&lt;p>Java 单例模式的各种写法和序列化&lt;br>
&lt;a href="http://www.hollischuang.com/archives/205">参考资料&lt;/a>&lt;/p>
&lt;h3 id="饱汉式">饱汉式&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">class&lt;/span> &lt;span style="color:#3f6e75">Singleton&lt;/span> { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">private&lt;/span> &lt;span style="color:#a90d91">static&lt;/span> &lt;span style="color:#000">Singleton&lt;/span> &lt;span style="color:#000">instance&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#a90d91">null&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">private&lt;/span> &lt;span style="color:#000">Singleton&lt;/span> (){} 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	 &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">static&lt;/span> &lt;span style="color:#000">Singleton&lt;/span> &lt;span style="color:#000">getInstance&lt;/span>() { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	 &lt;span style="color:#a90d91">if&lt;/span>(&lt;span style="color:#000">instance&lt;/span> &lt;span style="color:#000">==&lt;/span> &lt;span style="color:#a90d91">null&lt;/span>) &lt;span style="color:#000">instance&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#a90d91">new&lt;/span> &lt;span style="color:#000">Singleton&lt;/span>(); &lt;span style="color:#a90d91">return&lt;/span> &lt;span style="color:#000">instance&lt;/span>; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#177500">//饱汉式，使用时创建&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>理解 Gradle build 脚本结构与语法</title><link>https://zhimoe.github.io/post/gradle-buildscript/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/gradle-buildscript/</guid><description>&lt;p>在看这个之前，希望你有用 ant 或者 maven 的使用经验，还有，对 groovy 的语法有一个简单的了解，不懂也没关系，下面会介绍。&lt;br>
理解 gradle 文件的前提是理解一个重要的 groovy 概念 &amp;ndash; closure&lt;/p>
&lt;h4 id="closure">closure&lt;/h4>
&lt;p>一个 closure 是一个定义在 groovy 文件中的{}代码块，这个代码块类似 js 中的匿名函数，它可以被赋值给变量，可以被调用，可以接收参数，还可以作为参数传递给别的函数。&lt;/p>
&lt;p>closure 中最重要的两个概念是委托对象和作为参数传递的语法格式（理解 gradle 文件很重要）。&lt;/p></description></item><item><title>面试题 - 类加载过程和子类重写父类方法的调用</title><link>https://zhimoe.github.io/post/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%92%8C%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/post/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%92%8C%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</guid><description>&lt;p>最近非常火的一道携程面试题 Java&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">class&lt;/span> &lt;span style="color:#3f6e75">Base&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">private&lt;/span> &lt;span style="color:#000">String&lt;/span> &lt;span style="color:#000">baseName&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#c41a16">&amp;#34;base&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#000">Base&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">callName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">void&lt;/span> &lt;span style="color:#000">callName&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">System&lt;/span>.&lt;span style="color:#836c28">out&lt;/span>.&lt;span style="color:#836c28">println&lt;/span>(&lt;span style="color:#000">baseName&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">static&lt;/span> &lt;span style="color:#a90d91">class&lt;/span> &lt;span style="color:#3f6e75">Sub&lt;/span> &lt;span style="color:#a90d91">extends&lt;/span> &lt;span style="color:#000">Base&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">private&lt;/span> &lt;span style="color:#000">String&lt;/span> &lt;span style="color:#000">baseName&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#c41a16">&amp;#34;sub&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">void&lt;/span> &lt;span style="color:#000">callName&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">System&lt;/span>.&lt;span style="color:#836c28">out&lt;/span>.&lt;span style="color:#836c28">println&lt;/span>(&lt;span style="color:#000">baseName&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">static&lt;/span> &lt;span style="color:#a90d91">void&lt;/span> &lt;span style="color:#000">main&lt;/span>(&lt;span style="color:#000">String&lt;/span>&lt;span style="color:#000">[]&lt;/span> &lt;span style="color:#000">args&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Base&lt;/span> &lt;span style="color:#000">b&lt;/span> &lt;span style="color:#000">=&lt;/span> &lt;span style="color:#a90d91">new&lt;/span> &lt;span style="color:#000">Sub&lt;/span>(); &lt;span style="color:#177500">// 输出？&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Java 新手如何学习 SpringMVC 框架</title><link>https://zhimoe.github.io/post/how-do-newbie-learn-spring/</link><pubDate>Fri, 21 Aug 2015 22:02:50 +0800</pubDate><guid>https://zhimoe.github.io/post/how-do-newbie-learn-spring/</guid><description>&lt;p>知乎回答备份，&lt;a href="https://www.zhihu.com/question/21142149/answer/52383396">原答案写于 15 年&lt;/a>&lt;br>
6,404 人赞同了该回答&lt;/p></description></item><item><title>你的半步，我的天涯</title><link>https://zhimoe.github.io/post/hanamitsuki-movie-review/</link><pubDate>Fri, 09 Aug 2013 23:05:01 +0800</pubDate><guid>https://zhimoe.github.io/post/hanamitsuki-movie-review/</guid><description>好久没看过爱情电影了，当《山楂树》赚尽眼泪时我没有看，当《那些年》红遍两岸时，我没有看。因为没有选择，看了这部电影。 《HANAMITS</description></item><item><title>写在 2012 岁末</title><link>https://zhimoe.github.io/post/goodbye-2012/</link><pubDate>Sun, 30 Dec 2012 23:50:24 +0800</pubDate><guid>https://zhimoe.github.io/post/goodbye-2012/</guid><description>&lt;pre>&lt;code> 时光如水，哗啦啦又是一年；
 岁月如歌，唏哩哩唱不成调。
&lt;/code>&lt;/pre></description></item><item><title>小城</title><link>https://zhimoe.github.io/post/essay-small-town/</link><pubDate>Thu, 23 Jun 2011 16:53:00 +0800</pubDate><guid>https://zhimoe.github.io/post/essay-small-town/</guid><description>我不喜欢西安，喜欢一个地方需要时间，而我还找不到理由。我不喜欢因为我仅仅是在这里生活。 我喜欢玉山，因为那里有曾经的我。一个人走在街上，</description></item><item><title>一点回忆</title><link>https://zhimoe.github.io/post/essay-memories-about-mother/</link><pubDate>Sat, 24 Jul 2010 21:58:19 +0800</pubDate><guid>https://zhimoe.github.io/post/essay-memories-about-mother/</guid><description>我想这不是一篇回忆，而是心情。默存说我们年轻时很容易把自己的写作冲动当成一种写作才能。我自知没有如此高雅的才能。但也不想在某一天突然发</description></item><item><title>搜索</title><link>https://zhimoe.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zhimoe.github.io/search/</guid><description>The searching is performed via fuse.js. For the search keywords, white spaces act as the AND operator, and | acts as the OR operator. To match an exact phrase, double quote it. For example, R Markdown matches articles that contain both R and Markdown, R | Markdown matches articles that contain R or Markdown, and &amp;quot;R Markdown&amp;quot; matches articles that contain the whole phrase R Markdown.</description></item></channel></rss>
<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Scala 2 Implicit - 香取海</title>
<meta property="og:title" content="Scala 2 Implicit - 香取海"><meta name=twitter:card content="summary"><meta property="description" content="//隐式参数是在调用时可以自动填充的参数，需要在调用范围内（scope) 有一个隐式变量可供填充。 def addInt(i:Int)(implicit n: Int) = i + n //需要提供一个隐式变量 n implicit val sn = 1 addInt(2) // 3 //如果有两个满足类型的隐式变量，则在编译 addInt(2) 时报错 //scala &amp;hellip;"><meta property="og:description" content="//隐式参数是在调用时可以自动填充的参数，需要在调用范围内（scope) 有一个隐式变量可供填充。 def addInt(i:Int)(implicit n: Int) = i + n //需要提供一个隐式变量 n implicit val sn = 1 addInt(2) // 3 //如果有两个满足类型的隐式变量，则在编译 addInt(2) 时报错 //scala &amp;hellip;"><link rel=stylesheet href=../../css/style.css><link rel=stylesheet href=../../css/fonts.css><link rel=stylesheet href=../../css/custom.css><link rel=icon type=image/png href=../../img/logo.png><link rel=apple-touch-icon href=../../img/logo.png><link rel=apple-touch-icon-precomposed href=../../img/logo.png></head><body class="single post"><div class=crop-h></div><div class=crop-v></div><div class=crop-c></div><nav class="nav-top small"><div class=logo><a href=../../>香取海</a></div><div class=menu><span class=active><a href=../../post/>博客</a></span>
<span><a href=../../categories/%E7%BC%96%E7%A8%8B/>编程</a></span>
<span><a href=../../categories/%E7%BF%BB%E8%AF%91/>翻译</a></span>
<span><a href=../../categories/%E9%9A%8F%E6%83%B3/>随想</a></span>
<span><a href=../../search/>搜索</a></span></div></nav><div class=article-meta><h1 class=title>Scala 2 Implicit</h1><h3 class=meta-line><span><span class=date>2019-03-30</span>
</span><span class=term><a href=../../categories/%E7%BC%96%E7%A8%8B/ class=term-cat>编程</a>
<a href=../../tags/code/ class=term-tag>#code </a><a href=../../tags/scala/ class=term-tag>#scala</a></span></h3></div><div class=main><nav id=TableOfContents><ul><li><a href=#隐式参数>隐式参数</a></li><li><a href=#隐式转换方法>隐式转换方法</a></li><li><a href=#implicit-class>implicit class</a></li><li><a href=#implicitly-方法>implicitly 方法</a></li><li><a href=#value-class>value class</a></li><li><a href=#extension-method>extension method</a></li></ul></nav><h2 id=隐式参数>隐式参数</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#177500>//隐式参数是在调用时可以自动填充的参数，需要在调用范围内（scope) 有一个隐式变量可供填充。
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>def</span> <span style=color:#000>addInt</span><span style=color:#000>(</span><span style=color:#000>i</span><span style=color:#a90d91>:</span><span style=color:#a90d91>Int</span><span style=color:#000>)(</span><span style=color:#a90d91>implicit</span> <span style=color:#000>n</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span> <span style=color:#a90d91>=</span> <span style=color:#000>i</span> <span style=color:#000>+</span> <span style=color:#000>n</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>//需要提供一个隐式变量 n
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>val</span> <span style=color:#000>sn</span> <span style=color:#a90d91>=</span> <span style=color:#1c01ce>1</span>
</span></span><span style=display:flex><span><span style=color:#000>addInt</span><span style=color:#000>(</span><span style=color:#1c01ce>2</span><span style=color:#000>)</span> <span style=color:#177500>// 3
</span></span></span><span style=display:flex><span><span style=color:#177500></span>
</span></span><span style=display:flex><span><span style=color:#177500>//如果有两个满足类型的隐式变量，则在编译 addInt(2) 时报错
</span></span></span><span style=display:flex><span><span style=color:#177500></span>
</span></span><span style=display:flex><span><span style=color:#177500>//scala 的方法中 ExecutionContext 一般作为 implicit 参数。
</span></span></span></code></pre></div><h2 id=隐式转换方法>隐式转换方法</h2><p>如果想要给 String 实现一个 mkStr 方法，简单的给 String 添加一个 Ops! 前缀再返回。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#177500>//1. 首先实现一个包含目标方法的类型，实现该方法
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>class</span> <span style=color:#3f6e75>StrOps</span><span style=color:#000>(</span><span style=color:#000>s</span><span style=color:#a90d91>:</span><span style=color:#a90d91>String</span><span style=color:#000>)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>  <span style=color:#a90d91>def</span> <span style=color:#000>mkStr</span><span style=color:#000>()</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>String</span> <span style=color:#000>=</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#c41a16>&#34;Ops! &#34;</span> <span style=color:#000>+</span> <span style=color:#000>s</span>
</span></span><span style=display:flex><span>  <span style=color:#000>}</span>
</span></span><span style=display:flex><span><span style=color:#000>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>//2. 告诉 scala 编译器 String 可以通过类型转换获得 mkStr 这个方法：
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>final</span> <span style=color:#a90d91>def</span> <span style=color:#000>string2StrOps</span><span style=color:#000>(</span><span style=color:#000>s</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>String</span><span style=color:#000>)</span> <span style=color:#a90d91>=</span> <span style=color:#a90d91>new</span> <span style=color:#3f6e75>StrOps</span><span style=color:#000>(</span><span style=color:#000>s</span><span style=color:#000>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>//3. 现在用户可以直接认为 String 有 mkStr 方法
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>val</span> <span style=color:#000>s</span> <span style=color:#a90d91>=</span> <span style=color:#c41a16>&#34;who changed my string&#34;</span>
</span></span><span style=display:flex><span><span style=color:#000>s</span><span style=color:#000>.</span><span style=color:#000>mkStr</span><span style=color:#000>()</span> <span style=color:#177500>//res2: String = Ops! who changed my string
</span></span></span><span style=display:flex><span><span style=color:#177500></span>
</span></span><span style=display:flex><span><span style=color:#177500>//在 scala.Predef 中定义了大量的隐式转换，例如 RichInt,RichDouble,StringOps 这些
</span></span></span></code></pre></div><h2 id=implicit-class>implicit class</h2><p>可以看到第 2 步非常的冗余，于是<a href="https://link.zhihu.com/?target=https%3A//docs.scala-lang.org/sips/implicit-classes.html">SIP-13</a>提出一个 implicit class，将上面的 1,2 步合并：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>StrOps</span><span style=color:#000>(</span><span style=color:#000>s</span><span style=color:#a90d91>:</span><span style=color:#a90d91>String</span><span style=color:#000>)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>  <span style=color:#a90d91>def</span> <span style=color:#000>mkStr</span><span style=color:#000>()</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>String</span> <span style=color:#000>=</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#c41a16>&#34;Ops! &#34;</span> <span style=color:#000>+</span> <span style=color:#000>s</span>
</span></span><span style=display:flex><span>  <span style=color:#000>}</span>
</span></span><span style=display:flex><span><span style=color:#000>}</span>
</span></span></code></pre></div><p>注意，这个只是一个语法糖。去糖后就是上面的那个形式。implicit class 有 3 个约束和一个注解问题：</p><ol><li><p>必须要有主一个构造函数且只能一个构造参数（implicit 参数除外）.构造参数就是源类型。这个构造函数即等价上面第 2 步的隐式转换方法：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>RichDate</span><span style=color:#000>(</span><span style=color:#000>date</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>java.util.Date</span><span style=color:#000>)</span> <span style=color:#177500>// OK!
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Indexer</span><span style=color:#000>[</span><span style=color:#a90d91>T</span><span style=color:#000>](</span><span style=color:#000>collecton</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Seq</span><span style=color:#000>[</span><span style=color:#a90d91>T</span><span style=color:#000>],</span> <span style=color:#000>index</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span> <span style=color:#177500>// BAD!
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Indexer</span><span style=color:#000>[</span><span style=color:#a90d91>T</span><span style=color:#000>](</span><span style=color:#000>collecton</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Seq</span><span style=color:#000>[</span><span style=color:#a90d91>T</span><span style=color:#000>])(</span><span style=color:#a90d91>implicit</span> <span style=color:#000>index</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Index</span><span style=color:#000>)</span> <span style=color:#177500>// OK!
</span></span></span></code></pre></div></li><li><p>只能定义在其他 trait/class/object 中：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#a90d91>object</span> <span style=color:#3f6e75>Helpers</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>implicit</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>RichInt</span><span style=color:#000>(</span><span style=color:#000>x</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span> <span style=color:#177500>// OK!
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>}</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>RichDouble</span><span style=color:#000>(</span><span style=color:#000>x</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Double</span><span style=color:#000>)</span> <span style=color:#177500>// BAD!
</span></span></span></code></pre></div></li><li><p>在当前 scope 内，不允许有和 implicit class 同名的方法，对象，变量。因为 case class 会自动生成同名 object 对象，所以 implicit class 不能是 case class.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#a90d91>object</span> <span style=color:#3f6e75>Bar</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Bar</span><span style=color:#000>(</span><span style=color:#000>x</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span> <span style=color:#177500>// BAD!
</span></span></span><span style=display:flex><span><span style=color:#177500></span>
</span></span><span style=display:flex><span><span style=color:#a90d91>val</span> <span style=color:#000>x</span> <span style=color:#a90d91>=</span> <span style=color:#1c01ce>5</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>x</span><span style=color:#000>(</span><span style=color:#000>y</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span> <span style=color:#177500>// BAD!
</span></span></span><span style=display:flex><span><span style=color:#177500></span>
</span></span><span style=display:flex><span><span style=color:#177500>//cuz case class has companion object by default 
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>case</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Baz</span><span style=color:#000>(</span><span style=color:#000>x</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span> <span style=color:#177500>// BAD! conflict with the companion object
</span></span></span></code></pre></div></li><li><p>还有就是 implicit class 的注解在去语法糖后会自动添加到类和方法，除非在注解中指明范围：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#000>@bar</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Foo</span><span style=color:#000>(</span><span style=color:#000>n</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>//desugar
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>@bar</span> <span style=color:#a90d91>implicit</span> <span style=color:#a90d91>def</span> <span style=color:#3f6e75>Foo</span><span style=color:#000>(</span><span style=color:#000>n</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Foo</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#3f6e75>Foo</span><span style=color:#000>(</span><span style=color:#000>n</span><span style=color:#000>)</span>
</span></span><span style=display:flex><span><span style=color:#000>@bar</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Foo</span><span style=color:#000>(</span><span style=color:#000>n</span><span style=color:#a90d91>:</span><span style=color:#a90d91>Int</span><span style=color:#000>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>//除非在注解中指明：genClass / method
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>@(</span><span style=color:#000>bar</span> <span style=color:#000>@genClass</span><span style=color:#000>)</span> <span style=color:#a90d91>implicit</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Foo</span><span style=color:#000>(</span><span style=color:#000>n</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>//desugar 得到
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>@bar</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Foo</span><span style=color:#000>(</span><span style=color:#000>n</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>def</span> <span style=color:#3f6e75>Foo</span><span style=color:#000>(</span><span style=color:#000>n</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Foo</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#3f6e75>Foo</span><span style=color:#000>(</span><span style=color:#000>n</span><span style=color:#000>)</span>
</span></span></code></pre></div></li></ol><h2 id=implicitly-方法>implicitly 方法</h2><p>scala 的 PreDef 中有有一个 implicitly 方法，表示在当前 scope 征召一个隐式变量并返回该变量。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#177500>//PreDef
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>@inline</span> <span style=color:#a90d91>def</span> <span style=color:#000>implicitly</span><span style=color:#000>[</span><span style=color:#a90d91>T</span><span style=color:#000>](</span><span style=color:#a90d91>implicit</span> <span style=color:#000>e</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>T</span><span style=color:#000>)</span> <span style=color:#a90d91>=</span> <span style=color:#000>e</span>
</span></span></code></pre></div><blockquote><p>implitly[T] means return implicit value of type T in the context</p></blockquote><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Foo</span><span style=color:#000>(</span><span style=color:#a90d91>val</span> <span style=color:#000>i</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>   <span style=color:#a90d91>def</span> <span style=color:#000>addValue</span><span style=color:#000>(</span><span style=color:#000>v</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span> <span style=color:#000>=</span> <span style=color:#000>i</span> <span style=color:#000>+</span> <span style=color:#000>v</span>
</span></span><span style=display:flex><span><span style=color:#000>}</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>val</span> <span style=color:#000>foo</span><span style=color:#a90d91>:</span><span style=color:#a90d91>Foo</span> <span style=color:#000>=</span> <span style=color:#3f6e75>Foo</span><span style=color:#000>(</span><span style=color:#1c01ce>1</span><span style=color:#000>)</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>val</span> <span style=color:#000>fooImplicitly</span> <span style=color:#a90d91>=</span> <span style=color:#000>implicitly</span><span style=color:#000>[</span><span style=color:#a90d91>Foo</span><span style=color:#000>]</span> <span style=color:#177500>// Foo(1)
</span></span></span></code></pre></div><h2 id=value-class>value class</h2><p>scala 还有一个概念：<a href="https://link.zhihu.com/?target=https%3A//docs.scala-lang.org/overviews/core/value-classes.html">value class</a></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#a90d91>class</span> <span style=color:#3f6e75>Wrapper</span><span style=color:#000>(</span><span style=color:#a90d91>val</span> <span style=color:#000>underlying</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span> <span style=color:#a90d91>extends</span> <span style=color:#3f6e75>AnyVal</span>
</span></span><span style=display:flex><span><span style=color:#177500>//1. 一个 public val 参数表示 runtime 类型，这里是 Int. 编译时是 Wrapper 类型，所以 value class 目的是降低分配开销。
</span></span></span><span style=display:flex><span><span style=color:#177500>//2. value class 需要 extends AnyVal
</span></span></span><span style=display:flex><span><span style=color:#177500>//3. value class 只能有 defs, 不能有 vals, vars, or nested traits, classes or objects,
</span></span></span><span style=display:flex><span><span style=color:#177500>//   因为 def 是通过静态方法实现的，而 val,var 这些则必须创建相应类型了。
</span></span></span><span style=display:flex><span><span style=color:#177500>//4. value class 只能扩展 通用 trait（universal traits）,
</span></span></span><span style=display:flex><span><span style=color:#177500>//   universal traits 是 A universal trait is a trait that extends Any, only has defs as members, and does no initialization.
</span></span></span></code></pre></div><h2 id=extension-method>extension method</h2><p>当 implicit class 类型参数是<code>AnyVal</code>子类时，value class 和上面的 implicit class 形式相近，所以可以通过 value class 降低 implicit class 的分配开销。例如 RichtInt</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#a90d91>implicit</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>RichInt</span><span style=color:#000>(</span><span style=color:#a90d91>val</span> <span style=color:#000>self</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>Int</span><span style=color:#000>)</span> <span style=color:#a90d91>extends</span> <span style=color:#3f6e75>AnyVal</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>  <span style=color:#a90d91>def</span> <span style=color:#000>toHexString</span><span style=color:#a90d91>:</span> <span style=color:#a90d91>String</span> <span style=color:#000>=</span> <span style=color:#000>java</span><span style=color:#000>.</span><span style=color:#000>lang</span><span style=color:#000>.</span><span style=color:#3f6e75>Integer</span><span style=color:#000>.</span><span style=color:#000>toHexString</span><span style=color:#000>(</span><span style=color:#000>self</span><span style=color:#000>)</span>
</span></span><span style=display:flex><span><span style=color:#000>}</span>
</span></span></code></pre></div><p>因为 RichInt 是 value class，在运行时（runtime）不会有 RichInt 这个类，而是 Int，而 3.toHexString 实际是通过静态方法实现的： <code>RichInt$.MODULE$.extension$toHexString(3)</code>,这么做好处是减少对象分配开销（avoid the overhead of allocation）.如果 implicit class 的类型参数不是 AnyVal 子类，那么在 runtime 时会有相应类型对象被创建，用户察觉不到区别。</p><p>value class 还有其他作用和局限性，可以参考上面链接。</p><nav class="post-nav fullwidth"><span>&larr; <a href=../../post/redis-hash-optimize-memory-usage/>使用 redis 的 hash 优化内存使用[翻译]</a></span>
<span class=post-nav-next><a href=../../post/publish-markdown-blog-by-travis/>使用 travis 自动发布 markdown 到博客</a> &rarr;</span></nav></div><footer class=small><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fix-toc.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/gh/rstudio/markdown/inst/resources/prism-xcode.css><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js defer></script><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/copy-button.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/copy-button.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/key-buttons.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/key-buttons.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/heading-anchor.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/external-link.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/ol-id.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fullwidth.min.js defer></script><hr><p class=nav-bottom><span><a href=https://zhi.moe>xdh</a> © 2024</span>
<span class=menu-bottom><a href=../../categories/>分类</a> <a href=../../tags/>标签</a>
<a href=../../post/index.xml type=application/rss+xml title="RSS feed">订阅</a>
<a href=#>回到顶部</a></span></p></footer></body></html>
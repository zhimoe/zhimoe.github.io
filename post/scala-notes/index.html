<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>Scala 学习笔记 - zhimoe</title>
    <meta name="keywords" content="读书,代码,架构,JVM,Java,Scala,Python,Clojure,Rust">
    
    <meta property="og:title" content="Scala 学习笔记">
    <meta property="og:site_name" content="zhimoe">
    <meta property="og:image" content="/img/avatar.png"> 
    <meta name="title" content="Scala 学习笔记 - zhimoe" />
    <meta name="description" content="编程是一门手艺"> 
    <link rel="shortcut icon" href="https://zhimoe.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://zhimoe.github.io/img/avatar.png" />
    <link rel="apple-touch-icon-precomposed" href="https://zhimoe.github.io/img/avatar.png" />
    <link href="https://cdn.jsdelivr.net/npm/typeface-alegreya-sans@1.1.13/index.min.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/npm/typeface-merriweather@0.0.72/index.min.css" rel="stylesheet" type="text/css" />    
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/npm/fancybox@2.1.5/dist/css/jquery.fancybox.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/zhimoe/zhimoe.github.io@gh-pages/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/zhimoe/zhimoe.github.io@gh-pages/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://zhimoe.github.io"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">zhimoe</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">the craft of programming</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://zhimoe.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://zhimoe.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://zhimoe.github.io/categories/%E7%BC%96%E7%A8%8B/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-code"></i> <br />编程
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://zhimoe.github.io/categories/%E7%BF%BB%E8%AF%91/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-pencil"></i> <br />翻译
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://zhimoe.github.io/categories/%E9%A1%B9%E7%9B%AE/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-bathtub"></i> <br />项目
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://zhimoe.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://zhimoe.github.io/post/scala-notes/" itemprop="url">
        Scala 学习笔记
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2019-03-31">
    2019-03-31
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://zhimoe.github.io/categories/%E7%BC%96%E7%A8%8B" itemprop="url" rel="index">
        <span itemprop="name">编程</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">6597 字 ~14分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h1 id="scala-notes">scala-notes</h1>
<p>some notes on scala, includes:</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> setup with maven</li>
<li><input checked="" disabled="" type="checkbox"> import</li>
<li><input checked="" disabled="" type="checkbox"> == and eq</li>
<li><input checked="" disabled="" type="checkbox"> case class</li>
<li><input checked="" disabled="" type="checkbox"> for&hellip;yield</li>
<li><input checked="" disabled="" type="checkbox"> companion object and class</li>
<li><input checked="" disabled="" type="checkbox"> method and function(def val)</li>
<li><input checked="" disabled="" type="checkbox"> _ in scala</li>
<li><input checked="" disabled="" type="checkbox"> =&gt; in scala</li>
<li><input checked="" disabled="" type="checkbox"> () {} in scala</li>
<li><input checked="" disabled="" type="checkbox"> implicit</li>
<li><input checked="" disabled="" type="checkbox"> string</li>
</ul>
<h2 id="setup-with-maven">setup with maven</h2>
<p>目前用sbt的项目比较少,maven的更多. 而且sbt烧cpu. maven项目使用scala参考我的gist:<a href="https://gist.github.com/zhimoe/db6caeed070bfabe70102e2bace0e5b0">scala_maven_pom.xml</a></p>
<p>学习scala可以使用scala插件的worksheet,这是一个基于脚本互动的REPL. 本文后面的代码全部在worksheet中测试.</p>
<h2 id="import">import</h2>
<p>scala的import语句很灵活，可以在任何地方导入class内部外部，方法内部，代码块内部，这样做有一个好处，限制导入方法和对象的scope，防止污染变量。在后面学了implicit隐式转换后，就知道import scope有多重要了。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#00f">import</span> scala.math._ <span style="color:#008000">// import everything in math package 
</span><span style="color:#008000"></span><span style="color:#00f">import</span> java.util.{ <span style="color:#2b91af">ArrayList</span> <span style="color:#00f">=&gt;</span> <span style="color:#00f">_</span>, <span style="color:#00f">_</span>} 
<span style="color:#008000">//第一个下划线表示隐藏ArrayList，第二个表示通配符，导入所有
</span><span style="color:#008000"></span>
<span style="color:#008000">//默认，scala导入:
</span><span style="color:#008000"></span>java.lang.<span style="color:#00f">_</span>
scala.<span style="color:#00f">_</span>
scala.<span style="color:#2b91af">Predef</span>.<span style="color:#00f">_</span> 
<span style="color:#008000">//推荐看一下Predef的源代码包括：
</span><span style="color:#008000">//Predef中定义的方法和属性
</span><span style="color:#008000">//常用方法和类
</span><span style="color:#008000">//打印方法 println等
</span><span style="color:#008000">//一些调试和错误方法
</span><span style="color:#008000">//一个特殊的方法表示方法未实现  
</span><span style="color:#008000"></span><span style="color:#00f">def</span> ??? <span style="color:#00f">:</span> <span style="color:#2b91af">Nothing</span> = <span style="color:#00f">throw</span> <span style="color:#00f">new</span> <span style="color:#2b91af">NotImplementedError</span>
<span style="color:#008000">//Predef还有大量的隐式转换和隐式参数
</span><span style="color:#008000"></span>
</code></pre></div><h2 id="-and-eq">== and eq</h2>
<p>scala里面<code>==</code>等价于java的<code>equals</code>方法即内容比较,并且可以正确处理<code>null</code>(还记得java规范里面烦人的 <code>&quot;A&quot;.equals(m)</code>规范么?). 而地址(引用)比较使用<code>eq</code> 方法,这个方法其实很少用到,应用代码一般无需比较2个变量的地址.</p>
<h2 id="case-class">case class</h2>
<p>case class类似data class,即java的pojo bean,但是提供了更多的方法.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#008000">// 5个特性
</span><span style="color:#008000">// 1.添加companion object,apply方法,unapply方法
</span><span style="color:#008000">// 2.toString, hashCode and equals and copy methods
</span><span style="color:#008000"></span><span style="color:#00f">case</span> <span style="color:#00f">class</span> <span style="color:#2b91af">Student</span>(name<span style="color:#00f">:</span> <span style="color:#2b91af">String</span>, marks<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>)

<span style="color:#00f">val</span> s1 <span style="color:#00f">=</span> <span style="color:#2b91af">Student</span>(<span style="color:#a31515">&#34;Rams&#34;</span>, 550)
<span style="color:#00f">val</span> s2 <span style="color:#00f">=</span> s1.copy()
<span style="color:#00f">val</span> s3 <span style="color:#00f">=</span> s1.copy(marks <span style="color:#00f">=</span> 590)
s2 == s1 <span style="color:#008000">//true
</span><span style="color:#008000"></span>s3 == s1 <span style="color:#008000">//false
</span><span style="color:#008000"></span>
<span style="color:#008000">// 3. 构造函数参数自动成为成员变量,即自动给构造参数添加val前缀
</span><span style="color:#008000">// 4. 可以用于模式匹配
</span><span style="color:#008000">// 5. 默认的,case class和case object是可序列化的(实现Serializable),也即是可以网络传输的
</span><span style="color:#008000"></span>
</code></pre></div><h2 id="foryield">for&hellip;yield</h2>
<blockquote>
<p>Scala’s “for comprehensions” are syntactic sugar for composition of multiple operations with <code>foreach, map, flatMap, filter or withFilter</code>
scala的for推导其实就是组合多个<code>foreach, map, flatMap, filter or withFilter</code>的语法糖.
以下代码结果r1,r2完全一致:</p>
</blockquote>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#00f">val</span> c1 <span style="color:#00f">=</span> <span style="color:#2b91af">List</span>(1, 2, 3)
<span style="color:#00f">val</span> c2 <span style="color:#00f">=</span> <span style="color:#2b91af">List</span>(<span style="color:#a31515">&#34;a&#34;</span>, <span style="color:#a31515">&#34;b&#34;</span>, <span style="color:#a31515">&#34;c&#34;</span>)
<span style="color:#00f">val</span> c3 <span style="color:#00f">=</span> <span style="color:#2b91af">List</span>(<span style="color:#a31515">&#34;!&#34;</span>, <span style="color:#a31515">&#34;@&#34;</span>, <span style="color:#a31515">&#34;#&#34;</span>)

<span style="color:#00f">val</span> r1 <span style="color:#00f">=</span> <span style="color:#00f">for</span> (x <span style="color:#00f">&lt;-</span> c1; y <span style="color:#00f">&lt;-</span> c2; z <span style="color:#00f">&lt;-</span> c3) <span style="color:#00f">yield</span> {
  x + y + z
}

<span style="color:#008000">//&lt;==&gt;
</span><span style="color:#008000"></span><span style="color:#00f">val</span> r2 <span style="color:#00f">=</span> c1.flatMap(x <span style="color:#00f">=&gt;</span> c2.flatMap(y <span style="color:#00f">=&gt;</span> c3.map(z <span style="color:#00f">=&gt;</span> {
  x + y + z
})))

assert(r1 == r2)<span style="color:#008000">//true
</span><span style="color:#008000"></span>
</code></pre></div><h2 id="companion-object">companion object</h2>
<p>Scala中，除了方法，一切都是对象！函数也是对象,根据参数的个数,函数的类型为FunctionN.N为函数参数个数.
伴生对象用于定义一些静态方法(工厂方法),其中apply和unapply方法常用. apply方法用于代替new的工厂方法.
同时,companion objects can access private fields and methods of their companion trait/class.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#00f">class</span> <span style="color:#2b91af">Person</span>(name<span style="color:#00f">:</span> <span style="color:#2b91af">String</span>, age<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>) {
  <span style="color:#00f">private</span> <span style="color:#00f">var</span> skill<span style="color:#00f">:</span> <span style="color:#2b91af">String</span> = <span style="color:#a31515">&#34;no skill&#34;</span>
  <span style="color:#00f">def</span> introduce() <span style="color:#00f">=</span> println(<span style="color:#a31515">s&#34;my name is </span><span style="color:#a31515">$name</span><span style="color:#a31515">, I am </span><span style="color:#a31515">$age</span><span style="color:#a31515"> years old&#34;</span>)
}

<span style="color:#008000">// companion object name should be identical to the class name. 
</span><span style="color:#008000"></span><span style="color:#00f">object</span> <span style="color:#2b91af">Person</span> {
  <span style="color:#00f">def</span> apply(name<span style="color:#00f">:</span> <span style="color:#2b91af">String</span>, age<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>)<span style="color:#00f">:</span> <span style="color:#2b91af">Person</span> = {
    <span style="color:#00f">new</span> <span style="color:#2b91af">Person</span>(name, age)
  }
  <span style="color:#008000">//apply method override
</span><span style="color:#008000"></span>  <span style="color:#00f">def</span> apply(name<span style="color:#00f">:</span> <span style="color:#2b91af">String</span>, age<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>, skill<span style="color:#00f">:</span> <span style="color:#2b91af">String</span>)<span style="color:#00f">:</span> <span style="color:#2b91af">Person</span> = {
    <span style="color:#00f">val</span> p <span style="color:#00f">=</span> <span style="color:#00f">new</span> <span style="color:#2b91af">Person</span>(name, age)
    p.skill <span style="color:#00f">=</span> skill
    p
  }
}

<span style="color:#00f">val</span> dahu <span style="color:#00f">=</span> <span style="color:#2b91af">Person</span>(<span style="color:#a31515">&#34;dahu&#34;</span>, 30)
dahu.introduce
</code></pre></div><p>伴生对象在模式匹配和抽取器的应用</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#008000">//关于抽取器和unapply方法的进一步示例:
</span><span style="color:#008000"></span><span style="color:#00f">trait</span> <span style="color:#2b91af">User</span>

<span style="color:#00f">class</span> <span style="color:#2b91af">FreeUser</span>(
                <span style="color:#00f">val</span> name<span style="color:#00f">:</span> <span style="color:#2b91af">String</span>,
                <span style="color:#00f">val</span> score<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>,
                <span style="color:#00f">val</span> upgradeProbability<span style="color:#00f">:</span> <span style="color:#2b91af">Double</span>)
  <span style="color:#00f">extends</span> <span style="color:#2b91af">User</span>

<span style="color:#00f">class</span> <span style="color:#2b91af">PremiumUser</span>(
                   <span style="color:#00f">val</span> name<span style="color:#00f">:</span> <span style="color:#2b91af">String</span>,
                   <span style="color:#00f">val</span> score<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>)
  <span style="color:#00f">extends</span> <span style="color:#2b91af">User</span>

<span style="color:#00f">object</span> <span style="color:#2b91af">FreeUser</span> {
  <span style="color:#00f">def</span> unapply(user<span style="color:#00f">:</span> <span style="color:#2b91af">FreeUser</span>)<span style="color:#00f">:</span> <span style="color:#2b91af">Option</span>[(<span style="color:#2b91af">String</span>, <span style="color:#2b91af">Int</span>, <span style="color:#2b91af">Double</span>)] <span style="color:#00f">=</span>
    <span style="color:#2b91af">Some</span>((user.name, user.score, user.upgradeProbability))
}

<span style="color:#00f">object</span> <span style="color:#2b91af">PremiumUser</span> {
  <span style="color:#00f">def</span> unapply(user<span style="color:#00f">:</span> <span style="color:#2b91af">PremiumUser</span>)<span style="color:#00f">:</span> <span style="color:#2b91af">Option</span>[(<span style="color:#2b91af">String</span>, <span style="color:#2b91af">Int</span>)] <span style="color:#00f">=</span>
    <span style="color:#2b91af">Some</span>((user.name, user.score))
}

<span style="color:#00f">val</span> freeUsr <span style="color:#00f">=</span> <span style="color:#00f">new</span> <span style="color:#2b91af">FreeUser</span>(<span style="color:#a31515">&#34;john&#34;</span>, 70, 0.5)
freeUsr <span style="color:#00f">match</span> {
  <span style="color:#00f">case</span> <span style="color:#2b91af">FreeUser</span>(name, <span style="color:#00f">_</span>, p) <span style="color:#00f">=&gt;</span> <span style="color:#00f">if</span> (p &gt; 0.75) println(<span style="color:#a31515">s&#34;what can I do for you,</span><span style="color:#a31515">$name</span><span style="color:#a31515">&#34;</span>)
  <span style="color:#00f">else</span> println(<span style="color:#a31515">s&#34;hello,</span><span style="color:#a31515">$name</span><span style="color:#a31515">&#34;</span>)
  <span style="color:#00f">case</span> <span style="color:#00f">_</span> <span style="color:#00f">=&gt;</span> println(<span style="color:#a31515">&#34;who are you&#34;</span>)
}

<span style="color:#008000">//bool抽取器
</span><span style="color:#008000"></span><span style="color:#00f">object</span> <span style="color:#2b91af">premiumCandidate</span> {
  <span style="color:#00f">def</span> unapply(user<span style="color:#00f">:</span> <span style="color:#2b91af">FreeUser</span>)<span style="color:#00f">:</span> <span style="color:#2b91af">Boolean</span> = user.upgradeProbability &gt; 0.4
}

<span style="color:#008000">// bool抽取器的用法
</span><span style="color:#008000"></span>freeUsr <span style="color:#00f">match</span> {
  <span style="color:#00f">case</span> freeUser@premiumCandidate() <span style="color:#00f">=&gt;</span> println(<span style="color:#a31515">s&#34;恭喜成为黄金会员候选人&#34;</span>)
  <span style="color:#00f">case</span> <span style="color:#00f">_</span> <span style="color:#00f">=&gt;</span> println(<span style="color:#a31515">&#34;欢迎回来&#34;</span>)
}
<span style="color:#008000">//来源: [Scala初学者指南](http://danielwestheide.com/scala/neophytes.html)
</span><span style="color:#008000"></span>
</code></pre></div><h2 id="method-and-functiondef-val">method and function(def val)</h2>
<p>先看函数定义</p>
<blockquote>
<p>A function can be invoked with a list of arguments to produce a result.
A function has a parameter list, a body, and a result type. Functions that are
members of a class, trait, or singleton object are called methods.
Functions defined inside other functions are called local functions. Functions
with the result type of Unit are called procedures. Anonymous functions in
source code are called function literals. At run time, function literals are
instantiated into objects called function values.</p>
<p>quote from：<!-- raw HTML omitted -->
Martin Odersky - Lex Spoon - Bill Venners</p>
</blockquote>
<p>函数由一个参数列表，一个函数体，一个结果类型构成。函数如果作为class，trait或者object（注意，这里的object是scala特有的单例对象，不是Java中的instance）的成员，那么这个函数叫方法。函数和方法的区别就是函数时FunctionN的一个实例,编译后是一个单独的class文件,而方法是依附对象的,调用方法的格式是obj.method(param),而调用函数的格式本质是将调用函数对象的apply方法.
函数定义在别的函数内部叫局部函数。函数返回值是Unit称为过程（procedures）。
匿名函数是通过函数字面量（ ()=&gt;{函数体} ）定义的函数。在运行时，函数字面量被实例化对象，叫函数值。
函数和方法的区别，大部分情况下不用在意区别：
函数是有类型的： (T1, &hellip;, Tn) =&gt; U，是trait FunctionN的一个实例对象，函数有一个apply方法，用来实际执行function的函数体。函数还有toString， andThen ，conpose等方法。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#00f">val</span> fn<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span> =&gt; <span style="color:#2b91af">String</span> <span style="color:#00f">=</span> i <span style="color:#00f">=&gt;</span> i+<span style="color:#a31515">&#34;123&#34;</span> <span style="color:#008000">//声明一个函数
</span><span style="color:#008000"></span>fn(3) <span style="color:#008000">//实际背后是fn.apply(3);
</span></code></pre></div><p>scala中除了method，一切都是instance
method只能用def 声明，function可以是val和def声明
method可以有类型参数[] ,function不能有，函数在声明时就需要知道具体类型。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#00f">def</span> fn(p<span style="color:#00f">:</span> <span style="color:#2b91af">List</span>[<span style="color:#2b91af">String</span>])<span style="color:#00f">:</span> <span style="color:#2b91af">Map</span>[<span style="color:#2b91af">T</span>] <span style="color:#00f">=</span> {...} <span style="color:#008000">//is function
</span><span style="color:#008000"></span><span style="color:#00f">def</span> m[<span style="color:#2b91af">T</span>](t<span style="color:#00f">:</span> <span style="color:#2b91af">List</span>[<span style="color:#2b91af">T</span>])<span style="color:#00f">:</span> <span style="color:#2b91af">Map</span>[<span style="color:#2b91af">T</span>] <span style="color:#00f">=</span> {...} <span style="color:#008000">//is method,可以有泛型参数.
</span><span style="color:#008000"></span>
将method转换成function有两种方法<span style="">：</span>
<span style="color:#00f">val</span> f1 <span style="color:#00f">=</span> m1 <span style="color:#00f">_</span>   <span style="color:#008000">//下划线表示参数列表 eta-expansion
</span><span style="color:#008000"></span><span style="color:#00f">val</span> f2<span style="color:#00f">:</span> (<span style="color:#2b91af">Int</span>) =&gt; <span style="color:#2b91af">Int</span> <span style="color:#00f">=</span> m1  <span style="color:#008000">//m1 的入参和返回值要和f2的一样
</span><span style="color:#008000"></span>
<span style="color:#008000">//scala可以自动将method转换为function，如果一个方法需要一个函数作为参数，
</span><span style="color:#008000">//那么可以直接将m1传递给他，不需要 下划线。
</span><span style="color:#008000">//每一次将方法转换成function都是得到一个新的function object。
</span><span style="color:#008000">//function既然是一个instance，那么编译成class文件会有一个class文件。
</span><span style="color:#008000"></span>
</code></pre></div><h2 id="_-in-scala">_ in scala</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#008000">/**
</span><span style="color:#008000">  * class Reference[T] {
</span><span style="color:#008000">  * private var contents: T = _  
</span><span style="color:#008000">  * //使用类型默认值初始化变量，如果T是Int，则contents是0，T是boolean，则是false；Unit则是()
</span><span style="color:#008000">  * }
</span><span style="color:#008000">  * 
</span><span style="color:#008000">  *
</span><span style="color:#008000">  * List(1, 2, 3) foreach (print _ ) //output 123，表示实参
</span><span style="color:#008000">  *
</span><span style="color:#008000">  * //在匿名函数中作为参数占位符：
</span><span style="color:#008000">  * List(1, 2, 3) map ( _ + 2 )
</span><span style="color:#008000">  * // _ + 2是一个匿名函数
</span><span style="color:#008000">  *
</span><span style="color:#008000">  * //模式匹配中的最后一行作为通配符
</span><span style="color:#008000">  * case _ =&gt; &#34;this is match anything other than before cases &#34;
</span><span style="color:#008000">  *
</span><span style="color:#008000">  * expr match {
</span><span style="color:#008000">  *
</span><span style="color:#008000">  * case List(1,_,_) =&gt; &#34; a list with three element and the first element is 1&#34;
</span><span style="color:#008000">  * case List(_*)  =&gt; &#34; a list with zero or more elements &#34;
</span><span style="color:#008000">  * case Map[_,_] =&gt; &#34; matches a map with any key type and any value type &#34;
</span><span style="color:#008000">  * case _ =&gt;
</span><span style="color:#008000">  * }
</span><span style="color:#008000">  *
</span><span style="color:#008000">  *
</span><span style="color:#008000">  * //import中作为通配符和隐藏符
</span><span style="color:#008000">  * import java.util.{ ArrayList =&gt; _, _} 
</span><span style="color:#008000">  * //第一个下划线表示隐藏ArrayList，第二个表示通配符，导入所有
</span><span style="color:#008000">  *
</span><span style="color:#008000">  * //将方法变为value
</span><span style="color:#008000">  * method _     // Eta expansion of method into method value
</span><span style="color:#008000">  *
</span><span style="color:#008000">  * //tuple 的访问
</span><span style="color:#008000">  * tpl._2 //返回tpl第二个元素，注意，tuple是从1开始的
</span><span style="color:#008000">  *
</span><span style="color:#008000">  *
</span><span style="color:#008000">  * //还有很多高级的概念，目前还不理解，so上给出的答案
</span><span style="color:#008000">  * def f[M[_]]       // Higher kinded type parameter
</span><span style="color:#008000">  * def f(m: M[_])    // Existential type
</span><span style="color:#008000">  * _ + _             // Anonymous function placeholder parameter
</span><span style="color:#008000">  * m _               // Eta expansion of method into method value
</span><span style="color:#008000">  * m(_)              // Partial function application
</span><span style="color:#008000">  * _ =&gt; 5            // Discarded parameter
</span><span style="color:#008000">  * case _ =&gt;         // Wild card pattern -- matches anything
</span><span style="color:#008000">  * val (a, _) = (1, 2) // same thing
</span><span style="color:#008000">  * for (_ &lt;- 1 to 10)  // same thing
</span><span style="color:#008000">  * f(xs: _*)         // Sequence xs is passed as multiple parameters to f(ys: T*)
</span><span style="color:#008000">  * case Seq(xs @ _*) // Identifier xs is bound to the whole matched sequence
</span><span style="color:#008000">  * var i: Int = _    // Initialization to the default value
</span><span style="color:#008000">  * def abc_&lt;&gt;!       // An underscore must separate alphanumerics from symbols on identifiers
</span><span style="color:#008000">  * t._2
</span><span style="color:#008000">  */</span>

</code></pre></div><h2 id="-in-scala">=&gt; in scala</h2>
<h3 id="函数字面量分隔参数和函数体">函数字面量分隔参数和函数体</h3>
<p>在函数字面量中 <code>=&gt;</code>分隔参数和函数体. 也可以表示一个函数类型.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala">(x<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>) <span style="color:#00f">=&gt;</span> x * 2表示一个匿名函数<span style="">，</span>接收一个整数<span style="">，</span>返回参数乘以2的结果<span style="">。</span>

scala&gt; <span style="color:#00f">val</span> f<span style="color:#00f">:</span> <span style="color:#2b91af">Function1</span>[<span style="color:#2b91af">Int</span>,<span style="color:#2b91af">String</span>] <span style="color:#00f">=</span> argInt <span style="color:#00f">=&gt;</span> <span style="color:#a31515">&#34;my int: &#34;</span>+argInt.toString
f<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span> =&gt; <span style="color:#2b91af">String</span> <span style="color:#00f">=</span> &lt;function1&gt;

<span style="color:#008000">// Int =&gt; String 等价 Function1[Int,String]
</span><span style="color:#008000"></span>scala&gt; <span style="color:#00f">val</span> f2<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span> =&gt; <span style="color:#2b91af">String</span> <span style="color:#00f">=</span> myInt <span style="color:#00f">=&gt;</span> <span style="color:#a31515">&#34;my int v2: &#34;</span>+myInt.toString
f2<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span> =&gt; <span style="color:#2b91af">String</span> <span style="color:#00f">=</span> &lt;function1&gt;
<span style="color:#008000">//注意，匿名函数没有参数也要括号 ()=&gt;{}；
</span><span style="color:#008000">//() =&gt; Unit表示没有返回值的函数
</span></code></pre></div><h3 id="call-by-name-parameter">call-by-name parameter</h3>
<p>在函数的参数声明中使用<code>=&gt;</code>(e.g. <code>def f(arg: =&gt; T</code>))表示这个参数是&quot;by-name parameter&rdquo;,表示这个参数只有在函数体中包含这个参数的语句被执行才会被evaluate。
这个特点叫call-by-name,arg可以是一个代码块，甚至函数，在传递给f时不会evaluate，只有f函数体内部调用arg时，arg才会被执行。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala">scala&gt; <span style="color:#00f">def</span> now()={println(<span style="color:#a31515">&#34;nano time:&#34;</span>);<span style="color:#2b91af">System</span>.nanoTime}

scala&gt; <span style="color:#00f">def</span> callByName(p<span style="color:#00f">:</span> =&gt; <span style="color:#2b91af">Long</span>)<span style="color:#00f">:</span><span style="color:#2b91af">Long</span> = {println(<span style="color:#a31515">&#34;call-by-name:&#34;</span>+p);p;}
	callByName<span style="color:#00f">:</span> (<span style="color:#2b91af">p:</span> =&gt; <span style="color:#2b91af">Long</span>)<span style="color:#2b91af">Long</span>
	
scala&gt; <span style="color:#00f">def</span> justCall(p <span style="color:#00f">:</span> <span style="color:#2b91af">Long</span>) <span style="color:#00f">:</span><span style="color:#2b91af">Long</span> = {println(<span style="color:#a31515">&#34;just-call:&#34;</span>+p);p;}
	justCall<span style="color:#00f">:</span> (<span style="color:#2b91af">p:</span> <span style="color:#2b91af">Long</span>)<span style="color:#2b91af">Long</span>
	
scala&gt; callByName(now())
	nano time<span style="color:#00f">:</span>
	<span style="color:#2b91af">call-by-name:</span><span style="">5664511571389</span>
	<span style="color:#2b91af">nano</span> <span style="color:#2b91af">time:</span>
	res2<span style="color:#00f">:</span> <span style="color:#2b91af">Long</span> = 5664511727048
<span style="color:#008000">//now()在callByName的函数体的每个出现的地方都执行了
</span><span style="color:#008000"></span>
scala&gt; justCall(now())
	nano time<span style="color:#00f">:</span>
	<span style="color:#2b91af">just-call:</span><span style="">5667489483159</span>
	<span style="color:#2b91af">res3:</span> <span style="color:#2b91af">Long</span> = 5667489483159
<span style="color:#008000">//now()只在传递参数的时候被执行了.
</span></code></pre></div><h3 id="模式匹配中分隔case模式和返回值">模式匹配中分隔case模式和返回值</h3>
<p>在case语句中，=&gt; 分隔模式和返回表达式。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#00f">var</span> a <span style="color:#00f">=</span> 1  
a <span style="color:#00f">match</span>{  
    <span style="color:#00f">case</span> 1 <span style="color:#00f">=&gt;</span> println(<span style="color:#a31515">&#34;One&#34;</span>)  
    <span style="color:#00f">case</span> 2 <span style="color:#00f">=&gt;</span> println(<span style="color:#a31515">&#34;Two&#34;</span>)  
    <span style="color:#00f">case</span> <span style="color:#00f">_</span> <span style="color:#00f">=&gt;</span> println(<span style="color:#a31515">&#34;No&#34;</span>)  
}
</code></pre></div><h2 id="--in-method-call">() {} in method call</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#008000">// 规则1:{}表示code block,你可以在里面放几乎任何语句,block的返回值是由最后一句决定
</span><span style="color:#008000">// 规则2:block内容如果只有一句可以省略{},但是case clause除外:{case ...}
</span><span style="color:#008000">// 规则3: 单参数方法如果实参是code block,那么可以省略()
</span><span style="color:#008000"></span>{
  <span style="color:#00f">import</span> util.Try
  println{<span style="color:#a31515">&#34;hello&#34;</span>}
  5
}
<span style="color:#00f">val</span> tupleList <span style="color:#00f">=</span> <span style="color:#2b91af">List</span>[(<span style="color:#2b91af">String</span>, <span style="color:#2b91af">String</span>)]()

<span style="color:#008000">//规则2
</span><span style="color:#008000"></span>tupleList takeWhile( { <span style="color:#00f">case</span>(t1,t2) <span style="color:#00f">=&gt;</span> t1==t2 } )

<span style="color:#008000">// 规则2
</span><span style="color:#008000"></span><span style="color:#2b91af">List</span>(1, 2, 3).reduceLeft(<span style="color:#00f">_</span>+<span style="color:#00f">_</span>)

<span style="color:#008000">// 一种特殊情况,提示:隐式转换
</span><span style="color:#008000"></span><span style="color:#00f">val</span> r <span style="color:#00f">=</span> <span style="color:#2b91af">List</span>(1, 2, 3).foldLeft(0) {<span style="color:#00f">_</span>+<span style="color:#00f">_</span>}
<span style="color:#008000">//val l = r{&#34;hello&#34;}
</span><span style="color:#008000"></span>
<span style="color:#008000">//不要调用这个方法
</span><span style="color:#008000"></span><span style="color:#00f">def</span> loopf(x<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>)<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span> = loopf {x}

<span style="color:#008000">//使用{}的特殊情况:for推导可以和()互换,一般建议是除了yield的其他情况都用()
</span><span style="color:#008000"></span><span style="color:#00f">for</span>{tpl <span style="color:#00f">&lt;-</span>tupleList} <span style="color:#00f">yield</span> tpl._2

<span style="color:#008000">//不建议
</span><span style="color:#008000"></span><span style="color:#00f">for</span>{tpl <span style="color:#00f">&lt;-</span>tupleList} {
  println(tpl)
}
<span style="color:#008000">//推荐
</span><span style="color:#008000"></span><span style="color:#00f">for</span>(tpl <span style="color:#00f">&lt;-</span>tupleList) {
  println(tpl)
}

<span style="color:#008000">//补充, 方法定义时如果没有返回值可以省略=,称为procedure,scala 2.13已经废弃,不要这么写
</span><span style="color:#008000">//don&#39;t
</span><span style="color:#008000"></span><span style="color:#00f">def</span> p(in<span style="color:#00f">:</span><span style="color:#2b91af">String</span> ){
  println(<span style="color:#a31515">s&#34;hello </span><span style="color:#a31515">$in</span><span style="color:#a31515">&#34;</span>)
}
</code></pre></div><h2 id="implicit">implicit</h2>
<p>implicit分为隐式参数和隐式转换方法.</p>
<h3 id="隐式参数">隐式参数</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#008000">//1.隐式参数
</span><span style="color:#008000"></span><span style="color:#00f">class</span> <span style="color:#2b91af">Prefixer</span>(<span style="color:#00f">val</span> prefix<span style="color:#00f">:</span> <span style="color:#2b91af">String</span>)

<span style="color:#00f">def</span> addPrefix(s<span style="color:#00f">:</span> <span style="color:#2b91af">String</span>)(<span style="color:#00f">implicit</span> p<span style="color:#00f">:</span> <span style="color:#2b91af">Prefixer</span>) <span style="color:#00f">=</span> p.prefix + s
<span style="color:#008000">// addPrefix需要提供一个隐式实际参数,否则报错.当然可以在调用时显式传递一个参数
</span><span style="color:#008000"></span><span style="color:#00f">implicit</span> <span style="color:#00f">val</span> myImplicitPrefixer <span style="color:#00f">=</span> <span style="color:#00f">new</span> <span style="color:#2b91af">Prefixer</span>(<span style="color:#a31515">&#34;***&#34;</span>)
addPrefix(<span style="color:#a31515">&#34;abc&#34;</span>) 
<span style="color:#008000">// returns &#34;***abc&#34;
</span></code></pre></div><h3 id="隐式转换">隐式转换</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#008000">//1. 定义一个含有目标方法的class
</span><span style="color:#008000"></span><span style="color:#00f">class</span> <span style="color:#2b91af">BlingString</span>(s<span style="color:#00f">:</span><span style="color:#2b91af">String</span>) {
  <span style="color:#00f">def</span> bling <span style="color:#00f">=</span> <span style="color:#a31515">&#34;*&#34;</span>+s+<span style="color:#a31515">&#34;*&#34;</span>
}

<span style="color:#008000">//2. 定义隐式转换方法
</span><span style="color:#008000"></span><span style="color:#00f">implicit</span> <span style="color:#00f">def</span> str2BlingString(s<span style="color:#00f">:</span><span style="color:#2b91af">String</span>) <span style="color:#00f">=</span> <span style="color:#00f">new</span> <span style="color:#2b91af">BlingString</span>(s)

<span style="color:#008000">//3. 使用目标方法
</span><span style="color:#008000"></span><span style="color:#00f">val</span> s <span style="color:#00f">=</span> <span style="color:#a31515">&#34;hello&#34;</span>
s.bling <span style="color:#008000">// *hello*
</span><span style="color:#008000"></span>
<span style="color:#008000">//在scala.Predef中定义了大量的隐式转换,例如RichInt,StringOps这些,提供类似mkString这些方法
</span><span style="color:#008000">//太阳底下无新事,scala常用对象的灵活丰富的语法都是通过隐式转换添加的.
</span></code></pre></div><h3 id="implicit-class">implicit class</h3>
<p>可以看到上面的第1,2步非常的繁琐，于是<a href="http://link.zhihu.com/?target=https%3A//docs.scala-lang.org/sips/implicit-classes.html">SIP-13</a>提出一个<code>implicit class</code>,将上面的2步合并:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#00f">implicit</span> <span style="color:#00f">class</span> <span style="color:#2b91af">BlingString</span>(s<span style="color:#00f">:</span><span style="color:#2b91af">String</span>) {
  <span style="color:#00f">def</span> bling <span style="color:#00f">=</span> <span style="color:#a31515">&#34;*&#34;</span>+s+<span style="color:#a31515">&#34;*&#34;</span>
}
<span style="color:#008000">//implicit def str2BlingString(s:String) = new BlingString(s)
</span><span style="color:#008000"></span>
<span style="color:#00f">val</span> hi <span style="color:#00f">=</span> <span style="color:#a31515">&#34;hello&#34;</span>
hi.bling <span style="color:#008000">// *hello*
</span></code></pre></div><p>注意，这个只是一个语法糖。去糖后就是上面的那个形式。 implicit class有3个约束和一个注解问题：</p>
<ol>
<li>
<p>必须要有主一个构造函数且只能一个构造参数（implicit参数除外）。构造参数就是源类型. 这个构造函数即等价上面第2步的隐式转换方法：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#00f">implicit</span> <span style="color:#00f">class</span> <span style="color:#2b91af">RichDate</span>(date<span style="color:#00f">:</span> <span style="color:#2b91af">java.util.Date</span>) <span style="color:#008000">// OK!
</span><span style="color:#008000"></span><span style="color:#00f">implicit</span> <span style="color:#00f">class</span> <span style="color:#2b91af">Indexer</span>[<span style="color:#2b91af">T</span>](collecton<span style="color:#00f">:</span> <span style="color:#2b91af">Seq</span>[<span style="color:#2b91af">T</span>], index<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>) <span style="color:#008000">// BAD!
</span><span style="color:#008000"></span><span style="color:#00f">implicit</span> <span style="color:#00f">class</span> <span style="color:#2b91af">Indexer</span>[<span style="color:#2b91af">T</span>](collecton<span style="color:#00f">:</span> <span style="color:#2b91af">Seq</span>[<span style="color:#2b91af">T</span>])(<span style="color:#00f">implicit</span> index<span style="color:#00f">:</span> <span style="color:#2b91af">Index</span>) <span style="color:#008000">// OK!
</span><span style="color:#008000"></span>
</code></pre></div></li>
<li>
<p>只能定义在其他trait/class/object中：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#00f">object</span> <span style="color:#2b91af">Helpers</span> {
<span style="color:#00f">implicit</span> <span style="color:#00f">class</span> <span style="color:#2b91af">RichInt</span>(x<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>) <span style="color:#008000">// OK!
</span><span style="color:#008000"></span>}
<span style="color:#00f">implicit</span> <span style="color:#00f">class</span> <span style="color:#2b91af">RichDouble</span>(x<span style="color:#00f">:</span> <span style="color:#2b91af">Double</span>) <span style="color:#008000">// BAD!
</span><span style="color:#008000"></span>
</code></pre></div></li>
<li>
<p>在当前scope内，不允许有和implicit class同名的方法，对象，变量。因为case class会自动生成同名object对象，所以implicit class不能是case class。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#00f">object</span> <span style="color:#2b91af">Bar</span>
<span style="color:#00f">implicit</span> <span style="color:#00f">class</span> <span style="color:#2b91af">Bar</span>(x<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>) <span style="color:#008000">// BAD!
</span><span style="color:#008000"></span>
<span style="color:#00f">val</span> x <span style="color:#00f">=</span> 5
<span style="color:#00f">implicit</span> <span style="color:#00f">class</span> <span style="color:#2b91af">x</span>(y<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>) <span style="color:#008000">// BAD!
</span><span style="color:#008000"></span>
<span style="color:#008000">//cuz case class has companion object by default 
</span><span style="color:#008000"></span><span style="color:#00f">implicit</span> <span style="color:#00f">case</span> <span style="color:#00f">class</span> <span style="color:#2b91af">Baz</span>(x<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>) <span style="color:#008000">// BAD! conflict with the companion object
</span><span style="color:#008000"></span>
</code></pre></div></li>
<li>
<p>还有就是implicit class的注解在去语法糖后会自动添加到类和方法，除非在注解中指明范围：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala">@bar
<span style="color:#00f">implicit</span> <span style="color:#00f">class</span> <span style="color:#2b91af">Foo</span>(n<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>)

<span style="color:#008000">//desugar
</span><span style="color:#008000"></span>@bar <span style="color:#00f">implicit</span> <span style="color:#00f">def</span> <span style="color:#2b91af">Foo</span>(n<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>)<span style="color:#00f">:</span> <span style="color:#2b91af">Foo</span> = <span style="color:#00f">new</span> <span style="color:#2b91af">Foo</span>(n)
@bar <span style="color:#00f">class</span> <span style="color:#2b91af">Foo</span>(n<span style="color:#00f">:</span><span style="color:#2b91af">Int</span>)

<span style="color:#008000">//除非在注解中指明：genClass / method
</span><span style="color:#008000"></span>@(bar @genClass) <span style="color:#00f">implicit</span> <span style="color:#00f">class</span> <span style="color:#2b91af">Foo</span>(n<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>)

<span style="color:#008000">//desugar得到
</span><span style="color:#008000"></span>@bar <span style="color:#00f">class</span> <span style="color:#2b91af">Foo</span>(n<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>)
<span style="color:#00f">implicit</span> <span style="color:#00f">def</span> <span style="color:#2b91af">Foo</span>(n<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>)<span style="color:#00f">:</span> <span style="color:#2b91af">Foo</span> = <span style="color:#00f">new</span> <span style="color:#2b91af">Foo</span>(n)
</code></pre></div></li>
</ol>
<h3 id="value-class">value class</h3>
<p>scala 还有一个概念：<a href="http://link.zhihu.com/?target=https%3A//docs.scala-lang.org/overviews/core/value-classes.html">value class</a></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#00f">class</span> <span style="color:#2b91af">Wrapper</span>(<span style="color:#00f">val</span> underlying<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>) <span style="color:#00f">extends</span> <span style="color:#2b91af">AnyVal</span>
<span style="color:#008000">//1. 一个public val参数表示runtime类型，这里是Int. 编译时是Wrapper类型，所以value class目的是降低分配开销。
</span><span style="color:#008000">//2. value class 需要 extends AnyVal
</span><span style="color:#008000">//3. value class 只能有 defs, 不能有vals, vars, or nested traits, classes or objects，
</span><span style="color:#008000">//   因为def是通过静态方法实现的，而val，var这些则必须创建相应类型了。
</span><span style="color:#008000">//4. value class 只能扩展通用trait（universal traits），
</span><span style="color:#008000">//   universal traits是A universal trait is a trait that extends Any, only has defs as members, and does no initialization.
</span><span style="color:#008000">//
</span></code></pre></div><h3 id="extension-method">extension method</h3>
<p>当implicit class类型参数是AnyVal子类时，value class和上面的implicit class形式相近，所以可以通过value class降低implicit class的分配开销。例如RichtInt</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#00f">implicit</span> <span style="color:#00f">class</span> <span style="color:#2b91af">RichInt</span>(<span style="color:#00f">val</span> self<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>) <span style="color:#00f">extends</span> <span style="color:#2b91af">AnyVal</span> {
  <span style="color:#00f">def</span> toHexString<span style="color:#00f">:</span> <span style="color:#2b91af">String</span> = java.lang.<span style="color:#2b91af">Integer</span>.toHexString(self)
}
</code></pre></div><p>因为RichInt是value class，在运行时（runtime）不会有RichInt这个类，而是Int，而<code>3.toHexString</code>实际是通过静态方法实现的： <code>RichInt$.MODULE$.extension$toHexString(3)</code>,这么做好处是减少对象分配开销(avoid the overhead of allocation)。如果implicit class的类型参数不是AnyVal子类，那么在runtime时会有相应类型对象被创建，用户察觉不到区别。
value class还有其他作用和局限性，可以参考上面链接。如果发现错误，请指出，先谢过。</p>
<p><a href="http://www.lihaoyi.com/post/ImplicitDesignPatternsinScala.html">Implicit Design Patterns in Scala​www.lihaoyi.com</a>
<a href="https://danielwestheide.com/scala/neophytes.html">The Neophyte&rsquo;s Guide to Scala​</a></p>
<h3 id="集合类的implicit转换">集合类的implicit转换</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#008000">//scala集合和java集合的转换是scala编程最常用的,毕竟java有大量第三方库.
</span><span style="color:#008000">//scala提供了两种方法,第一种方法就是隐式转换collection.JavaConversions(scala 2.8)
</span><span style="color:#008000">//很快意识到隐式转换对于使用者的代码阅读比较复杂,在2.8.1提供了显示转换collection.JavaConverters,
</span><span style="color:#008000">//先看JavaConversions隐式转换:
</span><span style="color:#008000"></span><span style="color:#00f">object</span> <span style="color:#2b91af">JavaConversions</span> <span style="color:#00f">extends</span> <span style="color:#2b91af">WrapAsScala</span> <span style="color:#00f">with</span> <span style="color:#2b91af">WrapAsJava</span>
<span style="color:#008000">//在WrapAsJava
</span><span style="color:#008000"></span>  <span style="color:#00f">implicit</span> <span style="color:#00f">def</span> mapAsJavaMap[<span style="color:#2b91af">A</span>, <span style="color:#2b91af">B</span>](m<span style="color:#00f">:</span> <span style="color:#2b91af">Map</span>[<span style="color:#2b91af">A</span>, <span style="color:#2b91af">B</span>])<span style="color:#00f">:</span> <span style="color:#2b91af">ju.Map</span>[<span style="color:#2b91af">A</span>, <span style="color:#2b91af">B</span>] <span style="color:#00f">=</span> m <span style="color:#00f">match</span> {
    <span style="color:#00f">case</span> <span style="color:#00f">null</span>                 <span style="color:#00f">=&gt;</span> <span style="color:#00f">null</span>
    <span style="color:#00f">case</span> <span style="color:#2b91af">JMapWrapper</span>(wrapped) <span style="color:#00f">=&gt;</span> wrapped.asInstanceOf[<span style="color:#2b91af">ju.Map</span>[<span style="color:#2b91af">A</span>, <span style="color:#2b91af">B</span>]]
    <span style="color:#00f">case</span> <span style="color:#00f">_</span>                    <span style="color:#00f">=&gt;</span> <span style="color:#00f">new</span> <span style="color:#2b91af">MapWrapper</span>(m)
  }

<span style="color:#008000">//然后看下collection.JavaConverters._,稍微复杂一些,但是换汤不换药,底层还是隐式转换,
</span><span style="color:#008000"></span><span style="color:#00f">object</span> <span style="color:#2b91af">JavaConverters</span> <span style="color:#00f">extends</span> <span style="color:#2b91af">DecorateAsJava</span> <span style="color:#00f">with</span> <span style="color:#2b91af">DecorateAsScala</span>
<span style="color:#008000">//在DecorateAsJava中有很多隐式转换方法,这些方法将scala集合转换为AsJava对象
</span><span style="color:#008000">//(注意下面的ju,是java.util缩写,详情见[征服scala_1](https://zhuanlan.zhihu.com/p/22670426))
</span><span style="color:#008000"></span><span style="color:#00f">implicit</span> <span style="color:#00f">def</span> seqAsJavaListConverter[<span style="color:#2b91af">A</span>](b <span style="color:#00f">:</span> <span style="color:#2b91af">Seq</span>[<span style="color:#2b91af">A</span>])<span style="color:#00f">:</span> <span style="color:#2b91af">AsJava</span>[<span style="color:#2b91af">ju.List</span>[<span style="color:#2b91af">A</span>]] <span style="color:#00f">=</span> <span style="color:#00f">new</span> <span style="color:#2b91af">AsJava</span>(seqAsJavaList(b))
<span style="color:#008000">// 而AsJava中定义了asJava方法,这样我们就可以在scala集合上面调用asJava
</span><span style="color:#008000"></span><span style="color:#00f">class</span> <span style="color:#2b91af">AsJava</span>[<span style="color:#2b91af">A</span>](op<span style="color:#00f">:</span> =&gt; A) {
    <span style="color:#008000">/** Converts a Scala collection to the corresponding Java collection */</span>
    <span style="color:#00f">def</span> asJava<span style="color:#00f">:</span> <span style="color:#2b91af">A</span> = op
}
<span style="color:#008000">//并且asJava方法的实现是作为构造参数传入AsJava的
</span><span style="color:#008000">//上面的seqAsJavaList就是将scala.Seq转换为ju.List的具体实现
</span><span style="color:#008000"></span><span style="color:#00f">def</span> seqAsJavaList[<span style="color:#2b91af">A</span>](s<span style="color:#00f">:</span> <span style="color:#2b91af">Seq</span>[<span style="color:#2b91af">A</span>])<span style="color:#00f">:</span> <span style="color:#2b91af">ju.List</span>[<span style="color:#2b91af">A</span>] <span style="color:#00f">=</span> s <span style="color:#00f">match</span> {
  <span style="color:#00f">case</span> <span style="color:#00f">null</span>                   <span style="color:#00f">=&gt;</span> <span style="color:#00f">null</span>
  <span style="color:#00f">case</span> <span style="color:#2b91af">JListWrapper</span>(wrapped)  <span style="color:#00f">=&gt;</span> wrapped.asInstanceOf[<span style="color:#2b91af">ju.List</span>[<span style="color:#2b91af">A</span>]]
  <span style="color:#00f">case</span> <span style="color:#00f">_</span>                      <span style="color:#00f">=&gt;</span> <span style="color:#00f">new</span> <span style="color:#2b91af">SeqWrapper</span>(s)
}

<span style="color:#008000">//综上,JavaConverters用的还是隐式转换,只不过增加了一个中间类AsJava/AsScala.
</span></code></pre></div><h3 id="隐式转换的scope">隐式转换的scope</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#008000">//无论是隐式参数还是隐式转换,编译器都要知道去哪里查找这些implicit参数或者方法,
</span><span style="color:#008000">//例如import collection.JavaConverters._
</span><span style="color:#008000">//由于scala import可以出现在任何地方,这为控制implicit的scope提供了灵活性
</span><span style="color:#008000">//这一块我不是完全清楚,只提供一个自己的理解
</span><span style="color:#008000">// 1.首先是当前scope的Implicits定义,例如,当前方法内,class内
</span><span style="color:#008000">// 2.显式导入 import collection.JavaConversions.asScalaIterator
</span><span style="color:#008000">// 3.通配符导入 import collection.JavaConverters._
</span><span style="color:#008000">// 4.类型的伴生对象内(这个常用)
</span><span style="color:#008000">// 5.参数类型的隐式scope (2.9.1添加):class构造参数的隐式转换搜索返回会被应用到
</span><span style="color:#008000"></span><span style="color:#00f">class</span> <span style="color:#2b91af">A</span>(<span style="color:#00f">val</span> n<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>) {
  <span style="color:#00f">def</span> +(other<span style="color:#00f">:</span> <span style="color:#2b91af">A</span>) <span style="color:#00f">=</span> <span style="color:#00f">new</span> A(n + other.n)
}
<span style="color:#00f">object</span> <span style="color:#2b91af">A</span> {
  <span style="color:#00f">implicit</span> <span style="color:#00f">def</span> fromInt(n<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>) <span style="color:#00f">=</span> <span style="color:#00f">new</span> A(n)
}

<span style="color:#00f">new</span> A(1) + 2 <span style="color:#008000">// new A(1) + A.fromInt(2)
</span><span style="color:#008000">//6.类型参数的隐式转换,下面的sorted方法期望有一个Ordering[A],
</span><span style="color:#008000">//在伴生对象中提供了一个 A -&gt; Ordering[A] ,
</span><span style="color:#008000"></span><span style="color:#00f">class</span> <span style="color:#2b91af">A</span>(<span style="color:#00f">val</span> n<span style="color:#00f">:</span> <span style="color:#2b91af">Int</span>)
<span style="color:#00f">object</span> <span style="color:#2b91af">A</span> {
    <span style="color:#00f">implicit</span> <span style="color:#00f">val</span> ord <span style="color:#00f">=</span> <span style="color:#00f">new</span> <span style="color:#2b91af">Ordering</span>[<span style="color:#2b91af">A</span>] {
        <span style="color:#00f">def</span> compare(x<span style="color:#00f">:</span> <span style="color:#2b91af">A</span>, y<span style="color:#00f">:</span> <span style="color:#2b91af">A</span>) <span style="color:#00f">=</span> implicitly[<span style="color:#2b91af">Ordering</span>[<span style="color:#2b91af">Int</span>]].compare(x.n, y.n)
    }
}
<span style="color:#2b91af">List</span>(<span style="color:#00f">new</span> A(5), <span style="color:#00f">new</span> A(2)).sorted
<span style="color:#008000">// 注意implicitly[Ordering[Int]] 表示在当前scope内搜索一个隐式参数值
</span><span style="color:#008000"></span><span style="color:#00f">def</span> implicitly[<span style="color:#2b91af">T</span>](<span style="color:#00f">implicit</span> e<span style="color:#00f">:</span> <span style="color:#2b91af">T</span>)<span style="color:#00f">:</span> <span style="color:#2b91af">T</span> = e
</code></pre></div><h2 id="string">string</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala">
<span style="color:#008000">// The s String Interpolator:
</span><span style="color:#008000"></span><span style="color:#00f">val</span> name <span style="color:#00f">=</span> <span style="color:#a31515">&#34;James&#34;</span>
println(<span style="color:#a31515">s&#34;Hello, </span><span style="color:#a31515">$name</span><span style="color:#a31515">&#34;</span>)  <span style="color:#008000">// Hello, James
</span><span style="color:#008000"></span>
<span style="color:#008000">// The f Interpolator
</span><span style="color:#008000"></span><span style="color:#00f">val</span> height <span style="color:#00f">=</span> 1.9d
<span style="color:#00f">val</span> name <span style="color:#00f">=</span> <span style="color:#a31515">&#34;James&#34;</span>
println(<span style="color:#a31515">f&#34;</span><span style="color:#a31515">$name</span><span style="color:#a31515">%s is </span><span style="color:#a31515">$height</span><span style="color:#a31515">%2.2f meters tall&#34;</span>)  <span style="color:#008000">// James is 1.90 meters tall
</span><span style="color:#008000"></span>
<span style="color:#008000">// The raw Interpolator
</span><span style="color:#008000">// The raw interpolator is similar to the s interpolator except that 
</span><span style="color:#008000">// it performs no escaping of literals within the string. 
</span><span style="color:#008000">// Here’s an example processed string
</span><span style="color:#008000">// 即不翻译转义字符
</span><span style="color:#008000"></span>scala&gt;<span style="color:#a31515">raw&#34;a\nb&#34;</span>
res1<span style="color:#00f">:</span> <span style="color:#2b91af">String</span> = a\nb

<span style="color:#008000">// &#34;&#34;&#34; triple quotes string
</span><span style="color:#008000">// triple quotes &#34;&#34;&#34; to escape characters
</span><span style="color:#008000"></span><span style="color:#00f">val</span> donutJson4<span style="color:#00f">:</span> <span style="color:#2b91af">String</span> =
    <span style="color:#a31515">&#34;&#34;&#34;
</span><span style="color:#a31515">      |{
</span><span style="color:#a31515">      |&#34;donut_name&#34;:&#34;Glazed Donut&#34;,
</span><span style="color:#a31515">      |&#34;taste_level&#34;:&#34;Very Tasty&#34;,
</span><span style="color:#a31515">      |&#34;price&#34;:2.50
</span><span style="color:#a31515">      |}
</span><span style="color:#a31515">      &#34;&#34;&#34;</span>
   .stripMargin
<span style="color:#008000">// |会被忽略
</span><span style="color:#008000">// &#34;&#34;&#34;还有个很好的用处,正则表达式:
</span><span style="color:#008000">// 在java中表示一个或多个空格,&#34;\\s+&#34;
</span><span style="color:#008000">// 在scala中只要 &#34;&#34;&#34;\s+&#34;&#34;&#34;,对于复杂正则表达式非常有用.
</span></code></pre></div><h2 id="links">links</h2>
<p><a href="https://www.btbytes.com/scala.html">https://www.btbytes.com/scala.html</a></p>
<p><a href="https://booksites.artima.com/programming_in_scala_2ed/examples/index.html">https://booksites.artima.com/programming_in_scala_2ed/examples/index.html</a></p>
<p><a href="http://blog.higher-order.com/assets/fpiscompanion.pdf">http://blog.higher-order.com/assets/fpiscompanion.pdf</a></p>
<p><a href="https://courses.cs.washington.edu/courses/cse341/09au/notes/scala.html">https://courses.cs.washington.edu/courses/cse341/09au/notes/scala.html</a></p>
<p><a href="https://github.com/dnvriend/my-scala-notes">https://github.com/dnvriend/my-scala-notes</a></p>
<p><a href="https://gist.github.com/jamesyang124/d65b067327452792287a">https://gist.github.com/jamesyang124/d65b067327452792287a</a></p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="https://zhimoe.github.io/tags/code" rel="tag" title="code">#code#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://zhimoe.github.io/post/scala-type-class/" rel="next" title="Scala Type Class">
        <i class="fa fa-chevron-left"></i> Scala Type Class
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://zhimoe.github.io/post/%E4%BD%BF%E7%94%A8redis%E7%9A%84hash%E4%BC%98%E5%8C%96%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8/" rel="prev" title="使用redis的hash优化内存使用">
        使用redis的hash优化内存使用 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     
<div id="disqus_thread"></div>
<script>


var disqus_config = function () {
  this.page.url = "https://zhimoe.github.io/post/scala-notes/";  
  this.page.identifier = "https://zhimoe.github.io/post/scala-notes/"; 
};

(function() { 
  var d = document, s = d.createElement('script');
  s.src = 'https://zhimoe.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>                            

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://zhimoe.github.io/img/avatar.png"
        alt="zhimoe" />
    <p class="site-author-name" itemprop="name">zhimoe</p>
    <p class="site-description motion-element" itemprop="description"> 
        the craft of programming</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://zhimoe.github.io/post/">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://zhimoe.github.io/categories/">      
         
        <span class="site-state-item-count">4</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://zhimoe.github.io/tags/">
         
        <span class="site-state-item-count">34</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/zhimoe/" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://twitter.com/_zhimoe" target="_blank" title="twitter">
            <i class="fa fa-fw fa-twitter"></i>
            twitter
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://www.zhihu.com/question/21142149/answer/52383396" target="_blank" title="知乎">
            <i class="fa fa-fw fa-globe"></i>
            知乎
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=55k6ne41ev6&amp;m=0&amp;c=03a89e&amp;cr1=b22222&amp;f=calibri&amp;l=33" async="async"></script>
</div>




    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#setup-with-maven">setup with maven</a></li>
    <li><a href="#import">import</a></li>
    <li><a href="#-and-eq">== and eq</a></li>
    <li><a href="#case-class">case class</a></li>
    <li><a href="#foryield">for&hellip;yield</a></li>
    <li><a href="#companion-object">companion object</a></li>
    <li><a href="#method-and-functiondef-val">method and function(def val)</a></li>
    <li><a href="#_-in-scala">_ in scala</a></li>
    <li><a href="#-in-scala">=&gt; in scala</a>
      <ul>
        <li><a href="#函数字面量分隔参数和函数体">函数字面量分隔参数和函数体</a></li>
        <li><a href="#call-by-name-parameter">call-by-name parameter</a></li>
        <li><a href="#模式匹配中分隔case模式和返回值">模式匹配中分隔case模式和返回值</a></li>
      </ul>
    </li>
    <li><a href="#--in-method-call">() {} in method call</a></li>
    <li><a href="#implicit">implicit</a>
      <ul>
        <li><a href="#隐式参数">隐式参数</a></li>
        <li><a href="#隐式转换">隐式转换</a></li>
        <li><a href="#implicit-class">implicit class</a></li>
        <li><a href="#value-class">value class</a></li>
        <li><a href="#extension-method">extension method</a></li>
        <li><a href="#集合类的implicit转换">集合类的implicit转换</a></li>
        <li><a href="#隐式转换的scope">隐式转换的scope</a></li>
      </ul>
    </li>
    <li><a href="#string">string</a></li>
    <li><a href="#links">links</a></li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">zhimoe</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.69.2</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/zhimoe/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js"></script> 
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery_lazyload@1.9.3/jquery.lazyload.min.js"></script>
<script type="text/javascript" src="https://libs.jshub.com/velocity/1.2.3/velocity.min.js"></script>
<script type="text/javascript" src="https://libs.jshub.com/velocity/1.2.3/velocity.ui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ua-parser-js@0.7.21/dist/ua-parser.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/fancybox@2.1.5/dist/css/jquery.fancybox.css"></script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhimoe/zhimoe.github.io@gh-pages/js/utils.js"></script> 
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhimoe/zhimoe.github.io@gh-pages/js/motion.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhimoe/zhimoe.github.io@gh-pages/js/affix.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhimoe/zhimoe.github.io@gh-pages/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhimoe/zhimoe.github.io@gh-pages/js/scrollspy.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhimoe/zhimoe.github.io@gh-pages/js/post-details.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhimoe/zhimoe.github.io@gh-pages/js/toc.js"></script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhimoe/zhimoe.github.io@gh-pages/js/bootstrap.js"></script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhimoe/zhimoe.github.io@gh-pages/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdn.jsdelivr.net/npm/mathjax@2.7.5/config/TeX-AMS-MML_HTMLorMML.js' async></script>
</body>
</html>
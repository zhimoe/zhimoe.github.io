<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Rust Packages Crates Mod Notes - 香取海</title>
<meta property="og:title" content="Rust Packages Crates Mod Notes - 香取海"><meta name=twitter:card content="summary"><meta property="description" content="初学 rust 对于项目的 package 和 crate 的关系，module 和文件的关系有点理不清。做了一点笔记。
[&amp;hellip;] A Cargo.toml is a package. and must have a package name, defined in [package] table:
[&amp;hellip;] [package] name = &amp;hellip;"><meta property="og:description" content="初学 rust 对于项目的 package 和 crate 的关系，module 和文件的关系有点理不清。做了一点笔记。
[&amp;hellip;] A Cargo.toml is a package. and must have a package name, defined in [package] table:
[&amp;hellip;] [package] name = &amp;hellip;"><link rel=stylesheet href=../../css/style.css><link rel=stylesheet href=../../css/fonts.css><link rel=stylesheet href=../../css/custom.css><link rel=icon type=image/png href=../../img/logo.png><link rel=apple-touch-icon href=../../img/logo.png><link rel=apple-touch-icon-precomposed href=../../img/logo.png></head><body class="single post"><div class=crop-h></div><div class=crop-v></div><div class=crop-c></div><nav class="nav-top small"><div class=logo><a href=../../>香取海</a></div><div class=menu><span class=active><a href=../../post/>博客</a></span>
<span><a href=../../categories/%E7%BC%96%E7%A8%8B/>编程</a></span>
<span><a href=../../categories/%E7%BF%BB%E8%AF%91/>翻译</a></span>
<span><a href=../../categories/%E9%9A%8F%E6%83%B3/>随想</a></span>
<span><a href=../../search/>搜索</a></span></div></nav><div class=article-meta><h1 class=title>Rust Packages Crates Mod Notes</h1><h3 class=meta-line><span><span class=date>2020-01-12</span>
</span><span class=term><a href=../../categories/%E7%BC%96%E7%A8%8B/ class=term-cat>编程</a>
<a href=../../tags/code/ class=term-tag>#code </a><a href=../../tags/rust/ class=term-tag>#rust</a></span></h3></div><div class=main><nav id=TableOfContents><ul><li><a href=#packages-and-crates>packages and crates</a></li><li><a href=#crate-and-mod>crate and mod</a></li><li><a href=#use-keyword>use keyword</a><ul><li><a href=#use-foobar-vs-use-cratefoobar>use foo::bar vs use crate::foo::bar</a></li></ul></li><li><a href=#split-up-mod-into-files>split up mod into files</a></li><li><a href=#pub-in-struct-and-enum>pub in struct and enum</a></li></ul></nav><p>初学 rust 对于项目的 package 和 crate 的关系，module 和文件的关系有点理不清。做了一点笔记。</p><h2 id=packages-and-crates>packages and crates</h2><p>A Cargo.toml is a package. and must have a package name, defined in <code>[package]</code> table:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#000>package</span>]
</span></span><span style=display:flex><span><span style=color:#000>name</span> = <span style=color:#c41a16>&#34;actix-web&#34;</span>
</span></span></code></pre></div><p>A package contains one or more crates.<br>a package can only have 0 or 1 library crate, no more; the entry file is <code>lib.rs</code><br>A package <em>can</em> contain as many binary crates as you’d like. the entry file is <code>main.rs</code> or <code>src/bin/b1.rs</code> etc.</p><p>by convention, package-name is use <code>-</code> (dash), but lib_name must use <code>_</code> (underscores, can not be dash <code>-</code>);</p><p>cargo will auto replace the <code>-</code> with <code>_</code> in package-name to name the default library crate(lib.rs in src root). you can name it in [lib]:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span><span style=color:#177500># rename the lib crate</span>
</span></span><span style=display:flex><span>[<span style=color:#000>lib</span>]
</span></span><span style=display:flex><span><span style=color:#000>name</span> = <span style=color:#c41a16>&#34;actix_web&#34;</span>
</span></span><span style=display:flex><span><span style=color:#000>path</span> = <span style=color:#c41a16>&#34;src/lib.rs&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500># also you can rename the binary crate:</span>
</span></span><span style=display:flex><span><span style=color:#177500># it use [[]], array of table in toml, </span>
</span></span><span style=display:flex><span><span style=color:#177500># cuz a package can have many binary crate.</span>
</span></span><span style=display:flex><span>[[<span style=color:#000>bin</span>]]
</span></span><span style=display:flex><span><span style=color:#000>name</span> = <span style=color:#c41a16>&#34;my-cool-binary&#34;</span>
</span></span><span style=display:flex><span><span style=color:#000>path</span> = <span style=color:#c41a16>&#34;src/my-cool-binary.rs&#34;</span>
</span></span></code></pre></div><p>one package(project) can only have one library crate, when the lib continues to get bigger, you want to split up the lib into multiple packages.<br>cargo introduce you with workspace.</p><blockquote><p>A workspace is a set of packages that share the same Cargo.lock and output directory.</p></blockquote><p>here is the actix-web package Cargo.toml file:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#000>workspace</span>]
</span></span><span style=display:flex><span><span style=color:#000>members</span> = [
</span></span><span style=display:flex><span>  <span style=color:#c41a16>&#34;.&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#c41a16>&#34;awc&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#c41a16>&#34;actix-http&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#c41a16>&#34;actix-cors&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#c41a16>&#34;actix-files&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#c41a16>&#34;actix-framed&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#c41a16>&#34;actix-session&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#c41a16>&#34;actix-identity&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#c41a16>&#34;actix-multipart&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#c41a16>&#34;actix-web-actors&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#c41a16>&#34;actix-web-codegen&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#c41a16>&#34;test-server&#34;</span>,
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span><span style=color:#177500># awc,actix-http... all are packages that contains their own Cargo.toml and src/lib.rs; </span>
</span></span></code></pre></div><h2 id=crate-and-mod>crate and mod</h2><p>A crate is a compilation unit in Rust.</p><p>Whenever <code>rustc some_file.rs</code> is called, some_file.rs is treated as the crate file.<br>If some_file.rs has mod declarations in it, then the contents of the module files would be inserted<br>in places where mod declarations in the crate file are found, before running the compiler it.<br>In other words, modules do not get compiled individually, only crates get compiled.</p><p><code>mod mod_name {}</code> defines a mod.</p><p><code>mod mod_name; </code>import a mod. cargo will look for mod_name.rs or mod_name/mod.rs and insert the content to current file.</p><p>by default the mod is private; but nested mod is allowed to use any code in super mod;</p><p><code>self</code> and <code>super</code> is to ref the current mod and parent mod;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#a90d91>fn</span> <span style=color:#000>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#177500>// absolute root path
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>crate</span>::<span style=color:#000>music</span>::<span style=color:#000>popular</span>::<span style=color:#000>play</span>();
</span></span><span style=display:flex><span>              
</span></span><span style=display:flex><span>    <span style=color:#177500>// relative path
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>music</span>::<span style=color:#000>popular</span>::<span style=color:#000>play</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=use-keyword>use keyword</h2><p>the <code>use</code> keyword brings path into scope;</p><p>注意，rust 中<code>mod</code>才是 import，<code>use</code>只是简化 path 长度。在同一个 package 内部，必须要<code>mod module_name;</code>之后才能使用<code>use module_name::func</code>.<br>如果是<code>Cargo.toml</code>中的依赖 crate，无需<code>mod</code>也无需<code>use</code>（使用 full path）就可以使用 crate 的 item。</p><p>对于 function，一般约定是 use 函数名上一级：<code>use mods::foo::bar;</code>，而不是直接 use 函数<code>use mods::foo::bar::func_name;</code></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#177500>//Providing New Names with the as Keyword
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>use</span> <span style=color:#000>std</span>::<span style=color:#000>io</span>::<span style=color:#a90d91>Result</span> <span style=color:#a90d91>as</span> <span style=color:#000>IoResult</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>//Re-exporting Names with pub use
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>pub</span> <span style=color:#a90d91>use</span> <span style=color:#a90d91>crate</span>::<span style=color:#000>music</span>::<span style=color:#000>popular</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>//Use nested paths or the glob operator
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>use</span> <span style=color:#000>std</span>::{<span style=color:#000>cmp</span>::<span style=color:#000>Ordering</span>, <span style=color:#000>io</span>};
</span></span><span style=display:flex><span><span style=color:#a90d91>use</span> <span style=color:#000>std</span>::<span style=color:#000>collections</span>::<span style=color:#000>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>//by default, use is absolute.
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>use</span> <span style=color:#a90d91>crate</span>::<span style=color:#000>music</span>::<span style=color:#000>popular</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>use</span> <span style=color:#000>std</span>::{<span style=color:#5b269a>self</span>,<span style=color:#000>Write</span>}; <span style=color:#177500>// std and Write 
</span></span></span><span style=display:flex><span><span style=color:#177500></span>
</span></span><span style=display:flex><span><span style=color:#177500>//bring a module into scope with `use` and a relative path need start `self`:
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>use</span> <span style=color:#5b269a>self</span>::<span style=color:#000>music</span>::<span style=color:#000>popular</span>;
</span></span></code></pre></div><p>in most cases you won&rsquo;t need to use <code>extern crate</code> anymore because Cargo informs the compiler about what crates are present. (There are one or two exceptions):<a href=https://doc.rust-lang.org/edition-guide/rust-2018/path-changes.html#an-exception>sysroot mod</a></p><h3 id=use-foobar-vs-use-cratefoobar>use foo::bar vs use crate::foo::bar</h3><p><a href=https://doc.rust-lang.org/reference/items/use-declarations.html#use-paths>use in</a></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#a90d91>mod</span> <span style=color:#000>my_mod</span> {
</span></span><span style=display:flex><span>    <span style=color:#a90d91>pub</span> <span style=color:#a90d91>mod</span> <span style=color:#000>foo</span> {
</span></span><span style=display:flex><span>        <span style=color:#a90d91>pub</span> <span style=color:#a90d91>mod</span> <span style=color:#000>bar</span> {
</span></span><span style=display:flex><span>            <span style=color:#a90d91>pub</span> <span style=color:#a90d91>fn</span> <span style=color:#000>greet</span>() {
</span></span><span style=display:flex><span>                <span style=color:#000>println!</span>(<span style=color:#c41a16>&#34;hello rust&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a90d91>pub</span> <span style=color:#a90d91>fn</span> <span style=color:#000>greet_twice</span>() {
</span></span><span style=display:flex><span>            <span style=color:#177500>// use super::foo::bar::greet;          // ok 相对路径
</span></span></span><span style=display:flex><span><span style=color:#177500></span>            <span style=color:#177500>// use self::bar::greet;                // ok 相对路径
</span></span></span><span style=display:flex><span><span style=color:#177500></span>            <span style=color:#177500>// use my_mod::foo::bar::greet;         // error in 2018+ but ok in 2015 edition.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>            <span style=color:#a90d91>use</span> <span style=color:#a90d91>crate</span>::<span style=color:#000>my_mod</span>::<span style=color:#000>foo</span>::<span style=color:#000>bar</span>::<span style=color:#000>greet</span>;     <span style=color:#177500>// ok 绝对路径，建议使用
</span></span></span><span style=display:flex><span><span style=color:#177500></span>            <span style=color:#000>greet</span>();
</span></span><span style=display:flex><span>            <span style=color:#000>greet</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>fn</span> <span style=color:#000>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#177500>// use crate::my_mod::foo::bar;   // ok 绝对路径 preferred
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#177500>// use self::my_mod::foo::bar;    // ok 相对路径
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>use</span> <span style=color:#000>my_mod</span>::<span style=color:#000>foo</span>::<span style=color:#000>bar</span>;             <span style=color:#177500>// ok 相对路径，省略了 self, error in 2015 edition: relative paths are not allowed without `self`;
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>bar</span>::<span style=color:#000>greet</span>();
</span></span><span style=display:flex><span>    <span style=color:#a90d91>use</span> <span style=color:#a90d91>crate</span>::<span style=color:#000>my_mod</span>::<span style=color:#000>foo</span>;
</span></span><span style=display:flex><span>    <span style=color:#000>foo</span>::<span style=color:#000>greet_twice</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=split-up-mod-into-files>split up mod into files</h2><ol><li>the mod can be defined in mod_name.rs or mod_name/mod.rs. and nested mod can be in mod_name/nested_mod.rs.</li><li>you can ref the nested_mod by use <code>mod nested_mod;</code> in mod_name.rs;</li></ol><h2 id=pub-in-struct-and-enum>pub in struct and enum</h2><ol><li>the Struct members is all private by default even struct name is pub;</li><li>the Enum members is all public by default if the name is pub;</li></ol><nav class="post-nav fullwidth"><span>&larr; <a href=../../post/scala-for-impatient-2nd-highlights/>Highlights in Scala for Impatient 2nd</a></span>
<span class=post-nav-next><a href=../../post/git-useful-tips/>git 常用命令备忘录</a> &rarr;</span></nav></div><footer class=small><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fix-toc.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/gh/rstudio/markdown/inst/resources/prism-xcode.css><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js defer></script><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/copy-button.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/copy-button.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/key-buttons.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/key-buttons.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/heading-anchor.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/external-link.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/ol-id.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fullwidth.min.js defer></script><hr><p class=nav-bottom><span><a href=https://zhi.moe>xdh</a> © 2024</span>
<span class=menu-bottom><a href=../../categories/>分类</a> <a href=../../tags/>标签</a>
<a href=../../post/index.xml type=application/rss+xml title="RSS feed">订阅</a>
<a href=#>回到顶部</a></span></p></footer></body></html>
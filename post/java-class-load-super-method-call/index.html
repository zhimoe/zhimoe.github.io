<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Java类加载过程和子类重写父类方法的调用 - 香取海</title>
<meta property="og:title" content="Java类加载过程和子类重写父类方法的调用 - 香取海"><meta name=twitter:card content="summary"><meta property="description" content="最近非常火的一道携程面试题 Java
[&amp;hellip;] public class Base { private String baseName = &amp;#34;base&amp;#34;; public Base() { callName(); } public void callName() { System.out.println(baseName); } static class Sub &amp;hellip;"><meta property="og:description" content="最近非常火的一道携程面试题 Java
[&amp;hellip;] public class Base { private String baseName = &amp;#34;base&amp;#34;; public Base() { callName(); } public void callName() { System.out.println(baseName); } static class Sub &amp;hellip;"><meta name=twitter:image content="https://jsd.cdn.zzko.cn/gh/zhimoe/zhimoe.pic@main/pic/base-sub.7jmh61bdbbo0.webp"><link rel=stylesheet href=../../css/style.css><link rel=stylesheet href=../../css/fonts.css><link rel=stylesheet href=../../css/custom.css><link rel=icon type=image/png href=../../img/logo.png><link rel=apple-touch-icon href=../../img/logo.png><link rel=apple-touch-icon-precomposed href=../../img/logo.png></head><body class="single post"><div class=crop-h></div><div class=crop-v></div><div class=crop-c></div><nav class="nav-top small"><div class=logo><a href=../../>香取海</a></div><div class=menu><span class=active><a href=../../post/>博客</a></span>
<span><a href=../../categories/%E7%BC%96%E7%A8%8B/>编程</a></span>
<span><a href=../../categories/%E7%BF%BB%E8%AF%91/>翻译</a></span>
<span><a href=../../categories/%E9%9A%8F%E6%83%B3/>随想</a></span>
<span><a href=../../search/>搜索</a></span></div></nav><div class=article-meta><h1 class=title>Java类加载过程和子类重写父类方法的调用</h1><h3 class=meta-line><span><span class=date>2016-01-01</span>
</span><span class=term><a href=../../categories/%E7%BC%96%E7%A8%8B/ class=term-cat>编程</a>
<a href=../../tags/java/ class=term-tag>#java </a><a href=../../tags/code/ class=term-tag>#code</a></span></h3></div><div class=main><p>最近非常火的一道携程面试题 Java</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a90d91>public</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Base</span> {
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#000>String</span> <span style=color:#000>baseName</span> <span style=color:#000>=</span> <span style=color:#c41a16>&#34;base&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#000>Base</span>() {
</span></span><span style=display:flex><span>        <span style=color:#000>callName</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#a90d91>void</span> <span style=color:#000>callName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#000>System</span>.<span style=color:#836c28>out</span>.<span style=color:#836c28>println</span>(<span style=color:#000>baseName</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>static</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Sub</span> <span style=color:#a90d91>extends</span> <span style=color:#000>Base</span> {
</span></span><span style=display:flex><span>        <span style=color:#a90d91>private</span> <span style=color:#000>String</span> <span style=color:#000>baseName</span> <span style=color:#000>=</span> <span style=color:#c41a16>&#34;sub&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a90d91>public</span> <span style=color:#a90d91>void</span> <span style=color:#000>callName</span>() {
</span></span><span style=display:flex><span>            <span style=color:#000>System</span>.<span style=color:#836c28>out</span>.<span style=color:#836c28>println</span>(<span style=color:#000>baseName</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>void</span> <span style=color:#000>main</span>(<span style=color:#000>String</span><span style=color:#000>[]</span> <span style=color:#000>args</span>) {
</span></span><span style=display:flex><span>        <span style=color:#000>Base</span> <span style=color:#000>b</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>Sub</span>(); <span style=color:#177500>// 输出？</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我的理解：<br>先理解两个方法：<br>class 的 (clinit) 方法和 (init) 方法不同：这两个方法一个是虚拟机在装载一个类初始化的时候调用的（<code>&lt;clinit></code>）.另一个是在类实例化时调用的（<code>&lt;init></code>）.</p><p>在加载类时需要类的初始化，JVM 对应的字节码方法是<code>&lt;clinit></code>，这个方法会初始化 static 变量和执行 static{}代码块，按源码定义的顺序执行。<strong>注意</strong>：如果 static{}代码块中引用了 static 变量，那么一定要使用之前定义 static 变量.ide 会提示的。</p><p>这时，class 的其他成员变量和方法都没有被执行。变量的内存都已经分配，值为 null 或者 0（基本类型），false(布尔类型).<br>当创建一个类的实例时，此时会调用<code>&lt;init></code>方法，这个方法会初始化非 static 变量和执行{}代码块。注意，这两个也是按源码顺序执行的。所以代码块如果要使用非 static 变量，一定要先定义。同样 ide 一般会提示的。但是要明白这个顺序。</p><p>以上说的执行顺序通过 eclipse 调试可以确定是正确的。</p><p>所以组合起来 创建一个类的实例对象需要下面的顺序：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-s data-lang=s><span style=display:flex><span>父类<span style=color:#000>P</span> <span style=color:#000>static代码块和static变量初始化</span> 
</span></span><span style=display:flex><span><span style=color:#000>-&gt;</span> 子类<span style=color:#000>S</span> <span style=color:#000>static代码块和static变量初始化</span>  
</span></span><span style=display:flex><span><span style=color:#000>-&gt;</span> 父类<span style=color:#000>P</span> 非<span style=color:#000>static代码块和非static变量初始化</span> 
</span></span><span style=display:flex><span><span style=color:#000>-&gt;</span> 父类<span style=color:#000>P构造函数</span> 
</span></span><span style=display:flex><span><span style=color:#000>-&gt;</span> 子类<span style=color:#000>S非static代码块和非static变量初始化</span> 
</span></span><span style=display:flex><span><span style=color:#000>-&gt;</span> 子类<span style=color:#000>S构造函数</span>
</span></span></code></pre></div><p>回到面试题：我们看看创建一个实例对象的调用栈：</p><p><img src=https://jsd.cdn.zzko.cn/gh/zhimoe/zhimoe.pic@main/pic/base-sub.7jmh61bdbbo0.webp alt="创建实例时调用栈 - 图片"></p><p>可以看到依次进入 16，8，21 行代码：</p><p>16 行：<code> static class Sub extends Base</code></p><p>8 行：<code> callName();//Base()构造函数中</code></p><p>21 行：<code> System.out.println (baseName) ;//Sub的callName()</code></p><p>根据前面的分析，这个类没有 static 代码块和 static 变量，也没有代码块。所以第一个执行的是父类非静态成员的 base=&ldquo;base&rdquo;;接着执行构造函数 Base();这里到了魔法的一步，调用的 callName() 是子类（21 行）的方法。这个行为就是<strong>动态单分派</strong>.详细资料看最后。由于子类的非 static 变量初始化没有完成，所有子类中的 base 变量是 null.输出也是 null.</p><p>！！！所以，不要再构造函数中调用可能会被子类覆盖的方法。</p><p>有的面试题会出现陷阱：在调用 callName() 方法改为 this.callName(). 其实都是一样的。在调用 Base 构造函数时没有 Base 的实例对象，调用者其实还是 Base$Sub 这个类。</p><p>还有一个进阶版：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a90d91>public</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Basic</span> {
</span></span><span style=display:flex><span>	<span style=color:#a90d91>public</span> <span style=color:#a90d91>void</span> <span style=color:#000>add</span>(<span style=color:#a90d91>int</span> <span style=color:#000>i</span>) {
</span></span><span style=display:flex><span>		<span style=color:#000>System</span>.<span style=color:#836c28>out</span>.<span style=color:#836c28>println</span>(<span style=color:#c41a16>&#34;Basic add&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a90d91>public</span> <span style=color:#000>Basic</span>() {
</span></span><span style=display:flex><span>		<span style=color:#000>add</span>(<span style=color:#2300ce>&#39;a&#39;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a90d91>public</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>void</span> <span style=color:#000>main</span>(<span style=color:#000>String</span><span style=color:#000>[]</span> <span style=color:#000>args</span>) {
</span></span><span style=display:flex><span>		<span style=color:#000>Basic</span> <span style=color:#000>a</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>A</span>();
</span></span><span style=display:flex><span>		<span style=color:#000>B</span> <span style=color:#000>b</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>B</span>();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>class</span> <span style=color:#3f6e75>A</span> <span style=color:#a90d91>extends</span> <span style=color:#000>Basic</span> {
</span></span><span style=display:flex><span>	<span style=color:#a90d91>public</span> <span style=color:#a90d91>void</span> <span style=color:#000>add</span>(<span style=color:#a90d91>int</span> <span style=color:#000>i</span>) {
</span></span><span style=display:flex><span>		<span style=color:#000>System</span>.<span style=color:#836c28>out</span>.<span style=color:#836c28>println</span>(<span style=color:#c41a16>&#34;A add&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>class</span> <span style=color:#3f6e75>B</span> <span style=color:#a90d91>extends</span> <span style=color:#000>Basic</span> {
</span></span><span style=display:flex><span>	<span style=color:#a90d91>public</span> <span style=color:#a90d91>void</span> <span style=color:#000>add</span>(<span style=color:#a90d91>char</span> <span style=color:#000>i</span>) {
</span></span><span style=display:flex><span>		<span style=color:#000>System</span>.<span style=color:#836c28>out</span>.<span style=color:#836c28>println</span>(<span style=color:#c41a16>&#34;B add&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不仅考察单分派，还有重载的静态多分派。进阶版问题的解释需以下知识点-java 的静态分派和动态单分派。</p><p><a href=http://blog.csdn.net/ns_code/article/details/17881581>CSDN-类加载机制 - 深入 java 虚拟机 读书笔记</a><br><a href=http://rednaxelafx.iteye.com/blog/260206>方法分派</a></p><p>重载是静态多分派，编译时期确定。<br>覆盖是动态单分派，运行时通过实际类型绑定。<br>静态多分派：所有依赖静态类型来定位方法执行版本的分派过程就叫做静态分派，静态分派最典型的应用就是方法重载。<br>动态单分派：根据运行期实际类型确定方法执行版本的分派过程叫做动态分派，动态分派最典型的应用就是方法重写。<br>同时理解：动态单分派就是多态，java 的面向接口编程的根基就是多态。</p><nav class="post-nav fullwidth"><span>&larr; <a href=../../post/java--and-equal/>Java-==-and-equals</a></span>
<span class=post-nav-next><a href=../../post/java-singleton/>单例模式和序列化</a> &rarr;</span></nav></div><footer class=small><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/center-img.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/alt-title.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/gh/rstudio/markdown/inst/resources/prism-xcode.css><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js defer></script><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/copy-button.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/copy-button.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/key-buttons.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/key-buttons.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/external-link.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fullwidth.min.js defer></script><hr><p class=nav-bottom><span><a href=https://zhi.moe>xdh</a> © 2024</span>
<span class=menu-bottom><a href=../../categories/>分类</a> <a href=../../tags/>标签</a>
<a href=../../post/index.xml type=application/rss+xml title="RSS feed">订阅</a>
<a href=#>回到顶部</a></span></p></footer></body></html>
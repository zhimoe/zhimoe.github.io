<!doctype html><html lang=zh dir=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>Tour of Rusts Standard Library Traits[翻译] - zhimoe</title><meta name=keywords content="读书,代码,架构,JVM,Java,Scala,Python,Clojure,Rust"><meta name=author content="zhimoe"><meta property="og:title" content="Tour of Rusts Standard Library Traits[翻译]"><meta property="og:site_name" content="zhimoe"><meta property="og:image" content="/img/author.jpg"><meta name=title content="Tour of Rusts Standard Library Traits[翻译] - zhimoe"><meta name=description content="编程是一门手艺"><link rel="shortcut icon" href=https://zhimoe.github.io/img/favicon.ico><link rel=apple-touch-icon href=https://zhimoe.github.io/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=https://zhimoe.github.io/img/apple-touch-icon.png><link href=https://cdn.jsdelivr.net/npm/typeface-fira-sans@1.1.13/index.min.css rel=stylesheet type=text/css><link href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet type=text/css><link href=https://cdn.jsdelivr.net/npm/imageviewer@1.1.0/dist/viewer.min.css rel=stylesheet><link href=https://zhimoe.github.io/css/main.css rel=stylesheet type=text/css><link href=https://zhimoe.github.io/css/syntax.css rel=stylesheet type=text/css></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class="site-meta custom-logo"><div class=custom-logo-site-title><a href=https://zhimoe.github.io/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>zhimoe</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>the craft of programming</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=https://zhimoe.github.io/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=https://zhimoe.github.io/post/ rel=section><i class="menu-item-icon fa fa-fw fa-list-alt"></i><br>归档</a></li><li class=menu-item><a href=https://zhimoe.github.io/categories/%E7%BC%96%E7%A8%8B/ rel=section><i class="menu-item-icon fa fa-fw fa-wpexplorer"></i><br>编程</a></li><li class=menu-item><a href=https://zhimoe.github.io/categories/%E7%BF%BB%E8%AF%91/ rel=section><i class="menu-item-icon fa fa-fw fa-language"></i><br>翻译</a></li><li class=menu-item><a href=https://zhimoe.github.io/categories/%E9%A1%B9%E7%9B%AE/ rel=section><i class="menu-item-icon fa fa-fw fa-bathtub"></i><br>项目</a></li><li class=menu-item><a href=https://zhimoe.github.io/about/ rel=section><i class="menu-item-icon fa fa-fw fa-grav"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://zhimoe.github.io/post/tour-of-rusts-standard-library-traits/ itemprop=url>Tour of Rusts Standard Library Traits[翻译]</a></h1><div class=post-meta><span class=post-time><span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2021-04-11">2021-04-11</time></span>
<span class=post-category>&nbsp; | &nbsp;
<span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=https://zhimoe.github.io/categories/%E7%BF%BB%E8%AF%91 itemprop=url rel=index style=text-decoration:underline><span itemprop=name>翻译</span></a>
&nbsp;</span></span>
<span>|
<span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>20129 字</span></span>
<span>|
<span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>41分钟</span></span></div></header><div class=post-body itemprop=articleBody><p>关于rust trait非常好的介绍,比rust book详细,系统.</p><h1 id=tour-of-rusts-standard-library-traits>Tour of Rust&rsquo;s Standard Library Traits</h1><p><strong>Table of Contents</strong></p><ul><li><a href=#intro>Intro</a></li><li><a href=#trait-basics>Trait Basics</a><ul><li><a href=#trait-items>Trait Items</a><ul><li><a href=#self>Self</a></li><li><a href=#functions>Functions</a></li><li><a href=#methods>Methods</a></li><li><a href=#associated-types>Associated Types</a></li><li><a href=#generic-parameters>Generic Parameters</a></li><li><a href=#generic-types-vs-associated-types>Generic Types vs Associated Types</a></li></ul></li><li><a href=#scope>Scope</a></li><li><a href=#derive-macros>Derive Macros</a></li><li><a href=#default-impls>Default Impls</a></li><li><a href=#generic-blanket-impls>Generic Blanket Impls</a></li><li><a href=#subtraits--supertraits>Subtraits & Supertraits</a></li><li><a href=#trait-objects>Trait Objects</a></li><li><a href=#marker-traits>Marker Traits</a></li><li><a href=#auto-traits>Auto Traits</a></li><li><a href=#unsafe-traits>Unsafe Traits</a></li></ul></li><li><a href=#auto-traits-1>Auto Traits</a><ul><li><a href=#send--sync>Send & Sync</a></li><li><a href=#sized>Sized</a></li></ul></li><li><a href=#general-traits>General Traits</a><ul><li><a href=#default>Default</a></li><li><a href=#clone>Clone</a></li><li><a href=#copy>Copy</a></li><li><a href=#any>Any</a></li></ul></li><li><a href=#formatting-traits>Formatting Traits</a><ul><li><a href=#display--tostring>Display & ToString</a></li><li><a href=#debug>Debug</a></li></ul></li><li><a href=#operator-traits>Operator Traits</a><ul><li><a href=#comparison-traits>Comparison Traits</a><ul><li><a href=#partialeq--eq>PartialEq & Eq</a></li><li><a href=#hash>Hash</a></li><li><a href=#partialord--ord>PartialOrd & Ord</a></li></ul></li><li><a href=#arithmetic-traits>Arithmetic Traits</a><ul><li><a href=#add--addassign>Add & AddAssign</a></li></ul></li><li><a href=#closure-traits>Closure Traits</a><ul><li><a href=#fnonce-fnmut--fn>FnOnce, FnMut, & Fn</a></li></ul></li><li><a href=#other-traits>Other Traits</a><ul><li><a href=#deref--derefmut>Deref & DerefMut</a></li><li><a href=#index--indexmut>Index & IndexMut</a></li><li><a href=#drop>Drop</a></li></ul></li></ul></li><li><a href=#conversion-traits>Conversion Traits</a><ul><li><a href=#from--into>From & Into</a></li></ul></li><li><a href=#error-handling>Error Handling</a><ul><li><a href=#error>Error</a></li></ul></li><li><a href=#conversion-traits-continued>Conversion Traits Continued</a><ul><li><a href=#tryfrom--tryinto>TryFrom & TryInto</a></li><li><a href=#fromstr>FromStr</a></li><li><a href=#asref--asmut>AsRef & AsMut</a></li><li><a href=#borrow--borrowmut>Borrow & BorrowMut</a></li><li><a href=#toowned>ToOwned</a></li></ul></li><li><a href=#iteration-traits>Iteration Traits</a><ul><li><a href=#iterator>Iterator</a></li><li><a href=#intoiterator>IntoIterator</a></li><li><a href=#fromiterator>FromIterator</a></li></ul></li><li><a href=#io-traits>I/O Traits</a><ul><li><a href=#read--write>Read & Write</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#discuss>Discuss</a></li><li><a href=#notifications>Notifications</a></li><li><a href=#further-reading>Further Reading</a></li></ul><h2 id=intro>Intro</h2><p>Have you ever wondered what&rsquo;s the difference between:</p><ul><li><code>Deref&lt;Target = T></code>, <code>AsRef&lt;T></code>, and <code>Borrow&lt;T></code>?</li><li><code>Clone</code>, <code>Copy</code>, and <code>ToOwned</code>?</li><li><code>From&lt;T></code> and <code>Into&lt;T></code>?</li><li><code>TryFrom&lt;&str></code> and <code>FromStr</code>?</li><li><code>FnOnce</code>, <code>FnMut</code>, <code>Fn</code>, and <code>fn</code>?</li></ul><p>Or ever asked yourself the questions:</p><ul><li><em>&ldquo;When do I use associated types vs generic types in my trait?&rdquo;</em></li><li><em>&ldquo;What are generic blanket impls?&rdquo;</em></li><li><em>&ldquo;How do subtraits and supertraits work?&rdquo;</em></li><li><em>&ldquo;Why does this trait not have any methods?&rdquo;</em></li></ul><p>Well then this is the article for you! It answers all of the above questions and much much more. Together we&rsquo;ll do a quick flyby tour of all of the most popular and commonly used traits from the Rust standard library!</p><p>You can read this article in order section by section or jump around to whichever traits interest you the most because each trait section begins with a list of links to <strong>Prerequisite</strong> sections that you should read to have adequate context to understand the current section&rsquo;s explanations.</p><h2 id=trait-basics>Trait Basics</h2><p>We&rsquo;ll cover just enough of the basics so that the rest of the article can be streamlined without having to repeat the same explanations of the same concepts over and over as they reappear in different traits.</p><h3 id=trait-items>Trait Items</h3><p>Trait items are any items that are part of a trait declaration.</p><h4 id=self>Self</h4><p><code>Self</code> always refers to the implementing type.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Trait {
</span></span><span style=display:flex><span>    <span style=color:green>// always returns i32
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> returns_num() -&gt; <span style=color:#2b91af>i32</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// returns implementing type
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> returns_self() -&gt; <span style=color:#2b91af>Self</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>SomeType</span>;
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>OtherType</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Trait <span style=color:#00f>for</span> SomeType {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> returns_num() -&gt; <span style=color:#2b91af>i32</span> {
</span></span><span style=display:flex><span>        5
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// Self == SomeType
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> returns_self() -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        SomeType
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Trait <span style=color:#00f>for</span> OtherType {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> returns_num() -&gt; <span style=color:#2b91af>i32</span> {
</span></span><span style=display:flex><span>        6
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// Self == OtherType
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> returns_self() -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        OtherType
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=functions>Functions</h4><p>A trait function is any function whose first parameter does not use the <code>self</code> keyword.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Default {
</span></span><span style=display:flex><span>    <span style=color:green>// function
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> default() -&gt; <span style=color:#2b91af>Self</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Trait functions can be called namespaced by the trait or implementing type:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> zero: <span style=color:#2b91af>i32</span> = Default::default();
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> zero = <span style=color:#2b91af>i32</span>::default();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=methods>Methods</h4><p>A trait method is any function whose first parameter uses the <code>self</code> keyword and is of type <code>Self</code>, <code>&Self</code>, <code>&mut Self</code>. The former types can also be wrapped with a <code>Box</code>, <code>Rc</code>, <code>Arc</code>, or <code>Pin</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Trait {
</span></span><span style=display:flex><span>    <span style=color:green>// methods
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> takes_self(self);
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> takes_immut_self(&amp;self);
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> takes_mut_self(&amp;<span style=color:#00f>mut</span> self);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// above methods desugared
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> takes_self(self: <span style=color:#2b91af>Self</span>);
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> takes_immut_self(self: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Self</span>);
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> takes_mut_self(self: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> Self);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// example from standard library
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>trait</span> ToString {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> to_string(&amp;self) -&gt; String;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Methods can be called using the dot operator on the implementing type:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> five = 5.to_string();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However, similarly to functions, they can also be called namespaced by the trait or implementing type:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> five = ToString::to_string(&amp;5);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> five = <span style=color:#2b91af>i32</span>::to_string(&amp;5);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=associated-types>Associated Types</h4><p>A trait can have associated types. This is useful when we need to use some type other than <code>Self</code> within function signatures but would still like the type to be chosen by the implementer rather than being hardcoded in the trait declaration:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Trait {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>AssociatedType</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> func(arg: <span style=color:#2b91af>Self</span>::AssociatedType);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>SomeType</span>;
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>OtherType</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// any type implementing Trait can
</span></span></span><span style=display:flex><span><span style=color:green>// choose the type of AssociatedType
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Trait <span style=color:#00f>for</span> SomeType {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>AssociatedType</span> = <span style=color:#2b91af>i8</span>; <span style=color:green>// chooses i8
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> func(arg: <span style=color:#2b91af>Self</span>::AssociatedType) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Trait <span style=color:#00f>for</span> OtherType {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>AssociatedType</span> = <span style=color:#2b91af>u8</span>; <span style=color:green>// chooses u8
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> func(arg: <span style=color:#2b91af>Self</span>::AssociatedType) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    SomeType::func(-1_<span style=color:#00f>i8</span>); <span style=color:green>// can only call func with i8 on SomeType
</span></span></span><span style=display:flex><span><span style=color:green></span>    OtherType::func(1_<span style=color:#00f>u8</span>); <span style=color:green>// can only call func with u8 on OtherType
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><h4 id=generic-parameters>Generic Parameters</h4><p><em>&ldquo;Generic parameters&rdquo;</em> broadly refers to generic type parameters, generic lifetime parameters, and generic const parameters. Since all of those are a mouthful to say people commonly abbreviate them to <em>&ldquo;generic types&rdquo;</em>, <em>&ldquo;lifetimes&rdquo;</em>, and <em>&ldquo;generic consts&rdquo;</em>. Since generic consts are not used in any of the standard library traits we&rsquo;ll be covering they&rsquo;re outside the scope of this article.</p><p>We can generalize a trait declaration using parameters:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// trait declaration generalized with lifetime &amp; type parameters
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>trait</span> Trait&lt;&#39;a, T&gt; {
</span></span><span style=display:flex><span>    <span style=color:green>// signature uses generic type
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> func1(arg: <span style=color:#2b91af>T</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:green>// signature uses lifetime
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> func2(arg: <span style=color:#00f>&amp;</span>&#39;a <span style=color:#2b91af>i32</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:green>// signature uses generic type &amp; lifetime
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> func3(arg: <span style=color:#00f>&amp;</span>&#39;a <span style=color:#2b91af>T</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>SomeType</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span>&lt;&#39;a&gt; Trait&lt;&#39;a, <span style=color:#2b91af>i8</span>&gt; <span style=color:#00f>for</span> SomeType {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> func1(arg: <span style=color:#2b91af>i8</span>) {}
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> func2(arg: <span style=color:#00f>&amp;</span>&#39;a <span style=color:#2b91af>i32</span>) {}
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> func3(arg: <span style=color:#00f>&amp;</span>&#39;a <span style=color:#2b91af>i8</span>) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span>&lt;&#39;b&gt; Trait&lt;&#39;b, <span style=color:#2b91af>u8</span>&gt; <span style=color:#00f>for</span> SomeType {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> func1(arg: <span style=color:#2b91af>u8</span>) {}
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> func2(arg: <span style=color:#00f>&amp;</span>&#39;b <span style=color:#2b91af>i32</span>) {}
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> func3(arg: <span style=color:#00f>&amp;</span>&#39;b <span style=color:#2b91af>u8</span>) {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s possible to provide default values for generic types. The most commonly used default value is <code>Self</code> but any type works:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// make T = Self by default
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>trait</span> Trait&lt;T = Self&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> func(t: <span style=color:#2b91af>T</span>) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// any type can be used as the default
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>trait</span> Trait2&lt;T = <span style=color:#2b91af>i32</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> func2(t: <span style=color:#2b91af>T</span>) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>SomeType</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// omitting the generic type will
</span></span></span><span style=display:flex><span><span style=color:green>// cause the impl to use the default
</span></span></span><span style=display:flex><span><span style=color:green>// value, which is Self here
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> Trait <span style=color:#00f>for</span> SomeType {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> func(t: <span style=color:#2b91af>SomeType</span>) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// default value here is i32
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> Trait2 <span style=color:#00f>for</span> SomeType {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> func2(t: <span style=color:#2b91af>i32</span>) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// the default is overridable as we&#39;d expect
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> Trait&lt;String&gt; <span style=color:#00f>for</span> SomeType {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> func(t: String) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// overridable here too
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> Trait2&lt;String&gt; <span style=color:#00f>for</span> SomeType {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> func2(t: String) {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Aside from parameterizing the trait it&rsquo;s also possible to parameterize individual functions and methods:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Trait {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> func&lt;&#39;a, T&gt;(t: <span style=color:#00f>&amp;</span>&#39;a <span style=color:#2b91af>T</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=generic-types-vs-associated-types>Generic Types vs Associated Types</h4><p>Both generic types and associated types defer the decision to the implementer on which concrete types should be used in the trait&rsquo;s functions and methods, so this section seeks to explain when to use one over the other.</p><p>The general rule-of-thumb is:</p><ul><li>Use associated types when there should only be a single impl of the trait per type.</li><li>Use generic types when there can be many possible impls of the trait per type.</li></ul><p>Let&rsquo;s say we want to define a trait called <code>Add</code> which allows us to add values together. Here&rsquo;s an initial design and impl that only uses associated types:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Add {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Rhs</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>Self</span>::Rhs) -&gt; <span style=color:#2b91af>Self</span>::Output;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Add <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Rhs</span> = Point;
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span> = Point;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#2b91af>self</span>.x + rhs.x,
</span></span><span style=display:flex><span>            y: <span style=color:#2b91af>self</span>.y + rhs.y,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 1 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p2 = Point { x: 2, y: 2 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p3 = p1.add(p2);
</span></span><span style=display:flex><span>    assert_eq!(p3.x, 3);
</span></span><span style=display:flex><span>    assert_eq!(p3.y, 3);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s say we wanted to add the ability to add <code>i32</code>s to <code>Point</code>s where the <code>i32</code> would be added to both the <code>x</code> and <code>y</code> members:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Add {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Rhs</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>Self</span>::Rhs) -&gt; <span style=color:#2b91af>Self</span>::Output;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Add <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Rhs</span> = Point;
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span> = Point;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#2b91af>self</span>.x + rhs.x,
</span></span><span style=display:flex><span>            y: <span style=color:#2b91af>self</span>.y + rhs.y,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Add <span style=color:#00f>for</span> Point { <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Rhs</span> = <span style=color:#2b91af>i32</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span> = Point;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>i32</span>) -&gt; <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#2b91af>self</span>.x + rhs,
</span></span><span style=display:flex><span>            y: <span style=color:#2b91af>self</span>.y + rhs,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 1 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p2 = Point { x: 2, y: 2 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p3 = p1.add(p2);
</span></span><span style=display:flex><span>    assert_eq!(p3.x, 3);
</span></span><span style=display:flex><span>    assert_eq!(p3.y, 3);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 1 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> int2 = 2;
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p3 = p1.add(int2); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(p3.x, 3);
</span></span><span style=display:flex><span>    assert_eq!(p3.y, 3);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Throws:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>error[E0119]: conflicting implementations of trait `<span style=color:#00f>Add</span>` <span style=color:#00f>for</span> type `Point`:
</span></span><span style=display:flex><span>  --&gt; src/main.rs:23:1
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>12 | impl <span style=color:#00f>Add</span> <span style=color:#00f>for</span> Point <span>{</span>
</span></span><span style=display:flex><span>   | ----------------<span style=color:green>-- first implementation here
</span></span></span><span style=display:flex><span><span style=color:green></span>...
</span></span><span style=display:flex><span>23 | impl <span style=color:#00f>Add</span> <span style=color:#00f>for</span> Point <span>{</span>
</span></span><span style=display:flex><span>   | ^^^^^^^^^^^^^^^^^^ conflicting implementation <span style=color:#00f>for</span> `Point`
</span></span></code></pre></div><p>Since the <code>Add</code> trait is not parameterized by any generic types we can only impl it once per type, which means we can only pick the types for both <code>Rhs</code> and <code>Output</code> once! To allow adding both <code>Points</code>s and <code>i32</code>s to <code>Point</code> we have to refactor <code>Rhs</code> from an associated type to a generic type, which would allow us to impl the trait multiple times for <code>Point</code> with different type arguments for <code>Rhs</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Add&lt;Rhs&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>Rhs</span>) -&gt; <span style=color:#2b91af>Self</span>::Output;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Add&lt;Point&gt; <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span> = Self;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>Self</span>::Output {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#2b91af>self</span>.x + rhs.x,
</span></span><span style=display:flex><span>            y: <span style=color:#2b91af>self</span>.y + rhs.y,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Add&lt;<span style=color:#2b91af>i32</span>&gt; <span style=color:#00f>for</span> Point { <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span> = Self;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>i32</span>) -&gt; <span style=color:#2b91af>Self</span>::Output {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#2b91af>self</span>.x + rhs,
</span></span><span style=display:flex><span>            y: <span style=color:#2b91af>self</span>.y + rhs,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 1 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p2 = Point { x: 2, y: 2 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p3 = p1.add(p2);
</span></span><span style=display:flex><span>    assert_eq!(p3.x, 3);
</span></span><span style=display:flex><span>    assert_eq!(p3.y, 3);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 1 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> int2 = 2;
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p3 = p1.add(int2); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(p3.x, 3);
</span></span><span style=display:flex><span>    assert_eq!(p3.y, 3);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s say we add a new type called <code>Line</code> which contains two <code>Point</code>s, and now there are contexts within our program where adding two <code>Point</code>s should produce a <code>Line</code> instead of a <code>Point</code>. This is not possible given the current design of the <code>Add</code> trait where <code>Output</code> is an associated type but we can satisfy these new requirements by refactoring <code>Output</code> from an associated type into a generic type:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Add&lt;Rhs, Output&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>Rhs</span>) -&gt; <span style=color:#2b91af>Output</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Add&lt;Point, Point&gt; <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#2b91af>self</span>.x + rhs.x,
</span></span><span style=display:flex><span>            y: <span style=color:#2b91af>self</span>.y + rhs.y,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Add&lt;<span style=color:#2b91af>i32</span>, Point&gt; <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>i32</span>) -&gt; <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#2b91af>self</span>.x + rhs,
</span></span><span style=display:flex><span>            y: <span style=color:#2b91af>self</span>.y + rhs,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Line</span> {
</span></span><span style=display:flex><span>    start: <span style=color:#2b91af>Point</span>,
</span></span><span style=display:flex><span>    end: <span style=color:#2b91af>Point</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Add&lt;Point, Line&gt; <span style=color:#00f>for</span> Point { <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>Line</span> {
</span></span><span style=display:flex><span>        Line {
</span></span><span style=display:flex><span>            start: <span style=color:#2b91af>self</span>,
</span></span><span style=display:flex><span>            end: <span style=color:#2b91af>rhs</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 1 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p2 = Point { x: 2, y: 2 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p3: <span style=color:#2b91af>Point</span> = p1.add(p2);
</span></span><span style=display:flex><span>    assert!(p3.x == 3 &amp;&amp; p3.y == 3);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 1 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> int2 = 2;
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p3 = p1.add(int2);
</span></span><span style=display:flex><span>    assert!(p3.x == 3 &amp;&amp; p3.y == 3);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 1 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p2 = Point { x: 2, y: 2 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> l: <span style=color:#2b91af>Line</span> = p1.add(p2); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert!(l.start.x == 1 &amp;&amp; l.start.y == 1 &amp;&amp; l.end.x == 2 &amp;&amp; l.end.y == 2)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So which <code>Add</code> trait above is the best? It really depends on the requirements of your program! They&rsquo;re all good in the right situations.</p><h3 id=scope>Scope</h3><p>Trait items cannot be used unless the trait is in scope. Most Rustaceans learn this the hard way the first time they try to write a program that does anything with I/O because the <code>Read</code> and <code>Write</code> traits are not in the standard library prelude:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::fs::File;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::io;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() -&gt; Result&lt;(), io::Error&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> file = File::open(<span style=color:#a31515>&#34;Cargo.toml&#34;</span>)?;
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> buffer = String::new();
</span></span><span style=display:flex><span>    file.read_to_string(&amp;<span style=color:#00f>mut</span> buffer)?; <span style=color:green>// ❌ read_to_string not found in File
</span></span></span><span style=display:flex><span><span style=color:green></span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>read_to_string(buf: &mut String)</code> is declared by the <code>std::io::Read</code> trait and implemented by the <code>std::fs::File</code> struct but in order to call it <code>std::io::Read</code> must be in scope:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::fs::File;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::io;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::io::Read; <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() -&gt; Result&lt;(), io::Error&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> file = File::open(<span style=color:#a31515>&#34;Cargo.toml&#34;</span>)?;
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> buffer = String::new();
</span></span><span style=display:flex><span>    file.read_to_string(&amp;<span style=color:#00f>mut</span> buffer)?; <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The standard library prelude is a module in the standard library, i.e. <code>std::prelude::v1</code>, that gets auto imported at the top of every other module, i.e. <code>use std::prelude::v1::*</code>. Thus the following traits are always in scope and we never have to explicitly import them ourselves because they&rsquo;re part of the prelude:</p><ul><li><a href=#asref--asmut>AsMut</a></li><li><a href=#asref--asmut>AsRef</a></li><li><a href=#clone>Clone</a></li><li><a href=#copy>Copy</a></li><li><a href=#default>Default</a></li><li><a href=#drop>Drop</a></li><li><a href=#partialeq--eq>Eq</a></li><li><a href=#fnonce-fnmut--fn>Fn</a></li><li><a href=#fnonce-fnmut--fn>FnMut</a></li><li><a href=#fnonce-fnmut--fn>FnOnce</a></li><li><a href=#from--into>From</a></li><li><a href=#from--into>Into</a></li><li><a href=#toowned>ToOwned</a></li><li><a href=#intoiterator>IntoIterator</a></li><li><a href=#iterator>Iterator</a></li><li><a href=#partialeq--eq>PartialEq</a></li><li><a href=#partialord--ord>PartialOrd</a></li><li><a href=#send--sync>Send</a></li><li><a href=#sized>Sized</a></li><li><a href=#send--sync>Sync</a></li><li><a href=#display--tostring>ToString</a></li><li><a href=#partialord--ord>Ord</a></li></ul><h3 id=derive-macros>Derive Macros</h3><p>The standard library exports a handful of derive macros which we can use to quickly and conveniently impl a trait on a type if all of its members also impl the trait. The derive macros are named after the traits they impl:</p><ul><li><a href=#clone>Clone</a></li><li><a href=#copy>Copy</a></li><li><a href=#debug>Debug</a></li><li><a href=#default>Default</a></li><li><a href=#partialeq--eq>Eq</a></li><li><a href=#hash>Hash</a></li><li><a href=#partialord--ord>Ord</a></li><li><a href=#partialeq--eq>PartialEq</a></li><li><a href=#partialord--ord>PartialOrd</a></li></ul><p>Example usage:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// macro derives Copy &amp; Clone impl for SomeType
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>#[derive(Copy, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>SomeType</span>;
</span></span></code></pre></div><p>Note: derive macros are just procedural macros and can do anything, there&rsquo;s no hard rule that they must impl a trait or that they can only work if all the members of the type impl a trait, these are just the conventions followed by the derive macros in the standard library.</p><h3 id=default-impls>Default Impls</h3><p>Traits can provide default impls for their functions and methods.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Trait {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> method(&amp;self) {
</span></span><span style=display:flex><span>        println!(<span style=color:#a31515>&#34;default impl&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>SomeType</span>;
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>OtherType</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// use default impl for Trait::method
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> Trait <span style=color:#00f>for</span> SomeType {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Trait <span style=color:#00f>for</span> OtherType {
</span></span><span style=display:flex><span>    <span style=color:green>// use our own impl for Trait::method
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> method(&amp;self) {
</span></span><span style=display:flex><span>        println!(<span style=color:#a31515>&#34;OtherType impl&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    SomeType.method(); <span style=color:green>// prints &#34;default impl&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>    OtherType.method(); <span style=color:green>// prints &#34;OtherType impl&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>This is especially handy if some of the trait methods can be implemented solely using other trait methods.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Greet {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> greet(&amp;self, name: <span style=color:#00f>&amp;</span><span style=color:#2b91af>str</span>) -&gt; String;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> greet_loudly(&amp;self, name: <span style=color:#00f>&amp;</span><span style=color:#2b91af>str</span>) -&gt; String {
</span></span><span style=display:flex><span>        self.greet(name) + <span style=color:#a31515>&#34;!&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Hello</span>;
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Hola</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Greet <span style=color:#00f>for</span> Hello {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> greet(&amp;self, name: <span style=color:#00f>&amp;</span><span style=color:#2b91af>str</span>) -&gt; String {
</span></span><span style=display:flex><span>        format!(<span style=color:#a31515>&#34;Hello {}&#34;</span>, name)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:green>// use default impl for greet_loudly
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Greet <span style=color:#00f>for</span> Hola {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> greet(&amp;self, name: <span style=color:#00f>&amp;</span><span style=color:#2b91af>str</span>) -&gt; String {
</span></span><span style=display:flex><span>        format!(<span style=color:#a31515>&#34;Hola {}&#34;</span>, name)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:green>// override default impl
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> greet_loudly(&amp;self, name: <span style=color:#00f>&amp;</span><span style=color:#2b91af>str</span>) -&gt; String {
</span></span><span style=display:flex><span>        <span style=color:#00f>let</span> <span style=color:#00f>mut</span> greeting = self.greet(name);
</span></span><span style=display:flex><span>        greeting.insert_str(0, <span style=color:#a31515>&#34;¡&#34;</span>);
</span></span><span style=display:flex><span>        greeting + <span style=color:#a31515>&#34;!&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    println!(<span style=color:#a31515>&#34;{}&#34;</span>, Hello.greet(<span style=color:#a31515>&#34;John&#34;</span>)); <span style=color:green>// prints &#34;Hello John&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>    println!(<span style=color:#a31515>&#34;{}&#34;</span>, Hello.greet_loudly(<span style=color:#a31515>&#34;John&#34;</span>)); <span style=color:green>// prints &#34;Hello John!&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>    println!(<span style=color:#a31515>&#34;{}&#34;</span>, Hola.greet(<span style=color:#a31515>&#34;John&#34;</span>)); <span style=color:green>// prints &#34;Hola John&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>    println!(<span style=color:#a31515>&#34;{}&#34;</span>, Hola.greet_loudly(<span style=color:#a31515>&#34;John&#34;</span>)); <span style=color:green>// prints &#34;¡Hola John!&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Many traits in the standard library provide default impls for many of their methods.</p><h3 id=generic-blanket-impls>Generic Blanket Impls</h3><p>A generic blanket impl is an impl on a generic type instead of a concrete type. To explain why and how we&rsquo;d use one let&rsquo;s start by writing an <code>is_even</code> method for number types:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Even {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> is_even(self) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Even <span style=color:#00f>for</span> <span style=color:#2b91af>i8</span> {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> is_even(self) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self % 2_<span style=color:#00f>i8</span> == 0_<span style=color:#00f>i8</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Even <span style=color:#00f>for</span> <span style=color:#2b91af>u8</span> {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> is_even(self) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self % 2_<span style=color:#00f>u8</span> == 0_<span style=color:#00f>u8</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Even <span style=color:#00f>for</span> <span style=color:#2b91af>i16</span> {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> is_even(self) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self % 2_<span style=color:#00f>i16</span> == 0_<span style=color:#00f>i16</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// etc
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span><span style=color:#00f>#[test]</span> <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> test_is_even() {
</span></span><span style=display:flex><span>    assert!(2_<span style=color:#00f>i8</span>.is_even());
</span></span><span style=display:flex><span>    assert!(4_<span style=color:#00f>u8</span>.is_even());
</span></span><span style=display:flex><span>    assert!(6_<span style=color:#00f>i16</span>.is_even());
</span></span><span style=display:flex><span>    <span style=color:green>// etc
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Obviously, this is very verbose. Also, all of our impls are almost identical. Furthermore, in the unlikely but still possible event that Rust decides to add more number types in the future we have to remember to come back to this code and update it with the new number types. We can solve all these problems using a generic blanket impl:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::fmt::Debug;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::convert::TryInto;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::ops::Rem;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> Even {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> is_even(self) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// generic blanket impl
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span>&lt;T&gt; Even <span style=color:#00f>for</span> T
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    T: <span style=color:#2b91af>Rem</span>&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
</span></span><span style=display:flex><span>    <span style=color:#2b91af>u8</span>: <span style=color:#2b91af>TryInto</span>&lt;T&gt;,
</span></span><span style=display:flex><span>    &lt;<span style=color:#2b91af>u8</span> <span style=color:#00f>as</span> TryInto&lt;T&gt;&gt;::Error: <span style=color:#2b91af>Debug</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> is_even(self) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:green>// these unwraps will never panic
</span></span></span><span style=display:flex><span><span style=color:green></span>        self % 2.try_into().unwrap() == 0.try_into().unwrap()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[test]</span> <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> test_is_even() {
</span></span><span style=display:flex><span>    assert!(2_<span style=color:#00f>i8</span>.is_even());
</span></span><span style=display:flex><span>    assert!(4_<span style=color:#00f>u8</span>.is_even());
</span></span><span style=display:flex><span>    assert!(6_<span style=color:#00f>i16</span>.is_even());
</span></span><span style=display:flex><span>    <span style=color:green>// etc
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Unlike default impls, which provide <em>an</em> impl, generic blanket impls provide <em>the</em> impl, so they are not overridable.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::fmt::Debug;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::convert::TryInto;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::ops::Rem;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> Even {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> is_even(self) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span>&lt;T&gt; Even <span style=color:#00f>for</span> T
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    T: <span style=color:#2b91af>Rem</span>&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
</span></span><span style=display:flex><span>    <span style=color:#2b91af>u8</span>: <span style=color:#2b91af>TryInto</span>&lt;T&gt;,
</span></span><span style=display:flex><span>    &lt;<span style=color:#2b91af>u8</span> <span style=color:#00f>as</span> TryInto&lt;T&gt;&gt;::Error: <span style=color:#2b91af>Debug</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> is_even(self) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self % 2.try_into().unwrap() == 0.try_into().unwrap()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Even <span style=color:#00f>for</span> <span style=color:#2b91af>u8</span> { <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> is_even(self) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self % 2_<span style=color:#00f>u8</span> == 0_<span style=color:#00f>u8</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Throws:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>error[E0119]: conflicting implementations of trait `Even` <span style=color:#00f>for</span> type `u8`:
</span></span><span style=display:flex><span>  --&gt; src/lib.rs:22:1
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>10 | / impl&lt;T&gt; Even <span style=color:#00f>for</span> T
</span></span><span style=display:flex><span>11 | | <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>12 | |     T: Rem&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
</span></span><span style=display:flex><span>13 | |     u8: TryInto&lt;T&gt;,
</span></span><span style=display:flex><span>...  |
</span></span><span style=display:flex><span>19 | |     <span>}</span>
</span></span><span style=display:flex><span>20 | | <span>}</span>
</span></span><span style=display:flex><span>   | |_- first implementation here
</span></span><span style=display:flex><span>21 | 
</span></span><span style=display:flex><span>22 |   impl Even <span style=color:#00f>for</span> u8 <span>{</span>
</span></span><span style=display:flex><span>   |   ^^^^^^^^^^^^^^^^ conflicting implementation <span style=color:#00f>for</span> `u8`
</span></span></code></pre></div><p>These impls overlap, hence they conflict, hence Rust rejects the code to ensure trait coherence. Trait coherence is the property that there exists at most one impl of a trait for any given type. The rules Rust uses to enforce trait coherence, the implications of those rules, and workarounds for the implications are outside the scope of this article.</p><h3 id=subtraits--supertraits>Subtraits & Supertraits</h3><p>The &ldquo;sub&rdquo; in &ldquo;subtrait&rdquo; refers to subset and the &ldquo;super&rdquo; in &ldquo;supertrait&rdquo; refers to superset. If we have this trait declaration:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Subtrait: <span style=color:#2b91af>Supertrait</span> {}
</span></span></code></pre></div><p>All of the types which impl <code>Subtrait</code> are a subset of all the types which impl <code>Supertrait</code>, or to put it in opposite but equivalent terms: all the types which impl <code>Supertrait</code> are a superset of all the types which impl <code>Subtrait</code>.</p><p>Also, the above is just syntax sugar for:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Subtrait <span style=color:#00f>where</span> Self: <span style=color:#2b91af>Supertrait</span> {}
</span></span></code></pre></div><p>It&rsquo;s a subtle yet important distinction to understand that the bound is on <code>Self</code>, i.e. the type impling <code>Subtrait</code>, and not on <code>Subtrait</code> itself. The latter would not make any sense, since trait bounds can only be applied to concrete types which can impl traits. Traits cannot impl other traits:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Supertrait {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> method(&amp;self) {
</span></span><span style=display:flex><span>        println!(<span style=color:#a31515>&#34;in supertrait&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> Subtrait: <span style=color:#2b91af>Supertrait</span> {
</span></span><span style=display:flex><span>    <span style=color:green>// this looks like it might impl or
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// override Supertrait::method but it
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// does not
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> method(&amp;self) {
</span></span><span style=display:flex><span>        println!(<span style=color:#a31515>&#34;in subtrait&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>SomeType</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// adds Supertrait::method to SomeType
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> Supertrait <span style=color:#00f>for</span> SomeType {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// adds Subtrait::method to SomeType
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> Subtrait <span style=color:#00f>for</span> SomeType {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// both methods exist on SomeType simultaneously
</span></span></span><span style=display:flex><span><span style=color:green>// neither overriding or shadowing the other
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    SomeType.method(); <span style=color:green>// ❌ ambiguous method call
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// must disambiguate using fully-qualified syntax
</span></span></span><span style=display:flex><span><span style=color:green></span>    &lt;SomeType <span style=color:#00f>as</span> Supertrait&gt;::method(&amp;st); <span style=color:green>// ✅ prints &#34;in supertrait&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>    &lt;SomeType <span style=color:#00f>as</span> Subtrait&gt;::method(&amp;st); <span style=color:green>// ✅ prints &#34;in subtrait&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Furthermore, there are no rules for how a type must impl both a subtrait and a supertrait. It can use the methods from either in the impl of the other.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Supertrait {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> super_method(&amp;<span style=color:#00f>mut</span> self);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> Subtrait: <span style=color:#2b91af>Supertrait</span> {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> sub_method(&amp;<span style=color:#00f>mut</span> self);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>CallSuperFromSub</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Supertrait <span style=color:#00f>for</span> CallSuperFromSub {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> super_method(&amp;<span style=color:#00f>mut</span> self) {
</span></span><span style=display:flex><span>        println!(<span style=color:#a31515>&#34;in super&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Subtrait <span style=color:#00f>for</span> CallSuperFromSub {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> sub_method(&amp;<span style=color:#00f>mut</span> self) {
</span></span><span style=display:flex><span>        println!(<span style=color:#a31515>&#34;in sub&#34;</span>);
</span></span><span style=display:flex><span>        self.super_method();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>CallSubFromSuper</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Supertrait <span style=color:#00f>for</span> CallSubFromSuper {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> super_method(&amp;<span style=color:#00f>mut</span> self) {
</span></span><span style=display:flex><span>        println!(<span style=color:#a31515>&#34;in super&#34;</span>);
</span></span><span style=display:flex><span>        self.sub_method();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Subtrait <span style=color:#00f>for</span> CallSubFromSuper {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> sub_method(&amp;<span style=color:#00f>mut</span> self) {
</span></span><span style=display:flex><span>        println!(<span style=color:#a31515>&#34;in sub&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>CallEachOther</span>(<span style=color:#2b91af>bool</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Supertrait <span style=color:#00f>for</span> CallEachOther {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> super_method(&amp;<span style=color:#00f>mut</span> self) {
</span></span><span style=display:flex><span>        println!(<span style=color:#a31515>&#34;in super&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> self.0 {
</span></span><span style=display:flex><span>            self.0 = <span style=color:#00f>false</span>;
</span></span><span style=display:flex><span>            self.sub_method();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Subtrait <span style=color:#00f>for</span> CallEachOther {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> sub_method(&amp;<span style=color:#00f>mut</span> self) {
</span></span><span style=display:flex><span>        println!(<span style=color:#a31515>&#34;in sub&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> self.0 {
</span></span><span style=display:flex><span>            self.0 = <span style=color:#00f>false</span>;
</span></span><span style=display:flex><span>            self.super_method();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    CallSuperFromSub.super_method(); <span style=color:green>// prints &#34;in super&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>    CallSuperFromSub.sub_method(); <span style=color:green>// prints &#34;in sub&#34;, &#34;in super&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>    
</span></span><span style=display:flex><span>    CallSubFromSuper.super_method(); <span style=color:green>// prints &#34;in super&#34;, &#34;in sub&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>    CallSubFromSuper.sub_method(); <span style=color:green>// prints &#34;in sub&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>    
</span></span><span style=display:flex><span>    CallEachOther(<span style=color:#00f>true</span>).super_method(); <span style=color:green>// prints &#34;in super&#34;, &#34;in sub&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>    CallEachOther(<span style=color:#00f>true</span>).sub_method(); <span style=color:green>// prints &#34;in sub&#34;, &#34;in super&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Hopefully the examples above show that the relationship between subtraits and supertraits can be complex. Before introducing a mental model that neatly encapsulates all of that complexity let&rsquo;s quickly review and establish the mental model we use for understanding trait bounds on generic types:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> function&lt;T: Clone&gt;(t: <span style=color:#2b91af>T</span>) {
</span></span><span style=display:flex><span>    <span style=color:green>// impl
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Without knowing anything about the impl of this function we could reasonably guess that <code>t.clone()</code> gets called at some point because when a generic type is bounded by a trait that strongly implies it has a dependency on the trait. The mental model for understanding the relationship between generic types and their trait bounds is a simple and intuitive one: generic types <em>depend on</em> their trait bounds.</p><p>Now let&rsquo;s look the trait declaration for <code>Copy</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Copy: Clone {}
</span></span></code></pre></div><p>The syntax above looks very similar to the syntax for applying a trait bound on a generic type and yet <code>Copy</code> doesn&rsquo;t depend on <code>Clone</code> at all. The mental model we developed earlier doesn&rsquo;t help us here. In my opinion, the most simple and elegant mental model for understanding the relationship between subtraits and supertraits is: subtraits <em>refine</em> their supertraits.</p><p>&ldquo;Refinement&rdquo; is intentionally kept somewhat vague because it can mean different things in different contexts:</p><ul><li>a subtrait might make its supertrait&rsquo;s methods&rsquo; impls more specialized, faster, use less memory, e.g. <code>Copy: Clone</code></li><li>a subtrait might make additional guarantees about the supertrait&rsquo;s methods&rsquo; impls, e.g. <code>Eq: PartialEq</code>, <code>Ord: PartialOrd</code>, <code>ExactSizeIterator: Iterator</code></li><li>a subtrait might make the supertrait&rsquo;s methods more flexible or easier to call, e.g. <code>FnMut: FnOnce</code>, <code>Fn: FnMut</code></li><li>a subtrait might extend a supertrait and add new methods, e.g. <code>DoubleEndedIterator: Iterator</code>, <code>ExactSizeIterator: Iterator</code></li></ul><h3 id=trait-objects>Trait Objects</h3><p>Generics give us compile-time polymorphism where trait objects give us run-time polymorphism. We can use trait objects to allow functions to dynamically return different types at run-time:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> example(condition: <span style=color:#2b91af>bool</span>, vec: Vec&lt;<span style=color:#2b91af>i32</span>&gt;) -&gt; Box&lt;<span style=color:#00f>dyn</span> Iterator&lt;Item = <span style=color:#2b91af>i32</span>&gt;&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> iter = vec.into_iter();
</span></span><span style=display:flex><span>    <span style=color:#00f>if</span> condition {
</span></span><span style=display:flex><span>        <span style=color:green>// Has type:
</span></span></span><span style=display:flex><span><span style=color:green></span>        <span style=color:green>// Box&lt;Map&lt;IntoIter&lt;i32&gt;, Fn(i32) -&gt; i32&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span>        <span style=color:green>// But is cast to:
</span></span></span><span style=display:flex><span><span style=color:green></span>        <span style=color:green>// Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span>        Box::new(iter.map(|n| n * 2))
</span></span><span style=display:flex><span>    } <span style=color:#00f>else</span> {
</span></span><span style=display:flex><span>        <span style=color:green>// Has type:
</span></span></span><span style=display:flex><span><span style=color:green></span>        <span style=color:green>// Box&lt;Filter&lt;IntoIter&lt;i32&gt;, Fn(&amp;i32) -&gt; bool&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span>        <span style=color:green>// But is cast to:
</span></span></span><span style=display:flex><span><span style=color:green></span>        <span style=color:green>// Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span>        Box::new(iter.filter(|&amp;n| n &gt;= 2))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Trait objects also allow us to store heterogeneous types in collections:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::<span style=color:#2b91af>f64</span>::consts::PI;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Circle</span> {
</span></span><span style=display:flex><span>    radius: <span style=color:#2b91af>f64</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Square</span> {
</span></span><span style=display:flex><span>    side: <span style=color:#2b91af>f64</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> Shape {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> area(&amp;self) -&gt; <span style=color:#2b91af>f64</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Shape <span style=color:#00f>for</span> Circle {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> area(&amp;self) -&gt; <span style=color:#2b91af>f64</span> {
</span></span><span style=display:flex><span>        PI * self.radius * self.radius
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Shape <span style=color:#00f>for</span> Square {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> area(&amp;self) -&gt; <span style=color:#2b91af>f64</span> {
</span></span><span style=display:flex><span>        self.side * self.side
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> get_total_area(shapes: Vec&lt;Box&lt;<span style=color:#00f>dyn</span> Shape&gt;&gt;) -&gt; <span style=color:#2b91af>f64</span> {
</span></span><span style=display:flex><span>    shapes.into_iter().map(|s| s.area()).sum()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> shapes: Vec&lt;Box&lt;<span style=color:#00f>dyn</span> Shape&gt;&gt; = vec![
</span></span><span style=display:flex><span>        Box::new(Circle { radius: 1.0 }), <span style=color:green>// Box&lt;Circle&gt; cast to Box&lt;dyn Shape&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span>        Box::new(Square { side: 1.0 }), <span style=color:green>// Box&lt;Square&gt; cast to Box&lt;dyn Shape&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span>    ];
</span></span><span style=display:flex><span>    assert_eq!(PI + 1.0, get_total_area(shapes)); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Trait objects are unsized so they must always be behind a pointer. We can tell the difference between a concrete type and a trait object at the type level based on the presence of the <code>dyn</code> keyword within the type:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Struct</span>;
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> Trait {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// regular struct
</span></span></span><span style=display:flex><span><span style=color:green></span>&amp;Struct
</span></span><span style=display:flex><span>Box&lt;Struct&gt;
</span></span><span style=display:flex><span>Rc&lt;Struct&gt;
</span></span><span style=display:flex><span>Arc&lt;Struct&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// trait objects
</span></span></span><span style=display:flex><span><span style=color:green></span>&amp;<span style=color:#00f>dyn</span> Trait
</span></span><span style=display:flex><span>Box&lt;<span style=color:#00f>dyn</span> Trait&gt;
</span></span><span style=display:flex><span>Rc&lt;<span style=color:#00f>dyn</span> Trait&gt;
</span></span><span style=display:flex><span>Arc&lt;<span style=color:#00f>dyn</span> Trait&gt;
</span></span></code></pre></div><p>Not all traits can be converted into trait objects. A trait is object-safe if it meets these requirements:</p><ul><li>trait doesn&rsquo;t require <code>Self: Sized</code></li><li>all of the trait&rsquo;s methods are object-safe</li></ul><p>A trait method is object-safe if it meets these requirements:</p><ul><li>method requires <code>Self: Sized</code> or</li><li>method only uses a <code>Self</code> type in receiver position</li></ul><p>Understanding why the requirements are what they are is not relevant to the rest of this article, but if you&rsquo;re still curious it&rsquo;s covered in <a href=./sizedness-in-rust.md>Sizedness in Rust</a>.</p><h3 id=marker-traits>Marker Traits</h3><p>Marker traits are traits that have no trait items. Their job is to &ldquo;mark&rdquo; the implementing type as having some property which is otherwise not possible to represent using the type system.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// Impling PartialEq for a type promises
</span></span></span><span style=display:flex><span><span style=color:green>// that equality for the type has these properties:
</span></span></span><span style=display:flex><span><span style=color:green>// - symmetry: a == b implies b == a, and
</span></span></span><span style=display:flex><span><span style=color:green>// - transitivity: a == b &amp;&amp; b == c implies a == c
</span></span></span><span style=display:flex><span><span style=color:green>// But DOES NOT promise this property:
</span></span></span><span style=display:flex><span><span style=color:green>// - reflexivity: a == a
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>trait</span> PartialEq {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Self</span>) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// Eq has no trait items! The eq method is already
</span></span></span><span style=display:flex><span><span style=color:green>// declared by PartialEq, but &#34;impling&#34; Eq
</span></span></span><span style=display:flex><span><span style=color:green>// for a type promises this additional equality property:
</span></span></span><span style=display:flex><span><span style=color:green>// - reflexivity: a == a
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>trait</span> Eq: PartialEq {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// f64 impls PartialEq but not Eq because NaN != NaN
</span></span></span><span style=display:flex><span><span style=color:green>// i32 impls PartialEq &amp; Eq because there&#39;s no NaNs :)
</span></span></span></code></pre></div><h3 id=auto-traits>Auto Traits</h3><p>Auto traits are traits that get automatically implemented for a type if all of its members also impl the trait. What &ldquo;members&rdquo; means depends on the type, for example: fields of a struct, variants of an enum, elements of an array, items of a tuple, and so on.</p><p>All auto traits are marker traits but not all marker traits are auto traits. Auto traits must be marker traits so the compiler can provide an automatic default impl for them, which would not be possible if they had any trait items.</p><p>Examples of auto traits:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// implemented for types which are safe to send between threads
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>unsafe</span> auto <span style=color:#00f>trait</span> Send {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// implemented for types whose references are safe to send between threads
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>unsafe</span> auto <span style=color:#00f>trait</span> Sync {}
</span></span></code></pre></div><h3 id=unsafe-traits>Unsafe Traits</h3><p>Traits can be marked unsafe to indicate that impling the trait might require unsafe code. Both <code>Send</code> and <code>Sync</code> are marked <code>unsafe</code> because if they aren&rsquo;t automatically implemented for a type that means it must contains some non-<code>Send</code> or non-<code>Sync</code> member and we have to take extra care as the implementers to make sure there are no data races if we want to manually mark the type as <code>Send</code> and <code>Sync</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// SomeType is not Send or Sync
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>struct</span> <span style=color:#2b91af>SomeType</span> {
</span></span><span style=display:flex><span>    not_send_or_sync: *<span style=color:#00f>const</span> (),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// but if we&#39;re confident that our impl doesn&#39;t have any data
</span></span></span><span style=display:flex><span><span style=color:green>// races we can explicitly mark it as Send and Sync using unsafe
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>unsafe</span> <span style=color:#00f>impl</span> Send <span style=color:#00f>for</span> SomeType {}
</span></span><span style=display:flex><span><span style=color:#00f>unsafe</span> <span style=color:#00f>impl</span> Sync <span style=color:#00f>for</span> SomeType {}
</span></span></code></pre></div><h2 id=auto-traits-1>Auto Traits</h2><h3 id=send--sync>Send & Sync</h3><p>Prerequisites</p><ul><li><a href=#marker-traits>Marker Traits</a></li><li><a href=#auto-traits>Auto Traits</a></li><li><a href=#unsafe-traits>Unsafe Traits</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>unsafe</span> auto <span style=color:#00f>trait</span> Send {}
</span></span><span style=display:flex><span><span style=color:#00f>unsafe</span> auto <span style=color:#00f>trait</span> Sync {}
</span></span></code></pre></div><p>If a type is <code>Send</code> that means it&rsquo;s safe to send between threads. If a type is <code>Sync</code> that means it&rsquo;s safe to share references of it between threads. In more precise terms some type <code>T</code> is <code>Sync</code> if and only if <code>&T</code> is <code>Send</code>.</p><p>Almost all types are <code>Send</code> and <code>Sync</code>. The only notable <code>Send</code> exception is <code>Rc</code> and the only notable <code>Sync</code> exceptions are <code>Rc</code>, <code>Cell</code>, <code>RefCell</code>. If we need a <code>Send</code> version of <code>Rc</code> we can use <code>Arc</code>. If we need a <code>Sync</code> version of <code>Cell</code> or <code>RefCell</code> we can <code>Mutex</code> or <code>RwLock</code>. Although if we&rsquo;re using the <code>Mutex</code> or <code>RwLock</code> to just wrap a primitive type it&rsquo;s often better to use the atomic primitive types provided by the standard library such as <code>AtomicBool</code>, <code>AtomicI32</code>, <code>AtomicUsize</code>, and so on.</p><p>That almost all types are <code>Sync</code> might be a surprise to some people, but yup, it&rsquo;s true even for types without any internal synchronization. This is possible thanks to Rust&rsquo;s strict borrowing rules.</p><p>We can pass many immutable references to the same data to many threads and we&rsquo;re guaranteed there are no data races because as long as any immutable references exist Rust statically guarantees the underlying data cannot be mutated:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> crossbeam::thread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> greeting = String::from(<span style=color:#a31515>&#34;Hello&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> greeting_ref = &amp;greeting;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    thread::scope(|scoped_thread| {
</span></span><span style=display:flex><span>        <span style=color:green>// spawn 3 threads
</span></span></span><span style=display:flex><span><span style=color:green></span>        <span style=color:#00f>for</span> n <span style=color:#00f>in</span> 1..=3 {
</span></span><span style=display:flex><span>            <span style=color:green>// greeting_ref copied into every thread
</span></span></span><span style=display:flex><span><span style=color:green></span>            scoped_thread.spawn(<span style=color:#00f>move</span> |_| {
</span></span><span style=display:flex><span>                println!(<span style=color:#a31515>&#34;{} {}&#34;</span>, greeting_ref, n); <span style=color:green>// prints &#34;Hello {n}&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>            });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:green>// line below could cause UB or data races but compiler rejects it
</span></span></span><span style=display:flex><span><span style=color:green></span>        greeting += <span style=color:#a31515>&#34; world&#34;</span>; <span style=color:green>// ❌ cannot mutate greeting while immutable refs exist
</span></span></span><span style=display:flex><span><span style=color:green></span>    });
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:green>// can mutate greeting after every thread has joined
</span></span></span><span style=display:flex><span><span style=color:green></span>    greeting += <span style=color:#a31515>&#34; world&#34;</span>; <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    println!(<span style=color:#a31515>&#34;{}&#34;</span>, greeting); <span style=color:green>// prints &#34;Hello world&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Likewise we can pass a single mutable reference to some data to a single thread and we&rsquo;re guaranteed there will be no data races because Rust statically guarantees aliased mutable references cannot exist and the underlying data cannot be mutated through anything other than the single existing mutable reference:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> crossbeam::thread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> greeting = String::from(<span style=color:#a31515>&#34;Hello&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> greeting_ref = &amp;<span style=color:#00f>mut</span> greeting;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    thread::scope(|scoped_thread| {
</span></span><span style=display:flex><span>        <span style=color:green>// greeting_ref moved into thread
</span></span></span><span style=display:flex><span><span style=color:green></span>        scoped_thread.spawn(<span style=color:#00f>move</span> |_| {
</span></span><span style=display:flex><span>            *greeting_ref += <span style=color:#a31515>&#34; world&#34;</span>;
</span></span><span style=display:flex><span>            println!(<span style=color:#a31515>&#34;{}&#34;</span>, greeting_ref); <span style=color:green>// prints &#34;Hello world&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>        });
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:green>// line below could cause UB or data races but compiler rejects it
</span></span></span><span style=display:flex><span><span style=color:green></span>        greeting += <span style=color:#a31515>&#34;!!!&#34;</span>; <span style=color:green>// ❌ cannot mutate greeting while mutable refs exist
</span></span></span><span style=display:flex><span><span style=color:green></span>    });
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:green>// can mutate greeting after the thread has joined
</span></span></span><span style=display:flex><span><span style=color:green></span>    greeting += <span style=color:#a31515>&#34;!!!&#34;</span>; <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    println!(<span style=color:#a31515>&#34;{}&#34;</span>, greeting); <span style=color:green>// prints &#34;Hello world!!!&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>This is why most types are <code>Sync</code> without requiring any explicit synchronization. In the event we need to simultaneously mutate some data <code>T</code> across multiple threads the compiler won&rsquo;t let us until we wrap the data in a <code>Arc&lt;Mutex&lt;T>></code> or <code>Arc&lt;RwLock&lt;T>></code> so the compiler enforces that explicit synchronization is used when it&rsquo;s needed.</p><h3 id=sized>Sized</h3><p>Prerequisites</p><ul><li><a href=#marker-traits>Marker Traits</a></li><li><a href=#auto-traits>Auto Traits</a></li></ul><p>If a type is <code>Sized</code> that means its size in bytes is known at compile-time and it&rsquo;s possible to put instances of the type on the stack.</p><p>Sizedness of types and its implications is a subtle yet huge topic that affects a lot of different aspects of the language. It&rsquo;s so important that I wrote an entire article on it called <a href=./sizedness-in-rust.md>Sizedness in Rust</a> which I highly recommend reading for anyone who would like to understand sizedness in-depth. I&rsquo;ll summarize a few key things which are relevant to this article.</p><ol><li>All generic types get an implicit <code>Sized</code> bound.</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> func&lt;T&gt;(t: <span style=color:#00f>&amp;</span><span style=color:#2b91af>T</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// example above desugared
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> func&lt;T: Sized&gt;(t: <span style=color:#00f>&amp;</span><span style=color:#2b91af>T</span>) {}
</span></span></code></pre></div><ol start=2><li>Since there&rsquo;s an implicit <code>Sized</code> bound on all generic types, if we want to opt-out of this implicit bound we need to use the special <em>&ldquo;relaxed bound&rdquo;</em> syntax <code>?Sized</code> which currently only exists for the <code>Sized</code> trait:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// now T can be unsized
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> func&lt;T: ?Sized&gt;(t: <span style=color:#00f>&amp;</span><span style=color:#2b91af>T</span>) {}
</span></span></code></pre></div><ol start=3><li>There&rsquo;s an implicit <code>?Sized</code> bound on all traits.</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Trait {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// example above desugared
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>trait</span> Trait: ?Sized {}
</span></span></code></pre></div><p>This is so that trait objects can impl the trait. Again, all of the nitty gritty details are in <a href=./sizedness-in-rust.md>Sizedness in Rust</a>.</p><h2 id=general-traits>General traits</h2><h3 id=default>Default</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#functions>Functions</a></li><li><a href=#derive-macros>Derive Macros</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Default {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> default() -&gt; <span style=color:#2b91af>Self</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s possible to construct default values of <code>Default</code> types.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Color</span> {
</span></span><span style=display:flex><span>    r: <span style=color:#2b91af>u8</span>,
</span></span><span style=display:flex><span>    g: <span style=color:#2b91af>u8</span>,
</span></span><span style=display:flex><span>    b: <span style=color:#2b91af>u8</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Default <span style=color:#00f>for</span> Color {
</span></span><span style=display:flex><span>    <span style=color:green>// default color is black
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> default() -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        Color {
</span></span><span style=display:flex><span>            r: 0,
</span></span><span style=display:flex><span>            g: 0,
</span></span><span style=display:flex><span>            b: 0,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is useful for quick prototyping but also in any instance where we just need an instance of a type and aren&rsquo;t picky about what it is:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:green>// just give me some color!
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> color = Color::default();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is also an option we may want to explicitly expose to the users of our functions:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Canvas</span>;
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Shape</span> {
</span></span><span style=display:flex><span>    Circle,
</span></span><span style=display:flex><span>    Rectangle,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Canvas {
</span></span><span style=display:flex><span>    <span style=color:green>// let user optionally pass a color
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> paint(&amp;<span style=color:#00f>mut</span> self, shape: <span style=color:#2b91af>Shape</span>, color: Option&lt;Color&gt;) {
</span></span><span style=display:flex><span>        <span style=color:green>// if no color is passed use the default color
</span></span></span><span style=display:flex><span><span style=color:green></span>        <span style=color:#00f>let</span> color = color.unwrap_or_default();
</span></span><span style=display:flex><span>        <span style=color:green>// etc
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Default</code> is also useful in generic contexts where we need to construct generic types:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> guarantee_length&lt;T: Default&gt;(<span style=color:#00f>mut</span> vec: Vec&lt;T&gt;, min_len: <span style=color:#2b91af>usize</span>) -&gt; Vec&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> _ <span style=color:#00f>in</span> 0..min_len.saturating_sub(vec.len()) {
</span></span><span style=display:flex><span>        vec.push(T::default());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    vec
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Another way we can take advantage of <code>Default</code> types is for partial initialization of structs using Rust&rsquo;s struct update syntax. We may have a <code>new</code> constructor for <code>Color</code> which takes every member as an argument:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span> Color {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> new(r: <span style=color:#2b91af>u8</span>, g: <span style=color:#2b91af>u8</span>, b: <span style=color:#2b91af>u8</span>) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        Color {
</span></span><span style=display:flex><span>            r,
</span></span><span style=display:flex><span>            g,
</span></span><span style=display:flex><span>            b,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However we can also have convenience constructors that only accept a particular struct member each and fall back to the default values for the other struct members:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span> Color {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> red(r: <span style=color:#2b91af>u8</span>) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        Color {
</span></span><span style=display:flex><span>            r,
</span></span><span style=display:flex><span>            ..Color::default()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> green(g: <span style=color:#2b91af>u8</span>) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        Color {
</span></span><span style=display:flex><span>            g,
</span></span><span style=display:flex><span>            ..Color::default()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> blue(b: <span style=color:#2b91af>u8</span>) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        Color {
</span></span><span style=display:flex><span>            b,
</span></span><span style=display:flex><span>            ..Color::default()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There&rsquo;s also a <code>Default</code> derive macro for so we can write <code>Color</code> like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// default color is still black
</span></span></span><span style=display:flex><span><span style=color:green>// because u8::default() == 0
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>#[derive(Default)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Color</span> {
</span></span><span style=display:flex><span>    r: <span style=color:#2b91af>u8</span>,
</span></span><span style=display:flex><span>    g: <span style=color:#2b91af>u8</span>,
</span></span><span style=display:flex><span>    b: <span style=color:#2b91af>u8</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=clone>Clone</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#default-impls>Default Impls</a></li><li><a href=#derive-macros>Derive Macros</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Clone {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> clone(&amp;self) -&gt; <span style=color:#2b91af>Self</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// provided default impls
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> clone_from(&amp;<span style=color:#00f>mut</span> self, source: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Self</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can convert immutable references of <code>Clone</code> types into owned values, i.e. <code>&T</code> -> <code>T</code>. <code>Clone</code> makes no promises about the efficiency of this conversion so it can be slow and expensive. To quickly impl <code>Clone</code> on a type we can use the derive macro:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>#[derive(Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>SomeType</span> {
</span></span><span style=display:flex><span>    cloneable_member1: <span style=color:#2b91af>CloneableType1</span>,
</span></span><span style=display:flex><span>    cloneable_member2: <span style=color:#2b91af>CloneableType2</span>,
</span></span><span style=display:flex><span>    <span style=color:green>// etc
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// macro generates impl below
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> Clone <span style=color:#00f>for</span> SomeType {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> clone(&amp;self) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        SomeType {
</span></span><span style=display:flex><span>            cloneable_member1: <span style=color:#2b91af>self</span>.cloneable_member1.clone(),
</span></span><span style=display:flex><span>            cloneable_member2: <span style=color:#2b91af>self</span>.cloneable_member2.clone(),
</span></span><span style=display:flex><span>            <span style=color:green>// etc
</span></span></span><span style=display:flex><span><span style=color:green></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Clone</code> can also be useful in constructing instances of a type within a generic context. Here&rsquo;s an example from the previous section except using <code>Clone</code> instead of <code>Default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> guarantee_length&lt;T: Clone&gt;(<span style=color:#00f>mut</span> vec: Vec&lt;T&gt;, min_len: <span style=color:#2b91af>usize</span>, fill_with: <span style=color:#00f>&amp;</span><span style=color:#2b91af>T</span>) -&gt; Vec&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> _ <span style=color:#00f>in</span> 0..min_len.saturating_sub(vec.len()) {
</span></span><span style=display:flex><span>        vec.push(fill_with.clone());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    vec
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>People also commonly use cloning as an escape hatch to avoid dealing with the borrow checker. Managing structs with references can be challenging, but we can turn the references into owned values by cloning them.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// oof, we gotta worry about lifetimes 😟
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>struct</span> <span style=color:#2b91af>SomeStruct</span>&lt;&#39;a&gt; {
</span></span><span style=display:flex><span>    data: <span style=color:#00f>&amp;</span>&#39;a Vec&lt;<span style=color:#2b91af>u8</span>&gt;,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// now we&#39;re on easy street 😎
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>struct</span> <span style=color:#2b91af>SomeStruct</span> {
</span></span><span style=display:flex><span>    data: Vec&lt;<span style=color:#2b91af>u8</span>&gt;,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If we&rsquo;re working on a program where performance is not the utmost concern then we don&rsquo;t need to sweat cloning data. Rust is a low-level language that exposes a lot of low-level details so it&rsquo;s easy to get caught up in premature optimizations instead of actually solving the problem at hand. For many programs the best order of priorities is usually to build for correctness first, elegance second, and performance third, and only focus on performance after the program has been profiled and the performance bottlenecks have been identified. This is good general advice to follow, and if it doesn&rsquo;t apply to your particular program then you would know.</p><h3 id=copy>Copy</h3><p>Prerequisites</p><ul><li><a href=#marker-traits>Marker Traits</a></li><li><a href=#subtraits--supertraits>Subtraits & Supertraits</a></li><li><a href=#derive-macros>Derive Macros</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Copy: Clone {}
</span></span></code></pre></div><p>We copy <code>Copy</code> types, e.g. <code>T</code> -> <code>T</code>. <code>Copy</code> promises the copy operation will be a simple bitwise copy so it will be very fast and efficient. We cannot impl <code>Copy</code> ourselves, only the compiler can provide an impl, but we can tell it to do so by using the <code>Copy</code> derive macro, together with the <code>Clone</code> derive macro since <code>Copy</code> is a subtrait of <code>Clone</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>#[derive(Copy, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>SomeType</span>;
</span></span></code></pre></div><p><code>Copy</code> refines <code>Clone</code>. A clone may be slow and expensive but a copy is guaranteed to be fast and cheap, so a copy is just a fast clone. If a type impls <code>Copy</code> that makes the <code>Clone</code> impl trivial:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// this is what the derive macro generates
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span>&lt;T: Copy&gt; Clone <span style=color:#00f>for</span> T {
</span></span><span style=display:flex><span>    <span style=color:green>// the clone method becomes just a copy
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> clone(&amp;self) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        *self
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Impling <code>Copy</code> for a type changes its behavior when it gets moved. By default all types have <em>move semantics</em> but once a type impls <code>Copy</code> it gets <em>copy semantics</em>. To explain the difference between the two let&rsquo;s examine these simple scenarios:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// a &#34;move&#34;, src: !Copy
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>let</span> dest = src; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// a &#34;copy&#34;, src: Copy
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>let</span> dest = src;
</span></span></code></pre></div><p>In both cases, <code>dest = src</code> performs a simple bitwise copy of <code>src</code>&rsquo;s contents and moves the result into <code>dest</code>, the only difference is that in the case of <em>&ldquo;a move&rdquo;</em> the borrow checker invalidates the <code>src</code> variable and makes sure it&rsquo;s not used anywhere else later and in the case of <em>&ldquo;a copy&rdquo;</em> <code>src</code> remains valid and usable.</p><p>In a nutshell: Copies <em>are</em> moves. Moves <em>are</em> copies. The only difference is how they&rsquo;re treated by the borrow checker.</p><p>For a more concrete example of a move, imagine <code>src</code> was a <code>Vec&lt;i32></code> and its contents looked something like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>{ data: *<span style=color:#00f>mut</span> [<span style=color:#2b91af>i32</span>], length: <span style=color:#2b91af>usize</span>, capacity: <span style=color:#2b91af>usize</span> }
</span></span></code></pre></div><p>When we write <code>dest = src</code> we end up with:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>src = { data: *<span style=color:#00f>mut</span> [<span style=color:#2b91af>i32</span>], length: <span style=color:#2b91af>usize</span>, capacity: <span style=color:#2b91af>usize</span> }
</span></span><span style=display:flex><span>dest = { data: *<span style=color:#00f>mut</span> [<span style=color:#2b91af>i32</span>], length: <span style=color:#2b91af>usize</span>, capacity: <span style=color:#2b91af>usize</span> }
</span></span></code></pre></div><p>At this point both <code>src</code> and <code>dest</code> have aliased mutable references to the same data, which is a big no-no, so the borrow checker invalidates the <code>src</code> variable so it can&rsquo;t be used again without throwing a compile error.</p><p>For a more concrete example of a copy, imagine <code>src</code> was an <code>Option&lt;i32></code> and its contents looked something like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>{ is_valid: <span style=color:#2b91af>bool</span>, data: <span style=color:#2b91af>i32</span> }
</span></span></code></pre></div><p>Now when we write <code>dest = src</code> we end up with:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>src = { is_valid: <span style=color:#2b91af>bool</span>, data: <span style=color:#2b91af>i32</span> }
</span></span><span style=display:flex><span>dest = { is_valid: <span style=color:#2b91af>bool</span>, data: <span style=color:#2b91af>i32</span> }
</span></span></code></pre></div><p>These are both usable simultaneously! Hence <code>Option&lt;i32></code> is <code>Copy</code>.</p><p>Although <code>Copy</code> could be an auto trait the Rust language designers decided it&rsquo;s simpler and safer for types to explicitly opt into copy semantics rather than silently inheriting copy semantics whenever the type is eligible, as the latter can cause surprising confusing behavior which often leads to bugs.</p><h3 id=any>Any</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#generic-blanket-impls>Generic Blanket Impls</a></li><li><a href=#subtraits--supertraits>Subtraits & Supertraits</a></li><li><a href=#trait-objects>Trait Objects</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Any: &#39;static {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> type_id(&amp;self) -&gt; <span style=color:#2b91af>TypeId</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Rust&rsquo;s style of polymorphism is parametric, but if we&rsquo;re looking to use a more ad-hoc style of polymorphism similar to dynamically-typed languages then we can emulate that using the <code>Any</code> trait. We don&rsquo;t have to manually impl this trait for our types because that&rsquo;s already covered by this generic blanket impl:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span>&lt;T: &#39;static + ?Sized&gt; Any <span style=color:#00f>for</span> T {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> type_id(&amp;self) -&gt; <span style=color:#2b91af>TypeId</span> {
</span></span><span style=display:flex><span>        TypeId::of::&lt;T&gt;()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The way we get a <code>T</code> out of a <code>dyn Any</code> is by using the <code>downcast_ref::&lt;T>()</code> and <code>downcast_mut::&lt;T>()</code> methods:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::any::Any;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(Default)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> inc(&amp;<span style=color:#00f>mut</span> self) {
</span></span><span style=display:flex><span>        self.x += 1;
</span></span><span style=display:flex><span>        self.y += 1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> map_any(<span style=color:#00f>mut</span> any: Box&lt;<span style=color:#00f>dyn</span> Any&gt;) -&gt; Box&lt;<span style=color:#00f>dyn</span> Any&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>if</span> <span style=color:#00f>let</span> Some(num) = any.downcast_mut::&lt;<span style=color:#2b91af>i32</span>&gt;() {
</span></span><span style=display:flex><span>        *num += 1;
</span></span><span style=display:flex><span>    } <span style=color:#00f>else</span> <span style=color:#00f>if</span> <span style=color:#00f>let</span> Some(string) = any.downcast_mut::&lt;String&gt;() {
</span></span><span style=display:flex><span>        *string += <span style=color:#a31515>&#34;!&#34;</span>;
</span></span><span style=display:flex><span>    } <span style=color:#00f>else</span> <span style=color:#00f>if</span> <span style=color:#00f>let</span> Some(point) = any.downcast_mut::&lt;Point&gt;() {
</span></span><span style=display:flex><span>        point.inc();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    any
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> vec: Vec&lt;Box&lt;<span style=color:#00f>dyn</span> Any&gt;&gt; = vec![
</span></span><span style=display:flex><span>        Box::new(0),
</span></span><span style=display:flex><span>        Box::new(String::from(<span style=color:#a31515>&#34;a&#34;</span>)),
</span></span><span style=display:flex><span>        Box::new(Point::default()),
</span></span><span style=display:flex><span>    ];
</span></span><span style=display:flex><span>    <span style=color:green>// vec = [0, &#34;a&#34;, Point { x: 0, y: 0 }]
</span></span></span><span style=display:flex><span><span style=color:green></span>    vec = vec.into_iter().map(map_any).collect();
</span></span><span style=display:flex><span>    <span style=color:green>// vec = [1, &#34;a!&#34;, Point { x: 1, y: 1 }]
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>This trait rarely <em>needs</em> to be used because on top of parametric polymorphism being superior to ad-hoc polymorphism in most scenarios the latter can also be emulated using enums which are more type-safe and require less indirection. For example, we could have written the above example like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>#[derive(Default)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> inc(&amp;<span style=color:#00f>mut</span> self) {
</span></span><span style=display:flex><span>        self.x += 1;
</span></span><span style=display:flex><span>        self.y += 1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Stuff</span> {
</span></span><span style=display:flex><span>    Integer(<span style=color:#2b91af>i32</span>),
</span></span><span style=display:flex><span>    String(String),
</span></span><span style=display:flex><span>    Point(Point),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> map_stuff(<span style=color:#00f>mut</span> stuff: <span style=color:#2b91af>Stuff</span>) -&gt; <span style=color:#2b91af>Stuff</span> {
</span></span><span style=display:flex><span>    <span style=color:#00f>match</span> &amp;<span style=color:#00f>mut</span> stuff {
</span></span><span style=display:flex><span>        Stuff::Integer(num) =&gt; *num += 1,
</span></span><span style=display:flex><span>        Stuff::String(string) =&gt; *string += <span style=color:#a31515>&#34;!&#34;</span>,
</span></span><span style=display:flex><span>        Stuff::Point(point) =&gt; point.inc(),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    stuff
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> vec = vec![
</span></span><span style=display:flex><span>        Stuff::Integer(0),
</span></span><span style=display:flex><span>        Stuff::String(String::from(<span style=color:#a31515>&#34;a&#34;</span>)),
</span></span><span style=display:flex><span>        Stuff::Point(Point::default()),
</span></span><span style=display:flex><span>    ];
</span></span><span style=display:flex><span>    <span style=color:green>// vec = [0, &#34;a&#34;, Point { x: 0, y: 0 }]
</span></span></span><span style=display:flex><span><span style=color:green></span>    vec = vec.into_iter().map(map_stuff).collect();
</span></span><span style=display:flex><span>    <span style=color:green>// vec = [1, &#34;a!&#34;, Point { x: 1, y: 1 }]
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Despite <code>Any</code> rarely being <em>needed</em> it can still be convenient to use sometimes, as we&rsquo;ll later see in the <strong>Error Handling</strong> section.</p><h2 id=formatting-traits>Formatting Traits</h2><p>We can serialize types into strings using the formatting macros in <code>std::fmt</code>, the most well-known of the bunch being <code>println!</code>. We can pass formatting parameters to the <code>{}</code> placeholders used within format <code>str</code>s which are then used to select which trait impl to use to serialize the placeholder&rsquo;s argument.</p><table><thead><tr><th>Trait</th><th>Placeholder</th><th>Description</th></tr></thead><tbody><tr><td><code>Display</code></td><td><code>{}</code></td><td>display representation</td></tr><tr><td><code>Debug</code></td><td><code>{:?}</code></td><td>debug representation</td></tr><tr><td><code>Octal</code></td><td><code>{:o}</code></td><td>octal representation</td></tr><tr><td><code>LowerHex</code></td><td><code>{:x}</code></td><td>lowercase hex representation</td></tr><tr><td><code>UpperHex</code></td><td><code>{:X}</code></td><td>uppercase hex representation</td></tr><tr><td><code>Pointer</code></td><td><code>{:p}</code></td><td>memory address</td></tr><tr><td><code>Binary</code></td><td><code>{:b}</code></td><td>binary representation</td></tr><tr><td><code>LowerExp</code></td><td><code>{:e}</code></td><td>lowercase exponential representation</td></tr><tr><td><code>UpperExp</code></td><td><code>{:E}</code></td><td>uppercase exponential representation</td></tr></tbody></table><h3 id=display--tostring>Display & ToString</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#generic-blanket-impls>Generic Blanket Impls</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Display {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> fmt(&amp;self, f: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> Formatter&lt;&#39;_&gt;) -&gt; Result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Display</code> types can be serialized into <code>String</code>s which are friendly to the end users of the program. Example impl for <code>Point</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::fmt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(Default)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> fmt::Display <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> fmt(&amp;self, f: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> fmt::Formatter&lt;&#39;_&gt;) -&gt; <span style=color:#2b91af>fmt</span>::Result {
</span></span><span style=display:flex><span>        write!(f, <span style=color:#a31515>&#34;({}, {})&#34;</span>, self.x, self.y)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    println!(<span style=color:#a31515>&#34;origin: {}&#34;</span>, Point::default());
</span></span><span style=display:flex><span>    <span style=color:green>// prints &#34;origin: (0, 0)&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span>    <span style=color:green>// get Point&#39;s Display representation as a String
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> stringified_point = format!(<span style=color:#a31515>&#34;{}&#34;</span>, Point::default());
</span></span><span style=display:flex><span>    assert_eq!(<span style=color:#a31515>&#34;(0, 0)&#34;</span>, stringified_point); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Aside from using the <code>format!</code> macro to get a type&rsquo;s display representation as a <code>String</code> we can use the <code>ToString</code> trait:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> ToString {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> to_string(&amp;self) -&gt; String;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There&rsquo;s no need for us to impl this ourselves. In fact we can&rsquo;t, because of this generic blanket impl that automatically impls <code>ToString</code> for any type which impls <code>Display</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span>&lt;T: <span style=color:#2b91af>Display</span> + ?Sized&gt; ToString <span style=color:#00f>for</span> T;
</span></span></code></pre></div><p>Using <code>ToString</code> with <code>Point</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>#[test]</span> <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> display_point() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> origin = Point::default();
</span></span><span style=display:flex><span>    assert_eq!(format!(<span style=color:#a31515>&#34;{}&#34;</span>, origin), <span style=color:#a31515>&#34;(0, 0)&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[test]</span> <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> point_to_string() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> origin = Point::default();
</span></span><span style=display:flex><span>    assert_eq!(origin.to_string(), <span style=color:#a31515>&#34;(0, 0)&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[test]</span> <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> display_equals_to_string() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> origin = Point::default();
</span></span><span style=display:flex><span>    assert_eq!(format!(<span style=color:#a31515>&#34;{}&#34;</span>, origin), origin.to_string());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=debug>Debug</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#derive-macros>Derive Macros</a></li><li><a href=#display--tostring>Display & ToString</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Debug {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> fmt(&amp;self, f: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> Formatter&lt;&#39;_&gt;) -&gt; Result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Debug</code> has an identical signature to <code>Display</code>. The only difference is that the <code>Debug</code> impl is called when we use the <code>{:?}</code> formatting specifier. <code>Debug</code> can be derived:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::fmt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// derive macro generates impl below
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> fmt::Debug <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> fmt(&amp;self, f: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> fmt::Formatter&lt;&#39;_&gt;) -&gt; <span style=color:#2b91af>fmt</span>::Result {
</span></span><span style=display:flex><span>        f.debug_struct(<span style=color:#a31515>&#34;Point&#34;</span>)
</span></span><span style=display:flex><span>            .field(<span style=color:#a31515>&#34;x&#34;</span>, &amp;self.x)
</span></span><span style=display:flex><span>            .field(<span style=color:#a31515>&#34;y&#34;</span>, &amp;self.y)
</span></span><span style=display:flex><span>            .finish()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Impling <code>Debug</code> for a type also allows it to be used within the <code>dbg!</code> macro which is superior to <code>println!</code> for quick and dirty print logging. Some of its advantages:</p><ol><li><code>dbg!</code> prints to stderr instead of stdout so the debug logs are easy to separate from the actual stdout output of our program.</li><li><code>dbg!</code> prints the expression passed to it as well as the value the expression evaluated to.</li><li><code>dbg!</code> takes ownership of its arguments and returns them so you can use it within expressions:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> some_condition() -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// no logging
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> example() {
</span></span><span style=display:flex><span>    <span style=color:#00f>if</span> some_condition() {
</span></span><span style=display:flex><span>        <span style=color:green>// some code
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// println! logging
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> example_println() {
</span></span><span style=display:flex><span>    <span style=color:green>// 🤦
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> result = some_condition();
</span></span><span style=display:flex><span>    println!(<span style=color:#a31515>&#34;{}&#34;</span>, result); <span style=color:green>// just prints &#34;true&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>if</span> result {
</span></span><span style=display:flex><span>        <span style=color:green>// some code
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// dbg! logging
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> example_dbg() {
</span></span><span style=display:flex><span>    <span style=color:green>// 😍
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>if</span> dbg!(some_condition()) { <span style=color:green>// prints &#34;[src/main.rs:22] some_condition() = true&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>        <span style=color:green>// some code
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The only downside is that <code>dbg!</code> isn&rsquo;t automatically stripped in release builds so we have to manually remove it from our code if we don&rsquo;t want to ship it in the final executable.</p><h2 id=operator-traits>Operator Traits</h2><p>All operators in Rust are associated with traits. If we&rsquo;d like to impl operators for our types we have to impl the associated traits.</p><table><thead><tr><th>Trait(s)</th><th>Category</th><th>Operator(s)</th><th>Description</th></tr></thead><tbody><tr><td><code>Eq</code>, <code>PartialEq</code></td><td>comparison</td><td><code>==</code></td><td>equality</td></tr><tr><td><code>Ord</code>, <code>PartialOrd</code></td><td>comparison</td><td><code>&lt;</code>, <code>></code>, <code>&lt;=</code>, <code>>=</code></td><td>comparison</td></tr><tr><td><code>Add</code></td><td>arithmetic</td><td><code>+</code></td><td>addition</td></tr><tr><td><code>AddAssign</code></td><td>arithmetic</td><td><code>+=</code></td><td>addition assignment</td></tr><tr><td><code>BitAnd</code></td><td>arithmetic</td><td><code>&</code></td><td>bitwise AND</td></tr><tr><td><code>BitAndAssign</code></td><td>arithmetic</td><td><code>&=</code></td><td>bitwise assignment</td></tr><tr><td><code>BitXor</code></td><td>arithmetic</td><td><code>^</code></td><td>bitwise XOR</td></tr><tr><td><code>BitXorAssign</code></td><td>arithmetic</td><td><code>^=</code></td><td>bitwise XOR assignment</td></tr><tr><td><code>Div</code></td><td>arithmetic</td><td><code>/</code></td><td>division</td></tr><tr><td><code>DivAssign</code></td><td>arithmetic</td><td><code>/=</code></td><td>division assignment</td></tr><tr><td><code>Mul</code></td><td>arithmetic</td><td><code>*</code></td><td>multiplication</td></tr><tr><td><code>MulAssign</code></td><td>arithmetic</td><td><code>*=</code></td><td>multiplication assignment</td></tr><tr><td><code>Neg</code></td><td>arithmetic</td><td><code>-</code></td><td>unary negation</td></tr><tr><td><code>Not</code></td><td>arithmetic</td><td><code>!</code></td><td>unary logical negation</td></tr><tr><td><code>Rem</code></td><td>arithmetic</td><td><code>%</code></td><td>remainder</td></tr><tr><td><code>RemAssign</code></td><td>arithmetic</td><td><code>%=</code></td><td>remainder assignment</td></tr><tr><td><code>Shl</code></td><td>arithmetic</td><td><code>&lt;&lt;</code></td><td>left shift</td></tr><tr><td><code>ShlAssign</code></td><td>arithmetic</td><td><code>&lt;&lt;=</code></td><td>left shift assignment</td></tr><tr><td><code>Shr</code></td><td>arithmetic</td><td><code>>></code></td><td>right shift</td></tr><tr><td><code>ShrAssign</code></td><td>arithmetic</td><td><code>>>=</code></td><td>right shift assignment</td></tr><tr><td><code>Sub</code></td><td>arithmetic</td><td><code>-</code></td><td>subtraction</td></tr><tr><td><code>SubAssign</code></td><td>arithmetic</td><td><code>-=</code></td><td>subtraction assignment</td></tr><tr><td><code>Fn</code></td><td>closure</td><td><code>(...args)</code></td><td>immutable closure invocation</td></tr><tr><td><code>FnMut</code></td><td>closure</td><td><code>(...args)</code></td><td>mutable closure invocation</td></tr><tr><td><code>FnOnce</code></td><td>closure</td><td><code>(...args)</code></td><td>one-time closure invocation</td></tr><tr><td><code>Deref</code></td><td>other</td><td><code>*</code></td><td>immutable dereference</td></tr><tr><td><code>DerefMut</code></td><td>other</td><td><code>*</code></td><td>mutable derenence</td></tr><tr><td><code>Drop</code></td><td>other</td><td>-</td><td>type destructor</td></tr><tr><td><code>Index</code></td><td>other</td><td><code>[]</code></td><td>immutable index</td></tr><tr><td><code>IndexMut</code></td><td>other</td><td><code>[]</code></td><td>mutable index</td></tr><tr><td><code>RangeBounds</code></td><td>other</td><td><code>..</code></td><td>range</td></tr></tbody></table><h3 id=comparison-traits>Comparison Traits</h3><table><thead><tr><th>Trait(s)</th><th>Category</th><th>Operator(s)</th><th>Description</th></tr></thead><tbody><tr><td><code>Eq</code>, <code>PartialEq</code></td><td>comparison</td><td><code>==</code></td><td>equality</td></tr><tr><td><code>Ord</code>, <code>PartialOrd</code></td><td>comparison</td><td><code>&lt;</code>, <code>></code>, <code>&lt;=</code>, <code>>=</code></td><td>comparison</td></tr></tbody></table><h4 id=partialeq--eq>PartialEq & Eq</h4><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#generic-parameters>Generic Parameters</a></li><li><a href=#default-impls>Default Impls</a></li><li><a href=#generic-blanket-impls>Generic Blanket Impls</a></li><li><a href=#marker-traits>Marker Traits</a></li><li><a href=#subtraits--supertraits>Subtraits & Supertraits</a></li><li><a href=#sized>Sized</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> PartialEq&lt;Rhs = Self&gt; 
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    Rhs: ?Sized, 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Rhs</span>) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// provided default impls
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> ne(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Rhs</span>) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>PartialEq&lt;Rhs></code> types can be checked for equality to <code>Rhs</code> types using the <code>==</code> operator.</p><p>All <code>PartialEq&lt;Rhs></code> impls must ensure that equality is symmetric and transitive. That means for all <code>a</code>, <code>b</code>, and <code>c</code>:</p><ul><li><code>a == b</code> implies <code>b == a</code> (symmetry)</li><li><code>a == b && b == c</code> implies <code>a == c</code> (transitivity)</li></ul><p>By default <code>Rhs = Self</code> because we almost always want to compare instances of a type to each other, and not to instances of different types. This also automatically guarantees our impl is symmetric and transitive.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// Rhs == Self == Point
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> PartialEq <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:green>// impl automatically symmetric &amp; transitive
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self.x == other.x &amp;&amp; self.y == other.y
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If all the members of a type impl <code>PartialEq</code> then it can be derived:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>#[derive(PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Suit</span> {
</span></span><span style=display:flex><span>    Spade,
</span></span><span style=display:flex><span>    Heart,
</span></span><span style=display:flex><span>    Club,
</span></span><span style=display:flex><span>    Diamond,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Once we impl <code>PartialEq</code> for our type we also get equality comparisons between references of our type for free thanks to these generic blanket impls:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// this impl only gives us: Point == Point
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>#[derive(PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// all of the generic blanket impls below
</span></span></span><span style=display:flex><span><span style=color:green>// are provided by the standard library
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span><span style=color:green>// this impl gives us: &amp;Point == &amp;Point
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span>&lt;A, B&gt; PartialEq&lt;&amp;&#39;_ B&gt; <span style=color:#00f>for</span> &amp;&#39;_ A
</span></span><span style=display:flex><span><span style=color:#00f>where</span> A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// this impl gives us: &amp;mut Point == &amp;Point
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span>&lt;A, B&gt; PartialEq&lt;&amp;&#39;_ B&gt; <span style=color:#00f>for</span> &amp;&#39;_ <span style=color:#00f>mut</span> A
</span></span><span style=display:flex><span><span style=color:#00f>where</span> A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// this impl gives us: &amp;Point == &amp;mut Point
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span>&lt;A, B&gt; PartialEq&lt;&amp;&#39;_ <span style=color:#00f>mut</span> B&gt; <span style=color:#00f>for</span> &amp;&#39;_ A
</span></span><span style=display:flex><span><span style=color:#00f>where</span> A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// this impl gives us: &amp;mut Point == &amp;mut Point
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span>&lt;A, B&gt; PartialEq&lt;&amp;&#39;_ <span style=color:#00f>mut</span> B&gt; <span style=color:#00f>for</span> &amp;&#39;_ <span style=color:#00f>mut</span> A
</span></span><span style=display:flex><span><span style=color:#00f>where</span> A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;
</span></span></code></pre></div><p>Since this trait is generic we can define equality between different types. The standard library leverages this to allow checking equality between the many string-like types such as <code>String</code>, <code>&str</code>, <code>PathBuf</code>, <code>&Path</code>, <code>OsString</code>, <code>&OsStr</code>, and so on.</p><p>Generally, we should only impl equality between different types <em>if they contain the same kind of data</em> and the only difference between the types is how they represent the data or how they allow interacting with the data.</p><p>Here&rsquo;s a cute but bad example of how someone might be tempted to impl <code>PartialEq</code> to check equality between different types that don&rsquo;t meet the above criteria:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>#[derive(PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Suit</span> {
</span></span><span style=display:flex><span>    Spade,
</span></span><span style=display:flex><span>    Club,
</span></span><span style=display:flex><span>    Heart,
</span></span><span style=display:flex><span>    Diamond,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Rank</span> {
</span></span><span style=display:flex><span>    Ace,
</span></span><span style=display:flex><span>    Two,
</span></span><span style=display:flex><span>    Three,
</span></span><span style=display:flex><span>    Four,
</span></span><span style=display:flex><span>    Five,
</span></span><span style=display:flex><span>    Six,
</span></span><span style=display:flex><span>    Seven,
</span></span><span style=display:flex><span>    Eight,
</span></span><span style=display:flex><span>    Nine,
</span></span><span style=display:flex><span>    Ten,
</span></span><span style=display:flex><span>    Jack,
</span></span><span style=display:flex><span>    Queen,
</span></span><span style=display:flex><span>    King,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Card</span> {
</span></span><span style=display:flex><span>    suit: <span style=color:#2b91af>Suit</span>,
</span></span><span style=display:flex><span>    rank: <span style=color:#2b91af>Rank</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// check equality of Card&#39;s suit
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> PartialEq&lt;Suit&gt; <span style=color:#00f>for</span> Card {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Suit</span>) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self.suit == *other
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// check equality of Card&#39;s rank
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> PartialEq&lt;Rank&gt; <span style=color:#00f>for</span> Card {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Rank</span>) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self.rank == *other
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> AceOfSpades = Card {
</span></span><span style=display:flex><span>        suit: <span style=color:#2b91af>Suit</span>::Spade,
</span></span><span style=display:flex><span>        rank: <span style=color:#2b91af>Rank</span>::Ace,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    assert!(AceOfSpades == Suit::Spade); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert!(AceOfSpades == Rank::Ace); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>It works and kinda makes sense. A card which is an Ace of Spades is both an Ace and a Spade, and if we&rsquo;re writing a library to handle playing cards it&rsquo;s reasonable that we&rsquo;d want to make it easy and convenient to individually check the suit and rank of a card. However, something&rsquo;s missing: symmetry! We can <code>Card == Suit</code> and <code>Card == Rank</code> but we cannot <code>Suit == Card</code> or <code>Rank == Card</code> so let&rsquo;s fix that:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// check equality of Card&#39;s suit
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> PartialEq&lt;Suit&gt; <span style=color:#00f>for</span> Card {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Suit</span>) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self.suit == *other
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// added for symmetry
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> PartialEq&lt;Card&gt; <span style=color:#00f>for</span> Suit {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Card</span>) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        *self == other.suit
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// check equality of Card&#39;s rank
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> PartialEq&lt;Rank&gt; <span style=color:#00f>for</span> Card {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Rank</span>) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self.rank == *other
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// added for symmetry
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> PartialEq&lt;Card&gt; <span style=color:#00f>for</span> Rank {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Card</span>) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        *self == other.rank
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We have symmetry! Great. Adding symmetry just broke transitivity! Oops. This is now possible:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:green>// Ace of Spades
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> a = Card {
</span></span><span style=display:flex><span>        suit: <span style=color:#2b91af>Suit</span>::Spade,
</span></span><span style=display:flex><span>        rank: <span style=color:#2b91af>Rank</span>::Ace,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> b = Suit::Spade;
</span></span><span style=display:flex><span>    <span style=color:green>// King of Spades
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> c = Card {
</span></span><span style=display:flex><span>        suit: <span style=color:#2b91af>Suit</span>::Spade,
</span></span><span style=display:flex><span>        rank: <span style=color:#2b91af>Rank</span>::King,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    assert!(a == b &amp;&amp; b == c); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert!(a == c); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>A good example of impling <code>PartialEq</code> to check equality between different types would be a program that works with distances and uses different types to represent different units of measurement.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>#[derive(PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Foot</span>(<span style=color:#2b91af>u32</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Yard</span>(<span style=color:#2b91af>u32</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Mile</span>(<span style=color:#2b91af>u32</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> PartialEq&lt;Mile&gt; <span style=color:#00f>for</span> Foot {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Mile</span>) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self.0 == other.0 * 5280
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> PartialEq&lt;Foot&gt; <span style=color:#00f>for</span> Mile {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Foot</span>) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self.0 * 5280 == other.0
</span></span><span style=display:flex><span>    }    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> PartialEq&lt;Mile&gt; <span style=color:#00f>for</span> Yard {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Mile</span>) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self.0 == other.0 * 1760
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> PartialEq&lt;Yard&gt; <span style=color:#00f>for</span> Mile {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Yard</span>) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self.0 * 1760 == other.0
</span></span><span style=display:flex><span>    }    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> PartialEq&lt;Foot&gt; <span style=color:#00f>for</span> Yard {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Foot</span>) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self.0 * 3 == other.0
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> PartialEq&lt;Yard&gt; <span style=color:#00f>for</span> Foot {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Yard</span>) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self.0 == other.0 * 3
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> a = Foot(5280);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> b = Yard(1760);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> c = Mile(1);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:green>// symmetry
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert!(a == b &amp;&amp; b == a); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert!(b == c &amp;&amp; c == b); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert!(a == c &amp;&amp; c == a); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span>    <span style=color:green>// transitivity
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert!(a == b &amp;&amp; b == c &amp;&amp; a == c); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert!(c == b &amp;&amp; b == a &amp;&amp; c == a); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p><code>Eq</code> is a marker trait and a subtrait of <code>PartialEq&lt;Self></code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Eq: PartialEq&lt;Self&gt; {}
</span></span></code></pre></div><p>If we impl <code>Eq</code> for a type, on top of the symmetry & transitivity properties required by <code>PartialEq</code>, we&rsquo;re also guaranteeing reflexivity, i.e. <code>a == a</code> for all <code>a</code>. In this sense <code>Eq</code> refines <code>PartialEq</code> because it represents a stricter version of equality. If all members of a type impl <code>Eq</code> then the <code>Eq</code> impl can be derived for the type.</p><p>Floats are <code>PartialEq</code> but not <code>Eq</code> because <code>NaN != NaN</code>. Almost all other <code>PartialEq</code> types are trivially <code>Eq</code>, unless of course if they contain floats.</p><p>Once a type impls <code>PartialEq</code> and <code>Debug</code> we can use it in the <code>assert_eq!</code> macro. We can also compare collections of <code>PartialEq</code> types.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>#[derive(PartialEq, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example_assert(p1: <span style=color:#2b91af>Point</span>, p2: <span style=color:#2b91af>Point</span>) {
</span></span><span style=display:flex><span>    assert_eq!(p1, p2);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example_compare_collections&lt;T: PartialEq&gt;(vec1: Vec&lt;T&gt;, vec2: Vec&lt;T&gt;) {
</span></span><span style=display:flex><span>    <span style=color:green>// if T: PartialEq this now works!
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>if</span> vec1 == vec2 {
</span></span><span style=display:flex><span>        <span style=color:green>// some code
</span></span></span><span style=display:flex><span><span style=color:green></span>    } <span style=color:#00f>else</span> {
</span></span><span style=display:flex><span>        <span style=color:green>// other code
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=hash>Hash</h4><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#generic-parameters>Generic Parameters</a></li><li><a href=#default-impls>Default Impls</a></li><li><a href=#derive-macros>Derive Macros</a></li><li><a href=#partialeq--eq>PartialEq & Eq</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Hash {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> hash&lt;H: <span style=color:#2b91af>Hasher</span>&gt;(&amp;self, state: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> H);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// provided default impls
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> hash_slice&lt;H: <span style=color:#2b91af>Hasher</span>&gt;(data: <span style=color:#00f>&amp;</span>[Self], state: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> H);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This trait is not associated with any operator, but the best time to talk about it is right after <code>PartialEq</code> & <code>Eq</code> so here it is. <code>Hash</code> types can be hashed using a <code>Hasher</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std:#<span>️⃣</span>:<span style=color:#2b91af>Hasher</span>;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std:#<span>️⃣</span>:<span style=color:#2b91af>Hash</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Hash <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> hash&lt;H: <span style=color:#2b91af>Hasher</span>&gt;(&amp;self, hasher: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> H) {
</span></span><span style=display:flex><span>        hasher.write_i32(self.x);
</span></span><span style=display:flex><span>        hasher.write_i32(self.y);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There&rsquo;s a derive macro which generates the same impl as above:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>#[derive(Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If a type impls both <code>Hash</code> and <code>Eq</code> those impls must agree with each other such that for all <code>a</code> and <code>b</code> if <code>a == b</code> then <code>a.hash() == b.hash()</code>. So we should always use the derive macro to impl both or manually impl both, but not mix the two, otherwise we risk breaking the above invariant.</p><p>The main benefit of impling <code>Eq</code> and <code>Hash</code> for a type is that it allows us to store that type as keys in <code>HashMap</code>s and <code>HashSet</code>s.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::collections::HashSet;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// now our type can be stored
</span></span></span><span style=display:flex><span><span style=color:green>// in HashSets and HashMaps!
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>#[derive(PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example_hashset() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> points = HashSet::new();
</span></span><span style=display:flex><span>    points.insert(Point { x: 0, y: 0 }); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><h4 id=partialord--ord>PartialOrd & Ord</h4><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#generic-parameters>Generic Parameters</a></li><li><a href=#default-impls>Default Impls</a></li><li><a href=#subtraits--supertraits>Subtraits & Supertraits</a></li><li><a href=#derive-macros>Derive Macros</a></li><li><a href=#sized>Sized</a></li><li><a href=#partialeq--eq>PartialEq & Eq</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Ordering</span> {
</span></span><span style=display:flex><span>    Less,
</span></span><span style=display:flex><span>    Equal,
</span></span><span style=display:flex><span>    Greater,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> PartialOrd&lt;Rhs = Self&gt;: PartialEq&lt;Rhs&gt; 
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    Rhs: ?Sized, 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> partial_cmp(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Rhs</span>) -&gt; Option&lt;Ordering&gt;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// provided default impls
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> lt(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Rhs</span>) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> le(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Rhs</span>) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> gt(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Rhs</span>) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> ge(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Rhs</span>) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>PartialOrd&lt;Rhs></code> types can be compared to <code>Rhs</code> types using the <code>&lt;</code>, <code>&lt;=</code>, <code>></code>, and <code>>=</code> operators.</p><p>All <code>PartialOrd</code> impls must ensure that comparisons are asymmetric and transitive. That means for all <code>a</code>, <code>b</code>, and <code>c</code>:</p><ul><li><code>a &lt; b</code> implies <code>!(a > b)</code> (asymmetry)</li><li><code>a &lt; b && b &lt; c</code> implies <code>a &lt; c</code> (transitivity)</li></ul><p><code>PartialOrd</code> is a subtrait of <code>PartialEq</code> and their impls must always agree with each other.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> must_always_agree&lt;T: PartialOrd + PartialEq&gt;(t1: <span style=color:#2b91af>T</span>, t2: <span style=color:#2b91af>T</span>) {
</span></span><span style=display:flex><span>    assert_eq!(t1.partial_cmp(&amp;t2) == Some(Ordering::Equal), t1 == t2);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>PartialOrd</code> refines <code>PartialEq</code> in the sense that when comparing <code>PartialEq</code> types we can check if they are equal or not equal, but when comparing <code>PartialOrd</code> types we can check if they are equal or not equal, and if they are not equal we can check if they are unequal because the first item is less than or greater than the second item.</p><p>By default <code>Rhs = Self</code> because we almost always want to compare instances of a type to each other, and not to instances of different types. This also automatically guarantees our impl is symmetric and transitive.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::cmp::Ordering;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(PartialEq, PartialOrd)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// Rhs == Self == Point
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> PartialOrd <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:green>// impl automatically symmetric &amp; transitive
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> partial_cmp(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Point</span>) -&gt; Option&lt;Ordering&gt; {
</span></span><span style=display:flex><span>        Some(<span style=color:#00f>match</span> self.x.cmp(&amp;other.x) {
</span></span><span style=display:flex><span>            Ordering::Equal =&gt; self.y.cmp(&amp;other.y),
</span></span><span style=display:flex><span>            ordering =&gt; ordering,
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If all the members of a type impl <code>PartialOrd</code> then it can be derived:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>#[derive(PartialEq, PartialOrd)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(PartialEq, PartialOrd)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Stoplight</span> {
</span></span><span style=display:flex><span>    Red,
</span></span><span style=display:flex><span>    Yellow,
</span></span><span style=display:flex><span>    Green,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>PartialOrd</code> derive macro orders types based on the lexicographical order of their members:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// generates PartialOrd impl which orders
</span></span></span><span style=display:flex><span><span style=color:green>// Points based on x member first and
</span></span></span><span style=display:flex><span><span style=color:green>// y member second because that&#39;s the order
</span></span></span><span style=display:flex><span><span style=color:green>// they appear in the source code
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>#[derive(PartialOrd, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// generates DIFFERENT PartialOrd impl
</span></span></span><span style=display:flex><span><span style=color:green>// which orders Points based on y member
</span></span></span><span style=display:flex><span><span style=color:green>// first and x member second
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>#[derive(PartialOrd, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Ord</code> is a subtrait of <code>Eq</code> and <code>PartialOrd&lt;Self></code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Ord: Eq + PartialOrd&lt;Self&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> cmp(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Self</span>) -&gt; <span style=color:#2b91af>Ordering</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// provided default impls
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> max(self, other: <span style=color:#2b91af>Self</span>) -&gt; <span style=color:#2b91af>Self</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> min(self, other: <span style=color:#2b91af>Self</span>) -&gt; <span style=color:#2b91af>Self</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> clamp(self, min: <span style=color:#2b91af>Self</span>, max: <span style=color:#2b91af>Self</span>) -&gt; <span style=color:#2b91af>Self</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If we impl <code>Ord</code> for a type, on top of the asymmetry & transitivity properties required by <code>PartialOrd</code>, we&rsquo;re also guaranteeing that the asymmetry is total, i.e. exactly one of <code>a &lt; b</code>, <code>a == b</code> or <code>a > b</code> is true for any given <code>a</code> and <code>b</code>. In this sense <code>Ord</code> refines <code>Eq</code> and <code>PartialOrd</code> because it represents a stricter version of comparisons. If a type impls <code>Ord</code> we can use that impl to trivially impl <code>PartialOrd</code>, <code>PartialEq</code>, and <code>Eq</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::cmp::Ordering;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// of course we can use the derive macros here
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>#[derive(Ord, PartialOrd, Eq, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// note: as with PartialOrd, the Ord derive macro
</span></span></span><span style=display:flex><span><span style=color:green>// orders a type based on the lexicographical order
</span></span></span><span style=display:flex><span><span style=color:green>// of its members
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span><span style=color:green>// but here&#39;s the impls if we wrote them out by hand
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> Ord <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> cmp(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Self</span>) -&gt; <span style=color:#2b91af>Ordering</span> {
</span></span><span style=display:flex><span>        <span style=color:#00f>match</span> self.x.cmp(&amp;self.y) {
</span></span><span style=display:flex><span>            Ordering::Equal =&gt; self.y.cmp(&amp;self.y),
</span></span><span style=display:flex><span>            ordering =&gt; ordering,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> PartialOrd <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> partial_cmp(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Self</span>) -&gt; Option&lt;Ordering&gt; {
</span></span><span style=display:flex><span>        Some(self.cmp(other))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> PartialEq <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq(&amp;self, other: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Self</span>) -&gt; <span style=color:#2b91af>bool</span> {
</span></span><span style=display:flex><span>        self.cmp(other) == Ordering::Equal
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Eq <span style=color:#00f>for</span> Point {}
</span></span></code></pre></div><p>Floats impl <code>PartialOrd</code> but not <code>Ord</code> because both <code>NaN &lt; 0 == false</code> and <code>NaN >= 0 == false</code> are simultaneously true. Almost all other <code>PartialOrd</code> types are trivially <code>Ord</code>, unless of course if they contain floats.</p><p>Once a type impls <code>Ord</code> we can store it in <code>BTreeMap</code>s and <code>BTreeSet</code>s as well as easily sort it using the <code>sort()</code> method on slices and any types which deref to slices such as arrays, <code>Vec</code>s, and <code>VecDeque</code>s.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::collections::BTreeSet;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// now our type can be stored
</span></span></span><span style=display:flex><span><span style=color:green>// in BTreeSets and BTreeMaps!
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>#[derive(Ord, PartialOrd, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example_btreeset() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> points = BTreeSet::new();
</span></span><span style=display:flex><span>    points.insert(Point { x: 0, y: 0 }); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// we can also .sort() Ord types in collections!
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> example_sort&lt;T: Ord&gt;(<span style=color:#00f>mut</span> sortable: Vec&lt;T&gt;) -&gt; Vec&lt;T&gt; {
</span></span><span style=display:flex><span>    sortable.sort();
</span></span><span style=display:flex><span>    sortable
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=arithmetic-traits>Arithmetic Traits</h3><table><thead><tr><th>Trait(s)</th><th>Category</th><th>Operator(s)</th><th>Description</th></tr></thead><tbody><tr><td><code>Add</code></td><td>arithmetic</td><td><code>+</code></td><td>addition</td></tr><tr><td><code>AddAssign</code></td><td>arithmetic</td><td><code>+=</code></td><td>addition assignment</td></tr><tr><td><code>BitAnd</code></td><td>arithmetic</td><td><code>&</code></td><td>bitwise AND</td></tr><tr><td><code>BitAndAssign</code></td><td>arithmetic</td><td><code>&=</code></td><td>bitwise assignment</td></tr><tr><td><code>BitXor</code></td><td>arithmetic</td><td><code>^</code></td><td>bitwise XOR</td></tr><tr><td><code>BitXorAssign</code></td><td>arithmetic</td><td><code>^=</code></td><td>bitwise XOR assignment</td></tr><tr><td><code>Div</code></td><td>arithmetic</td><td><code>/</code></td><td>division</td></tr><tr><td><code>DivAssign</code></td><td>arithmetic</td><td><code>/=</code></td><td>division assignment</td></tr><tr><td><code>Mul</code></td><td>arithmetic</td><td><code>*</code></td><td>multiplication</td></tr><tr><td><code>MulAssign</code></td><td>arithmetic</td><td><code>*=</code></td><td>multiplication assignment</td></tr><tr><td><code>Neg</code></td><td>arithmetic</td><td><code>-</code></td><td>unary negation</td></tr><tr><td><code>Not</code></td><td>arithmetic</td><td><code>!</code></td><td>unary logical negation</td></tr><tr><td><code>Rem</code></td><td>arithmetic</td><td><code>%</code></td><td>remainder</td></tr><tr><td><code>RemAssign</code></td><td>arithmetic</td><td><code>%=</code></td><td>remainder assignment</td></tr><tr><td><code>Shl</code></td><td>arithmetic</td><td><code>&lt;&lt;</code></td><td>left shift</td></tr><tr><td><code>ShlAssign</code></td><td>arithmetic</td><td><code>&lt;&lt;=</code></td><td>left shift assignment</td></tr><tr><td><code>Shr</code></td><td>arithmetic</td><td><code>>></code></td><td>right shift</td></tr><tr><td><code>ShrAssign</code></td><td>arithmetic</td><td><code>>>=</code></td><td>right shift assignment</td></tr><tr><td><code>Sub</code></td><td>arithmetic</td><td><code>-</code></td><td>subtraction</td></tr><tr><td><code>SubAssign</code></td><td>arithmetic</td><td><code>-=</code></td><td>subtraction assignment</td></tr></tbody></table><p>Going over all of these would be very redundant. Most of these only apply to number types anyway. We&rsquo;ll only go over <code>Add</code> and <code>AddAssign</code> since the <code>+</code> operator is commonly overloaded to do other stuff like adding items to collections or concatenating things together, that way we cover the most interesting ground and don&rsquo;t repeat ourselves.</p><h4 id=add--addassign>Add & AddAssign</h4><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#associated-types>Associated Types</a></li><li><a href=#generic-parameters>Generic Parameters</a></li><li><a href=#generic-types-vs-associated-types>Generic Types vs Associated Types</a></li><li><a href=#derive-macros>Derive Macros</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Add&lt;Rhs = Self&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>Rhs</span>) -&gt; <span style=color:#2b91af>Self</span>::Output;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Add&lt;Rhs, Output = T></code> types can be added to <code>Rhs</code> types and will produce <code>T</code> as output.</p><p>Example <code>Add&lt;Point, Output = Point></code> impl for <code>Point</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>#[derive(Clone, Copy)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Add <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span> = Point;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#2b91af>self</span>.x + rhs.x,
</span></span><span style=display:flex><span>            y: <span style=color:#2b91af>self</span>.y + rhs.y,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 2 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p2 = Point { x: 3, y: 4 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p3 = p1 + p2;
</span></span><span style=display:flex><span>    assert_eq!(p3.x, p1.x + p2.x); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(p3.y, p1.y + p2.y); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>But what if we only had references to <code>Point</code>s? Can we still add them then? Let&rsquo;s try:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 2 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p2 = Point { x: 3, y: 4 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p3 = &amp;p1 + &amp;p2; <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Unfortunately not. The compiler throws:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>error[E0369]: cannot add `&amp;Point` to `&amp;Point`
</span></span><span style=display:flex><span>  --&gt; src/main.rs:50:25
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>50 |     let p3: Point = &amp;p1 + &amp;p2;
</span></span><span style=display:flex><span>   |                     --- ^ --- &amp;Point
</span></span><span style=display:flex><span>   |                     |
</span></span><span style=display:flex><span>   |                     &amp;Point
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>   = note: an implementation of `std::ops::Add` might be missing for `&amp;Point`
</span></span></code></pre></div><p>Within Rust&rsquo;s type system, for some type <code>T</code>, the types <code>T</code>, <code>&T</code>, and <code>&mut T</code> are all treated as unique distinct types which means we have to provide trait impls for each of them separately. Let&rsquo;s define an <code>Add</code> impl for <code>&Point</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span> Add <span style=color:#00f>for</span> &amp;Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span> = Point;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#2b91af>self</span>.x + rhs.x,
</span></span><span style=display:flex><span>            y: <span style=color:#2b91af>self</span>.y + rhs.y,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 2 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p2 = Point { x: 3, y: 4 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p3 = &amp;p1 + &amp;p2; <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(p3.x, p1.x + p2.x); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(p3.y, p1.y + p2.y); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>However, something still doesn&rsquo;t feel quite right. We have two separate impls of <code>Add</code> for <code>Point</code> and <code>&Point</code> and they <em>happen</em> to do the same thing currently but there&rsquo;s no guarantee that they will in the future! For example, let&rsquo;s say we decide that when we add two <code>Point</code>s together we want to create a <code>Line</code> containing those two <code>Point</code>s instead of creating a new <code>Point</code>, we&rsquo;d update our <code>Add</code> impl like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::ops::Add;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(Copy, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(Copy, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Line</span> {
</span></span><span style=display:flex><span>    start: <span style=color:#2b91af>Point</span>,
</span></span><span style=display:flex><span>    end: <span style=color:#2b91af>Point</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// we updated this impl
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> Add <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span> = Line;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>Line</span> {
</span></span><span style=display:flex><span>        Line {
</span></span><span style=display:flex><span>            start: <span style=color:#2b91af>self</span>,
</span></span><span style=display:flex><span>            end: <span style=color:#2b91af>rhs</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// but forgot to update this impl, uh oh!
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> Add <span style=color:#00f>for</span> &amp;Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span> = Point;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#2b91af>self</span>.x + rhs.x,
</span></span><span style=display:flex><span>            y: <span style=color:#2b91af>self</span>.y + rhs.y,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 2 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p2 = Point { x: 3, y: 4 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> line: <span style=color:#2b91af>Line</span> = p1 + p2; <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 2 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p2 = Point { x: 3, y: 4 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> line: <span style=color:#2b91af>Line</span> = &amp;p1 + &amp;p2; <span style=color:green>// ❌ expected Line, found Point
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Our current impl of <code>Add</code> for <code>&Point</code> creates an unnecessary maintenance burden, we want the impl to match <code>Point</code>&rsquo;s impl without having to manually update it every time we change <code>Point</code>&rsquo;s impl. We&rsquo;d like to keep our code as DRY (Don&rsquo;t Repeat Yourself) as possible. Luckily this is achievable:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// updated, DRY impl
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> Add <span style=color:#00f>for</span> &amp;Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span> = &lt;Point <span style=color:#00f>as</span> Add&gt;::Output;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add(self, rhs: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>Self</span>::Output {
</span></span><span style=display:flex><span>        Point::add(*self, *rhs)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 2 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p2 = Point { x: 3, y: 4 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> line: <span style=color:#2b91af>Line</span> = p1 + p2; <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p1 = Point { x: 1, y: 2 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p2 = Point { x: 3, y: 4 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> line: <span style=color:#2b91af>Line</span> = &amp;p1 + &amp;p2; <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p><code>AddAssign&lt;Rhs></code> types allow us to add + assign <code>Rhs</code> types to them. The trait declaration:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> AddAssign&lt;Rhs = Self&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add_assign(&amp;<span style=color:#00f>mut</span> self, rhs: <span style=color:#2b91af>Rhs</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Example impls for <code>Point</code> and <code>&Point</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::ops::AddAssign;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(Copy, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AddAssign <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add_assign(&amp;<span style=color:#00f>mut</span> self, rhs: <span style=color:#2b91af>Point</span>) {
</span></span><span style=display:flex><span>        self.x += rhs.x;
</span></span><span style=display:flex><span>        self.y += rhs.y;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AddAssign&lt;&amp;Point&gt; <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add_assign(&amp;<span style=color:#00f>mut</span> self, rhs: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Point</span>) {
</span></span><span style=display:flex><span>        Point::add_assign(self, *rhs);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> p1 = Point { x: 1, y: 2 };
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p2 = Point { x: 3, y: 4 };
</span></span><span style=display:flex><span>    p1 += &amp;p2;
</span></span><span style=display:flex><span>    p1 += p2;
</span></span><span style=display:flex><span>    assert!(p1.x == 7 &amp;&amp; p1.y == 10);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=closure-traits>Closure Traits</h3><table><thead><tr><th>Trait(s)</th><th>Category</th><th>Operator(s)</th><th>Description</th></tr></thead><tbody><tr><td><code>Fn</code></td><td>closure</td><td><code>(...args)</code></td><td>immutable closure invocation</td></tr><tr><td><code>FnMut</code></td><td>closure</td><td><code>(...args)</code></td><td>mutable closure invocation</td></tr><tr><td><code>FnOnce</code></td><td>closure</td><td><code>(...args)</code></td><td>one-time closure invocation</td></tr></tbody></table><h4 id=fnonce-fnmut--fn>FnOnce, FnMut, & Fn</h4><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#associated-types>Associated Types</a></li><li><a href=#generic-parameters>Generic Parameters</a></li><li><a href=#generic-types-vs-associated-types>Generic Types vs Associated Types</a></li><li><a href=#subtraits--supertraits>Subtraits & Supertraits</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> FnOnce&lt;Args&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> call_once(self, args: <span style=color:#2b91af>Args</span>) -&gt; <span style=color:#2b91af>Self</span>::Output;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> call_mut(&amp;<span style=color:#00f>mut</span> self, args: <span style=color:#2b91af>Args</span>) -&gt; <span style=color:#2b91af>Self</span>::Output;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> call(&amp;self, args: <span style=color:#2b91af>Args</span>) -&gt; <span style=color:#2b91af>Self</span>::Output;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Although these traits exist it&rsquo;s not possible to impl them for our own types in stable Rust. The only types we can create which impl these traits are closures. Depending on what the closure captures from its environment determines whether it impls <code>FnOnce</code>, <code>FnMut</code>, or <code>Fn</code>.</p><p>An <code>FnOnce</code> closure can only be called once because it consumes some value as part of its execution:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> range = 0..10;
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> get_range_count = || range.count();
</span></span><span style=display:flex><span>    assert_eq!(get_range_count(), 10); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    get_range_count(); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>The <code>.count()</code> method on iterators consumes the iterator so it can only be called once. Hence our closure can only be called once. Which is why when we try to call it a second time we get this error:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>error[E0382]: <span style=color:#00f>use</span> of moved value: `get_range_count`
</span></span><span style=display:flex><span> --&gt; src/main.rs:5:5
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span>4 |     assert_eq!(get_range_count(), 10);
</span></span><span style=display:flex><span>  |                ---------------<span style=color:green>-- `get_range_count` moved due to this call
</span></span></span><span style=display:flex><span><span style=color:green></span>5 |     get_range_count();
</span></span><span style=display:flex><span>  |     ^^^^^^^^^^^^^^^ value used here after move
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span>note: closure cannot be invoked more than once because it moves the variable `range` <span style=color:#00f>out</span> of its environment
</span></span><span style=display:flex><span> --&gt; src/main.rs:3:30
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span>3 |     let get_range_count = || range.count();
</span></span><span style=display:flex><span>  |                              ^^^^^
</span></span><span style=display:flex><span>note: this value implements `FnOnce`, which causes it <span style=color:#00f>to</span> be moved <span style=color:#00f>when</span> called
</span></span><span style=display:flex><span> --&gt; src/main.rs:4:16
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span>4 |     assert_eq!(get_range_count(), 10);
</span></span><span style=display:flex><span>  |                ^^^^^^^^^^^^^^^
</span></span></code></pre></div><p>An <code>FnMut</code> closure can be called multiple times and can also mutate variables it has captured from its environment. We might say <code>FnMut</code> closures perform side-effects or are stateful. Here&rsquo;s an example of a closure that filters out all non-ascending values from an iterator by keeping track of the smallest value it has seen so far:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> nums = vec![0, 4, 2, 8, 10, 7, 15, 18, 13];
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> min = <span style=color:#2b91af>i32</span>::MIN;
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> ascending = nums.into_iter().filter(|&amp;n| {
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> n &lt;= min {
</span></span><span style=display:flex><span>            <span style=color:#00f>false</span>
</span></span><span style=display:flex><span>        } <span style=color:#00f>else</span> {
</span></span><span style=display:flex><span>            min = n;
</span></span><span style=display:flex><span>            <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }).collect::&lt;Vec&lt;_&gt;&gt;();
</span></span><span style=display:flex><span>    assert_eq!(vec![0, 4, 8, 10, 15, 18], ascending); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p><code>FnMut</code> refines <code>FnOnce</code> in the sense that <code>FnOnce</code> requires taking ownership of its arguments and can only be called once, but <code>FnMut</code> requires only taking mutable references and can be called multiple times. <code>FnMut</code> can be used anywhere <code>FnOnce</code> can be used.</p><p>An <code>Fn</code> closure can be called multiple times and does not mutate any variables it has captured from its environment. We might say <code>Fn</code> closures have no side-effects or are stateless. Here&rsquo;s an example closure that filters out all values less than some stack variable it captures from its environment from an iterator:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> nums = vec![0, 4, 2, 8, 10, 7, 15, 18, 13];
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> min = 9;
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> greater_than_9 = nums.into_iter().filter(|&amp;n| n &gt; min).collect::&lt;Vec&lt;_&gt;&gt;();
</span></span><span style=display:flex><span>    assert_eq!(vec![10, 15, 18, 13], greater_than_9); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p><code>Fn</code> refines <code>FnMut</code> in the sense that <code>FnMut</code> requires mutable references and can be called multiple times, but <code>Fn</code> only requires immutable references and can be called multiple times. <code>Fn</code> can be used anywhere <code>FnMut</code> can be used, which includes anywhere <code>FnOnce</code> can be used.</p><p>If a closure doesn&rsquo;t capture anything from its environment it&rsquo;s technically not a closure, but just an anonymously declared inline function, and can be casted to, used, and passed around as a regular function pointer, i.e. <code>fn</code>. Function pointers can be used anywhere <code>Fn</code> can be used, which includes anwhere <code>FnMut</code> and <code>FnOnce</code> can be used.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> add_one(x: <span style=color:#2b91af>i32</span>) -&gt; <span style=color:#2b91af>i32</span> {
</span></span><span style=display:flex><span>    x + 1
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> fn_ptr: <span style=color:#2b91af>fn</span>(<span style=color:#2b91af>i32</span>) -&gt; <span style=color:#2b91af>i32</span> = add_one;
</span></span><span style=display:flex><span>    assert_eq!(fn_ptr(1), 2); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    
</span></span><span style=display:flex><span>    <span style=color:green>// capture-less closure cast to fn pointer
</span></span></span><span style=display:flex><span><span style=color:green></span>    fn_ptr = |x| x + 1; <span style=color:green>// same as add_one
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(fn_ptr(1), 2); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Example of passing a regular function pointer in place of a closure:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> nums = vec![-1, 1, -2, 2, -3, 3];
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> absolutes: Vec&lt;<span style=color:#2b91af>i32</span>&gt; = nums.into_iter().map(<span style=color:#2b91af>i32</span>::abs).collect();
</span></span><span style=display:flex><span>    assert_eq!(vec![1, 1, 2, 2, 3, 3], absolutes); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><h3 id=other-traits>Other Traits</h3><table><thead><tr><th>Trait(s)</th><th>Category</th><th>Operator(s)</th><th>Description</th></tr></thead><tbody><tr><td><code>Deref</code></td><td>other</td><td><code>*</code></td><td>immutable dereference</td></tr><tr><td><code>DerefMut</code></td><td>other</td><td><code>*</code></td><td>mutable derenence</td></tr><tr><td><code>Drop</code></td><td>other</td><td>-</td><td>type destructor</td></tr><tr><td><code>Index</code></td><td>other</td><td><code>[]</code></td><td>immutable index</td></tr><tr><td><code>IndexMut</code></td><td>other</td><td><code>[]</code></td><td>mutable index</td></tr><tr><td><code>RangeBounds</code></td><td>other</td><td><code>..</code></td><td>range</td></tr></tbody></table><h4 id=deref--derefmut>Deref & DerefMut</h4><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#associated-types>Associated Types</a></li><li><a href=#subtraits--supertraits>Subtraits & Supertraits</a></li><li><a href=#sized>Sized</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Deref {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Target</span>: ?Sized;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> deref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Self</span>::Target;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> DerefMut: <span style=color:#2b91af>Deref</span> {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> deref_mut(&amp;<span style=color:#00f>mut</span> self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> Self::Target;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Deref&lt;Target = T></code> types can dereferenced to <code>T</code> types using the dereference operator <code>*</code>. This has obvious use-cases for smart pointer types like <code>Box</code> and <code>Rc</code>. However, we rarely see the dereference operator explicitly used in Rust code, and that&rsquo;s because of a Rust feature called <em>deref coercion</em>.</p><p>Rust automatically dereferences types when they&rsquo;re being passed as function arguments, returned from a function, or used as part of a method call. This is the reason why we can pass <code>&String</code> and <code>&Vec&lt;T></code> to functions expecting <code>&str</code> and <code>&[T]</code> because <code>String</code> impls <code>Deref&lt;Target = str></code> and <code>Vec&lt;T></code> impls <code>Deref&lt;Target = [T]></code>.</p><p><code>Deref</code> and <code>DerefMut</code> should only be implemented for smart pointer types. The most common way people attempt to misuse and abuse these traits is to try to shoehorn some kind of OOP-style data inheritance into Rust. This does not work. Rust is not OOP. Let&rsquo;s examine a few different situations where, how, and why it does not work. Let&rsquo;s start with this example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::ops::Deref;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Human</span> {
</span></span><span style=display:flex><span>    health_points: <span style=color:#2b91af>u32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Weapon</span> {
</span></span><span style=display:flex><span>    Spear,
</span></span><span style=display:flex><span>    Axe,
</span></span><span style=display:flex><span>    Sword,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// a Soldier is just a Human with a Weapon
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>struct</span> <span style=color:#2b91af>Soldier</span> {
</span></span><span style=display:flex><span>    human: <span style=color:#2b91af>Human</span>,
</span></span><span style=display:flex><span>    weapon: <span style=color:#2b91af>Weapon</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Deref <span style=color:#00f>for</span> Soldier {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Target</span> = Human;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> deref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Human</span> {
</span></span><span style=display:flex><span>        &amp;self.human
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Mount</span> {
</span></span><span style=display:flex><span>    Horse,
</span></span><span style=display:flex><span>    Donkey,
</span></span><span style=display:flex><span>    Cow,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// a Knight is just a Soldier with a Mount
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>struct</span> <span style=color:#2b91af>Knight</span> {
</span></span><span style=display:flex><span>    soldier: <span style=color:#2b91af>Soldier</span>,
</span></span><span style=display:flex><span>    mount: <span style=color:#2b91af>Mount</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Deref <span style=color:#00f>for</span> Knight {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Target</span> = Soldier;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> deref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Soldier</span> {
</span></span><span style=display:flex><span>        &amp;self.soldier
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Spell</span> {
</span></span><span style=display:flex><span>    MagicMissile,
</span></span><span style=display:flex><span>    FireBolt,
</span></span><span style=display:flex><span>    ThornWhip,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// a Mage is just a Human who can cast Spells
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>struct</span> <span style=color:#2b91af>Mage</span> {
</span></span><span style=display:flex><span>    human: <span style=color:#2b91af>Human</span>,
</span></span><span style=display:flex><span>    spells: Vec&lt;Spell&gt;,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Deref <span style=color:#00f>for</span> Mage {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Target</span> = Human;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> deref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Human</span> {
</span></span><span style=display:flex><span>        &amp;self.human
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Staff</span> {
</span></span><span style=display:flex><span>    Wooden,
</span></span><span style=display:flex><span>    Metallic,
</span></span><span style=display:flex><span>    Plastic,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// a Wizard is just a Mage with a Staff
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>struct</span> <span style=color:#2b91af>Wizard</span> {
</span></span><span style=display:flex><span>    mage: <span style=color:#2b91af>Mage</span>,
</span></span><span style=display:flex><span>    staff: <span style=color:#2b91af>Staff</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Deref <span style=color:#00f>for</span> Wizard {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Target</span> = Mage;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> deref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Mage</span> {
</span></span><span style=display:flex><span>        &amp;self.mage
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> borrows_human(human: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Human</span>) {}
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> borrows_soldier(soldier: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Soldier</span>) {}
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> borrows_knight(knight: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Knight</span>) {}
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> borrows_mage(mage: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Mage</span>) {}
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> borrows_wizard(wizard: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Wizard</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example(human: <span style=color:#2b91af>Human</span>, soldier: <span style=color:#2b91af>Soldier</span>, knight: <span style=color:#2b91af>Knight</span>, mage: <span style=color:#2b91af>Mage</span>, wizard: <span style=color:#2b91af>Wizard</span>) {
</span></span><span style=display:flex><span>    <span style=color:green>// all types can be used as Humans
</span></span></span><span style=display:flex><span><span style=color:green></span>    borrows_human(&amp;human);
</span></span><span style=display:flex><span>    borrows_human(&amp;soldier);
</span></span><span style=display:flex><span>    borrows_human(&amp;knight);
</span></span><span style=display:flex><span>    borrows_human(&amp;mage);
</span></span><span style=display:flex><span>    borrows_human(&amp;wizard);
</span></span><span style=display:flex><span>    <span style=color:green>// Knights can be used as Soldiers
</span></span></span><span style=display:flex><span><span style=color:green></span>    borrows_soldier(&amp;soldier);
</span></span><span style=display:flex><span>    borrows_soldier(&amp;knight);
</span></span><span style=display:flex><span>    <span style=color:green>// Wizards can be used as Mages
</span></span></span><span style=display:flex><span><span style=color:green></span>    borrows_mage(&amp;mage);
</span></span><span style=display:flex><span>    borrows_mage(&amp;wizard);
</span></span><span style=display:flex><span>    <span style=color:green>// Knights &amp; Wizards passed as themselves
</span></span></span><span style=display:flex><span><span style=color:green></span>    borrows_knight(&amp;knight);
</span></span><span style=display:flex><span>    borrows_wizard(&amp;wizard);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So at first glance the above looks pretty good! However it quickly breaks down to scrutiny. First of all, deref coercion only works on references, so it doesn&rsquo;t work when we actually want to pass ownership:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> takes_human(human: <span style=color:#2b91af>Human</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example(human: <span style=color:#2b91af>Human</span>, soldier: <span style=color:#2b91af>Soldier</span>, knight: <span style=color:#2b91af>Knight</span>, mage: <span style=color:#2b91af>Mage</span>, wizard: <span style=color:#2b91af>Wizard</span>) {
</span></span><span style=display:flex><span>    <span style=color:green>// all types CANNOT be used as Humans
</span></span></span><span style=display:flex><span><span style=color:green></span>    takes_human(human);
</span></span><span style=display:flex><span>    takes_human(soldier); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>    takes_human(knight); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>    takes_human(mage); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>    takes_human(wizard); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Furthermore, deref coercion doesn&rsquo;t work in generic contexts. Let&rsquo;s say we impl some trait only on humans:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Rest {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> rest(&amp;self);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Rest <span style=color:#00f>for</span> Human {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> rest(&amp;self) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> take_rest&lt;T: <span style=color:#2b91af>Rest</span>&gt;(rester: <span style=color:#00f>&amp;</span><span style=color:#2b91af>T</span>) {
</span></span><span style=display:flex><span>    rester.rest()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example(human: <span style=color:#2b91af>Human</span>, soldier: <span style=color:#2b91af>Soldier</span>, knight: <span style=color:#2b91af>Knight</span>, mage: <span style=color:#2b91af>Mage</span>, wizard: <span style=color:#2b91af>Wizard</span>) {
</span></span><span style=display:flex><span>    <span style=color:green>// all types CANNOT be used as Rest types, only Human
</span></span></span><span style=display:flex><span><span style=color:green></span>    take_rest(&amp;human);
</span></span><span style=display:flex><span>    take_rest(&amp;soldier); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>    take_rest(&amp;knight); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>    take_rest(&amp;mage); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>    take_rest(&amp;wizard); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Also, although deref coercion works in a lot of places it doesn&rsquo;t work everywhere. It doesn&rsquo;t work on operands, even though operators are just syntax sugar for method calls. Let&rsquo;s say, to be cute, we wanted <code>Mage</code>s to learn <code>Spell</code>s using the <code>+=</code> operator:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span> DerefMut <span style=color:#00f>for</span> Wizard {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> deref_mut(&amp;<span style=color:#00f>mut</span> self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> Mage {
</span></span><span style=display:flex><span>        &amp;<span style=color:#00f>mut</span> self.mage
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AddAssign&lt;Spell&gt; <span style=color:#00f>for</span> Mage {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> add_assign(&amp;<span style=color:#00f>mut</span> self, spell: <span style=color:#2b91af>Spell</span>) {
</span></span><span style=display:flex><span>        self.spells.push(spell);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example(<span style=color:#00f>mut</span> mage: <span style=color:#2b91af>Mage</span>, <span style=color:#00f>mut</span> wizard: <span style=color:#2b91af>Wizard</span>, spell: <span style=color:#2b91af>Spell</span>) {
</span></span><span style=display:flex><span>    mage += spell;
</span></span><span style=display:flex><span>    wizard += spell; <span style=color:green>// ❌ wizard not coerced to mage here
</span></span></span><span style=display:flex><span><span style=color:green></span>    wizard.add_assign(spell); <span style=color:green>// oof, we have to call it like this 🤦
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>In languages with OOP-style data inheritance the value of <code>self</code> within a method is always equal to the type which called the method but in the case of Rust the value of <code>self</code> is always equal to the type which implemented the method:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Human</span> {
</span></span><span style=display:flex><span>    profession: <span style=color:#00f>&amp;</span>&#39;static <span style=color:#2b91af>str</span>,
</span></span><span style=display:flex><span>    health_points: <span style=color:#2b91af>u32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Human {
</span></span><span style=display:flex><span>    <span style=color:green>// self will always be a Human here, even if we call it on a Soldier
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> state_profession(&amp;self) {
</span></span><span style=display:flex><span>        println!(<span style=color:#a31515>&#34;I&#39;m a {}!&#34;</span>, self.profession);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Soldier</span> {
</span></span><span style=display:flex><span>    profession: <span style=color:#00f>&amp;</span>&#39;static <span style=color:#2b91af>str</span>,
</span></span><span style=display:flex><span>    human: <span style=color:#2b91af>Human</span>,
</span></span><span style=display:flex><span>    weapon: <span style=color:#2b91af>Weapon</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example(soldier: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Soldier</span>) {
</span></span><span style=display:flex><span>    assert_eq!(<span style=color:#a31515>&#34;servant&#34;</span>, soldier.human.profession);
</span></span><span style=display:flex><span>    assert_eq!(<span style=color:#a31515>&#34;spearman&#34;</span>, soldier.profession);
</span></span><span style=display:flex><span>    soldier.human.state_profession(); <span style=color:green>// prints &#34;I&#39;m a servant!&#34;
</span></span></span><span style=display:flex><span><span style=color:green></span>    soldier.state_profession(); <span style=color:green>// still prints &#34;I&#39;m a servant!&#34; 🤦
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>The above gotcha is especially damning when impling <code>Deref</code> or <code>DerefMut</code> on a newtype. Let&rsquo;s say we want to create a <code>SortedVec</code> type which is just a <code>Vec</code> but it&rsquo;s always in sorted order. Here&rsquo;s how we might do that:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>SortedVec</span>&lt;T: Ord&gt;(Vec&lt;T&gt;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span>&lt;T: Ord&gt; SortedVec&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> new(<span style=color:#00f>mut</span> vec: Vec&lt;T&gt;) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        vec.sort();
</span></span><span style=display:flex><span>        SortedVec(vec)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> push(&amp;<span style=color:#00f>mut</span> self, t: <span style=color:#2b91af>T</span>) {
</span></span><span style=display:flex><span>        self.0.push(t);
</span></span><span style=display:flex><span>        self.0.sort();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Obviously we cannot impl <code>DerefMut&lt;Target = Vec&lt;T>></code> here or anyone using <code>SortedVec</code> would be able to trivially break the sorted order. However, impling <code>Deref&lt;Target = Vec&lt;T>></code> surely must be safe, right? Try to spot the bug in the program below:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::ops::Deref;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>SortedVec</span>&lt;T: Ord&gt;(Vec&lt;T&gt;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span>&lt;T: Ord&gt; SortedVec&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> new(<span style=color:#00f>mut</span> vec: Vec&lt;T&gt;) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        vec.sort();
</span></span><span style=display:flex><span>        SortedVec(vec)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> push(&amp;<span style=color:#00f>mut</span> self, t: <span style=color:#2b91af>T</span>) {
</span></span><span style=display:flex><span>        self.0.push(t);
</span></span><span style=display:flex><span>        self.0.sort();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span>&lt;T: Ord&gt; Deref <span style=color:#00f>for</span> SortedVec&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Target</span> = Vec&lt;T&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> deref(&amp;self) -&gt; <span style=color:#00f>&amp;</span>Vec&lt;T&gt; {
</span></span><span style=display:flex><span>        &amp;self.0
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> sorted = SortedVec::new(vec![2, 8, 6, 3]);
</span></span><span style=display:flex><span>    sorted.push(1);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> sortedClone = sorted.clone();
</span></span><span style=display:flex><span>    sortedClone.push(4);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We never implemented <code>Clone</code> for <code>SortedVec</code> so when we call the <code>.clone()</code> method the compiler is using deref coercion to resolve that method call on <code>Vec</code> and so it returns a <code>Vec</code> and not a <code>SortedVec</code>!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> sorted: <span style=color:#2b91af>SortedVec</span>&lt;<span style=color:#2b91af>i32</span>&gt; = SortedVec::new(vec![2, 8, 6, 3]);
</span></span><span style=display:flex><span>    sorted.push(1); <span style=color:green>// still sorted
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span>    <span style=color:green>// calling clone on SortedVec actually returns a Vec 🤦
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> sortedClone: Vec&lt;<span style=color:#2b91af>i32</span>&gt; = sorted.clone();
</span></span><span style=display:flex><span>    sortedClone.push(4); <span style=color:green>// sortedClone no longer sorted 💀
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Anyway, none of the above limitations, constraints, or gotchas are faults of Rust because Rust was never designed to be an OO language or to support any OOP patterns in the first place.</p><p>The main takeaway from this section is do not try to be cute or clever with <code>Deref</code> and <code>DerefMut</code> impls. They&rsquo;re really only appropriate for smart pointer types, which can only be implemented within the standard library for now as smart pointer types currently require unstable features and compiler magic to work. If we want functionality and behavior similar to <code>Deref</code> and <code>DerefMut</code> then what we&rsquo;re actually probably looking for is <code>AsRef</code> and <code>AsMut</code> which we&rsquo;ll get to later.</p><h4 id=index--indexmut>Index & IndexMut</h4><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#associated-types>Associated Types</a></li><li><a href=#generic-parameters>Generic Parameters</a></li><li><a href=#generic-types-vs-associated-types>Generic Types vs Associated Types</a></li><li><a href=#subtraits--supertraits>Subtraits & Supertraits</a></li><li><a href=#sized>Sized</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Index&lt;Idx: ?Sized&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span>: ?Sized;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> index(&amp;self, index: <span style=color:#2b91af>Idx</span>) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Self</span>::Output;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> IndexMut&lt;Idx&gt;: <span style=color:#2b91af>Index</span>&lt;Idx&gt; <span style=color:#00f>where</span> Idx: ?Sized {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> index_mut(&amp;<span style=color:#00f>mut</span> self, index: <span style=color:#2b91af>Idx</span>) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> Self::Output;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can index <code>[]</code> into <code>Index&lt;T, Output = U></code> types with <code>T</code> values and the index operation will return <code>&U</code> values. For syntax sugar, the compiler auto inserts a deref operator <code>*</code> in front of any value returned from an index operation:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:green>// Vec&lt;i32&gt; impls Index&lt;usize, Output = i32&gt; so
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// indexing Vec&lt;i32&gt; should produce &amp;i32s and yet...
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> vec = vec![1, 2, 3, 4, 5];
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> num_ref: <span style=color:#00f>&amp;</span><span style=color:#2b91af>i32</span> = vec[0]; <span style=color:green>// ❌ expected &amp;i32 found i32
</span></span></span><span style=display:flex><span><span style=color:green></span>    
</span></span><span style=display:flex><span>    <span style=color:green>// above line actually desugars to
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> num_ref: <span style=color:#00f>&amp;</span><span style=color:#2b91af>i32</span> = *vec[0]; <span style=color:green>// ❌ expected &amp;i32 found i32
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span>    <span style=color:green>// both of these alternatives work
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> num: <span style=color:#2b91af>i32</span> = vec[0]; <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> num_ref = &amp;vec[0]; <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>It&rsquo;s kinda confusing at first, because it seems like the <code>Index</code> trait does not follow its own method signature, but really it&rsquo;s just questionable syntax sugar.</p><p>Since <code>Idx</code> is a generic type the <code>Index</code> trait can be implemented many times for a given type, and in the case of <code>Vec&lt;T></code> not only can we index into it using <code>usize</code> but we can also index into its using <code>Range&lt;usize></code>s to get slices.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> vec = vec![1, 2, 3, 4, 5];
</span></span><span style=display:flex><span>    assert_eq!(&amp;vec[..], &amp;[1, 2, 3, 4, 5]); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(&amp;vec[1..], &amp;[2, 3, 4, 5]); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(&amp;vec[..4], &amp;[1, 2, 3, 4]); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(&amp;vec[1..4], &amp;[2, 3, 4]); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>To show off how we might impl <code>Index</code> ourselves here&rsquo;s a fun example which shows how we can use a newtype and the <code>Index</code> trait to impl wrapping indexes and negative indexes on a <code>Vec</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::ops::Index;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>WrappingIndex</span>&lt;T&gt;(Vec&lt;T&gt;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span>&lt;T&gt; Index&lt;<span style=color:#2b91af>usize</span>&gt; <span style=color:#00f>for</span> WrappingIndex&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span> = T;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> index(&amp;self, index: <span style=color:#2b91af>usize</span>) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>T</span> {
</span></span><span style=display:flex><span>        &amp;self.0[index % self.0.len()]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span>&lt;T&gt; Index&lt;<span style=color:#2b91af>i128</span>&gt; <span style=color:#00f>for</span> WrappingIndex&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span> = T;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> index(&amp;self, index: <span style=color:#2b91af>i128</span>) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>T</span> {
</span></span><span style=display:flex><span>        <span style=color:#00f>let</span> self_len = self.0.len() <span style=color:#00f>as</span> <span style=color:#2b91af>i128</span>;
</span></span><span style=display:flex><span>        <span style=color:#00f>let</span> idx = (((index % self_len) + self_len) % self_len) <span style=color:#00f>as</span> <span style=color:#2b91af>usize</span>;
</span></span><span style=display:flex><span>        &amp;self.0[idx]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[test]</span> <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> indexes() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> wrapping_vec = WrappingIndex(vec![1, 2, 3]);
</span></span><span style=display:flex><span>    assert_eq!(1, wrapping_vec[0_<span style=color:#00f>usize</span>]);
</span></span><span style=display:flex><span>    assert_eq!(2, wrapping_vec[1_<span style=color:#00f>usize</span>]);
</span></span><span style=display:flex><span>    assert_eq!(3, wrapping_vec[2_<span style=color:#00f>usize</span>]);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[test]</span> <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> wrapping_indexes() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> wrapping_vec = WrappingIndex(vec![1, 2, 3]);
</span></span><span style=display:flex><span>    assert_eq!(1, wrapping_vec[3_<span style=color:#00f>usize</span>]);
</span></span><span style=display:flex><span>    assert_eq!(2, wrapping_vec[4_<span style=color:#00f>usize</span>]);
</span></span><span style=display:flex><span>    assert_eq!(3, wrapping_vec[5_<span style=color:#00f>usize</span>]);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[test]</span> <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> neg_indexes() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> wrapping_vec = WrappingIndex(vec![1, 2, 3]);
</span></span><span style=display:flex><span>    assert_eq!(1, wrapping_vec[-3_<span style=color:#2b91af>i128</span>]);
</span></span><span style=display:flex><span>    assert_eq!(2, wrapping_vec[-2_<span style=color:#2b91af>i128</span>]);
</span></span><span style=display:flex><span>    assert_eq!(3, wrapping_vec[-1_<span style=color:#2b91af>i128</span>]);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[test]</span> <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> wrapping_neg_indexes() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> wrapping_vec = WrappingIndex(vec![1, 2, 3]);
</span></span><span style=display:flex><span>    assert_eq!(1, wrapping_vec[-6_<span style=color:#2b91af>i128</span>]);
</span></span><span style=display:flex><span>    assert_eq!(2, wrapping_vec[-5_<span style=color:#2b91af>i128</span>]);
</span></span><span style=display:flex><span>    assert_eq!(3, wrapping_vec[-4_<span style=color:#2b91af>i128</span>]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There&rsquo;s no requirement that the <code>Idx</code> type has to be a number type or a <code>Range</code>, it could be an enum! Here&rsquo;s an example using basketball positions to index into a basketball team to retrieve players on the team:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::ops::Index;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>BasketballPosition</span> {
</span></span><span style=display:flex><span>    PointGuard,
</span></span><span style=display:flex><span>    ShootingGuard,
</span></span><span style=display:flex><span>    Center,
</span></span><span style=display:flex><span>    PowerForward,
</span></span><span style=display:flex><span>    SmallForward,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>BasketballPlayer</span> {
</span></span><span style=display:flex><span>    name: <span style=color:#00f>&amp;</span>&#39;static <span style=color:#2b91af>str</span>,
</span></span><span style=display:flex><span>    position: <span style=color:#2b91af>BasketballPosition</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>BasketballTeam</span> {
</span></span><span style=display:flex><span>    point_guard: <span style=color:#2b91af>BasketballPlayer</span>,
</span></span><span style=display:flex><span>    shooting_guard: <span style=color:#2b91af>BasketballPlayer</span>,
</span></span><span style=display:flex><span>    center: <span style=color:#2b91af>BasketballPlayer</span>,
</span></span><span style=display:flex><span>    power_forward: <span style=color:#2b91af>BasketballPlayer</span>,
</span></span><span style=display:flex><span>    small_forward: <span style=color:#2b91af>BasketballPlayer</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Index&lt;BasketballPosition&gt; <span style=color:#00f>for</span> BasketballTeam {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Output</span> = BasketballPlayer;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> index(&amp;self, position: <span style=color:#2b91af>BasketballPosition</span>) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>BasketballPlayer</span> {
</span></span><span style=display:flex><span>        <span style=color:#00f>match</span> position {
</span></span><span style=display:flex><span>            BasketballPosition::PointGuard =&gt; &amp;self.point_guard,
</span></span><span style=display:flex><span>            BasketballPosition::ShootingGuard =&gt; &amp;self.shooting_guard,
</span></span><span style=display:flex><span>            BasketballPosition::Center =&gt; &amp;self.center,
</span></span><span style=display:flex><span>            BasketballPosition::PowerForward =&gt; &amp;self.power_forward,
</span></span><span style=display:flex><span>            BasketballPosition::SmallForward =&gt; &amp;self.small_forward,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=drop>Drop</h4><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Drop {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> drop(&amp;<span style=color:#00f>mut</span> self);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If a type impls <code>Drop</code> then <code>drop</code> will be called on the type when it goes out of scope but before it&rsquo;s destroyed. We will rarely need to impl this for our types but a good example of where it&rsquo;s useful is if a type holds on to some external resources which needs to be cleaned up when the type is destroyed.</p><p>There&rsquo;s a <code>BufWriter</code> type in the standard library that allows us to buffer writes to <code>Write</code> types. However, what if the <code>BufWriter</code> gets destroyed before the content in its buffer has been flushed to the underlying <code>Write</code> type? Thankfully that&rsquo;s not possible! The <code>BufWriter</code> impls the <code>Drop</code> trait so that <code>flush</code> is always called on it whenever it goes out of scope!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span>&lt;W: <span style=color:#2b91af>Write</span>&gt; Drop <span style=color:#00f>for</span> BufWriter&lt;W&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> drop(&amp;<span style=color:#00f>mut</span> self) {
</span></span><span style=display:flex><span>        self.flush_buf();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Also, <code>Mutex</code>s in Rust don&rsquo;t have <code>unlock()</code> methods because they don&rsquo;t need them! Calling <code>lock()</code> on a <code>Mutex</code> returns a <code>MutexGuard</code> which automatically unlocks the <code>Mutex</code> when it goes out of scope thanks to its <code>Drop</code> impl:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span>&lt;T: ?Sized&gt; Drop <span style=color:#00f>for</span> MutexGuard&lt;&#39;_, T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> drop(&amp;<span style=color:#00f>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=color:#00f>unsafe</span> {
</span></span><span style=display:flex><span>            self.lock.inner.raw_unlock();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In general, if you&rsquo;re impling an abstraction over some resource that needs to be cleaned up after use then that&rsquo;s a great reason to make use of the <code>Drop</code> trait.</p><h2 id=conversion-traits>Conversion Traits</h2><h3 id=from--into>From & Into</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#functions>Functions</a></li><li><a href=#methods>Methods</a></li><li><a href=#generic-parameters>Generic Parameters</a></li><li><a href=#generic-blanket-impls>Generic Blanket Impls</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> From&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from(T) -&gt; <span style=color:#2b91af>Self</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>From&lt;T></code> types allow us to convert <code>T</code> into <code>Self</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Into&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> into(self) -&gt; <span style=color:#2b91af>T</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Into&lt;T></code> types allow us to convert <code>Self</code> into <code>T</code>.</p><p>These traits are two different sides of the same coin. We can only impl <code>From&lt;T></code> for our types because the <code>Into&lt;T></code> impl is automatically provided by this generic blanket impl:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span>&lt;T, U&gt; Into&lt;U&gt; <span style=color:#00f>for</span> T
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    U: From&lt;T&gt;,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> into(self) -&gt; <span style=color:#2b91af>U</span> {
</span></span><span style=display:flex><span>        U::from(self)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The reason both traits exist is because it allows us to write trait bounds on generic types slightly differently:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> function&lt;T&gt;(t: <span style=color:#2b91af>T</span>)
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    <span style=color:green>// these bounds are equivalent
</span></span></span><span style=display:flex><span><span style=color:green></span>    T: From&lt;<span style=color:#2b91af>i32</span>&gt;,
</span></span><span style=display:flex><span>    <span style=color:#2b91af>i32</span>: Into&lt;T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green>// these examples are equivalent
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> example: <span style=color:#2b91af>T</span> = T::from(0);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> example: <span style=color:#2b91af>T</span> = 0.into();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There are no hard rules about when to use one or the other, so go with whatever makes the most sense for each situation. Now let&rsquo;s look at some example impls on <code>Point</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> From&lt;(<span style=color:#2b91af>i32</span>, <span style=color:#2b91af>i32</span>)&gt; <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from((x, y): (<span style=color:#2b91af>i32</span>, <span style=color:#2b91af>i32</span>)) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        Point { x, y }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> From&lt;[<span style=color:#2b91af>i32</span>; 2]&gt; <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from([x, y]: [<span style=color:#2b91af>i32</span>; 2]) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        Point { x, y }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example() {
</span></span><span style=display:flex><span>    <span style=color:green>// using From
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> origin = Point::from((0, 0));
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> origin = Point::from([0, 0]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// using Into
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> origin: <span style=color:#2b91af>Point</span> = (0, 0).into();
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> origin: <span style=color:#2b91af>Point</span> = [0, 0].into();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The impl is not symmetric, so if we&rsquo;d like to convert <code>Point</code>s into tuples and arrays we have to explicitly add those as well:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> From&lt;(<span style=color:#2b91af>i32</span>, <span style=color:#2b91af>i32</span>)&gt; <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from((x, y): (<span style=color:#2b91af>i32</span>, <span style=color:#2b91af>i32</span>)) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        Point { x, y }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> From&lt;Point&gt; <span style=color:#00f>for</span> (<span style=color:#2b91af>i32</span>, <span style=color:#2b91af>i32</span>) {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from(Point { x, y }: <span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        (x, y)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> From&lt;[<span style=color:#2b91af>i32</span>; 2]&gt; <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from([x, y]: [<span style=color:#2b91af>i32</span>; 2]) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        Point { x, y }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> From&lt;Point&gt; <span style=color:#00f>for</span> [<span style=color:#2b91af>i32</span>; 2] {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from(Point { x, y }: <span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        [x, y]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example() {
</span></span><span style=display:flex><span>    <span style=color:green>// from (i32, i32) into Point
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> point = Point::from((0, 0));
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> point: <span style=color:#2b91af>Point</span> = (0, 0).into();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// from Point into (i32, i32)
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> tuple = &lt;(<span style=color:#2b91af>i32</span>, <span style=color:#2b91af>i32</span>)&gt;::from(point);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> tuple: (<span style=color:#2b91af>i32</span>, <span style=color:#2b91af>i32</span>) = point.into();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// from [i32; 2] into Point
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> point = Point::from([0, 0]);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> point: <span style=color:#2b91af>Point</span> = [0, 0].into();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// from Point into [i32; 2]
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> array = &lt;[<span style=color:#2b91af>i32</span>; 2]&gt;::from(point);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> array: [<span style=color:#2b91af>i32</span>; 2] = point.into();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A popular use of <code>From&lt;T></code> is to trim down boilerplate code. Let&rsquo;s say we add a <code>Triangle</code> type to our program which contains three <code>Point</code>s, here&rsquo;s some of the many ways we can construct it:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> new(x: <span style=color:#2b91af>i32</span>, y: <span style=color:#2b91af>i32</span>) -&gt; <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>        Point { x, y }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> From&lt;(<span style=color:#2b91af>i32</span>, <span style=color:#2b91af>i32</span>)&gt; <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from((x, y): (<span style=color:#2b91af>i32</span>, <span style=color:#2b91af>i32</span>)) -&gt; <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>        Point { x, y }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Triangle</span> {
</span></span><span style=display:flex><span>    p1: <span style=color:#2b91af>Point</span>,
</span></span><span style=display:flex><span>    p2: <span style=color:#2b91af>Point</span>,
</span></span><span style=display:flex><span>    p3: <span style=color:#2b91af>Point</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Triangle {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> new(p1: <span style=color:#2b91af>Point</span>, p2: <span style=color:#2b91af>Point</span>, p3: <span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>Triangle</span> {
</span></span><span style=display:flex><span>        Triangle { p1, p2, p3 }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span>&lt;P&gt; From&lt;[P; 3]&gt; <span style=color:#00f>for</span> Triangle
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    P: Into&lt;Point&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from([p1, p2, p3]: [P; 3]) -&gt; <span style=color:#2b91af>Triangle</span> {
</span></span><span style=display:flex><span>        Triangle {
</span></span><span style=display:flex><span>            p1: <span style=color:#2b91af>p1</span>.into(),
</span></span><span style=display:flex><span>            p2: <span style=color:#2b91af>p2</span>.into(),
</span></span><span style=display:flex><span>            p3: <span style=color:#2b91af>p3</span>.into(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example() {
</span></span><span style=display:flex><span>    <span style=color:green>// manual construction
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> triangle = Triangle {
</span></span><span style=display:flex><span>        p1: <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>            x: 0,
</span></span><span style=display:flex><span>            y: 0,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        p2: <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>            x: 1,
</span></span><span style=display:flex><span>            y: 1,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        p3: <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>            x: 2,
</span></span><span style=display:flex><span>            y: 2,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// using Point::new
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> triangle = Triangle {
</span></span><span style=display:flex><span>        p1: <span style=color:#2b91af>Point</span>::new(0, 0),
</span></span><span style=display:flex><span>        p2: <span style=color:#2b91af>Point</span>::new(1, 1),
</span></span><span style=display:flex><span>        p3: <span style=color:#2b91af>Point</span>::new(2, 2),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// using From&lt;(i32, i32)&gt; for Point
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> triangle = Triangle {
</span></span><span style=display:flex><span>        p1: (0, 0).into(),
</span></span><span style=display:flex><span>        p2: (1, 1).into(),
</span></span><span style=display:flex><span>        p3: (2, 2).into(),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// using Triangle::new + From&lt;(i32, i32)&gt; for Point
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> triangle = Triangle::new(
</span></span><span style=display:flex><span>        (0, 0).into(),
</span></span><span style=display:flex><span>        (1, 1).into(),
</span></span><span style=display:flex><span>        (2, 2).into(),
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// using From&lt;[Into&lt;Point&gt;; 3]&gt; for Triangle
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> triangle: <span style=color:#2b91af>Triangle</span> = [
</span></span><span style=display:flex><span>        (0, 0),
</span></span><span style=display:flex><span>        (1, 1),
</span></span><span style=display:flex><span>        (2, 2),
</span></span><span style=display:flex><span>    ].into();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There are no rules for when, how, or why we should impl <code>From&lt;T></code> for our types so it&rsquo;s up to us to use our best judgement for every situation.</p><p>One popular use of <code>Into&lt;T></code> is to make functions which need owned values generic over whether they take owned or borrowed values:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Person</span> {
</span></span><span style=display:flex><span>    name: String,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Person {
</span></span><span style=display:flex><span>    <span style=color:green>// accepts:
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// - String
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> new1(name: String) -&gt; <span style=color:#2b91af>Person</span> {
</span></span><span style=display:flex><span>        Person { name }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// accepts:
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// - String
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// - &amp;String
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// - &amp;str
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// - Box&lt;str&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// - Cow&lt;&#39;_, str&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// - char
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// since all of the above types can be converted into String
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> new2&lt;N: Into&lt;String&gt;&gt;(name: <span style=color:#2b91af>N</span>) -&gt; <span style=color:#2b91af>Person</span> {
</span></span><span style=display:flex><span>        Person { name: <span style=color:#2b91af>name</span>.into() }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=error-handling>Error Handling</h2><p>The best time to talk about error handling and the <code>Error</code> trait is after going over <code>Display</code>, <code>Debug</code>, <code>Any</code>, and <code>From</code> but before getting to <code>TryFrom</code> hence why the <strong>Error Handling</strong> section awkwardly bisects the <strong>Conversion Traits</strong> section.</p><h3 id=error>Error</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#default-impls>Default Impls</a></li><li><a href=#generic-blanket-impls>Generic Blanket Impls</a></li><li><a href=#subtraits--supertraits>Subtraits & Supertraits</a></li><li><a href=#trait-objects>Trait Objects</a></li><li><a href=#display--tostring>Display & ToString</a></li><li><a href=#debug>Debug</a></li><li><a href=#any>Any</a></li><li><a href=#from--into>From & Into</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Error: <span style=color:#2b91af>Debug</span> + Display {
</span></span><span style=display:flex><span>    <span style=color:green>// provided default impls
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> source(&amp;self) -&gt; Option&lt;&amp;(<span style=color:#00f>dyn</span> Error + &#39;static)&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> backtrace(&amp;self) -&gt; Option&lt;&amp;Backtrace&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> description(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>str</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> cause(&amp;self) -&gt; Option&lt;&amp;<span style=color:#00f>dyn</span> Error&gt;;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In Rust errors are returned, not thrown. Let&rsquo;s look at some examples.</p><p>Since dividing integer types by zero panics if we wanted to make our program safer and more explicit we could impl a <code>safe_div</code> function which returns a <code>Result</code> instead like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::fmt;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(Debug, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>DivByZero</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> fmt::Display <span style=color:#00f>for</span> DivByZero {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> fmt(&amp;self, f: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> fmt::Formatter&lt;&#39;_&gt;) -&gt; <span style=color:#2b91af>fmt</span>::Result {
</span></span><span style=display:flex><span>        write!(f, <span style=color:#a31515>&#34;division by zero error&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> error::Error <span style=color:#00f>for</span> DivByZero {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> safe_div(numerator: <span style=color:#2b91af>i32</span>, denominator: <span style=color:#2b91af>i32</span>) -&gt; Result&lt;<span style=color:#2b91af>i32</span>, DivByZero&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>if</span> denominator == 0 {
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> Err(DivByZero);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Ok(numerator / denominator)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[test]</span> <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> test_safe_div() {
</span></span><span style=display:flex><span>    assert_eq!(safe_div(8, 2), Ok(4));
</span></span><span style=display:flex><span>    assert_eq!(safe_div(5, 0), Err(DivByZero));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since errors are returned and not thrown they must be explicitly handled, and if the current function cannot handle an error it should propagate it up to the caller. The most idiomatic way to propagate errors is to use the <code>?</code> operator, which is just syntax sugar for the now deprecated <code>try!</code> macro which simply does this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>macro_rules! <span style=color:#00f>try</span> {
</span></span><span style=display:flex><span>    (<span style=color:#00f>$expr</span>:<span style=color:#2b91af>expr</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#00f>match</span> <span style=color:#00f>$expr</span> {
</span></span><span style=display:flex><span>            <span style=color:green>// if Ok just unwrap the value
</span></span></span><span style=display:flex><span><span style=color:green></span>            Ok(val) =&gt; val,
</span></span><span style=display:flex><span>            <span style=color:green>// if Err map the err value using From and return
</span></span></span><span style=display:flex><span><span style=color:green></span>            Err(err) =&gt; {
</span></span><span style=display:flex><span>                <span style=color:#00f>return</span> Err(From::from(err));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If we wanted to write a function which reads a file into a <code>String</code> we could write it like this, propagating the <code>io::Error</code>s using <code>?</code> everywhere they can appear:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::io::Read;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::path::Path;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::io;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::fs::File;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> read_file_to_string(path: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Path</span>) -&gt; Result&lt;String, io::Error&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> file = File::open(path)?; <span style=color:green>// ⬆️ io::Error
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> contents = String::new();
</span></span><span style=display:flex><span>    file.read_to_string(&amp;<span style=color:#00f>mut</span> contents)?; <span style=color:green>// ⬆️ io::Error
</span></span></span><span style=display:flex><span><span style=color:green></span>    Ok(contents)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But let&rsquo;s say the file we&rsquo;re reading is actually a list of numbers and we want to sum them together, we&rsquo;d update our function like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::io::Read;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::path::Path;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::io;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::fs::File;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> sum_file(path: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Path</span>) -&gt; Result&lt;<span style=color:#2b91af>i32</span>, <span style=color:green>/* What to put here? */</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> file = File::open(path)?; <span style=color:green>// ⬆️ io::Error
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> contents = String::new();
</span></span><span style=display:flex><span>    file.read_to_string(&amp;<span style=color:#00f>mut</span> contents)?; <span style=color:green>// ⬆️ io::Error
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> sum = 0;
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> line <span style=color:#00f>in</span> contents.lines() {
</span></span><span style=display:flex><span>        sum += line.parse::&lt;<span style=color:#2b91af>i32</span>&gt;()?; <span style=color:green>// ⬆️ ParseIntError
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>    Ok(sum)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But what&rsquo;s the error type of our <code>Result</code> now? It can return either an <code>io::Error</code> or a <code>ParseIntError</code>. We&rsquo;re going to look at three approaches for solving this problem, starting with the most quick & dirty way and finishing with the most robust way.</p><p>The first approach is recognizing that all types which impl <code>Error</code> also impl <code>Display</code> so we can map all the errors to <code>String</code>s and use <code>String</code> as our error type:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::fs::File;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::io;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::io::Read;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::path::Path;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> sum_file(path: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Path</span>) -&gt; Result&lt;<span style=color:#2b91af>i32</span>, String&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> file = File::open(path)
</span></span><span style=display:flex><span>        .map_err(|e| e.to_string())?; <span style=color:green>// ⬆️ io::Error -&gt; String
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> contents = String::new();
</span></span><span style=display:flex><span>    file.read_to_string(&amp;<span style=color:#00f>mut</span> contents)
</span></span><span style=display:flex><span>        .map_err(|e| e.to_string())?; <span style=color:green>// ⬆️ io::Error -&gt; String
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> sum = 0;
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> line <span style=color:#00f>in</span> contents.lines() {
</span></span><span style=display:flex><span>        sum += line.parse::&lt;<span style=color:#2b91af>i32</span>&gt;()
</span></span><span style=display:flex><span>            .map_err(|e| e.to_string())?; <span style=color:green>// ⬆️ ParseIntError -&gt; String
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>    Ok(sum)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The obvious downside of stringifying every error is that we throw away type information which makes it harder for the caller to handle the errors.</p><p>One nonobvious upside to the above approach is we can customize the strings to provide more context-specific information. For example, <code>ParseIntError</code> usually stringifies to <code>"invalid digit found in string"</code> which is very vague and doesn&rsquo;t mention what the invalid string is or what integer type it was trying to parse into. If we were debugging this problem that error message would almost be useless. However we can make it significantly better by providing all the context relevant information ourselves:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>sum += line.parse::&lt;<span style=color:#2b91af>i32</span>&gt;()
</span></span><span style=display:flex><span>    .map_err(|_| format!(<span style=color:#a31515>&#34;failed to parse {} into i32&#34;</span>, line))?;
</span></span></code></pre></div><p>The second approach takes advantage of this generic blanket impl from the standard library:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span>&lt;E: <span style=color:#2b91af>error</span>::Error&gt; From&lt;E&gt; <span style=color:#00f>for</span> Box&lt;<span style=color:#00f>dyn</span> error::Error&gt;;
</span></span></code></pre></div><p>Which means that any <code>Error</code> type can be implicitly converted into a <code>Box&lt;dyn error::Error></code> by the <code>?</code> operator, so we can set to error type to <code>Box&lt;dyn error::Error></code> in the <code>Result</code> return type of any function which produces errors and the <code>?</code> operator will do the rest of the work for us:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::fs::File;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::io::Read;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::path::Path;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> sum_file(path: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Path</span>) -&gt; Result&lt;<span style=color:#2b91af>i32</span>, Box&lt;<span style=color:#00f>dyn</span> error::Error&gt;&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> file = File::open(path)?; <span style=color:green>// ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> contents = String::new();
</span></span><span style=display:flex><span>    file.read_to_string(&amp;<span style=color:#00f>mut</span> contents)?; <span style=color:green>// ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> sum = 0;
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> line <span style=color:#00f>in</span> contents.lines() {
</span></span><span style=display:flex><span>        sum += line.parse::&lt;<span style=color:#2b91af>i32</span>&gt;()?; <span style=color:green>// ⬆️ ParseIntError -&gt; Box&lt;dyn error::Error&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>    Ok(sum)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>While being more concise, this seems to suffer from the same downside of the previous approach by throwing away type information. This is mostly true, but if the caller is aware of the impl details of our function they can still handle the different errors types using the <code>downcast_ref()</code> method on <code>error::Error</code> which works the same as it does on <code>dyn Any</code> types:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> handle_sum_file_errors(path: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Path</span>) {
</span></span><span style=display:flex><span>    <span style=color:#00f>match</span> sum_file(path) {
</span></span><span style=display:flex><span>        Ok(sum) =&gt; println!(<span style=color:#a31515>&#34;the sum is {}&#34;</span>, sum),
</span></span><span style=display:flex><span>        Err(err) =&gt; {
</span></span><span style=display:flex><span>            <span style=color:#00f>if</span> <span style=color:#00f>let</span> Some(e) = err.downcast_ref::&lt;io::Error&gt;() {
</span></span><span style=display:flex><span>                <span style=color:green>// handle io::Error
</span></span></span><span style=display:flex><span><span style=color:green></span>            } <span style=color:#00f>else</span> <span style=color:#00f>if</span> <span style=color:#00f>let</span> Some(e) = err.downcast_ref::&lt;ParseIntError&gt;() {
</span></span><span style=display:flex><span>                <span style=color:green>// handle ParseIntError
</span></span></span><span style=display:flex><span><span style=color:green></span>            } <span style=color:#00f>else</span> {
</span></span><span style=display:flex><span>                <span style=color:green>// we know sum_file can only return one of the
</span></span></span><span style=display:flex><span><span style=color:green></span>                <span style=color:green>// above errors so this branch is unreachable
</span></span></span><span style=display:flex><span><span style=color:green></span>                unreachable!();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The third approach, which is the most robust and type-safe way to aggregate these different errors would be to build our own custom error type using an enum:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::num::ParseIntError;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::fs::File;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::io;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::io::Read;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::path::Path;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::error;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::fmt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>SumFileError</span> {
</span></span><span style=display:flex><span>    Io(io::Error),
</span></span><span style=display:flex><span>    Parse(ParseIntError),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> From&lt;io::Error&gt; <span style=color:#00f>for</span> SumFileError {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from(err: <span style=color:#2b91af>io</span>::Error) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        SumFileError::Io(err)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> From&lt;ParseIntError&gt; <span style=color:#00f>for</span> SumFileError {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from(err: <span style=color:#2b91af>ParseIntError</span>) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        SumFileError::Parse(err)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> fmt::Display <span style=color:#00f>for</span> SumFileError {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> fmt(&amp;self, f: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> fmt::Formatter&lt;&#39;_&gt;) -&gt; <span style=color:#2b91af>fmt</span>::Result {
</span></span><span style=display:flex><span>        <span style=color:#00f>match</span> self {
</span></span><span style=display:flex><span>            SumFileError::Io(err) =&gt; write!(f, <span style=color:#a31515>&#34;sum file error: {}&#34;</span>, err),
</span></span><span style=display:flex><span>            SumFileError::Parse(err) =&gt; write!(f, <span style=color:#a31515>&#34;sum file error: {}&#34;</span>, err),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> error::Error <span style=color:#00f>for</span> SumFileError {
</span></span><span style=display:flex><span>    <span style=color:green>// the default impl for this method always returns None
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// but we can now override it to make it way more useful!
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> source(&amp;self) -&gt; Option&lt;&amp;(<span style=color:#00f>dyn</span> error::Error + &#39;static)&gt; {
</span></span><span style=display:flex><span>        Some(<span style=color:#00f>match</span> self {
</span></span><span style=display:flex><span>            SumFileError::Io(err) =&gt; err,
</span></span><span style=display:flex><span>            SumFileError::Parse(err) =&gt; err,
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> sum_file(path: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Path</span>) -&gt; Result&lt;<span style=color:#2b91af>i32</span>, SumFileError&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> file = File::open(path)?; <span style=color:green>// ⬆️ io::Error -&gt; SumFileError
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> contents = String::new();
</span></span><span style=display:flex><span>    file.read_to_string(&amp;<span style=color:#00f>mut</span> contents)?; <span style=color:green>// ⬆️ io::Error -&gt; SumFileError
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> sum = 0;
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> line <span style=color:#00f>in</span> contents.lines() {
</span></span><span style=display:flex><span>        sum += line.parse::&lt;<span style=color:#2b91af>i32</span>&gt;()?; <span style=color:green>// ⬆️ ParseIntError -&gt; SumFileError
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>    Ok(sum)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> handle_sum_file_errors(path: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Path</span>) {
</span></span><span style=display:flex><span>    <span style=color:#00f>match</span> sum_file(path) {
</span></span><span style=display:flex><span>        Ok(sum) =&gt; println!(<span style=color:#a31515>&#34;the sum is {}&#34;</span>, sum),
</span></span><span style=display:flex><span>        Err(SumFileError::Io(err)) =&gt; {
</span></span><span style=display:flex><span>            <span style=color:green>// handle io::Error
</span></span></span><span style=display:flex><span><span style=color:green></span>        },
</span></span><span style=display:flex><span>        Err(SumFileError::Parse(err)) =&gt; {
</span></span><span style=display:flex><span>            <span style=color:green>// handle ParseIntError
</span></span></span><span style=display:flex><span><span style=color:green></span>        },
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=conversion-traits-continued>Conversion Traits Continued</h2><h3 id=tryfrom--tryinto>TryFrom & TryInto</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#functions>Functions</a></li><li><a href=#methods>Methods</a></li><li><a href=#associated-types>Associated Types</a></li><li><a href=#generic-parameters>Generic Parameters</a></li><li><a href=#generic-types-vs-associated-types>Generic Types vs Associated Types</a></li><li><a href=#generic-blanket-impls>Generic Blanket Impls</a></li><li><a href=#from--into>From & Into</a></li><li><a href=#error>Error</a></li></ul><p><code>TryFrom</code> and <code>TryInto</code> are the fallible versions of <code>From</code> and <code>Into</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> TryFrom&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Error</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> try_from(value: <span style=color:#2b91af>T</span>) -&gt; Result&lt;Self, Self::Error&gt;;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> TryInto&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Error</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> try_into(self) -&gt; Result&lt;T, Self::Error&gt;;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Similarly to <code>Into</code> we cannot impl <code>TryInto</code> because its impl is provided by this generic blanket impl:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span>&lt;T, U&gt; TryInto&lt;U&gt; <span style=color:#00f>for</span> T
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    U: <span style=color:#2b91af>TryFrom</span>&lt;T&gt;,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Error</span> = U::Error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> try_into(self) -&gt; Result&lt;U, U::Error&gt; {
</span></span><span style=display:flex><span>        U::try_from(self)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s say that in the context of our program it doesn&rsquo;t make sense for <code>Point</code>s to have <code>x</code> and <code>y</code> values that are less than <code>-1000</code> or greater than <code>1000</code>. This is how we&rsquo;d rewrite our earlier <code>From</code> impls using <code>TryFrom</code> to signal to the users of our type that this conversion can now fail:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::convert::TryFrom;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::error;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::fmt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>OutOfBounds</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> fmt::Display <span style=color:#00f>for</span> OutOfBounds {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> fmt(&amp;self, f: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> fmt::Formatter&lt;&#39;_&gt;) -&gt; <span style=color:#2b91af>fmt</span>::Result {
</span></span><span style=display:flex><span>        write!(f, <span style=color:#a31515>&#34;out of bounds&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> error::Error <span style=color:#00f>for</span> OutOfBounds {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// now fallible
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> TryFrom&lt;(<span style=color:#2b91af>i32</span>, <span style=color:#2b91af>i32</span>)&gt; <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Error</span> = OutOfBounds;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> try_from((x, y): (<span style=color:#2b91af>i32</span>, <span style=color:#2b91af>i32</span>)) -&gt; Result&lt;Point, OutOfBounds&gt; {
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> x.abs() &gt; 1000 || y.abs() &gt; 1000 {
</span></span><span style=display:flex><span>            <span style=color:#00f>return</span> Err(OutOfBounds);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Ok(Point { x, y })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// still infallible
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> From&lt;Point&gt; <span style=color:#00f>for</span> (<span style=color:#2b91af>i32</span>, <span style=color:#2b91af>i32</span>) {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from(Point { x, y }: <span style=color:#2b91af>Point</span>) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        (x, y)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And here&rsquo;s the refactored <code>TryFrom&lt;[TryInto&lt;Point>; 3]></code> impl for <code>Triangle</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::convert::{TryFrom, TryInto};
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::error;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::fmt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>OutOfBounds</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> fmt::Display <span style=color:#00f>for</span> OutOfBounds {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> fmt(&amp;self, f: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> fmt::Formatter&lt;&#39;_&gt;) -&gt; <span style=color:#2b91af>fmt</span>::Result {
</span></span><span style=display:flex><span>        write!(f, <span style=color:#a31515>&#34;out of bounds&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> error::Error <span style=color:#00f>for</span> OutOfBounds {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> TryFrom&lt;(<span style=color:#2b91af>i32</span>, <span style=color:#2b91af>i32</span>)&gt; <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Error</span> = OutOfBounds;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> try_from((x, y): (<span style=color:#2b91af>i32</span>, <span style=color:#2b91af>i32</span>)) -&gt; Result&lt;Self, Self::Error&gt; {
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> x.abs() &gt; 1000 || y.abs() &gt; 1000 {
</span></span><span style=display:flex><span>            <span style=color:#00f>return</span> Err(OutOfBounds);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Ok(Point { x, y })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Triangle</span> {
</span></span><span style=display:flex><span>    p1: <span style=color:#2b91af>Point</span>,
</span></span><span style=display:flex><span>    p2: <span style=color:#2b91af>Point</span>,
</span></span><span style=display:flex><span>    p3: <span style=color:#2b91af>Point</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span>&lt;P&gt; TryFrom&lt;[P; 3]&gt; <span style=color:#00f>for</span> Triangle
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    P: <span style=color:#2b91af>TryInto</span>&lt;Point&gt;,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Error</span> = P::Error;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> try_from([p1, p2, p3]: [P; 3]) -&gt; Result&lt;Self, Self::Error&gt; {
</span></span><span style=display:flex><span>        Ok(Triangle {
</span></span><span style=display:flex><span>            p1: <span style=color:#2b91af>p1</span>.try_into()?,
</span></span><span style=display:flex><span>            p2: <span style=color:#2b91af>p2</span>.try_into()?,
</span></span><span style=display:flex><span>            p3: <span style=color:#2b91af>p3</span>.try_into()?,
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example() -&gt; Result&lt;Triangle, OutOfBounds&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> t: <span style=color:#2b91af>Triangle</span> = [(0, 0), (1, 1), (2, 2)].try_into()?;
</span></span><span style=display:flex><span>    Ok(t)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=fromstr>FromStr</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#functions>Functions</a></li><li><a href=#associated-types>Associated Types</a></li><li><a href=#error>Error</a></li><li><a href=#tryfrom--tryinto>TryFrom & TryInto</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> FromStr {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> Err;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from_str(s: <span style=color:#00f>&amp;</span><span style=color:#2b91af>str</span>) -&gt; Result&lt;Self, Self::Err&gt;;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>FromStr</code> types allow performing a fallible conversion from <code>&str</code> into <code>Self</code>. The idiomatic way to use <code>FromStr</code> is to call the <code>.parse()</code> method on <code>&str</code>s:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::<span style=color:#2b91af>str</span>::FromStr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example&lt;T: <span style=color:#2b91af>FromStr</span>&gt;(s: <span style=color:#00f>&amp;</span>&#39;static <span style=color:#2b91af>str</span>) {
</span></span><span style=display:flex><span>    <span style=color:green>// these are all equivalent
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>let</span> t: Result&lt;T, _&gt; = FromStr::from_str(s);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> t = T::from_str(s);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> t: Result&lt;T, _&gt; = s.parse();
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> t = s.parse::&lt;T&gt;(); <span style=color:green>// most idiomatic
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Example impl for <code>Point</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::error;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::fmt;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::iter::Enumerate;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::num::ParseIntError;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::<span style=color:#2b91af>str</span>::{Chars, FromStr};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(Debug, Eq, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#2b91af>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> new(x: <span style=color:#2b91af>i32</span>, y: <span style=color:#2b91af>i32</span>) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        Point { x, y }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[derive(Debug, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>ParsePointError</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> fmt::Display <span style=color:#00f>for</span> ParsePointError {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> fmt(&amp;self, f: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> fmt::Formatter&lt;&#39;_&gt;) -&gt; <span style=color:#2b91af>fmt</span>::Result {
</span></span><span style=display:flex><span>        write!(f, <span style=color:#a31515>&#34;failed to parse point&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> From&lt;ParseIntError&gt; <span style=color:#00f>for</span> ParsePointError {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from(_e: <span style=color:#2b91af>ParseIntError</span>) -&gt; <span style=color:#2b91af>Self</span> {
</span></span><span style=display:flex><span>        ParsePointError
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> error::Error <span style=color:#00f>for</span> ParsePointError {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> FromStr <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> Err = ParsePointError;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from_str(s: <span style=color:#00f>&amp;</span><span style=color:#2b91af>str</span>) -&gt; Result&lt;Self, Self::Err&gt; {
</span></span><span style=display:flex><span>        <span style=color:#00f>let</span> is_num = |(_, c): <span style=color:#00f>&amp;</span>(<span style=color:#2b91af>usize</span>, <span style=color:#2b91af>char</span>)| matches!(c, <span style=color:#a31515>&#39;0&#39;</span>..=<span style=color:#a31515>&#39;9&#39;</span> | <span style=color:#a31515>&#39;-&#39;</span>);
</span></span><span style=display:flex><span>        <span style=color:#00f>let</span> isnt_num = |t: <span style=color:#00f>&amp;</span>(_, _)| !is_num(t);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#00f>let</span> get_num =
</span></span><span style=display:flex><span>            |char_idxs: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> Enumerate&lt;Chars&lt;&#39;_&gt;&gt;| -&gt; Result&lt;(<span style=color:#2b91af>usize</span>, <span style=color:#2b91af>usize</span>), ParsePointError&gt; {
</span></span><span style=display:flex><span>                <span style=color:#00f>let</span> (start, _) = char_idxs
</span></span><span style=display:flex><span>                    .skip_while(isnt_num)
</span></span><span style=display:flex><span>                    .next()
</span></span><span style=display:flex><span>                    .ok_or(ParsePointError)?;
</span></span><span style=display:flex><span>                <span style=color:#00f>let</span> (end, _) = char_idxs
</span></span><span style=display:flex><span>                    .skip_while(is_num)
</span></span><span style=display:flex><span>                    .next()
</span></span><span style=display:flex><span>                    .ok_or(ParsePointError)?;
</span></span><span style=display:flex><span>                Ok((start, end))
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#00f>let</span> <span style=color:#00f>mut</span> char_idxs = s.chars().enumerate();
</span></span><span style=display:flex><span>        <span style=color:#00f>let</span> (x_start, x_end) = get_num(&amp;<span style=color:#00f>mut</span> char_idxs)?;
</span></span><span style=display:flex><span>        <span style=color:#00f>let</span> (y_start, y_end) = get_num(&amp;<span style=color:#00f>mut</span> char_idxs)?;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#00f>let</span> x = s[x_start..x_end].parse::&lt;<span style=color:#2b91af>i32</span>&gt;()?;
</span></span><span style=display:flex><span>        <span style=color:#00f>let</span> y = s[y_start..y_end].parse::&lt;<span style=color:#2b91af>i32</span>&gt;()?;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(Point { x, y })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[test]</span> <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> pos_x_y() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p = <span style=color:#a31515>&#34;(4, 5)&#34;</span>.parse::&lt;Point&gt;();
</span></span><span style=display:flex><span>    assert_eq!(p, Ok(Point::new(4, 5)));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[test]</span> <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> neg_x_y() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p = <span style=color:#a31515>&#34;(-6, -2)&#34;</span>.parse::&lt;Point&gt;();
</span></span><span style=display:flex><span>    assert_eq!(p, Ok(Point::new(-6, -2)));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>#[test]</span> <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> not_a_point() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> p = <span style=color:#a31515>&#34;not a point&#34;</span>.parse::&lt;Point&gt;();
</span></span><span style=display:flex><span>    assert_eq!(p, Err(ParsePointError));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>FromStr</code> has the same signature as <code>TryFrom&lt;&str></code>. It doesn&rsquo;t matter which one we impl for a type first as long as we forward the impl to the other one. Here&rsquo;s a <code>TryFrom&lt;&str></code> impl for <code>Point</code> assuming it already has a <code>FromStr</code> impl:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span> TryFrom&lt;&amp;<span style=color:#2b91af>str</span>&gt; <span style=color:#00f>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Error</span> = &lt;Point <span style=color:#00f>as</span> FromStr&gt;::Err;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> try_from(s: <span style=color:#00f>&amp;</span><span style=color:#2b91af>str</span>) -&gt; Result&lt;Point, Self::Error&gt; {
</span></span><span style=display:flex><span>        &lt;Point <span style=color:#00f>as</span> FromStr&gt;::from_str(s)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=asref--asmut>AsRef & AsMut</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#sized>Sized</a></li><li><a href=#generic-parameters>Generic Parameters</a></li><li><a href=#sized>Sized</a></li><li><a href=#deref--derefmut>Deref & DerefMut</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> AsRef&lt;T: ?Sized&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>T</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> AsMut&lt;T: ?Sized&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_mut(&amp;<span style=color:#00f>mut</span> self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> T;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>AsRef</code> is for cheap reference to reference conversions. However, one of the most common ways it&rsquo;s used is to make functions generic over whether they take ownership or not:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// accepts:
</span></span></span><span style=display:flex><span><span style=color:green>//  - &amp;str
</span></span></span><span style=display:flex><span><span style=color:green>//  - &amp;String
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> takes_str(s: <span style=color:#00f>&amp;</span><span style=color:#2b91af>str</span>) {
</span></span><span style=display:flex><span>    <span style=color:green>// use &amp;str
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// accepts:
</span></span></span><span style=display:flex><span><span style=color:green>//  - &amp;str
</span></span></span><span style=display:flex><span><span style=color:green>//  - &amp;String
</span></span></span><span style=display:flex><span><span style=color:green>//  - String
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> takes_asref_str&lt;S: AsRef&lt;<span style=color:#2b91af>str</span>&gt;&gt;(s: <span style=color:#2b91af>S</span>) {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> s: <span style=color:#00f>&amp;</span><span style=color:#2b91af>str</span> = s.as_ref();
</span></span><span style=display:flex><span>    <span style=color:green>// use &amp;str
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example(slice: <span style=color:#00f>&amp;</span><span style=color:#2b91af>str</span>, borrow: <span style=color:#00f>&amp;</span>String, owned: String) {
</span></span><span style=display:flex><span>    takes_str(slice);
</span></span><span style=display:flex><span>    takes_str(borrow);
</span></span><span style=display:flex><span>    takes_str(owned); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>    takes_asref_str(slice);
</span></span><span style=display:flex><span>    takes_asref_str(borrow);
</span></span><span style=display:flex><span>    takes_asref_str(owned); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>The other most common use-case is returning a reference to inner private data wrapped by a type which protects some invariant. A good example from the standard library is <code>String</code> which is just a wrapper around <code>Vec&lt;u8></code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> String {
</span></span><span style=display:flex><span>    vec: Vec&lt;<span style=color:#2b91af>u8</span>&gt;,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This inner <code>Vec</code> cannot be made public because if it was people could mutate any byte and break the <code>String</code>&rsquo;s valid UTF-8 encoding. However, it&rsquo;s safe to expose an immutable read-only reference to the inner byte array, hence this impl:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;[<span style=color:#2b91af>u8</span>]&gt; <span style=color:#00f>for</span> String;
</span></span></code></pre></div><p>Generally, it often only makes sense to impl <code>AsRef</code> for a type if it wraps some other type to either provide additional functionality around the inner type or protect some invariant on the inner type.</p><p>Let&rsquo;s examine a example of bad <code>AsRef</code> impls:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>User</span> {
</span></span><span style=display:flex><span>    name: String,
</span></span><span style=display:flex><span>    age: <span style=color:#2b91af>u32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;String&gt; <span style=color:#00f>for</span> User {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span>String {
</span></span><span style=display:flex><span>        &amp;self.name
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;<span style=color:#2b91af>u32</span>&gt; <span style=color:#00f>for</span> User {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>u32</span> {
</span></span><span style=display:flex><span>        &amp;self.age
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This works and kinda makes sense at first, but quickly falls apart if we add more members to <code>User</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>User</span> {
</span></span><span style=display:flex><span>    name: String,
</span></span><span style=display:flex><span>    email: String,
</span></span><span style=display:flex><span>    age: <span style=color:#2b91af>u32</span>,
</span></span><span style=display:flex><span>    height: <span style=color:#2b91af>u32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;String&gt; <span style=color:#00f>for</span> User {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span>String {
</span></span><span style=display:flex><span>        <span style=color:green>// uh, do we return name or email here?
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;<span style=color:#2b91af>u32</span>&gt; <span style=color:#00f>for</span> User {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>u32</span> {
</span></span><span style=display:flex><span>        <span style=color:green>// uh, do we return age or height here?
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A <code>User</code> is composed of <code>String</code>s and <code>u32</code>s but it&rsquo;s not really the same thing as a <code>String</code> or a <code>u32</code>. Even if we had much more specific types:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>User</span> {
</span></span><span style=display:flex><span>    name: <span style=color:#2b91af>Name</span>,
</span></span><span style=display:flex><span>    email: <span style=color:#2b91af>Email</span>,
</span></span><span style=display:flex><span>    age: <span style=color:#2b91af>Age</span>,
</span></span><span style=display:flex><span>    height: <span style=color:#2b91af>Height</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It wouldn&rsquo;t make much sense to impl <code>AsRef</code> for any of those because <code>AsRef</code> is for cheap reference to reference conversions between semantically equivalent things, and <code>Name</code>, <code>Email</code>, <code>Age</code>, and <code>Height</code> by themselves are not the same thing as a <code>User</code>.</p><p>A good example where we would impl <code>AsRef</code> would be if we introduced a new type <code>Moderator</code> that just wrapped a <code>User</code> and added some moderation specific privileges:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>User</span> {
</span></span><span style=display:flex><span>    name: String,
</span></span><span style=display:flex><span>    age: <span style=color:#2b91af>u32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// unfortunately the standard library cannot provide
</span></span></span><span style=display:flex><span><span style=color:green>// a generic blanket impl to save us from this boilerplate
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>impl</span> AsRef&lt;User&gt; <span style=color:#00f>for</span> User {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>User</span> {
</span></span><span style=display:flex><span>        self
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Privilege</span> {
</span></span><span style=display:flex><span>    BanUsers,
</span></span><span style=display:flex><span>    EditPosts,
</span></span><span style=display:flex><span>    DeletePosts,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// although Moderators have some special
</span></span></span><span style=display:flex><span><span style=color:green>// privileges they are still regular Users
</span></span></span><span style=display:flex><span><span style=color:green>// and should be able to do all the same stuff
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>struct</span> <span style=color:#2b91af>Moderator</span> {
</span></span><span style=display:flex><span>    user: <span style=color:#2b91af>User</span>,
</span></span><span style=display:flex><span>    privileges: Vec&lt;Privilege&gt;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;Moderator&gt; <span style=color:#00f>for</span> Moderator {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Moderator</span> {
</span></span><span style=display:flex><span>        self
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;User&gt; <span style=color:#00f>for</span> Moderator {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>User</span> {
</span></span><span style=display:flex><span>        &amp;self.user
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// this should be callable with Users
</span></span></span><span style=display:flex><span><span style=color:green>// and Moderators (who are also Users)
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> create_post&lt;U: AsRef&lt;User&gt;&gt;(u: <span style=color:#2b91af>U</span>) {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> user = u.as_ref();
</span></span><span style=display:flex><span>    <span style=color:green>// etc
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example(user: <span style=color:#2b91af>User</span>, moderator: <span style=color:#2b91af>Moderator</span>) {
</span></span><span style=display:flex><span>    create_post(&amp;user);
</span></span><span style=display:flex><span>    create_post(&amp;moderator); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>This works because <code>Moderator</code>s are just <code>User</code>s. Here&rsquo;s the example from the <code>Deref</code> section except using <code>AsRef</code> instead:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::convert::AsRef;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>Human</span> {
</span></span><span style=display:flex><span>    health_points: <span style=color:#2b91af>u32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;Human&gt; <span style=color:#00f>for</span> Human {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Human</span> {
</span></span><span style=display:flex><span>        self
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Weapon</span> {
</span></span><span style=display:flex><span>    Spear,
</span></span><span style=display:flex><span>    Axe,
</span></span><span style=display:flex><span>    Sword,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// a Soldier is just a Human with a Weapon
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>struct</span> <span style=color:#2b91af>Soldier</span> {
</span></span><span style=display:flex><span>    human: <span style=color:#2b91af>Human</span>,
</span></span><span style=display:flex><span>    weapon: <span style=color:#2b91af>Weapon</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;Soldier&gt; <span style=color:#00f>for</span> Soldier {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Soldier</span> {
</span></span><span style=display:flex><span>        self
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;Human&gt; <span style=color:#00f>for</span> Soldier {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Human</span> {
</span></span><span style=display:flex><span>        &amp;self.human
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Mount</span> {
</span></span><span style=display:flex><span>    Horse,
</span></span><span style=display:flex><span>    Donkey,
</span></span><span style=display:flex><span>    Cow,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// a Knight is just a Soldier with a Mount
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>struct</span> <span style=color:#2b91af>Knight</span> {
</span></span><span style=display:flex><span>    soldier: <span style=color:#2b91af>Soldier</span>,
</span></span><span style=display:flex><span>    mount: <span style=color:#2b91af>Mount</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;Knight&gt; <span style=color:#00f>for</span> Knight {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Knight</span> {
</span></span><span style=display:flex><span>        self
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;Soldier&gt; <span style=color:#00f>for</span> Knight {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Soldier</span> {
</span></span><span style=display:flex><span>        &amp;self.soldier
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;Human&gt; <span style=color:#00f>for</span> Knight {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Human</span> {
</span></span><span style=display:flex><span>        &amp;self.soldier.human
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Spell</span> {
</span></span><span style=display:flex><span>    MagicMissile,
</span></span><span style=display:flex><span>    FireBolt,
</span></span><span style=display:flex><span>    ThornWhip,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// a Mage is just a Human who can cast Spells
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>struct</span> <span style=color:#2b91af>Mage</span> {
</span></span><span style=display:flex><span>    human: <span style=color:#2b91af>Human</span>,
</span></span><span style=display:flex><span>    spells: Vec&lt;Spell&gt;,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;Mage&gt; <span style=color:#00f>for</span> Mage {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Mage</span> {
</span></span><span style=display:flex><span>        self
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;Human&gt; <span style=color:#00f>for</span> Mage {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Human</span> {
</span></span><span style=display:flex><span>        &amp;self.human
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>enum</span> <span style=color:#2b91af>Staff</span> {
</span></span><span style=display:flex><span>    Wooden,
</span></span><span style=display:flex><span>    Metallic,
</span></span><span style=display:flex><span>    Plastic,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// a Wizard is just a Mage with a Staff
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>struct</span> <span style=color:#2b91af>Wizard</span> {
</span></span><span style=display:flex><span>    mage: <span style=color:#2b91af>Mage</span>,
</span></span><span style=display:flex><span>    staff: <span style=color:#2b91af>Staff</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;Wizard&gt; <span style=color:#00f>for</span> Wizard {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Wizard</span> {
</span></span><span style=display:flex><span>        self
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;Mage&gt; <span style=color:#00f>for</span> Wizard {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Mage</span> {
</span></span><span style=display:flex><span>        &amp;self.mage
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> AsRef&lt;Human&gt; <span style=color:#00f>for</span> Wizard {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> as_ref(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Human</span> {
</span></span><span style=display:flex><span>        &amp;self.mage.human
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> borrows_human&lt;H: AsRef&lt;Human&gt;&gt;(human: <span style=color:#2b91af>H</span>) {}
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> borrows_soldier&lt;S: AsRef&lt;Soldier&gt;&gt;(soldier: <span style=color:#2b91af>S</span>) {}
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> borrows_knight&lt;K: AsRef&lt;Knight&gt;&gt;(knight: <span style=color:#2b91af>K</span>) {}
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> borrows_mage&lt;M: AsRef&lt;Mage&gt;&gt;(mage: <span style=color:#2b91af>M</span>) {}
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> borrows_wizard&lt;W: AsRef&lt;Wizard&gt;&gt;(wizard: <span style=color:#2b91af>W</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> example(human: <span style=color:#2b91af>Human</span>, soldier: <span style=color:#2b91af>Soldier</span>, knight: <span style=color:#2b91af>Knight</span>, mage: <span style=color:#2b91af>Mage</span>, wizard: <span style=color:#2b91af>Wizard</span>) {
</span></span><span style=display:flex><span>    <span style=color:green>// all types can be used as Humans
</span></span></span><span style=display:flex><span><span style=color:green></span>    borrows_human(&amp;human);
</span></span><span style=display:flex><span>    borrows_human(&amp;soldier);
</span></span><span style=display:flex><span>    borrows_human(&amp;knight);
</span></span><span style=display:flex><span>    borrows_human(&amp;mage);
</span></span><span style=display:flex><span>    borrows_human(&amp;wizard);
</span></span><span style=display:flex><span>    <span style=color:green>// Knights can be used as Soldiers
</span></span></span><span style=display:flex><span><span style=color:green></span>    borrows_soldier(&amp;soldier);
</span></span><span style=display:flex><span>    borrows_soldier(&amp;knight);
</span></span><span style=display:flex><span>    <span style=color:green>// Wizards can be used as Mages
</span></span></span><span style=display:flex><span><span style=color:green></span>    borrows_mage(&amp;mage);
</span></span><span style=display:flex><span>    borrows_mage(&amp;wizard);
</span></span><span style=display:flex><span>    <span style=color:green>// Knights &amp; Wizards passed as themselves
</span></span></span><span style=display:flex><span><span style=color:green></span>    borrows_knight(&amp;knight);
</span></span><span style=display:flex><span>    borrows_wizard(&amp;wizard);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Deref</code> didn&rsquo;t work in the prior version of the example above because deref coercion is an implicit conversion between types which leaves room for people to mistakenly formulate the wrong ideas and expectations for how it will behave. <code>AsRef</code> works above because it makes the conversion between types explicit and there&rsquo;s no room leftover to develop any wrong ideas or expectations.</p><h3 id=borrow--borrowmut>Borrow & BorrowMut</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#generic-parameters>Generic Parameters</a></li><li><a href=#subtraits--supertraits>Subtraits & Supertraits</a></li><li><a href=#sized>Sized</a></li><li><a href=#asref--asmut>AsRef & AsMut</a></li><li><a href=#partialeq--eq>PartialEq & Eq</a></li><li><a href=#hash>Hash</a></li><li><a href=#partialord--ord>PartialOrd & Ord</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Borrow&lt;Borrowed&gt; 
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    Borrowed: ?Sized, 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> borrow(&amp;self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>Borrowed</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> BorrowMut&lt;Borrowed&gt;: <span style=color:#2b91af>Borrow</span>&lt;Borrowed&gt; 
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    Borrowed: ?Sized, 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> borrow_mut(&amp;<span style=color:#00f>mut</span> self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> Borrowed;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>These traits were invented to solve the very specific problem of looking up <code>String</code> keys in <code>HashSet</code>s, <code>HashMap</code>s, <code>BTreeSet</code>s, and <code>BTreeMap</code>s using <code>&str</code> values.</p><p>We can view <code>Borrow&lt;T></code> and <code>BorrowMut&lt;T></code> as stricter versions of <code>AsRef&lt;T></code> and <code>AsMut&lt;T></code>, where the returned reference <code>&T</code> has equivalent <code>Eq</code>, <code>Hash</code>, and <code>Ord</code> impls to <code>Self</code>. This is more easily explained with a commented example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::borrow::Borrow;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std:#<span>️⃣</span>:<span style=color:#2b91af>Hasher</span>;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::collections::hash_map::DefaultHasher;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std:#<span>️⃣</span>:<span style=color:#2b91af>Hash</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> get_hash&lt;T: <span style=color:#2b91af>Hash</span>&gt;(t: <span style=color:#2b91af>T</span>) -&gt; <span style=color:#2b91af>u64</span> {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> hasher = DefaultHasher::new();
</span></span><span style=display:flex><span>    t.hash(&amp;<span style=color:#00f>mut</span> hasher);
</span></span><span style=display:flex><span>    hasher.finish()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> asref_example&lt;Owned, Ref&gt;(owned1: <span style=color:#2b91af>Owned</span>, owned2: <span style=color:#2b91af>Owned</span>)
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    Owned: Eq + Ord + Hash + AsRef&lt;Ref&gt;,
</span></span><span style=display:flex><span>    Ref: Eq + Ord + Hash
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> ref1: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Ref</span> = owned1.as_ref();
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> ref2: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Ref</span> = owned2.as_ref();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:green>// refs aren&#39;t required to be equal if owned types are equal
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(owned1 == owned2, ref1 == ref2); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> owned1_hash = get_hash(&amp;owned1);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> owned2_hash = get_hash(&amp;owned2);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> ref1_hash = get_hash(&amp;ref1);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> ref2_hash = get_hash(&amp;ref2);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:green>// ref hashes aren&#39;t required to be equal if owned type hashes are equal
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(owned1_hash == owned2_hash, ref1_hash == ref2_hash); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>    
</span></span><span style=display:flex><span>    <span style=color:green>// ref comparisons aren&#39;t required to match owned type comparisons
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(owned1.cmp(&amp;owned2), ref1.cmp(&amp;ref2)); <span style=color:green>// ❌
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> borrow_example&lt;Owned, Borrowed&gt;(owned1: <span style=color:#2b91af>Owned</span>, owned2: <span style=color:#2b91af>Owned</span>)
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    Owned: Eq + Ord + Hash + Borrow&lt;Borrowed&gt;,
</span></span><span style=display:flex><span>    Borrowed: Eq + Ord + Hash
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> borrow1: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Borrowed</span> = owned1.borrow();
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> borrow2: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Borrowed</span> = owned2.borrow();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:green>// borrows are required to be equal if owned types are equal
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(owned1 == owned2, borrow1 == borrow2); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> owned1_hash = get_hash(&amp;owned1);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> owned2_hash = get_hash(&amp;owned2);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> borrow1_hash = get_hash(&amp;borrow1);
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> borrow2_hash = get_hash(&amp;borrow2);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:green>// borrow hashes are required to be equal if owned type hashes are equal
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(owned1_hash == owned2_hash, borrow1_hash == borrow2_hash); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>    
</span></span><span style=display:flex><span>    <span style=color:green>// borrow comparisons are required to match owned type comparisons
</span></span></span><span style=display:flex><span><span style=color:green></span>    assert_eq!(owned1.cmp(&amp;owned2), borrow1.cmp(&amp;borrow2)); <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>It&rsquo;s good to be aware of these traits and understand why they exist since it helps demystify some of the methods on <code>HashSet</code>, <code>HashMap</code>, <code>BTreeSet</code>, and <code>BTreeMap</code> but it&rsquo;s very rare that we would ever need to impl these traits for any of our types because it&rsquo;s very rare that we would ever need create a pair of types where one is the &ldquo;borrowed&rdquo; version of the other in the first place. If we have some <code>T</code> then <code>&T</code> will get the job done 99.99% of the time, and <code>T: Borrow&lt;T></code> is already implemented for all <code>T</code> because of a generic blanket impl, so we don&rsquo;t need to manually impl it and we don&rsquo;t need to create some <code>U</code> such that <code>T: Borrow&lt;U></code>.</p><h3 id=toowned>ToOwned</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#default-impls>Default Impls</a></li><li><a href=#clone>Clone</a></li><li><a href=#borrow--borrowmut>Borrow & BorrowMut</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> ToOwned {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Owned</span>: <span style=color:#2b91af>Borrow</span>&lt;Self&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> to_owned(&amp;self) -&gt; <span style=color:#2b91af>Self</span>::Owned;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:green>// provided default impls
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> clone_into(&amp;self, target: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> Self::Owned);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>ToOwned</code> is a more generic version of <code>Clone</code>. <code>Clone</code> allows us to take a <code>&T</code> and turn it into an <code>T</code> but <code>ToOwned</code> allows us to take a <code>&Borrowed</code> and turn it into a <code>Owned</code> where <code>Owned: Borrow&lt;Borrowed></code>.</p><p>In other words, we can&rsquo;t &ldquo;clone&rdquo; a <code>&str</code> into a <code>String</code>, or a <code>&Path</code> into a <code>PathBuf</code>, or an <code>&OsStr</code> into an <code>OsString</code>, since the <code>clone</code> method signature doesn&rsquo;t support this kind of cross-type cloning, and that&rsquo;s what <code>ToOwned</code> was made for.</p><p>For similar reasons as <code>Borrow</code> and <code>BorrowMut</code>, it&rsquo;s good to be aware of this trait and understand why it exists but it&rsquo;s very rare we&rsquo;ll ever need to impl it for any of our types.</p><h2 id=iteration-traits>Iteration Traits</h2><h3 id=iterator>Iterator</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#associated-types>Associated Types</a></li><li><a href=#default-impls>Default Impls</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Iterator {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Item</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> next(&amp;<span style=color:#00f>mut</span> self) -&gt; Option&lt;Self::Item&gt;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// provided default impls
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> size_hint(&amp;self) -&gt; (<span style=color:#2b91af>usize</span>, Option&lt;<span style=color:#2b91af>usize</span>&gt;);
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> count(self) -&gt; <span style=color:#2b91af>usize</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> last(self) -&gt; Option&lt;Self::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> advance_by(&amp;<span style=color:#00f>mut</span> self, n: <span style=color:#2b91af>usize</span>) -&gt; Result&lt;(), <span style=color:#2b91af>usize</span>&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> nth(&amp;<span style=color:#00f>mut</span> self, n: <span style=color:#2b91af>usize</span>) -&gt; Option&lt;Self::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> step_by(self, step: <span style=color:#2b91af>usize</span>) -&gt; <span style=color:#2b91af>StepBy</span>&lt;Self&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> chain&lt;U&gt;(
</span></span><span style=display:flex><span>        self, 
</span></span><span style=display:flex><span>        other: <span style=color:#2b91af>U</span>
</span></span><span style=display:flex><span>    ) -&gt; <span style=color:#2b91af>Chain</span>&lt;Self, &lt;U <span style=color:#00f>as</span> IntoIterator&gt;::IntoIter&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        U: IntoIterator&lt;Item = Self::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> zip&lt;U&gt;(self, other: <span style=color:#2b91af>U</span>) -&gt; <span style=color:#2b91af>Zip</span>&lt;Self, &lt;U <span style=color:#00f>as</span> IntoIterator&gt;::IntoIter&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        U: IntoIterator;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> map&lt;B, F&gt;(self, f: <span style=color:#2b91af>F</span>) -&gt; <span style=color:#2b91af>Map</span>&lt;Self, F&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(Self::Item) -&gt; <span style=color:#2b91af>B</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> for_each&lt;F&gt;(self, f: <span style=color:#2b91af>F</span>)
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(Self::Item);
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> filter&lt;P&gt;(self, predicate: <span style=color:#2b91af>P</span>) -&gt; <span style=color:#2b91af>Filter</span>&lt;Self, P&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        P: FnMut(&amp;Self::Item) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> filter_map&lt;B, F&gt;(self, f: <span style=color:#2b91af>F</span>) -&gt; <span style=color:#2b91af>FilterMap</span>&lt;Self, F&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> enumerate(self) -&gt; <span style=color:#2b91af>Enumerate</span>&lt;Self&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> peekable(self) -&gt; <span style=color:#2b91af>Peekable</span>&lt;Self&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> skip_while&lt;P&gt;(self, predicate: <span style=color:#2b91af>P</span>) -&gt; <span style=color:#2b91af>SkipWhile</span>&lt;Self, P&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        P: FnMut(&amp;Self::Item) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> take_while&lt;P&gt;(self, predicate: <span style=color:#2b91af>P</span>) -&gt; <span style=color:#2b91af>TakeWhile</span>&lt;Self, P&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        P: FnMut(&amp;Self::Item) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> map_while&lt;B, P&gt;(self, predicate: <span style=color:#2b91af>P</span>) -&gt; <span style=color:#2b91af>MapWhile</span>&lt;Self, P&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        P: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> skip(self, n: <span style=color:#2b91af>usize</span>) -&gt; <span style=color:#2b91af>Skip</span>&lt;Self&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> take(self, n: <span style=color:#2b91af>usize</span>) -&gt; <span style=color:#2b91af>Take</span>&lt;Self&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> scan&lt;St, B, F&gt;(self, initial_state: <span style=color:#2b91af>St</span>, f: <span style=color:#2b91af>F</span>) -&gt; <span style=color:#2b91af>Scan</span>&lt;Self, St, F&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(&amp;<span style=color:#00f>mut</span> St, Self::Item) -&gt; Option&lt;B&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> flat_map&lt;U, F&gt;(self, f: <span style=color:#2b91af>F</span>) -&gt; <span style=color:#2b91af>FlatMap</span>&lt;Self, U, F&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(Self::Item) -&gt; <span style=color:#2b91af>U</span>,
</span></span><span style=display:flex><span>        U: IntoIterator;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> flatten(self) -&gt; <span style=color:#2b91af>Flatten</span>&lt;Self&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        Self::Item: IntoIterator;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> fuse(self) -&gt; <span style=color:#2b91af>Fuse</span>&lt;Self&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> inspect&lt;F&gt;(self, f: <span style=color:#2b91af>F</span>) -&gt; <span style=color:#2b91af>Inspect</span>&lt;Self, F&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(&amp;Self::Item);
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> by_ref(&amp;<span style=color:#00f>mut</span> self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> Self;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> collect&lt;B&gt;(self) -&gt; <span style=color:#2b91af>B</span>
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        B: <span style=color:#2b91af>FromIterator</span>&lt;Self::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> partition&lt;B, F&gt;(self, f: <span style=color:#2b91af>F</span>) -&gt; (B, B)
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(&amp;Self::Item) -&gt; <span style=color:#2b91af>bool</span>,
</span></span><span style=display:flex><span>        B: Default + Extend&lt;Self::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> partition_in_place&lt;&#39;a, T, P&gt;(self, predicate: <span style=color:#2b91af>P</span>) -&gt; <span style=color:#2b91af>usize</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>where</span>
</span></span><span style=display:flex><span>        Self: DoubleEndedIterator&lt;Item = &amp;&#39;a <span style=color:#00f>mut</span> T&gt;,
</span></span><span style=display:flex><span>        T: &#39;a,
</span></span><span style=display:flex><span>        P: FnMut(&amp;T) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> is_partitioned&lt;P&gt;(self, predicate: <span style=color:#2b91af>P</span>) -&gt; <span style=color:#2b91af>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>where</span>
</span></span><span style=display:flex><span>        P: FnMut(Self::Item) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> try_fold&lt;B, F, R&gt;(&amp;<span style=color:#00f>mut</span> self, init: <span style=color:#2b91af>B</span>, f: <span style=color:#2b91af>F</span>) -&gt; <span style=color:#2b91af>R</span>
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(B, Self::Item) -&gt; <span style=color:#2b91af>R</span>,
</span></span><span style=display:flex><span>        R: <span style=color:#2b91af>Try</span>&lt;Ok = B&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> try_for_each&lt;F, R&gt;(&amp;<span style=color:#00f>mut</span> self, f: <span style=color:#2b91af>F</span>) -&gt; <span style=color:#2b91af>R</span>
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(Self::Item) -&gt; <span style=color:#2b91af>R</span>,
</span></span><span style=display:flex><span>        R: <span style=color:#2b91af>Try</span>&lt;Ok = ()&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> fold&lt;B, F&gt;(self, init: <span style=color:#2b91af>B</span>, f: <span style=color:#2b91af>F</span>) -&gt; <span style=color:#2b91af>B</span>
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(B, Self::Item) -&gt; <span style=color:#2b91af>B</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> fold_first&lt;F&gt;(self, f: <span style=color:#2b91af>F</span>) -&gt; Option&lt;Self::Item&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(Self::Item, Self::Item) -&gt; <span style=color:#2b91af>Self</span>::Item;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> all&lt;F&gt;(&amp;<span style=color:#00f>mut</span> self, f: <span style=color:#2b91af>F</span>) -&gt; <span style=color:#2b91af>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>where</span>
</span></span><span style=display:flex><span>        F: FnMut(Self::Item) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> any&lt;F&gt;(&amp;<span style=color:#00f>mut</span> self, f: <span style=color:#2b91af>F</span>) -&gt; <span style=color:#2b91af>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>where</span>
</span></span><span style=display:flex><span>        F: FnMut(Self::Item) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> find&lt;P&gt;(&amp;<span style=color:#00f>mut</span> self, predicate: <span style=color:#2b91af>P</span>) -&gt; Option&lt;Self::Item&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        P: FnMut(&amp;Self::Item) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> find_map&lt;B, F&gt;(&amp;<span style=color:#00f>mut</span> self, f: <span style=color:#2b91af>F</span>) -&gt; Option&lt;B&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> try_find&lt;F, R&gt;(
</span></span><span style=display:flex><span>        &amp;<span style=color:#00f>mut</span> self, 
</span></span><span style=display:flex><span>        f: <span style=color:#2b91af>F</span>
</span></span><span style=display:flex><span>    ) -&gt; Result&lt;Option&lt;Self::Item&gt;, &lt;R <span style=color:#00f>as</span> Try&gt;::Error&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(&amp;Self::Item) -&gt; <span style=color:#2b91af>R</span>,
</span></span><span style=display:flex><span>        R: <span style=color:#2b91af>Try</span>&lt;Ok = <span style=color:#2b91af>bool</span>&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> position&lt;P&gt;(&amp;<span style=color:#00f>mut</span> self, predicate: <span style=color:#2b91af>P</span>) -&gt; Option&lt;<span style=color:#2b91af>usize</span>&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        P: FnMut(Self::Item) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> rposition&lt;P&gt;(&amp;<span style=color:#00f>mut</span> self, predicate: <span style=color:#2b91af>P</span>) -&gt; Option&lt;<span style=color:#2b91af>usize</span>&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        Self: ExactSizeIterator + DoubleEndedIterator,
</span></span><span style=display:flex><span>        P: FnMut(Self::Item) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> max(self) -&gt; Option&lt;Self::Item&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        Self::Item: Ord;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> min(self) -&gt; Option&lt;Self::Item&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        Self::Item: Ord;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> max_by_key&lt;B, F&gt;(self, f: <span style=color:#2b91af>F</span>) -&gt; Option&lt;Self::Item&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(&amp;Self::Item) -&gt; <span style=color:#2b91af>B</span>,
</span></span><span style=display:flex><span>        B: Ord;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> max_by&lt;F&gt;(self, compare: <span style=color:#2b91af>F</span>) -&gt; Option&lt;Self::Item&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; <span style=color:#2b91af>Ordering</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> min_by_key&lt;B, F&gt;(self, f: <span style=color:#2b91af>F</span>) -&gt; Option&lt;Self::Item&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(&amp;Self::Item) -&gt; <span style=color:#2b91af>B</span>,
</span></span><span style=display:flex><span>        B: Ord;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> min_by&lt;F&gt;(self, compare: <span style=color:#2b91af>F</span>) -&gt; Option&lt;Self::Item&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; <span style=color:#2b91af>Ordering</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> rev(self) -&gt; <span style=color:#2b91af>Rev</span>&lt;Self&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        Self: DoubleEndedIterator;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> unzip&lt;A, B, FromA, FromB&gt;(self) -&gt; (FromA, FromB)
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        Self: Iterator&lt;Item = (A, B)&gt;,
</span></span><span style=display:flex><span>        FromA: Default + Extend&lt;A&gt;,
</span></span><span style=display:flex><span>        FromB: Default + Extend&lt;B&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> copied&lt;&#39;a, T&gt;(self) -&gt; <span style=color:#2b91af>Copied</span>&lt;Self&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        Self: Iterator&lt;Item = &amp;&#39;a T&gt;,
</span></span><span style=display:flex><span>        T: &#39;a + Copy;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> cloned&lt;&#39;a, T&gt;(self) -&gt; <span style=color:#2b91af>Cloned</span>&lt;Self&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        Self: Iterator&lt;Item = &amp;&#39;a T&gt;,
</span></span><span style=display:flex><span>        T: &#39;a + Clone;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> cycle(self) -&gt; <span style=color:#2b91af>Cycle</span>&lt;Self&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        Self: Clone;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> sum&lt;S&gt;(self) -&gt; <span style=color:#2b91af>S</span>
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        S: <span style=color:#2b91af>Sum</span>&lt;Self::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> product&lt;P&gt;(self) -&gt; <span style=color:#2b91af>P</span>
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        P: <span style=color:#2b91af>Product</span>&lt;Self::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> cmp&lt;I&gt;(self, other: <span style=color:#2b91af>I</span>) -&gt; <span style=color:#2b91af>Ordering</span>
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        I: IntoIterator&lt;Item = Self::Item&gt;,
</span></span><span style=display:flex><span>        Self::Item: Ord;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> cmp_by&lt;I, F&gt;(self, other: <span style=color:#2b91af>I</span>, cmp: <span style=color:#2b91af>F</span>) -&gt; <span style=color:#2b91af>Ordering</span>
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(Self::Item, &lt;I <span style=color:#00f>as</span> IntoIterator&gt;::Item) -&gt; <span style=color:#2b91af>Ordering</span>,
</span></span><span style=display:flex><span>        I: IntoIterator;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> partial_cmp&lt;I&gt;(self, other: <span style=color:#2b91af>I</span>) -&gt; Option&lt;Ordering&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        I: IntoIterator,
</span></span><span style=display:flex><span>        Self::Item: PartialOrd&lt;&lt;I <span style=color:#00f>as</span> IntoIterator&gt;::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> partial_cmp_by&lt;I, F&gt;(
</span></span><span style=display:flex><span>        self, 
</span></span><span style=display:flex><span>        other: <span style=color:#2b91af>I</span>, 
</span></span><span style=display:flex><span>        partial_cmp: <span style=color:#2b91af>F</span>
</span></span><span style=display:flex><span>    ) -&gt; Option&lt;Ordering&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        F: FnMut(Self::Item, &lt;I <span style=color:#00f>as</span> IntoIterator&gt;::Item) -&gt; Option&lt;Ordering&gt;,
</span></span><span style=display:flex><span>        I: IntoIterator;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq&lt;I&gt;(self, other: <span style=color:#2b91af>I</span>) -&gt; <span style=color:#2b91af>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>where</span>
</span></span><span style=display:flex><span>        I: IntoIterator,
</span></span><span style=display:flex><span>        Self::Item: PartialEq&lt;&lt;I <span style=color:#00f>as</span> IntoIterator&gt;::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> eq_by&lt;I, F&gt;(self, other: <span style=color:#2b91af>I</span>, eq: <span style=color:#2b91af>F</span>) -&gt; <span style=color:#2b91af>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>where</span>
</span></span><span style=display:flex><span>        F: FnMut(Self::Item, &lt;I <span style=color:#00f>as</span> IntoIterator&gt;::Item) -&gt; <span style=color:#2b91af>bool</span>,
</span></span><span style=display:flex><span>        I: IntoIterator;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> ne&lt;I&gt;(self, other: <span style=color:#2b91af>I</span>) -&gt; <span style=color:#2b91af>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>where</span>
</span></span><span style=display:flex><span>        I: IntoIterator,
</span></span><span style=display:flex><span>        Self::Item: PartialEq&lt;&lt;I <span style=color:#00f>as</span> IntoIterator&gt;::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> lt&lt;I&gt;(self, other: <span style=color:#2b91af>I</span>) -&gt; <span style=color:#2b91af>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>where</span>
</span></span><span style=display:flex><span>        I: IntoIterator,
</span></span><span style=display:flex><span>        Self::Item: PartialOrd&lt;&lt;I <span style=color:#00f>as</span> IntoIterator&gt;::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> le&lt;I&gt;(self, other: <span style=color:#2b91af>I</span>) -&gt; <span style=color:#2b91af>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>where</span>
</span></span><span style=display:flex><span>        I: IntoIterator,
</span></span><span style=display:flex><span>        Self::Item: PartialOrd&lt;&lt;I <span style=color:#00f>as</span> IntoIterator&gt;::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> gt&lt;I&gt;(self, other: <span style=color:#2b91af>I</span>) -&gt; <span style=color:#2b91af>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>where</span>
</span></span><span style=display:flex><span>        I: IntoIterator,
</span></span><span style=display:flex><span>        Self::Item: PartialOrd&lt;&lt;I <span style=color:#00f>as</span> IntoIterator&gt;::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> ge&lt;I&gt;(self, other: <span style=color:#2b91af>I</span>) -&gt; <span style=color:#2b91af>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>where</span>
</span></span><span style=display:flex><span>        I: IntoIterator,
</span></span><span style=display:flex><span>        Self::Item: PartialOrd&lt;&lt;I <span style=color:#00f>as</span> IntoIterator&gt;::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> is_sorted(self) -&gt; <span style=color:#2b91af>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>where</span>
</span></span><span style=display:flex><span>        Self::Item: PartialOrd&lt;Self::Item&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> is_sorted_by&lt;F&gt;(self, compare: <span style=color:#2b91af>F</span>) -&gt; <span style=color:#2b91af>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>where</span>
</span></span><span style=display:flex><span>        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Option&lt;Ordering&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> is_sorted_by_key&lt;F, K&gt;(self, f: <span style=color:#2b91af>F</span>) -&gt; <span style=color:#2b91af>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>where</span>
</span></span><span style=display:flex><span>        F: FnMut(Self::Item) -&gt; <span style=color:#2b91af>K</span>,
</span></span><span style=display:flex><span>        K: PartialOrd&lt;K&gt;;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Iterator&lt;Item = T></code> types can be iterated and will produce <code>T</code> types. There&rsquo;s no <code>IteratorMut</code> trait. Each <code>Iterator</code> impl can specify whether it returns immutable references, mutable references, or owned values via the <code>Item</code> associated type.</p><table><thead><tr><th><code>Vec&lt;T></code> method</th><th>Returns</th></tr></thead><tbody><tr><td><code>.iter()</code></td><td><code>Iterator&lt;Item = &T></code></td></tr><tr><td><code>.iter_mut()</code></td><td><code>Iterator&lt;Item = &mut T></code></td></tr><tr><td><code>.into_iter()</code></td><td><code>Iterator&lt;Item = T></code></td></tr></tbody></table><p>Something that is not immediately obvious to beginner Rustaceans but that intermediate Rustaceans take for granted is that most types are not their own iterators. If a type is iterable we almost always impl some custom iterator type which iterates over it rather than trying to make it iterate over itself:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>MyType</span> {
</span></span><span style=display:flex><span>    items: Vec&lt;String&gt;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> MyType {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> iter(&amp;self) -&gt; <span style=color:#2b91af>impl</span> Iterator&lt;Item = &amp;String&gt; {
</span></span><span style=display:flex><span>        MyTypeIterator {
</span></span><span style=display:flex><span>            index: 0,
</span></span><span style=display:flex><span>            items: <span style=color:#00f>&amp;</span><span style=color:#2b91af>self</span>.items
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>MyTypeIterator</span>&lt;&#39;a&gt; {
</span></span><span style=display:flex><span>    index: <span style=color:#2b91af>usize</span>,
</span></span><span style=display:flex><span>    items: <span style=color:#00f>&amp;</span>&#39;a Vec&lt;String&gt;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span>&lt;&#39;a&gt; Iterator <span style=color:#00f>for</span> MyTypeIterator&lt;&#39;a&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Item</span> = &amp;&#39;a String;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> next(&amp;<span style=color:#00f>mut</span> self) -&gt; Option&lt;Self::Item&gt; {
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> self.index &gt;= self.items.len() {
</span></span><span style=display:flex><span>            None
</span></span><span style=display:flex><span>        } <span style=color:#00f>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#00f>let</span> item = &amp;self.items[self.index];
</span></span><span style=display:flex><span>            self.index += 1;
</span></span><span style=display:flex><span>            Some(item)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For the sake of teaching the above example shows how to impl an <code>Iterator</code> from scratch but the idiomatic solution in this situation would be to just defer to <code>Vec</code>&rsquo;s <code>iter</code> method:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>struct</span> <span style=color:#2b91af>MyType</span> {
</span></span><span style=display:flex><span>    items: Vec&lt;String&gt;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>impl</span> MyType {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> iter(&amp;self) -&gt; <span style=color:#2b91af>impl</span> Iterator&lt;Item = &amp;String&gt; {
</span></span><span style=display:flex><span>        self.items.iter()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Also this is a good generic blanket impl to be aware of:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span>&lt;I: Iterator + ?Sized&gt; Iterator <span style=color:#00f>for</span> &amp;<span style=color:#00f>mut</span> I;
</span></span></code></pre></div><p>It says that any mutable reference to an iterator is also an iterator. This is useful to know because it allows us to use iterator methods with <code>self</code> receivers as if they had <code>&mut self</code> receivers.</p><p>As an example, imagine we have a function which processes an iterator of more than three items, but the first step of the function is to take out the first three items of the iterator and process them separately before iterating over the remaining items, here&rsquo;s how a beginner may attempt to write this function:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> example&lt;I: Iterator&lt;Item = <span style=color:#2b91af>i32</span>&gt;&gt;(<span style=color:#00f>mut</span> iter: <span style=color:#2b91af>I</span>) {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> first3: Vec&lt;<span style=color:#2b91af>i32</span>&gt; = iter.take(3).collect();
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> item <span style=color:#00f>in</span> iter { <span style=color:green>// ❌ iter consumed in line above
</span></span></span><span style=display:flex><span><span style=color:green></span>        <span style=color:green>// process remaining items
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Well that&rsquo;s annoying. The <code>take</code> method has a <code>self</code> receiver so it seems like we cannot call it without consuming the whole iterator! Here&rsquo;s what a naive refactor of the above code might look like:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> example&lt;I: Iterator&lt;Item = <span style=color:#2b91af>i32</span>&gt;&gt;(<span style=color:#00f>mut</span> iter: <span style=color:#2b91af>I</span>) {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> first3: Vec&lt;<span style=color:#2b91af>i32</span>&gt; = vec![
</span></span><span style=display:flex><span>        iter.next().unwrap(),
</span></span><span style=display:flex><span>        iter.next().unwrap(),
</span></span><span style=display:flex><span>        iter.next().unwrap(),
</span></span><span style=display:flex><span>    ];
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> item <span style=color:#00f>in</span> iter { <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>        <span style=color:green>// process remaining items
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Which is okay. However, the idiomatic refactor is actually:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> example&lt;I: Iterator&lt;Item = <span style=color:#2b91af>i32</span>&gt;&gt;(<span style=color:#00f>mut</span> iter: <span style=color:#2b91af>I</span>) {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> first3: Vec&lt;<span style=color:#2b91af>i32</span>&gt; = iter.by_ref().take(3).collect();
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> item <span style=color:#00f>in</span> iter { <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span>        <span style=color:green>// process remaining items
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Not very easy to discover. But anyway, now we know.</p><p>Also, there are no rules or conventions on what can or cannot be an iterator. If the type impls <code>Iterator</code> then it&rsquo;s an iterator. Some creative examples from the standard library:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::sync::mpsc::channel;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::thread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> paths_can_be_iterated(path: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Path</span>) {
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> part <span style=color:#00f>in</span> path {
</span></span><span style=display:flex><span>        <span style=color:green>// iterate over parts of a path
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>fn</span> receivers_can_be_iterated() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> (send, recv) = channel();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    thread::spawn(<span style=color:#00f>move</span> || {
</span></span><span style=display:flex><span>        send.send(1).unwrap();
</span></span><span style=display:flex><span>        send.send(2).unwrap();
</span></span><span style=display:flex><span>        send.send(3).unwrap();
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> received <span style=color:#00f>in</span> recv {
</span></span><span style=display:flex><span>        <span style=color:green>// iterate over received values
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=intoiterator>IntoIterator</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#associated-types>Associated Types</a></li><li><a href=#iterator>Iterator</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> IntoIterator 
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    &lt;Self::IntoIter <span style=color:#00f>as</span> Iterator&gt;::Item == Self::Item, 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>Item</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>type</span> <span style=color:#2b91af>IntoIter</span>: Iterator;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> into_iter(self) -&gt; <span style=color:#2b91af>Self</span>::IntoIter;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>IntoIterator</code> types can be converted into iterators, hence the name. The <code>into_iter</code> method is called on a type when it&rsquo;s used within a <code>for-in</code> loop:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// vec = Vec&lt;T&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>for</span> v <span style=color:#00f>in</span> vec {} <span style=color:green>// v = T
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span><span style=color:green>// above line desugared
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>for</span> v <span style=color:#00f>in</span> vec.into_iter() {}
</span></span></code></pre></div><p>Not only does <code>Vec</code> impl <code>IntoIterator</code> but so does <code>&Vec</code> and <code>&mut Vec</code> if we&rsquo;d like to iterate over immutable or mutable references instead of owned values, respectively.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:green>// vec = Vec&lt;T&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>for</span> v <span style=color:#00f>in</span> &amp;vec {} <span style=color:green>// v = &amp;T
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span><span style=color:green>// above example desugared
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>for</span> v <span style=color:#00f>in</span> (&amp;vec).into_iter() {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// vec = Vec&lt;T&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>for</span> v <span style=color:#00f>in</span> &amp;<span style=color:#00f>mut</span> vec {} <span style=color:green>// v = &amp;mut T
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span><span style=color:green>// above example desugared
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>for</span> v <span style=color:#00f>in</span> (&amp;<span style=color:#00f>mut</span> vec).into_iter() {}
</span></span></code></pre></div><h3 id=fromiterator>FromIterator</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#functions>Functions</a></li><li><a href=#generic-parameters>Generic Parameters</a></li><li><a href=#iterator>Iterator</a></li><li><a href=#intoiterator>IntoIterator</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> FromIterator&lt;A&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> from_iter&lt;T&gt;(iter: <span style=color:#2b91af>T</span>) -&gt; <span style=color:#2b91af>Self</span>
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        T: IntoIterator&lt;Item = A&gt;;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>FromIterator</code> types can be created from an iterator, hence the name. <code>FromIterator</code> is most commonly and idiomatically used by calling the <code>collect</code> method on <code>Iterator</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> collect&lt;B&gt;(self) -&gt; <span style=color:#2b91af>B</span>
</span></span><span style=display:flex><span><span style=color:#00f>where</span>
</span></span><span style=display:flex><span>    B: <span style=color:#2b91af>FromIterator</span>&lt;Self::Item&gt;;
</span></span></code></pre></div><p>Example of collecting an <code>Iterator&lt;Item = char></code> into a <code>String</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>fn</span> filter_letters(string: <span style=color:#00f>&amp;</span><span style=color:#2b91af>str</span>) -&gt; String {
</span></span><span style=display:flex><span>    string.chars().filter(|c| c.is_alphabetic()).collect()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>All the collections in the standard library impl <code>IntoIterator</code> and <code>FromIterator</code> so that makes it easier to convert between them:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::collections::{BTreeSet, HashMap, HashSet, LinkedList};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// String -&gt; HashSet&lt;char&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> unique_chars(string: <span style=color:#00f>&amp;</span><span style=color:#2b91af>str</span>) -&gt; <span style=color:#2b91af>HashSet</span>&lt;<span style=color:#2b91af>char</span>&gt; {
</span></span><span style=display:flex><span>    string.chars().collect()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// Vec&lt;T&gt; -&gt; BTreeSet&lt;T&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> ordered_unique_items&lt;T: Ord&gt;(vec: Vec&lt;T&gt;) -&gt; <span style=color:#2b91af>BTreeSet</span>&lt;T&gt; {
</span></span><span style=display:flex><span>    vec.into_iter().collect()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// HashMap&lt;K, V&gt; -&gt; LinkedList&lt;(K, V)&gt;
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> entry_list&lt;K, V&gt;(map: <span style=color:#2b91af>HashMap</span>&lt;K, V&gt;) -&gt; <span style=color:#2b91af>LinkedList</span>&lt;(K, V)&gt; {
</span></span><span style=display:flex><span>    map.into_iter().collect()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// and countless more possible examples
</span></span></span></code></pre></div><h2 id=io-traits>I/O Traits</h2><h3 id=read--write>Read & Write</h3><p>Prerequisites</p><ul><li><a href=#self>Self</a></li><li><a href=#methods>Methods</a></li><li><a href=#scope>Scope</a></li><li><a href=#generic-blanket-impls>Generic Blanket Impls</a></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>trait</span> Read {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> read(&amp;<span style=color:#00f>mut</span> self, buf: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> [<span style=color:#2b91af>u8</span>]) -&gt; Result&lt;<span style=color:#2b91af>usize</span>&gt;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// provided default impls
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> read_vectored(&amp;<span style=color:#00f>mut</span> self, bufs: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> [IoSliceMut&lt;&#39;_&gt;]) -&gt; Result&lt;<span style=color:#2b91af>usize</span>&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> is_read_vectored(&amp;self) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>unsafe</span> <span style=color:#00f>fn</span> initializer(&amp;self) -&gt; <span style=color:#2b91af>Initializer</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> read_to_end(&amp;<span style=color:#00f>mut</span> self, buf: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> Vec&lt;<span style=color:#2b91af>u8</span>&gt;) -&gt; Result&lt;<span style=color:#2b91af>usize</span>&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> read_to_string(&amp;<span style=color:#00f>mut</span> self, buf: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> String) -&gt; Result&lt;<span style=color:#2b91af>usize</span>&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> read_exact(&amp;<span style=color:#00f>mut</span> self, buf: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> [<span style=color:#2b91af>u8</span>]) -&gt; Result&lt;()&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> by_ref(&amp;<span style=color:#00f>mut</span> self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> Self
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        Self: Sized;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> bytes(self) -&gt; <span style=color:#2b91af>Bytes</span>&lt;Self&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        Self: Sized;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> chain&lt;R: <span style=color:#2b91af>Read</span>&gt;(self, next: <span style=color:#2b91af>R</span>) -&gt; <span style=color:#2b91af>Chain</span>&lt;Self, R&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        Self: Sized;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> take(self, limit: <span style=color:#2b91af>u64</span>) -&gt; <span style=color:#2b91af>Take</span>&lt;Self&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        Self: Sized;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> Write {
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> write(&amp;<span style=color:#00f>mut</span> self, buf: <span style=color:#00f>&amp;</span>[<span style=color:#2b91af>u8</span>]) -&gt; Result&lt;<span style=color:#2b91af>usize</span>&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> flush(&amp;<span style=color:#00f>mut</span> self) -&gt; Result&lt;()&gt;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// provided default impls
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>fn</span> write_vectored(&amp;<span style=color:#00f>mut</span> self, bufs: <span style=color:#00f>&amp;</span>[IoSlice&lt;&#39;_&gt;]) -&gt; Result&lt;<span style=color:#2b91af>usize</span>&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> is_write_vectored(&amp;self) -&gt; <span style=color:#2b91af>bool</span>;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> write_all(&amp;<span style=color:#00f>mut</span> self, buf: <span style=color:#00f>&amp;</span>[<span style=color:#2b91af>u8</span>]) -&gt; Result&lt;()&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> write_all_vectored(&amp;<span style=color:#00f>mut</span> self, bufs: <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> [IoSlice&lt;&#39;_&gt;]) -&gt; Result&lt;()&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> write_fmt(&amp;<span style=color:#00f>mut</span> self, fmt: <span style=color:#2b91af>Arguments</span>&lt;&#39;_&gt;) -&gt; Result&lt;()&gt;;
</span></span><span style=display:flex><span>    <span style=color:#00f>fn</span> by_ref(&amp;<span style=color:#00f>mut</span> self) -&gt; <span style=color:#00f>&amp;</span><span style=color:#2b91af>mut</span> Self
</span></span><span style=display:flex><span>    <span style=color:#00f>where</span>
</span></span><span style=display:flex><span>        Self: Sized;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Generic blanket impls worth knowing:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>impl</span>&lt;R: <span style=color:#2b91af>Read</span> + ?Sized&gt; Read <span style=color:#00f>for</span> &amp;<span style=color:#00f>mut</span> R;
</span></span><span style=display:flex><span><span style=color:#00f>impl</span>&lt;W: <span style=color:#2b91af>Write</span> + ?Sized&gt; Write <span style=color:#00f>for</span> &amp;<span style=color:#00f>mut</span> W;
</span></span></code></pre></div><p>These say that any mutable reference to a <code>Read</code> type is also <code>Read</code>, and same with <code>Write</code>. This is useful to know because it allows us to use any method with a <code>self</code> receiver as if it had a <code>&mut self</code> receiver. We already went over how to do this and why it&rsquo;s useful in the <code>Iterator</code> trait section so I&rsquo;m not going to repeat it again here.</p><p>I&rsquo;d like to point out that <code>&[u8]</code> impls <code>Read</code> and that <code>Vec&lt;u8></code> impls <code>Write</code> so we can easily unit test our file handling functions using <code>String</code>s which are trivial to convert to <code>&[u8]</code> and from <code>Vec&lt;u8></code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00f>use</span> std::path::Path;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::fs::File;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::io::Read;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::io::Write;
</span></span><span style=display:flex><span><span style=color:#00f>use</span> std::io;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// function we want to test
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> uppercase&lt;R: <span style=color:#2b91af>Read</span>, W: <span style=color:#2b91af>Write</span>&gt;(<span style=color:#00f>mut</span> read: <span style=color:#2b91af>R</span>, <span style=color:#00f>mut</span> write: <span style=color:#2b91af>W</span>) -&gt; Result&lt;(), io::Error&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> buffer = String::new();
</span></span><span style=display:flex><span>    read.read_to_string(&amp;<span style=color:#00f>mut</span> buffer)?;
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> uppercase = buffer.to_uppercase();
</span></span><span style=display:flex><span>    write.write_all(uppercase.as_bytes())?;
</span></span><span style=display:flex><span>    write.flush()?;
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// in actual program we&#39;d pass Files
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> example(in_path: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Path</span>, out_path: <span style=color:#00f>&amp;</span><span style=color:#2b91af>Path</span>) -&gt; Result&lt;(), io::Error&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> in_file = File::open(in_path)?;
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> out_file = File::open(out_path)?;
</span></span><span style=display:flex><span>    uppercase(in_file, out_file)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// however in unit tests we can use Strings!
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>#[test]</span> <span style=color:green>// ✅
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>fn</span> example_test() {
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> in_file: String = <span style=color:#a31515>&#34;i am screaming&#34;</span>.into();
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> <span style=color:#00f>mut</span> out_file: Vec&lt;<span style=color:#2b91af>u8</span>&gt; = Vec::new();
</span></span><span style=display:flex><span>    uppercase(in_file.as_bytes(), &amp;<span style=color:#00f>mut</span> out_file).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#00f>let</span> out_result = String::from_utf8(out_file).unwrap();
</span></span><span style=display:flex><span>    assert_eq!(out_result, <span style=color:#a31515>&#34;I AM SCREAMING&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=conclusion>Conclusion</h2><p>We learned a lot together! Too much in fact. This is us now:</p><p><img src=../assets/jason-jarvis-stdlib-traits.png alt="rust standard library traits"></p><p><em>Artist credit: <a href=https://thejenkinscomic.wordpress.com/2020/05/06/memory/>The Jenkins Comic</a></em></p><h2 id=discuss>Discuss</h2><p>Discuss this article on</p><ul><li><a href=https://github.com/pretzelhammer/rust-blog/discussions>Github</a></li><li><a href=https://www.reddit.com/r/learnrust/comments/ml9shl/tour_of_rusts_standard_library_traits/>learnrust subreddit</a></li><li><a href=https://users.rust-lang.org/t/blog-post-tour-of-rusts-standard-library-traits/57974>official Rust users forum</a></li><li><a href=https://twitter.com/pretzelhammer/status/1379561720176336902>Twitter</a></li><li><a href=https://lobste.rs/s/g27ezp/tour_rust_s_standard_library_traits>lobste.rs</a></li><li><a href=https://www.reddit.com/r/rust/comments/mmrao0/tour_of_rusts_standard_library_traits/>rust subreddit</a></li></ul><h2 id=notifications>Notifications</h2><p>Get notified when the next blog post get published by</p><ul><li><a href=https://twitter.com/pretzelhammer>Following pretzelhammer on Twitter</a> or</li><li>Watching this repo&rsquo;s releases (click <code>Watch</code> -> click <code>Custom</code> -> select <code>Releases</code> -> click <code>Apply</code>)</li></ul><h2 id=further-reading>Further Reading</h2><ul><li><a href=./sizedness-in-rust.md>Sizedness in Rust</a></li><li><a href=./common-rust-lifetime-misconceptions.md>Common Rust Lifetime Misconceptions</a></li><li><a href=./learning-rust-in-2020.md>Learning Rust in 2020</a></li><li><a href=./too-many-brainfuck-compilers.md>Learn Assembly with Entirely Too Many Brainfuck Compilers</a></li></ul><p>source:<a href=https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md>Tour of Rust&rsquo;s Standard Library Traits</a></p></div><footer class=post-footer><div class=post-tags><a href=https://zhimoe.github.io/tags/code rel=tag title=code>#code#</a>
<a href=https://zhimoe.github.io/tags/rust rel=tag title=rust>#rust#</a></div><div class=post-nav><div class=article-copyright><div class=article-copyright-info><p><span>文章：</span><a href=https://zhimoe.github.io/post/tour-of-rusts-standard-library-traits/> Tour of Rusts Standard Library Traits[翻译] by zhimoe</a></p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作不易，打赏作者 ^_^</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=https://zhimoe.github.io/img/wechat-pay.jpg alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=https://zhimoe.github.io/img/ali-pay.jpg alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://zhimoe.github.io/post/hangzhou-house-tip/ rel=next title=买房装修总结><i class="fa fa-chevron-left"></i> 买房装修总结</a></div><div class="post-nav-prev post-nav-item"><a href=https://zhimoe.github.io/post/py-tips-for-impatient-dev/ rel=prev title="Py Tips for Impatient Dev">Py Tips for Impatient Dev
<i class="fa fa-chevron-right"></i></a></div></div><div id=disqus_thread></div><script>var disqus_config=function(){this.page.url="https://zhimoe.github.io/post/tour-of-rusts-standard-library-traits/",this.page.identifier="https://zhimoe.github.io/post/tour-of-rusts-standard-library-traits/"};(function(){var e=document,t=e.createElement("script");t.src="https://zhimoe.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>文章目录</li><li class=sidebar-nav-overview data-target=site-overview>站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=https://zhimoe.github.io/img/avatar.png alt=zhimoe><p class=site-author-name itemprop=name>zhimoe</p><p class="site-description motion-element" itemprop=description>Captain your own Ship.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=https://zhimoe.github.io/post/><span class=site-state-item-count>63</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=https://zhimoe.github.io/categories/><span class=site-state-item-count>4</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=https://zhimoe.github.io/tags/><span class=site-state-item-count>39</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/zhimoe/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span>
<span class=links-of-author-item><a href=https://www.zhihu.com/question/21142149/answer/52383396 target=_blank title=ZhiHu><i class="fa fa-fw fa-globe"></i>
ZhiHu</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class=links-of-blogroll-title><i class="fa fa-fw fa-external-link"></i>
书签</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://learngitbranching.js.org/ title=可视化学习Git target=_blank>可视化学习Git</a></li><li class=links-of-blogroll-item><a href=https://tech.meituan.com/ title=美团技术团队 target=_blank>美团技术团队</a></li><li class=links-of-blogroll-item><a href=https://gallerix.asia/ title=艺术绘画 target=_blank>艺术绘画</a></li><li class=links-of-blogroll-item><a href=https://500px.com/ title=500px target=_blank>500px</a></li><li class=links-of-blogroll-item><a href=https://cheats.rs/ title=RustCheatsheet target=_blank>RustCheatsheet</a></li><li class=links-of-blogroll-item><a href=https://developers.google.com/machine-learning/crash-course/ title=谷歌机器学习课程 target=_blank>谷歌机器学习课程</a></li></ul></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/code>Code</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/java>Java</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/scala>Scala</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/python>Python</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/rust>Rust</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/spring>Spring</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/docker>Docker</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/git>Git</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/aop>Aop</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/aurulent>Aurulent</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#trait-basics>Trait Basics</a><ul><li><a href=#trait-items>Trait Items</a></li><li><a href=#scope>Scope</a></li><li><a href=#derive-macros>Derive Macros</a></li><li><a href=#default-impls>Default Impls</a></li><li><a href=#generic-blanket-impls>Generic Blanket Impls</a></li><li><a href=#subtraits--supertraits>Subtraits & Supertraits</a></li><li><a href=#trait-objects>Trait Objects</a></li><li><a href=#marker-traits>Marker Traits</a></li><li><a href=#auto-traits>Auto Traits</a></li><li><a href=#unsafe-traits>Unsafe Traits</a></li></ul></li><li><a href=#auto-traits-1>Auto Traits</a><ul><li><a href=#send--sync>Send & Sync</a></li><li><a href=#sized>Sized</a></li></ul></li><li><a href=#general-traits>General traits</a><ul><li><a href=#default>Default</a></li><li><a href=#clone>Clone</a></li><li><a href=#copy>Copy</a></li><li><a href=#any>Any</a></li></ul></li><li><a href=#formatting-traits>Formatting Traits</a><ul><li><a href=#display--tostring>Display & ToString</a></li><li><a href=#debug>Debug</a></li></ul></li><li><a href=#operator-traits>Operator Traits</a><ul><li><a href=#comparison-traits>Comparison Traits</a></li><li><a href=#arithmetic-traits>Arithmetic Traits</a></li><li><a href=#closure-traits>Closure Traits</a></li><li><a href=#other-traits>Other Traits</a></li></ul></li><li><a href=#conversion-traits>Conversion Traits</a><ul><li><a href=#from--into>From & Into</a></li></ul></li><li><a href=#error-handling>Error Handling</a><ul><li><a href=#error>Error</a></li></ul></li><li><a href=#conversion-traits-continued>Conversion Traits Continued</a><ul><li><a href=#tryfrom--tryinto>TryFrom & TryInto</a></li><li><a href=#fromstr>FromStr</a></li><li><a href=#asref--asmut>AsRef & AsMut</a></li><li><a href=#borrow--borrowmut>Borrow & BorrowMut</a></li><li><a href=#toowned>ToOwned</a></li></ul></li><li><a href=#iteration-traits>Iteration Traits</a><ul><li><a href=#iterator>Iterator</a></li><li><a href=#intoiterator>IntoIterator</a></li><li><a href=#fromiterator>FromIterator</a></li></ul></li><li><a href=#io-traits>I/O Traits</a><ul><li><a href=#read--write>Read & Write</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#discuss>Discuss</a></li><li><a href=#notifications>Notifications</a></li><li><a href=#further-reading>Further Reading</a></li></ul></nav></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>zhimoe</span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/jquery@2.1.4/dist/jquery.min.js></script>
<script type=text/javascript src=https://zhimoe.github.io/js/search.js></script>
<script type=text/javascript src=https://zhimoe.github.io/js/affix.js></script>
<script type=text/javascript src=https://zhimoe.github.io/js/scrollspy.js></script>
<script type=text/javascript>function detectIE(){let e=window.navigator.userAgent,t=e.indexOf("MSIE "),n=e.indexOf("Trident/"),s=e.indexOf("Edge/");return t>0||n>0||s>0?-1:1}function getCntViewHeight(){let t=$("#content").height(),e=$(window).height();return t>e?t-e:$(document).height()-e}function getScrollbarWidth(){let e=$("<div />").addClass("scrollbar-measure").prependTo("body"),t=e[0],n=t.offsetWidth-t.clientWidth;return e.remove(),n}function registerBackTop(){let t=50,e=$(".back-to-top");$(window).on("scroll",function(){e.toggleClass("back-to-top-on",window.pageYOffset>t);let s=$(window).scrollTop(),o=getCntViewHeight(),i=s/o,n=Math.round(i*100),a=n>100?100:n;$("#scrollpercent>span").html(a)}),e.on("click",function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){let e=".post-toc",s=$(e),t=".active-current";s.on("activate.bs.scrollspy",function(){let t=$(e+" .active").last();n(),t.addClass("active-current")}).on("clear.bs.scrollspy",n),$("body").scrollspy({target:e});function n(){$(e+" "+t).removeClass(t.substring(1))}}function initAffix(){let e=$(".header-inner").height(),t=parseInt($(".main").css("padding-bottom"),10),n=e+10;$(".sidebar-inner").affix({offset:{top:n,bottom:t}}),$(document).on("affixed.bs.affix",function(){updateTOCHeight(document.body.clientHeight-100)})}function initTOCDimension(){let e;$(window).on("resize",function(){e&&clearTimeout(e),e=setTimeout(function(){let e=document.body.clientHeight-100;updateTOCHeight(e)},0)}),updateTOCHeight(document.body.clientHeight-100);let t=getScrollbarWidth();$(".post-toc").css("width","calc(100% + "+t+"px)")}function updateTOCHeight(e){e=e||"auto",$(".post-toc").css("max-height",e)}$(function(){let t=$(".header-inner").height()+10;$("#sidebar").css({"margin-top":t}).show();let n=parseInt($("#sidebar").css("margin-top")),s=parseInt($(".sidebar-inner").css("height")),e=n+s,o=$(".content-wrap").height();o<e&&$(".content-wrap").css("min-height",e),$(".site-nav-toggle").on("click",function(){let e=$(".site-nav"),o=$(".toggle"),t="site-nav-on",i="toggle-close",n=e.hasClass(t),a=n?"slideUp":"slideDown",s=n?"removeClass":"addClass";e.stop()[a]("normal",function(){e[s](t),o[s](i)})}),registerBackTop(),initScrollSpy(),initAffix(),initTOCDimension(),$(".sidebar-nav-toc").click(function(){$(this).addClass("sidebar-nav-active"),$(this).next().removeClass("sidebar-nav-active"),$("."+$(this).next().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)}),$(".sidebar-nav-overview").click(function(){$(this).addClass("sidebar-nav-active"),$(this).prev().removeClass("sidebar-nav-active"),$("."+$(this).prev().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)})})</script><script src=https://cdn.jsdelivr.net/npm/imageviewer@1.1.0/dist/viewer.min.js></script>
<script type=text/javascript>$(function(){$(".post-body").viewer()})</script><script>(function(){let e=document.createElement("script"),n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js";let t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()</script></body></html>
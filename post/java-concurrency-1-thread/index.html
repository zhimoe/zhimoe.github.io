<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Java 并发 1-线程与任务 - 香取海</title>
<meta property="og:title" content="Java 并发 1-线程与任务 - 香取海"><meta name=twitter:card content="summary"><meta property="description" content="线程：任务执行的环境，可以理解为传送带。注意任务必须在线程上面被执行。
[&amp;hellip;] 任务：Runnable/Callable 的实现，可以理解为传送带上面的工序。
[&amp;hellip;] 资源：线程在处理任务具体工序时需要使用的对象，例如信号量，锁，并发集合。需要注意，任务本身描述也是一个对象（即 Runnable/Callable 子类实例），所以在 Runnable &amp;hellip;"><meta property="og:description" content="线程：任务执行的环境，可以理解为传送带。注意任务必须在线程上面被执行。
[&amp;hellip;] 任务：Runnable/Callable 的实现，可以理解为传送带上面的工序。
[&amp;hellip;] 资源：线程在处理任务具体工序时需要使用的对象，例如信号量，锁，并发集合。需要注意，任务本身描述也是一个对象（即 Runnable/Callable 子类实例），所以在 Runnable &amp;hellip;"><meta name=twitter:image content="https://jsd.cdn.zzko.cn/gh/zhimoe/zhimoe.pic@main/pic/java-thread-lifecycle.4w2mxew710c0.webp"><link rel=stylesheet href=../../css/style.css><link rel=stylesheet href=../../css/fonts.css><link rel=stylesheet href=../../css/custom.css><link rel=icon type=image/png href=../../img/logo.png><link rel=apple-touch-icon href=../../img/logo.png><link rel=apple-touch-icon-precomposed href=../../img/logo.png></head><body class="single post"><div class=crop-h></div><div class=crop-v></div><div class=crop-c></div><nav class="nav-top small"><div class=logo><a href=../../>香取海</a></div><div class=menu><span class=active><a href=../../post/>博客</a></span>
<span><a href=../../categories/%E7%BC%96%E7%A8%8B/>编程</a></span>
<span><a href=../../categories/%E7%BF%BB%E8%AF%91/>翻译</a></span>
<span><a href=../../categories/%E9%9A%8F%E6%83%B3/>随想</a></span>
<span><a href=../../search/>搜索</a></span></div></nav><div class=article-meta><h1 class=title>Java 并发 1-线程与任务</h1><h3 class=meta-line><span><span class=date>2016-01-01</span>
</span><span class=term><a href=../../categories/%E7%BC%96%E7%A8%8B/ class=term-cat>编程</a>
<a href=../../tags/java/ class=term-tag>#java </a><a href=../../tags/%E5%B9%B6%E5%8F%91/ class=term-tag>#并发</a></span></h3></div><div class=main><nav id=TableOfContents><ul><li><a href=#基本概念>基本概念</a></li><li><a href=#任务>任务</a></li><li><a href=#线程-thread>线程 Thread</a></li><li><a href=#threadjoin-方法>Thread.join 方法</a></li><li><a href=#executorservice>ExecutorService</a></li><li><a href=#线程池如何实现复用的>线程池如何实现复用的</a></li><li><a href=#completionservice>CompletionService</a></li></ul></nav><h3 id=基本概念>基本概念</h3><p>线程：任务执行的环境，可以理解为传送带。注意任务必须在线程上面被执行。</p><p>任务：Runnable/Callable 的实现，可以理解为传送带上面的工序。</p><p>资源：线程在处理任务具体工序时需要使用的对象，例如信号量，锁，并发集合。需要注意，任务本身描述也是一个对象（即 Runnable/Callable 子类实例），所以在 Runnable 代码里面你会看到 synchronized(this) 的用法，就是把任务描述本身当作一个资源，甚至 Thread 内部也可以将当前 thread 对象当做资源。</p><h3 id=任务>任务</h3><p>多线程编程的核心元素就是任务，任务是独立的活动，不依赖其他任务的状态、结果、以及边界效应。定义任务的内容使用 Runnable 和 Callable。</p><p>Runnable 接口表示没有返回的一个过程（procedure），没有受检异常；<br>Callable 接口的 call 方法会返回一个结果，并有可能抛出受检异常。如果要表示没有返回值，可以使用<code>Callable&lt;Void></code>，但是不鼓励使用这个代替 Runnable，当一个任务内容没有返回值，只是利用副作用时，应该优先使用 Runable，使得含义清晰，并且 JDK 中<code>ScheduledExecutorService</code>也有只能接收 Runable 的方法。</p><p>Future 接口描述了任务的生命周期，并提供方法获得任务执行的结果。该接口有一个实现类：<code>FutureTask</code>.该类的实例一定和一个具体任务相关。<code>ExecutorService</code>所有的 submit 方法都会返回一个 Future 实例。你也可以直接通过 FutureTask 构造函数将 Runnable/Callable 对象构建成一个 FutureTask 实例，该实例将管理该任务的生命周期。</p><p>注意，FutureTask 实现了 Runnable 和 Future（通过实现 RunnableFuture 接口），所以既可以使用 ExecutorService，也可以使用 Thread 执行 FutureTask 任务内容。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#177500>// FutureTask 接口关系</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>interface</span> <span style=color:#3f6e75>RunnableFuture</span><span style=color:#000>&lt;</span><span style=color:#000>V</span><span style=color:#000>&gt;</span> <span style=color:#a90d91>extends</span> <span style=color:#000>Runnable</span>, <span style=color:#000>Future</span><span style=color:#000>&lt;</span><span style=color:#000>V</span><span style=color:#000>&gt;</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>public</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>FutureTask</span><span style=color:#000>&lt;</span><span style=color:#000>V</span><span style=color:#000>&gt;</span> <span style=color:#a90d91>implements</span> <span style=color:#000>RunnableFuture</span><span style=color:#000>&lt;</span><span style=color:#000>V</span><span style=color:#000>&gt;</span> 
</span></span></code></pre></div><h3 id=线程-thread>线程 Thread</h3><p>创建一个线程的方法是 new Thread()，但是向线程提交任务的方式有两种：一是直接继承 Thread 将任务编码在自定义 Thread 的 run 方法里面；二是将 Runnable 实例传递给 Thread 构造函数，区别只不过是否将任务绑定在线程实例上而已，第二种方式更灵活实现了线程与任务的解耦，权责分明。<br>启动线程使用 t.start()，注意，如果是调用 t.run() 是在当前线程中执行任务，不是新线程。</p><p>线程的生命周期</p><p><img src=https://jsd.cdn.zzko.cn/gh/zhimoe/zhimoe.pic@main/pic/java-thread-lifecycle.4w2mxew710c0.webp alt=线程生命周期></p><p>详细说明参考<a href=https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/03%20%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8%206%20%E7%A7%8D%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%EF%BC%9F.md>Java 并发编程</a></p><h3 id=threadjoin-方法>Thread.join 方法</h3><p>当调用 t.join 时，调用线程（calling thread）会暂停，一直到线程 t 终止或者抛出一个 InterruptedException。</p><pre><code>The join() method may also return if the referenced thread was interrupted.
In this case, the join method throws an InterruptedException.
</code></pre><h3 id=executorservice>ExecutorService</h3><p>执行器框架，root 接口是 Executor，只有一个 execute 方法执行 runnable 实例。更常用是子接口 ExecutorService，除了可以执行 runnable,callable，还可以 invoke 一个 callable 集合：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#000>&lt;!--</span> <span style=color:#000>ExecutorService</span> <span style=color:#000>methods</span> <span style=color:#000>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>&lt;</span><span style=color:#000>T</span><span style=color:#000>&gt;</span> <span style=color:#000>List</span><span style=color:#000>&lt;</span><span style=color:#000>Future</span><span style=color:#000>&lt;</span><span style=color:#000>T</span><span style=color:#000>&gt;&gt;</span> <span style=color:#000>invokeAll</span>(<span style=color:#000>Collection</span><span style=color:#000>&lt;</span><span style=color:#000>?</span> <span style=color:#a90d91>extends</span> <span style=color:#000>Callable</span><span style=color:#000>&lt;</span><span style=color:#000>T</span><span style=color:#000>&gt;&gt;</span> <span style=color:#000>tasks</span>)
</span></span><span style=display:flex><span><span style=color:#000>&lt;</span><span style=color:#000>T</span><span style=color:#000>&gt;</span> <span style=color:#000>T</span> <span style=color:#000>invokeAny</span>(<span style=color:#000>Collection</span><span style=color:#000>&lt;</span><span style=color:#000>?</span> <span style=color:#a90d91>extends</span> <span style=color:#000>Callable</span><span style=color:#000>&lt;</span><span style=color:#000>T</span><span style=color:#000>&gt;&gt;</span> <span style=color:#000>tasks</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>&lt;</span><span style=color:#000>T</span><span style=color:#000>&gt;</span> <span style=color:#000>Future</span><span style=color:#000>&lt;</span><span style=color:#000>T</span><span style=color:#000>&gt;</span> <span style=color:#000>submit</span>(<span style=color:#000>Callable</span><span style=color:#000>&lt;</span><span style=color:#000>T</span><span style=color:#000>&gt;</span> <span style=color:#000>task</span>)
</span></span><span style=display:flex><span><span style=color:#000>Future</span><span style=color:#000>&lt;</span><span style=color:#000>?</span><span style=color:#000>&gt;</span> <span style=color:#000>submit</span>(<span style=color:#000>Runnable</span> <span style=color:#000>task</span>)
</span></span></code></pre></div><h4 id=scheduledexecutorservice>ScheduledExecutorService</h4><p>The ScheduledExecutorService interface supplements the methods of its parent ExecutorService with schedule, which<br>executes a Runnable or Callable task after a specified delay. In addition, the interface defines scheduleAtFixedRate and<br>scheduleWithFixedDelay, which executes specified tasks repeatedly, at defined intervals.</p><p>scheduleAtFixedRate: 第一次是 initialDelay 后执行，第二次是 initialDelay + 1 * period 后执行，类推。</p><p>scheduleWithFixedDelay: 是前面任务执行结束后开始计算间隔计时。</p><p>两个方法都不会并发执行任务，特别是第一个方法，如果任务时间比参数中等待时间 period 长，那么只会延期执行。对于第二个方法，本来就是要等前面结束才执行，所以没有这个问题。两个方法遇到异常，那么后面任务也不会执行，因为任务是重复的，后面也会遇到异常。周期任务可以取消，或者遇到执行器终结才结束。</p><h3 id=线程池如何实现复用的>线程池如何实现复用的</h3><p>其实非常简单 就是 Thread Worker 的 runWorker() 方法中有一个 while 循环不停获取 task 并调用 task.run 方法。后面单开一篇详细介绍。</p><h3 id=completionservice>CompletionService</h3><p>如果有多个任务，那么 ExecutorService 只能不停的轮询 Future 看是否有任务结束，并取得结果.CompletionService 则是另外是自动的告诉你那些任务结果已经准备好。注意构造方法需要一个 ExecutorService</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span># 辅助理解
</span></span><span style=display:flex><span>ExecutorService = incoming queue + worker threads
</span></span><span style=display:flex><span>CompletionService = incoming queue + worker threads + output queue
</span></span></code></pre></div><p><a href=http://stackoverflow.com/questions/4912228/when-should-i-use-a-completionservice-over-an-executorservice>CompletionService 参考</a></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>ExecutorService</span> <span style=color:#000>executor</span> <span style=color:#000>=</span> <span style=color:#000>Executors</span>.<span style=color:#836c28>newFixedThreadPool</span>(<span style=color:#000>numberOfThreadsInThePool</span>);
</span></span><span style=display:flex><span><span style=color:#000>CompletionService</span><span style=color:#000>&lt;</span><span style=color:#000>String</span><span style=color:#000>&gt;</span> <span style=color:#000>completionService</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>ExecutorCompletionService</span><span style=color:#000>&lt;</span><span style=color:#000>String</span><span style=color:#000>&gt;</span>(<span style=color:#000>executor</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>for</span> (<span style=color:#a90d91>final</span> <span style=color:#000>String</span> <span style=color:#000>num</span>: <span style=color:#000>nums</span>) {
</span></span><span style=display:flex><span>  <span style=color:#000>completionService</span>.<span style=color:#836c28>submit</span>(<span style=color:#a90d91>new</span> <span style=color:#000>Task</span>(<span style=color:#000>num</span>)); <span style=color:#177500>//Task is Callable</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a90d91>try</span> {
</span></span><span style=display:flex><span>  <span style=color:#a90d91>for</span> (<span style=color:#a90d91>int</span> <span style=color:#000>t</span> <span style=color:#000>=</span> <span style=color:#000>0</span>, <span style=color:#000>n</span> <span style=color:#000>=</span> <span style=color:#000>nums</span>.<span style=color:#836c28>size</span>(); <span style=color:#000>t</span> <span style=color:#000>&lt;</span> <span style=color:#000>n</span>; <span style=color:#000>t</span><span style=color:#000>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000>Future</span><span style=color:#000>&lt;</span><span style=color:#000>String</span><span style=color:#000>&gt;</span> <span style=color:#000>f</span> <span style=color:#000>=</span> <span style=color:#000>completionService</span>.<span style=color:#836c28>take</span>();
</span></span><span style=display:flex><span>    <span style=color:#000>System</span>.<span style=color:#836c28>out</span>.<span style=color:#836c28>print</span>(<span style=color:#000>f</span>.<span style=color:#836c28>get</span>());
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>} <span style=color:#a90d91>catch</span> (<span style=color:#000>InterruptedException</span> <span style=color:#000>e</span>) {
</span></span><span style=display:flex><span>  <span style=color:#000>Thread</span>.<span style=color:#836c28>currentThread</span>().<span style=color:#836c28>interrupt</span>();
</span></span><span style=display:flex><span>} <span style=color:#a90d91>catch</span> (<span style=color:#000>ExecutionException</span> <span style=color:#000>e</span>) {
</span></span><span style=display:flex><span>  <span style=color:#000>Thread</span>.<span style=color:#836c28>currentThread</span>().<span style=color:#836c28>interrupt</span>();
</span></span><span style=display:flex><span>} <span style=color:#a90d91>finally</span> {
</span></span><span style=display:flex><span>  <span style=color:#a90d91>if</span> (<span style=color:#000>executor</span> <span style=color:#000>!=</span> <span style=color:#a90d91>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000>executor</span>.<span style=color:#836c28>shutdownNow</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=参考书籍>参考书籍：</h4><p>Doug Lea “Concurrent Programming in Java” 2004</p><p>Brian Goetz “java concurrency in practice” 2007</p><p>Venkat “Programming concurrency on the JVM”</p><nav class="post-nav fullwidth"><span>&larr; <a href=../../post/java-aop-example/>Java AOP 举例</a></span>
<span class=post-nav-next><a href=../../post/java-concurrency-2-control/>Java 并发 2-同步与锁</a> &rarr;</span></nav></div><footer class=small><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fix-toc.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/center-img.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/alt-title.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/gh/rstudio/markdown/inst/resources/prism-xcode.css><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js defer></script><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/copy-button.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/copy-button.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/key-buttons.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/key-buttons.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/heading-anchor.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/external-link.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fullwidth.min.js defer></script><hr><p class=nav-bottom><span><a href=https://zhi.moe>xdh</a> © 2024</span>
<span class=menu-bottom><a href=../../categories/>分类</a> <a href=../../tags/>标签</a>
<a href=../../post/index.xml type=application/rss+xml title="RSS feed">订阅</a>
<a href=#>回到顶部</a></span></p></footer></body></html>
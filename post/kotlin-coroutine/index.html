<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Kotlin Coroutine - 香取海</title>
<meta property="og:title" content="Kotlin Coroutine - 香取海"><meta name=twitter:card content="summary"><meta property="description" content="A coroutine is an instance of suspendable computation. 协程是可被挂起的计算的实例。换句话说协程是一个对象，这个对象保存着一段可以切换线程的任务 + 当前执行的状态两部分信息。
日常涉及协程的编码，主要是描述协程的任务和管理多个协程的生命周期、异常处理等。
[&amp;hellip;] Kotlin 使用堆栈帧管理要运行哪个函数以及所有局部变量。挂起协 &amp;hellip;"><meta property="og:description" content="A coroutine is an instance of suspendable computation. 协程是可被挂起的计算的实例。换句话说协程是一个对象，这个对象保存着一段可以切换线程的任务 + 当前执行的状态两部分信息。
日常涉及协程的编码，主要是描述协程的任务和管理多个协程的生命周期、异常处理等。
[&amp;hellip;] Kotlin 使用堆栈帧管理要运行哪个函数以及所有局部变量。挂起协 &amp;hellip;"><link rel=stylesheet href=../../css/style.css><link rel=stylesheet href=../../css/fonts.css><link rel=stylesheet href=../../css/custom.css><link rel=icon type=image/png href=../../img/logo.png><link rel=apple-touch-icon href=../../img/logo.png><link rel=apple-touch-icon-precomposed href=../../img/logo.png></head><body class="single post"><div class=crop-h></div><div class=crop-v></div><div class=crop-c></div><nav class="nav-top small"><div class=logo><a href=../../>香取海</a></div><div class=menu><span class=active><a href=../../post/>博客</a></span>
<span><a href=../../categories/%E7%BC%96%E7%A8%8B/>编程</a></span>
<span><a href=../../categories/%E7%BF%BB%E8%AF%91/>翻译</a></span>
<span><a href=../../categories/%E9%9A%8F%E6%83%B3/>随想</a></span>
<span><a href=../../search/>搜索</a></span></div></nav><div class=article-meta><h1 class=title>Kotlin Coroutine</h1><h3 class=meta-line><span><span class=date>2023-04-30</span>
</span><span class=term><a href=../../categories/%E7%BC%96%E7%A8%8B/ class=term-cat>编程</a>
<a href=../../tags/code/ class=term-tag>#code</a></span></h3></div><div class=main><nav id=TableOfContents><ul><li><a href=#问题场景>问题场景</a></li><li><a href=#suspend-关键字>suspend 关键字</a></li><li><a href=#coroutine-builder>coroutine builder</a></li><li><a href=#结构化并发>结构化并发</a></li><li><a href=#dispatcher>Dispatcher</a></li><li><a href=#coroutinecontext>CoroutineContext</a></li><li><a href=#coroutinescope>CoroutineScope</a></li><li><a href=#flow>Flow</a></li><li><a href=#channel>Channel</a></li><li><a href=#其他常用函数>其他常用函数</a></li><li><a href=#coroutinestart-函数>Coroutine.start 函数</a></li></ul></nav><pre><code>A coroutine is an instance of suspendable computation. 
</code></pre><p>协程是可被挂起的计算的实例。换句话说协程是一个对象，这个对象保存着一段可以切换线程的任务 + 当前执行的状态两部分信息。<br>日常涉及协程的编码，主要是描述协程的任务和管理多个协程的生命周期、异常处理等。</p><p>Kotlin 使用堆栈帧管理要运行哪个函数以及所有局部变量。挂起协程时，系统会复制并保存当前的堆栈帧以供稍后使用。恢复时，会将堆栈帧从其保存位置复制回来，然后函数再次开始运行。即使代码可能看起来像普通的顺序阻塞请求，协程也能确保网络请求避免阻塞主线程。</p><h3 id=问题场景>问题场景</h3><p>假设现在有个场景，根据用户 id 调用两个外部接口获取用户的姓名和公司名称，拼接后返回。<br>由于两个外部接口耗时较高，直接的思路就是使用两个线程来发送请求然后等待请求全部响应后拼接响应值。</p><h4 id=方式-1-java-的-callable>方式 1 Java 的 Callable</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#177500>// 定义两个 Callable 来异步执行方法</span>
</span></span><span style=display:flex><span><span style=color:#000>Callable</span><span style=color:#000>&lt;</span><span style=color:#000>String</span><span style=color:#000>&gt;</span> <span style=color:#000>getUserName</span> <span style=color:#000>=</span> () <span style=color:#000>-&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#177500>// 模拟调用耗时方法获取用户名</span>
</span></span><span style=display:flex><span>    <span style=color:#000>Thread</span>.<span style=color:#836c28>sleep</span>(<span style=color:#000>1000</span>); 
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#c41a16>&#34;John&#34;</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>Callable</span><span style=color:#000>&lt;</span><span style=color:#000>String</span><span style=color:#000>&gt;</span> <span style=color:#000>getCompany</span> <span style=color:#000>=</span> () <span style=color:#000>-&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#177500>// 模拟调用耗时方法获取公司名</span>
</span></span><span style=display:flex><span>    <span style=color:#000>Thread</span>.<span style=color:#836c28>sleep</span>(<span style=color:#000>1000</span>);
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#c41a16>&#34;Doe Corp.&#34;</span>; 
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>// 使用 ExecutorService 执行两个 Callable 并获取 Future</span>
</span></span><span style=display:flex><span><span style=color:#000>ExecutorService</span> <span style=color:#000>executor</span> <span style=color:#000>=</span> <span style=color:#000>Executors</span>.<span style=color:#836c28>newFixedThreadPool</span>(<span style=color:#000>2</span>);
</span></span><span style=display:flex><span><span style=color:#000>Future</span><span style=color:#000>&lt;</span><span style=color:#000>String</span><span style=color:#000>&gt;</span> <span style=color:#000>nameFuture</span> <span style=color:#000>=</span> <span style=color:#000>executor</span>.<span style=color:#836c28>submit</span>(<span style=color:#000>getUserName</span>);
</span></span><span style=display:flex><span><span style=color:#000>Future</span><span style=color:#000>&lt;</span><span style=color:#000>String</span><span style=color:#000>&gt;</span> <span style=color:#000>companyFuture</span> <span style=color:#000>=</span> <span style=color:#000>executor</span>.<span style=color:#836c28>submit</span>(<span style=color:#000>getCompany</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>// 在主线程中获取结果并合并</span>
</span></span><span style=display:flex><span><span style=color:#000>String</span> <span style=color:#000>name</span> <span style=color:#000>=</span> <span style=color:#000>nameFuture</span>.<span style=color:#836c28>get</span>();    
</span></span><span style=display:flex><span><span style=color:#000>String</span> <span style=color:#000>company</span> <span style=color:#000>=</span> <span style=color:#000>companyFuture</span>.<span style=color:#836c28>get</span>();
</span></span><span style=display:flex><span><span style=color:#000>String</span> <span style=color:#000>info</span> <span style=color:#000>=</span> <span style=color:#000>name</span> <span style=color:#000>+</span> <span style=color:#c41a16>&#34;, &#34;</span> <span style=color:#000>+</span> <span style=color:#000>company</span>;
</span></span><span style=display:flex><span><span style=color:#000>System</span>.<span style=color:#836c28>out</span>.<span style=color:#836c28>println</span>(<span style=color:#000>info</span>); <span style=color:#177500>// John, Doe Corp.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>executor</span>.<span style=color:#836c28>shutdown</span>();
</span></span></code></pre></div><h4 id=方式-2-java-的-completablefuture>方式 2 Java 的 CompletableFuture</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#177500>// 定义两个异步操作</span>
</span></span><span style=display:flex><span><span style=color:#000>CompletableFuture</span><span style=color:#000>&lt;</span><span style=color:#000>String</span><span style=color:#000>&gt;</span> <span style=color:#000>getUserName</span> <span style=color:#000>=</span> <span style=color:#000>CompletableFuture</span>.<span style=color:#836c28>supplyAsync</span>(() <span style=color:#000>-&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#000>Thread</span>.<span style=color:#836c28>sleep</span>(<span style=color:#000>1000</span>);
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#c41a16>&#34;John&#34;</span>;
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>CompletableFuture</span><span style=color:#000>&lt;</span><span style=color:#000>String</span><span style=color:#000>&gt;</span> <span style=color:#000>getCompany</span> <span style=color:#000>=</span> <span style=color:#000>CompletableFuture</span>.<span style=color:#836c28>supplyAsync</span>(() <span style=color:#000>-&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#000>Thread</span>.<span style=color:#836c28>sleep</span>(<span style=color:#000>1000</span>);
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#c41a16>&#34;Doe Corp.&#34;</span>;
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>// 使用 thenCombine 合并两个异步操作的结果</span>
</span></span><span style=display:flex><span><span style=color:#000>CompletableFuture</span><span style=color:#000>&lt;</span><span style=color:#000>String</span><span style=color:#000>&gt;</span> <span style=color:#000>combined</span> <span style=color:#000>=</span> <span style=color:#000>getUserName</span>.<span style=color:#836c28>thenCombine</span>(<span style=color:#000>getCompany</span>, (<span style=color:#000>name</span>, <span style=color:#000>company</span>) <span style=color:#000>-&gt;</span> <span style=color:#000>name</span> <span style=color:#000>+</span> <span style=color:#c41a16>&#34;, &#34;</span> <span style=color:#000>+</span> <span style=color:#000>company</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>// 获取最终结果</span>
</span></span><span style=display:flex><span><span style=color:#000>String</span> <span style=color:#000>result</span> <span style=color:#000>=</span> <span style=color:#000>combined</span>.<span style=color:#836c28>get</span>(); 
</span></span><span style=display:flex><span><span style=color:#000>System</span>.<span style=color:#836c28>out</span>.<span style=color:#836c28>println</span>(<span style=color:#000>result</span>); <span style=color:#177500>// John, Doe Corp.</span>
</span></span></code></pre></div><h4 id=方式-3-kotlin-的-coroutine>方式 3 Kotlin 的 Coroutine</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a90d91>suspend</span> <span style=color:#a90d91>fun</span> <span style=color:#000>getUserName</span>(): <span style=color:#000>String</span> {
</span></span><span style=display:flex><span>    <span style=color:#000>delay</span>(<span style=color:#1c01ce>1000</span>)  <span style=color:#177500>// 模拟调用耗时方法
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>return</span> <span style=color:#c41a16>&#34;John&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>suspend</span> <span style=color:#a90d91>fun</span> <span style=color:#000>getCompany</span>(): <span style=color:#000>String</span> {
</span></span><span style=display:flex><span>    <span style=color:#000>delay</span>(<span style=color:#1c01ce>1000</span>)  <span style=color:#177500>// 模拟调用耗时方法
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>return</span> <span style=color:#c41a16>&#34;Doe Corp.&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>fun</span> <span style=color:#000>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#177500>// 使用 async 并发调用两个 suspend 函数
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>val</span> <span style=color:#000>name</span> = <span style=color:#000>async</span> { <span style=color:#000>getUserName</span>() }
</span></span><span style=display:flex><span>    <span style=color:#a90d91>val</span> <span style=color:#000>company</span> = <span style=color:#000>async</span> { <span style=color:#000>getCompany</span>() }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#177500>// 使用 await 等待两个任务完成并获取结果
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>val</span> <span style=color:#000>nameResult</span> = <span style=color:#000>name</span>.<span style=color:#000>await</span>()  
</span></span><span style=display:flex><span>    <span style=color:#a90d91>val</span> <span style=color:#000>companyResult</span> = <span style=color:#000>company</span>.<span style=color:#000>await</span>()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#000>println</span>(<span style=color:#c41a16>&#34;</span><span style=color:#c41a16>$nameResult</span><span style=color:#c41a16>, </span><span style=color:#c41a16>$companyResult</span><span style=color:#c41a16>&#34;</span>) <span style=color:#177500>// John, Doe Corp. 
</span></span></span><span style=display:flex><span><span style=color:#177500></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>// 或者使用 awaitAll
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>suspend</span> <span style=color:#a90d91>fun</span> <span style=color:#000>fetchTwoDocs</span>() =        <span style=color:#177500>// called on any Dispatcher (any thread, possibly Main)
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>coroutineScope</span> {
</span></span><span style=display:flex><span>        <span style=color:#a90d91>val</span> <span style=color:#000>deferreds</span> = <span style=color:#000>listOf</span>(     <span style=color:#177500>// fetch two docs at the same time
</span></span></span><span style=display:flex><span><span style=color:#177500></span>            <span style=color:#000>async</span> { <span style=color:#000>fetchDoc</span>(<span style=color:#1c01ce>1</span>) },  <span style=color:#177500>// async returns a result for the first doc
</span></span></span><span style=display:flex><span><span style=color:#177500></span>            <span style=color:#000>async</span> { <span style=color:#000>fetchDoc</span>(<span style=color:#1c01ce>2</span>) }   <span style=color:#177500>// async returns a result for the second doc
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        )
</span></span><span style=display:flex><span>        <span style=color:#000>deferreds</span>.<span style=color:#000>awaitAll</span>()        <span style=color:#177500>// use awaitAll to wait for both network requests
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#177500>// The awaitAll function should be preferred over map { it.await() }
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    }
</span></span></code></pre></div><h3 id=suspend-关键字>suspend 关键字</h3><p>suspend 函数是协程中的任务描述部分，suspend 关键字只是一个语法提示，告诉函数调用者该函数可能被切换线程，同理，也只能在 suspend 函数内部调用其他 suspend 函数，例如上面的 delay.</p><p>编译器和 IDE 根据 suspend 关键字来做一个语法提示与校验。</p><h3 id=coroutine-builder>coroutine builder</h3><p>利用 suspend fun 只能描述任务/函数，还需要使用 coroutine builder 来创建协程。<br><code>launch</code>函数会创建一个协程返回一个<code>Job</code>不包含协程结果信息。<code>async</code>函数也创建一个协程返回<code>Deferred</code>-类似 Future 包含协程的未来计算结果。可以通过<code>Deferred</code>对象的 await 方法获取结果值。<br>所有的 coroutine builder 都是<code>CoroutineScope</code>的扩展函数，因为任何协程的生命周期都由对应的<code>CoroutineScope</code>对象管理。后面会看到有些方法会默认创建<code>CoroutineScope</code>对象。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a90d91>val</span> <span style=color:#000>time</span> = <span style=color:#000>measureTimeMillis</span> {
</span></span><span style=display:flex><span>    <span style=color:#a90d91>val</span> <span style=color:#000>one</span> = <span style=color:#000>async</span> { <span style=color:#000>doSomethingUsefulOne</span>() }
</span></span><span style=display:flex><span>    <span style=color:#a90d91>val</span> <span style=color:#000>two</span> = <span style=color:#000>async</span> { <span style=color:#000>doSomethingUsefulTwo</span>() }
</span></span><span style=display:flex><span>    <span style=color:#000>println</span>(<span style=color:#c41a16>&#34;The answer is </span><span style=color:#c41a16>${one.await() + two.await()}</span><span style=color:#c41a16>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#000>println</span>(<span style=color:#c41a16>&#34;Completed in </span><span style=color:#c41a16>$time</span><span style=color:#c41a16> ms&#34;</span>)
</span></span></code></pre></div><p><code>start = CoroutineStart.LAZY</code>的 async 协程只有在被调用<code>start</code>或者<code>await</code>时才会启动。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a90d91>val</span> <span style=color:#000>time</span> = <span style=color:#000>measureTimeMillis</span> {
</span></span><span style=display:flex><span>    <span style=color:#a90d91>val</span> <span style=color:#000>one</span> = <span style=color:#000>async</span>(<span style=color:#000>start</span> = <span style=color:#3f6e75>CoroutineStart</span>.<span style=color:#000>LAZY</span>) { <span style=color:#000>doSomethingUsefulOne</span>() }
</span></span><span style=display:flex><span>    <span style=color:#a90d91>val</span> <span style=color:#000>two</span> = <span style=color:#000>async</span>(<span style=color:#000>start</span> = <span style=color:#3f6e75>CoroutineStart</span>.<span style=color:#000>LAZY</span>) { <span style=color:#000>doSomethingUsefulTwo</span>() }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000>one</span>.<span style=color:#000>start</span>() <span style=color:#177500>// 不会阻塞，直接下一行执行
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>two</span>.<span style=color:#000>start</span>() 
</span></span><span style=display:flex><span>    <span style=color:#000>println</span>(<span style=color:#c41a16>&#34;The answer is </span><span style=color:#c41a16>${one.await() + two.await()}</span><span style=color:#c41a16>&#34;</span>) <span style=color:#177500>//注意，如果没有上面两个 start 的话，那么这两个 await 是先后调用，导致两个协程顺序执行而不是异步
</span></span></span><span style=display:flex><span><span style=color:#177500></span>}
</span></span><span style=display:flex><span><span style=color:#000>println</span>(<span style=color:#c41a16>&#34;Completed in </span><span style=color:#c41a16>$time</span><span style=color:#c41a16> ms&#34;</span>)
</span></span></code></pre></div><h3 id=结构化并发>结构化并发</h3><p>还是上面方式 3 的两个 suspend 函数，如果其中一个方法异常，另一个方法也就没有必要继续执行了，在 Java 多线程目前难以做到（JEP 428 已经实现，参考 jdk19 的 StructuredTaskScope 类）,<br>而在 kotlin 协程中，只需要将两个线程放在同一个<code>CoroutineScope</code>即可实现：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a90d91>fun</span> <span style=color:#000>main</span>() = <span style=color:#000>runBlocking</span>&lt;<span style=color:#000>Unit</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a90d91>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#000>failedConcurrentSum</span>()
</span></span><span style=display:flex><span>    } <span style=color:#a90d91>catch</span>(<span style=color:#000>e</span>: <span style=color:#000>ArithmeticException</span>) {
</span></span><span style=display:flex><span>        <span style=color:#000>println</span>(<span style=color:#c41a16>&#34;Computation failed with ArithmeticException&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>suspend</span> <span style=color:#a90d91>fun</span> <span style=color:#000>failedConcurrentSum</span>(): <span style=color:#000>Int</span> = <span style=color:#000>coroutineScope</span> { <span style=color:#177500>//coroutineScope 函数创建一个新的 scope 
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>val</span> <span style=color:#000>one</span> = <span style=color:#000>async</span>&lt;<span style=color:#000>Int</span>&gt; { 
</span></span><span style=display:flex><span>        <span style=color:#a90d91>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#000>delay</span>(<span style=color:#3f6e75>Long</span>.<span style=color:#000>MAX_VALUE</span>) <span style=color:#177500>// Emulates very long computation
</span></span></span><span style=display:flex><span><span style=color:#177500></span>            <span style=color:#1c01ce>42</span>
</span></span><span style=display:flex><span>        } <span style=color:#a90d91>finally</span> {
</span></span><span style=display:flex><span>            <span style=color:#000>println</span>(<span style=color:#c41a16>&#34;First child was cancelled&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a90d91>val</span> <span style=color:#000>two</span> = <span style=color:#000>async</span>&lt;<span style=color:#000>Int</span>&gt; { 
</span></span><span style=display:flex><span>        <span style=color:#000>println</span>(<span style=color:#c41a16>&#34;Second child throws an exception&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#a90d91>throw</span> <span style=color:#000>ArithmeticException</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#000>one</span>.<span style=color:#000>await</span>() + <span style=color:#000>two</span>.<span style=color:#000>await</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>结构化并发是 kotlin 协程的核心优势之一，只有在你遇到复杂的场景时才能感受到结构化并发的威力与优雅。</p><h3 id=dispatcher>Dispatcher</h3><p>CoroutineDispatcher 用来决定哪个（或几个）线程来运行该协程，可以将协程的执行限制在一个线程或者某个线程池，或者不限制。自带的几个 dispatcher:<br><code>Dispatchers.Main</code>: A coroutine dispatcher that is confined to the Main thread operating with UI objects. Usually such dispatcher is single-threaded.<br><code>Dispatchers.Default</code>: The default CoroutineDispatcher that is used by all standard builders like launch, async, etc. if no dispatcher nor any other ContinuationInterceptor is specified in their context.<br><code>Dispatchers.IO</code>: The CoroutineDispatcher that is designed for offloading blocking IO tasks to a shared pool of threads.<br><code>Dispatchers.Unconfined</code>: A coroutine dispatcher that is not confined to any specific thread. It executes initial continuation of the coroutine in the current call-frame and lets the coroutine resume in whatever thread that is used by the corresponding suspending function, without mandating any specific threading policy.</p><p>注意，即使是同一个函数内的不同行代码也不一定在同一个线程上面执行。</p><p>注意，Dispatcher 实现了 CoroutineContext 接口，所以会看到<code>withContext(Dispatchers.IO) {}</code>用法。</p><h3 id=coroutinecontext>CoroutineContext</h3><p>协程执行时总有带有一个 CoroutineContext，可以理解为就是一个元信息 Map，保存了 Job、coroutine dispatcher 等信息：<br>Job: 控制协程的生命周期。<br>CoroutineDispatcher: 将工作分派到适当的线程。<br>CoroutineName: 协程的名称，可用于调试。<br>CoroutineExceptionHandler: 处理未捕获的异常。</p><p>coroutine builder（async、launch）接收可选的 CoroutineContext 对象参数。CoroutineContext 最常见的用途就是指定协程的 dispatcher.</p><p>在 kotlin 中，<code>CoroutineContext</code>表示协程的 context，包含了多个元素。而<code>CoroutineContext.Element</code>表示 context 的一个元素。类似 map 和 kv 的关系。<br>但是<code>CoroutineContext.Element</code>继承了<code>CoroutineContext</code>，即一个 element 也是一个 context. 这种抽象可以简化一些 API 设计，例如，withContext 函数的参数类型是 CoroutineContext，但是我们常常会传入一个 CoroutineContext.Element 的实现类如 Dispatchers. 由于后者继承了前者，所以这样的使用方式也是被允许的。<br>由于实现了 plus 操作符方法，<code>Job() + Dispatchers.Main</code>也表示一个<code>CoroutineContext</code>。</p><h3 id=coroutinescope>CoroutineScope</h3><p>CoroutineScope 是协程最重要也是最难理解的点。CoroutineScope 给每个协程都定义了一个 scope，用来组织和管理一组协程的生命周期。<br>async 和 launch 也是 CoroutineScope 的扩展函数。很多教程里面直接调用 async 函数其实是使用了 GlobalScope 对象。<br>获取独立的 scope 对象最佳实践是通过 <code>CoroutineScope()</code> 和 <code>MainScope()</code> 工厂函数。一般不建议自己实现<code>CoroutineScope</code>接口。</p><p><code>suspend withContext</code>和<code>suspend coroutineScope</code>函数也叫 scoping function.<br><code>withContext</code>: Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result.<br><code>coroutineScope</code>: Creates a CoroutineScope and calls the specified suspend block with this scope. The provided scope inherits its coroutineContext from the outer scope, but overrides the context&rsquo;s Job.<br><code>withContext</code>比<code>coroutineScope</code>多了一个 context:CoroutineContext 参数。</p><p><code>withContext</code>几个使用示例</p><ol><li>切换到 IO 上下文执行 IO 操作</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a90d91>suspend</span> <span style=color:#a90d91>fun</span> <span style=color:#000>doSomething</span>() {
</span></span><span style=display:flex><span>    <span style=color:#000>withContext</span>(<span style=color:#3f6e75>Dispatchers</span>.<span style=color:#000>IO</span>) {
</span></span><span style=display:flex><span>        <span style=color:#177500>// 在 IO 上下文中执行 IO 密集型代码
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>doNetworkRequest</span>() 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>切换到主线程更新 UI</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a90d91>suspend</span> <span style=color:#a90d91>fun</span> <span style=color:#000>doSomething</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a90d91>val</span> <span style=color:#000>result</span> = <span style=color:#000>withContext</span>(<span style=color:#3f6e75>Dispatchers</span>.<span style=color:#000>Default</span>) {
</span></span><span style=display:flex><span>        <span style=color:#177500>// 在默认上下文中进行计算
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>calculateResult</span>() 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#000>withContext</span>(<span style=color:#3f6e75>Dispatchers</span>.<span style=color:#000>Main</span>) {
</span></span><span style=display:flex><span>        <span style=color:#177500>// 在主线程中更新 UI
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>updateUI</span>(<span style=color:#000>result</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>同时在两个不同上下文中执行任务</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a90d91>suspend</span> <span style=color:#a90d91>fun</span> <span style=color:#000>doSomething</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a90d91>val</span> <span style=color:#000>job1</span> = <span style=color:#3f6e75>GlobalScope</span>.<span style=color:#000>launch</span>(<span style=color:#3f6e75>Dispatchers</span>.<span style=color:#000>IO</span>) {
</span></span><span style=display:flex><span>        <span style=color:#177500>// ...
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    } 
</span></span><span style=display:flex><span>    <span style=color:#a90d91>val</span> <span style=color:#000>job2</span> = <span style=color:#3f6e75>GlobalScope</span>.<span style=color:#000>launch</span>(<span style=color:#3f6e75>Dispatchers</span>.<span style=color:#000>Main</span>) {
</span></span><span style=display:flex><span>        <span style=color:#177500>// ...
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    }
</span></span><span style=display:flex><span>    <span style=color:#000>withContext</span>(<span style=color:#3f6e75>Dispatchers</span>.<span style=color:#000>IO</span>) {
</span></span><span style=display:flex><span>        <span style=color:#000>job1</span>.<span style=color:#000>join</span>()   <span style=color:#177500>// 等待 IO 上下文的任务结束
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    }
</span></span><span style=display:flex><span>    <span style=color:#000>withContext</span>(<span style=color:#3f6e75>Dispatchers</span>.<span style=color:#000>Main</span>) {
</span></span><span style=display:flex><span>        <span style=color:#000>job2</span>.<span style=color:#000>join</span>()   <span style=color:#177500>// 等待主线程的任务结束 
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    } 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>取消上下文切换</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a90d91>suspend</span> <span style=color:#a90d91>fun</span> <span style=color:#000>doSomething</span>() {
</span></span><span style=display:flex><span>    <span style=color:#000>withContext</span>(<span style=color:#000>NonCancellable</span>) { <span style=color:#177500>// 使用 NonCancellable 上下文
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#177500>// 这里的代码块不会被取消
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>doSomething</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#177500>// ...
</span></span></span><span style=display:flex><span><span style=color:#177500></span>}
</span></span></code></pre></div><h4 id=withcontext-vs-async>withContext vs async</h4><p>看上去除了返回值不一样，两者的功能非常相似，都是接收 context 和 block 参数。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#177500>// async
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>fun</span> <span style=color:#000>asyncDemo</span>() = <span style=color:#000>runBlocking</span> {
</span></span><span style=display:flex><span>    <span style=color:#000>println</span>(<span style=color:#c41a16>&#34;I am working&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a90d91>val</span> <span style=color:#000>opOne</span> = <span style=color:#000>async</span>(<span style=color:#000>IO</span>) { <span style=color:#000>operationOne</span>() }.<span style=color:#000>await</span>() <span style=color:#177500>//注意 这里会阻塞等到 operationOne 返回才能继续下一行执行
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>val</span> <span style=color:#000>opTwo</span> = <span style=color:#000>async</span>(<span style=color:#000>IO</span>) { <span style=color:#000>operationTwo</span>() }.<span style=color:#000>await</span>()
</span></span><span style=display:flex><span>    <span style=color:#000>println</span>(<span style=color:#c41a16>&#34;Done working.&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#000>println</span>(<span style=color:#c41a16>&#34;The multiplied result is </span><span style=color:#c41a16>${opOne * opTwo}</span><span style=color:#c41a16>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>// withContext
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>fun</span> <span style=color:#000>withContextDemo</span>() = <span style=color:#000>runBlocking</span> {
</span></span><span style=display:flex><span>    <span style=color:#000>println</span>(<span style=color:#c41a16>&#34;I am working&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a90d91>val</span> <span style=color:#000>opOne</span> = <span style=color:#000>withContext</span>(<span style=color:#000>IO</span>) { <span style=color:#000>operationOne</span>() }
</span></span><span style=display:flex><span>    <span style=color:#a90d91>val</span> <span style=color:#000>opTwo</span> = <span style=color:#000>withContext</span>(<span style=color:#000>IO</span>) { <span style=color:#000>operationTwo</span>() }
</span></span><span style=display:flex><span>    <span style=color:#000>println</span>(<span style=color:#c41a16>&#34;Done working.&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#000>println</span>(<span style=color:#c41a16>&#34;The multiplied result is </span><span style=color:#c41a16>${opOne * opTwo}</span><span style=color:#c41a16>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其实 async 是用于并发异步编程的，上面的 async 使用方式是不推荐的，因为在创建一个协程后立即调用 await 会阻塞当前线程，所以上面 opOne 和 opTwo 是顺序执行。<br>withContext 只是用于 Context 切换。上面的代码其实也可以写成</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a90d91>val</span> <span style=color:#000>result</span> = <span style=color:#000>withContext</span>(<span style=color:#000>IO</span>) { <span style=color:#000>operationOne</span>() + <span style=color:#000>operationTwo</span>() }
</span></span></code></pre></div><h3 id=flow>Flow</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a90d91>fun</span> <span style=color:#000>simple</span>(): <span style=color:#000>Flow</span>&lt;<span style=color:#000>Int</span>&gt; = <span style=color:#000>flow</span> { <span style=color:#177500>// flow builder, no suspend keyword before fun
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>for</span> (<span style=color:#000>i</span> <span style=color:#a90d91>in</span> <span style=color:#1c01ce>1.</span>.<span style=color:#1c01ce>3</span>) {
</span></span><span style=display:flex><span>        <span style=color:#000>delay</span>(<span style=color:#1c01ce>1000</span>) <span style=color:#177500>// pretend we are doing something useful here
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>emit</span>(<span style=color:#000>i</span>) <span style=color:#177500>// emit next value
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>// Collect the flow
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>simple</span>().<span style=color:#000>collect</span> { <span style=color:#a90d91>value</span> <span style=color:#000>-&gt;</span> <span style=color:#000>println</span>(<span style=color:#a90d91>value</span>) }
</span></span><span style=display:flex><span><span style=color:#177500>// We can replace delay with Thread.sleep in the body of simple&#39;s flow { ... } and see that the main thread is blocked in this case.
</span></span></span></code></pre></div><p>Flow 只有在 collect 调用时才计算，也可以中途取消：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a90d91>fun</span> <span style=color:#000>simple</span>(): <span style=color:#000>Flow</span>&lt;<span style=color:#000>Int</span>&gt; = <span style=color:#000>flow</span> { 
</span></span><span style=display:flex><span>    <span style=color:#a90d91>for</span> (<span style=color:#000>i</span> <span style=color:#a90d91>in</span> <span style=color:#1c01ce>1.</span>.<span style=color:#1c01ce>3</span>) {
</span></span><span style=display:flex><span>        <span style=color:#000>delay</span>(<span style=color:#1c01ce>100</span>)          
</span></span><span style=display:flex><span>        <span style=color:#000>println</span>(<span style=color:#c41a16>&#34;Emitting </span><span style=color:#c41a16>$i</span><span style=color:#c41a16>&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#000>emit</span>(<span style=color:#000>i</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>fun</span> <span style=color:#000>main</span>() = <span style=color:#000>runBlocking</span>&lt;<span style=color:#000>Unit</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#000>withTimeoutOrNull</span>(<span style=color:#1c01ce>250</span>) { <span style=color:#177500>// Timeout after 250ms 
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>simple</span>().<span style=color:#000>collect</span> { <span style=color:#a90d91>value</span> <span style=color:#000>-&gt;</span> <span style=color:#000>println</span>(<span style=color:#a90d91>value</span>) } 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#000>println</span>(<span style=color:#c41a16>&#34;Done&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#177500>// only collected 1 2 
</span></span></span></code></pre></div><p>除了 <code>flow</code> 还有 <code>flowOf(1,2,3)</code> 、 <code>coll.asFlow()</code> 等 flow builder 函数。<br>operator: <code>transform</code> <code>take</code> <code>collect</code> <code>toList/toSet</code> <code>first</code> <code>reduce</code> <code>fold - reduce with initial value</code></p><p><code>flowOn</code> change the context of a flow:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>fun simple(): Flow&lt;Int&gt; = flow {
</span></span><span style=display:flex><span>    for (i in 1..3) {
</span></span><span style=display:flex><span>        Thread.sleep(100) // pretend we are computing it in CPU-consuming way
</span></span><span style=display:flex><span>        log(&#34;Emitting $i&#34;)
</span></span><span style=display:flex><span>        emit(i) // emit next value
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}.flowOn(Dispatchers.Default) // RIGHT way to change context for CPU-consuming code in flow builder
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fun main() = runBlocking&lt;Unit&gt; {
</span></span><span style=display:flex><span>    simple().collect { value -&gt;
</span></span><span style=display:flex><span>        log(&#34;Collected $value&#34;) 
</span></span><span style=display:flex><span>    } 
</span></span><span style=display:flex><span>}            
</span></span></code></pre></div><p>如果 collect 函数比 flow 的 emit 还慢的话，可以使用<code>buffer</code>将 flow 提前生成</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a90d91>val</span> <span style=color:#000>time</span> = <span style=color:#000>measureTimeMillis</span> {
</span></span><span style=display:flex><span>    <span style=color:#000>simple</span>() <span style=color:#177500>// 100ms for each element
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        .<span style=color:#000>buffer</span>() <span style=color:#177500>// buffer emissions, don&#39;t wait
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        .<span style=color:#000>collect</span> { <span style=color:#a90d91>value</span> <span style=color:#000>-&gt;</span> 
</span></span><span style=display:flex><span>            <span style=color:#000>delay</span>(<span style=color:#1c01ce>300</span>) <span style=color:#177500>// pretend we are processing it for 300 ms
</span></span></span><span style=display:flex><span><span style=color:#177500></span>            <span style=color:#000>println</span>(<span style=color:#a90d91>value</span>) 
</span></span><span style=display:flex><span>        } 
</span></span><span style=display:flex><span>}   
</span></span><span style=display:flex><span><span style=color:#000>println</span>(<span style=color:#c41a16>&#34;Collected in </span><span style=color:#c41a16>$time</span><span style=color:#c41a16> ms&#34;</span>)
</span></span></code></pre></div><h3 id=channel>Channel</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a90d91>val</span> <span style=color:#000>channel</span> = <span style=color:#000>Channel</span>&lt;<span style=color:#000>Int</span>&gt;()
</span></span><span style=display:flex><span><span style=color:#000>launch</span> {
</span></span><span style=display:flex><span>    <span style=color:#a90d91>for</span> (<span style=color:#000>x</span> <span style=color:#a90d91>in</span> <span style=color:#1c01ce>1.</span>.<span style=color:#1c01ce>5</span>) <span style=color:#000>channel</span>.<span style=color:#000>send</span>(<span style=color:#000>x</span> * <span style=color:#000>x</span>)
</span></span><span style=display:flex><span>    <span style=color:#000>channel</span>.<span style=color:#000>close</span>() <span style=color:#177500>// we&#39;re done sending
</span></span></span><span style=display:flex><span><span style=color:#177500></span>}
</span></span><span style=display:flex><span><span style=color:#177500>// here we print received values using `for` loop (until the channel is closed)
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>for</span> (<span style=color:#000>y</span> <span style=color:#a90d91>in</span> <span style=color:#000>channel</span>) <span style=color:#000>println</span>(<span style=color:#000>y</span>)
</span></span><span style=display:flex><span><span style=color:#000>println</span>(<span style=color:#c41a16>&#34;Done!&#34;</span>)
</span></span></code></pre></div><h3 id=其他常用函数>其他常用函数</h3><p><code>runBlocking</code>的签名<code>actual fun &lt;T> runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -> T): T</code><br>看着和 withContext 非常相似，但是 withContext 是 suspend 函数，runBlocking 不是。<br>runBlocking 运行一个新的协程，并可中断地阻塞当前线程，直到协程完成。此函数不应在协程中使用。它旨在将常规的阻塞代码与挂起风格编写的库连接起来，以便在 main 函数和测试中使用。</p><p>前面说过，所有的协程都应该在一个 CoroutineScope 下面被管理。在<code>runBlocking {}</code>大括号内部写代码时 IDE 会提示你当前 this 的 type 是 CoroutineScope，这个 scope 实际是 runBlocking 方法内构建的 BlockingCoroutine 对象。<br>由于<code>AbstractCoroutine</code>接口继承了<code>CoroutineScope</code>，所以 BlockingCoroutine 也是一个 CoroutineScope 实例。</p><p><code>kotlin.system.measureTimeMillis</code> Executes the given block and returns elapsed time in milliseconds.</p><p><code>delay</code> Delays coroutine for a given time without blocking a thread and resumes it after a specified time.</p><p><code>suspend fun yield()</code> Yields the thread (or thread pool) of the current coroutine dispatcher to other coroutines on the same dispatcher to run if possible.</p><h3 id=coroutinestart-函数>Coroutine.start 函数</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a90d91>public</span> <span style=color:#a90d91>fun</span> &lt;<span style=color:#3f6e75>R</span>&gt; <span style=color:#000>start</span>(<span style=color:#000>start</span>: <span style=color:#000>CoroutineStart</span>, <span style=color:#a90d91>receiver</span>: <span style=color:#000>R</span>, <span style=color:#000>block</span>: <span style=color:#a90d91>suspend</span> <span style=color:#3f6e75>R</span>.() <span style=color:#000>-&gt;</span> <span style=color:#000>T</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000>start</span>(<span style=color:#000>block</span>, <span style=color:#a90d91>receiver</span>, <span style=color:#a90d91>this</span>) <span style=color:#177500>//这里实际调用的是 CoroutineStart.invoke 方法。this 指的是当前 coroutine
</span></span></span><span style=display:flex><span><span style=color:#177500></span>}
</span></span></code></pre></div><nav class="post-nav fullwidth"><span>&larr; <a href=../../post/python-read-large-excel-file/>使用 OpenPyXL 读写 excel 大文件</a></span>
<span class=post-nav-next><a href=../../post/access-into-wsl2-ubuntu-from-macos/>SSH 访问 Windows 的 WSL2 Ubuntu</a> &rarr;</span></nav></div><footer class=small><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fix-toc.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/gh/rstudio/markdown/inst/resources/prism-xcode.css><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js defer></script><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/copy-button.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/copy-button.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/key-buttons.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/key-buttons.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/heading-anchor.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/ol-id.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fullwidth.min.js defer></script><hr><p class=nav-bottom><span><a href=https://zhi.moe>xdh</a> © 2024</span>
<span class=menu-bottom><a href=../../categories/>分类</a> <a href=../../tags/>标签</a>
<a href=../../post/index.xml type=application/rss+xml title="RSS feed">订阅</a>
<a href=#>回到顶部</a></span></p></footer></body></html>
<!doctype html><html lang=zh dir=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>通过例子学习Clojure - zhimoe</title><meta name=keywords content="读书,代码,架构,JVM,Java,Scala,Python,Clojure,Rust"><meta name=author content="zhimoe"><meta property="og:title" content="通过例子学习Clojure"><meta property="og:site_name" content="zhimoe"><meta property="og:image" content="/img/author.jpg"><meta name=title content="通过例子学习Clojure - zhimoe"><meta name=description content="编程是一门手艺"><link rel="shortcut icon" href=https://zhimoe.github.io/img/favicon.ico><link rel=apple-touch-icon href=https://zhimoe.github.io/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=https://zhimoe.github.io/img/apple-touch-icon.png><link href=https://cdn.jsdelivr.net/npm/typeface-fira-sans@1.1.13/index.min.css rel=stylesheet type=text/css><link href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet type=text/css><link href=https://cdn.jsdelivr.net/npm/imageviewer@1.1.0/dist/viewer.min.css rel=stylesheet><link href=https://zhimoe.github.io/css/main.css rel=stylesheet type=text/css><link href=https://zhimoe.github.io/css/syntax.css rel=stylesheet type=text/css></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class="site-meta custom-logo"><div class=custom-logo-site-title><a href=https://zhimoe.github.io/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>zhimoe</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>the craft of programming</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=https://zhimoe.github.io/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=https://zhimoe.github.io/post/ rel=section><i class="menu-item-icon fa fa-fw fa-list-alt"></i><br>归档</a></li><li class=menu-item><a href=https://zhimoe.github.io/categories/%E7%BC%96%E7%A8%8B/ rel=section><i class="menu-item-icon fa fa-fw fa-wpexplorer"></i><br>编程</a></li><li class=menu-item><a href=https://zhimoe.github.io/categories/%E7%BF%BB%E8%AF%91/ rel=section><i class="menu-item-icon fa fa-fw fa-language"></i><br>翻译</a></li><li class=menu-item><a href=https://zhimoe.github.io/categories/%E9%A1%B9%E7%9B%AE/ rel=section><i class="menu-item-icon fa fa-fw fa-bathtub"></i><br>项目</a></li><li class=menu-item><a href=https://zhimoe.github.io/about/ rel=section><i class="menu-item-icon fa fa-fw fa-grav"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://zhimoe.github.io/post/learn-clojure-by-example/ itemprop=url>通过例子学习Clojure</a></h1><div class=post-meta><span class=post-time><span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2019-05-13">2019-05-13</time></span>
<span class=post-category>&nbsp; | &nbsp;
<span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=https://zhimoe.github.io/categories/%E7%BC%96%E7%A8%8B itemprop=url rel=index style=text-decoration:underline><span itemprop=name>编程</span></a>
&nbsp;</span></span>
<span>|
<span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>2709 字</span></span>
<span>|
<span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>6分钟</span></span></div></header><div class=post-body itemprop=articleBody><p>这份笔记试图打造最强的clojure小抄,keep refactoring it&mldr;</p><h2 id=clojure-入门>clojure 入门</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#00f>ns </span>clj-notes.core
</span></span><span style=display:flex><span>  (<span style=color:#a31515>:gen-class</span>))
</span></span><span style=display:flex><span><span style=color:green>;:gen-class generate java class file</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;Parameter is variable in the declaration of function.</span>
</span></span><span style=display:flex><span><span style=color:green>;Argument is the actual value of this variable that gets passed to function.</span>
</span></span><span style=display:flex><span><span style=color:green>;</span>
</span></span><span style=display:flex><span><span style=color:green>;install leiningen:</span>
</span></span><span style=display:flex><span><span style=color:green>;put lein.bat in your PATH</span>
</span></span><span style=display:flex><span><span style=color:green>;open cmder,run: lein repl</span>
</span></span><span style=display:flex><span><span style=color:green>;start repl,use exit,(exit),(quit) or ctrl+d to quit repl</span>
</span></span><span style=display:flex><span>(println <span style=color:#a31515>&#34;hello clojure&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;Symbols are used to bind names to values</span>
</span></span><span style=display:flex><span><span style=color:green>;&#39; will prevent a form from being evaluated</span>
</span></span><span style=display:flex><span><span style=color:green>;&#39;() same as (quote ())</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;def global variable</span>
</span></span><span style=display:flex><span><span style=color:green>;let local variable binding</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>object <span style=color:#a31515>&#34;light&#34;</span>)
</span></span><span style=display:flex><span>(println object)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[x 10
</span></span><span style=display:flex><span>      y 20
</span></span><span style=display:flex><span>      z 30]
</span></span><span style=display:flex><span>  (+ x y z))
</span></span><span style=display:flex><span><span style=color:green>;=&gt; 60</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;data collection</span>
</span></span><span style=display:flex><span><span style=color:green>;seq is abstract for list vector array</span>
</span></span><span style=display:flex><span><span style=color:green>;map</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>dict {<span style=color:#a31515>:k1</span> <span style=color:#a31515>&#34;v1&#34;</span> <span style=color:#a31515>:k2</span> <span style=color:#a31515>&#34;v2&#34;</span>})
</span></span><span style=display:flex><span><span style=color:green>;keyword as function</span>
</span></span><span style=display:flex><span>(<span style=color:#a31515>:k1</span> dict)                                                  <span style=color:green>;return v1</span>
</span></span><span style=display:flex><span><span style=color:green>;map as function</span>
</span></span><span style=display:flex><span>(dict <span style=color:#a31515>:k1</span>)                                                  <span style=color:green>;return v1</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[v (dict <span style=color:#a31515>:k1</span>)]
</span></span><span style=display:flex><span>  (println v))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;also you can use get on seq or map</span>
</span></span><span style=display:flex><span>(get {<span style=color:#a31515>:a</span> 1 <span style=color:#a31515>:b</span> 2} <span style=color:#a31515>:b</span>)
</span></span><span style=display:flex><span><span style=color:green>;=&gt; 2</span>
</span></span><span style=display:flex><span><span style=color:green>;clojure.core/seq is a function that produces a sequence over the given argument. </span>
</span></span><span style=display:flex><span><span style=color:green>;Data types that clojure.core/seq can produce a sequence over are called seqable:</span>
</span></span><span style=display:flex><span><span style=color:green>;</span>
</span></span><span style=display:flex><span><span style=color:green>;Clojure collections</span>
</span></span><span style=display:flex><span><span style=color:green>;Java maps</span>
</span></span><span style=display:flex><span><span style=color:green>;All iterable types (types that implement java.util.Iterable)</span>
</span></span><span style=display:flex><span><span style=color:green>;Java collections (java.util.Set, java.util.List, etc)</span>
</span></span><span style=display:flex><span><span style=color:green>;Java arrays</span>
</span></span><span style=display:flex><span><span style=color:green>;All types that implement java.lang.CharSequence interface, including Java strings</span>
</span></span><span style=display:flex><span><span style=color:green>;All types that implement clojure.lang.Seqable interface</span>
</span></span><span style=display:flex><span><span style=color:green>;nil</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;function for seq or collection</span>
</span></span><span style=display:flex><span><span style=color:green>;=</span>
</span></span><span style=display:flex><span><span style=color:green>;count</span>
</span></span><span style=display:flex><span><span style=color:green>;conj</span>
</span></span><span style=display:flex><span><span style=color:green>;empty</span>
</span></span><span style=display:flex><span><span style=color:green>;seq</span>
</span></span><span style=display:flex><span><span style=color:green>;first</span>
</span></span><span style=display:flex><span><span style=color:green>;rest</span>
</span></span><span style=display:flex><span><span style=color:green>;next</span>
</span></span><span style=display:flex><span><span style=color:green>;count</span>
</span></span><span style=display:flex><span><span style=color:green>;counted?</span>
</span></span><span style=display:flex><span><span style=color:green>;conj</span>
</span></span><span style=display:flex><span><span style=color:green>;get</span>
</span></span><span style=display:flex><span><span style=color:green>;assoc</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;defn 定义函数</span>
</span></span><span style=display:flex><span><span style=color:green>;defn- 定义ns内私有函数</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>f
</span></span><span style=display:flex><span>  <span style=color:#a31515>&#34;the second line is doc-string&#34;</span>
</span></span><span style=display:flex><span>  {<span style=color:#a31515>:added</span>  <span style=color:#a31515>&#34;1.2&#34;</span>                                            <span style=color:green>;this is attr-map</span>
</span></span><span style=display:flex><span>   <span style=color:#a31515>:static</span> true}
</span></span><span style=display:flex><span>  [param]
</span></span><span style=display:flex><span>  (print <span style=color:#a31515>&#34;hello &#34;</span> param))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(meta (<span style=color:#00f>var </span>f))
</span></span><span style=display:flex><span><span style=color:green>;#&#39; is the reader macro for var and works the exactly same</span>
</span></span><span style=display:flex><span>(meta #<span style=color:#a31515>&#39;f</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;fn create a function</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>f (<span style=color:#00f>fn </span>[] (println <span style=color:#a31515>&#34;this is from fn function&#34;</span>)))
</span></span><span style=display:flex><span><span style=color:green>;#() is the shortcut for fn</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>plus-one #(+ 1 %))
</span></span><span style=display:flex><span><span style=color:green>;% will be replaced with arguments passed to the function</span>
</span></span><span style=display:flex><span><span style=color:green>;%1 is for the first argument, %2 is for the second and so on</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>des
</span></span><span style=display:flex><span>  [{k1 <span style=color:#a31515>:k1</span>}]                                                <span style=color:green>;get :k1 value from argument (map) and binding it to k1(parameter)</span>
</span></span><span style=display:flex><span>  (println <span style=color:#a31515>&#34;destructing in map&#34;</span> k1))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(des dict)                                                  <span style=color:green>;destructing in map v1</span>
</span></span><span style=display:flex><span><span style=color:green>;key don&#39;t have to be keyword</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>currency-of
</span></span><span style=display:flex><span>  [{currency <span style=color:#a31515>&#34;currency&#34;</span>}]
</span></span><span style=display:flex><span>  currency)
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>currency-of
</span></span><span style=display:flex><span>  [{currency <span style=color:#a31515>&#39;currency</span>}]
</span></span><span style=display:flex><span>  currency)
</span></span><span style=display:flex><span><span style=color:green>;if want to destructing multi key,use :keys, in this case,parameter name(currency amount) </span>
</span></span><span style=display:flex><span><span style=color:green>;must same as arguments&#39;s keys(:currency :amount),can not use string as key</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>currency-of
</span></span><span style=display:flex><span>  [{<span style=color:#a31515>:keys</span> [currency amount]}]
</span></span><span style=display:flex><span>  (* currency amount))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(currency-of {<span style=color:#a31515>:currency</span> <span style=color:#a31515>&#34;RMB&#34;</span> <span style=color:#a31515>:amount</span> 100000})              <span style=color:green>;ok</span>
</span></span><span style=display:flex><span>(currency-of {<span style=color:#a31515>&#34;currency&#34;</span> <span style=color:#a31515>&#34;RMB&#34;</span> <span style=color:#a31515>&#34;amount&#34;</span> 100000})            <span style=color:green>;currency will be nil,you will need use :strs or syms</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>currency-strs
</span></span><span style=display:flex><span>  [{<span style=color:#a31515>:strs</span> [currency amount]}]
</span></span><span style=display:flex><span>  currency)
</span></span><span style=display:flex><span>(currency-strs {<span style=color:#a31515>&#34;currency&#34;</span> <span style=color:#a31515>&#34;RMB&#34;</span> <span style=color:#a31515>&#34;amount&#34;</span> 100000})          <span style=color:green>;ok</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>currency-syms
</span></span><span style=display:flex><span>  [{<span style=color:#a31515>:syms</span> [currency amount]}]
</span></span><span style=display:flex><span>  currency)
</span></span><span style=display:flex><span>(currency-syms {<span style=color:#a31515>&#39;currency</span> <span style=color:#a31515>&#34;CNY&#34;</span> <span style=color:#a31515>&#39;amount</span> 100000})            <span style=color:green>;ok</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;use :or to give a default value for parameter</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>currency-or
</span></span><span style=display:flex><span>  [{<span style=color:#a31515>:keys</span> [currency amount] <span style=color:#a31515>:or</span> {currency <span style=color:#a31515>&#34;USD&#34;</span>}}]
</span></span><span style=display:flex><span>  currency)
</span></span><span style=display:flex><span>(currency-or {<span style=color:#a31515>:amount</span> 100000})                              <span style=color:green>;=&gt; &#34;USD&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;use &amp; for Variadic Functions parameters</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>log
</span></span><span style=display:flex><span>  [message &amp; args]
</span></span><span style=display:flex><span>  (println <span style=color:#a31515>&#34;args: &#34;</span> args))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;named params , achieved by Variadic Functions destructing</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>job-info
</span></span><span style=display:flex><span>  [&amp; {<span style=color:#a31515>:keys</span> [name job income] <span style=color:#a31515>:or</span> {job <span style=color:#a31515>&#34;unemployed&#34;</span> income <span style=color:#a31515>&#34;$0.00&#34;</span>}}]
</span></span><span style=display:flex><span>  (<span style=color:#00f>if </span>name
</span></span><span style=display:flex><span>    [name job income]
</span></span><span style=display:flex><span>    (println <span style=color:#a31515>&#34;No name specified&#34;</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;cation! arguments to job-info is not a map</span>
</span></span><span style=display:flex><span>(job-info <span style=color:#a31515>:name</span> <span style=color:#a31515>&#34;Robert&#34;</span> <span style=color:#a31515>:job</span> <span style=color:#a31515>&#34;Engineer&#34;</span>)
</span></span><span style=display:flex><span><span style=color:green>;[&#34;Robert&#34; &#34;Engineer&#34; &#34;$0.00&#34;]</span>
</span></span><span style=display:flex><span><span style=color:green>;Without the use of a variadic argument list, </span>
</span></span><span style=display:flex><span><span style=color:green>;you would have to call the function with a single map argument such as</span>
</span></span><span style=display:flex><span>(job-info {<span style=color:#a31515>:name</span> <span style=color:#a31515>&#34;Robert&#34;</span> <span style=color:#a31515>:job</span> <span style=color:#a31515>&#34;Engineer&#34;</span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;destructuring example</span>
</span></span><span style=display:flex><span><span style=color:green>;https://gist.github.com/john2x/e1dca953548bfdfb9844</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>my-vec [1 2 3])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[[a b c d] my-vec]
</span></span><span style=display:flex><span>  (println a b c d))
</span></span><span style=display:flex><span><span style=color:green>;1 2 3 nil</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[[a b &amp; the-rest] my-vec]
</span></span><span style=display:flex><span>  (println <span style=color:#a31515>&#34;a=&#34;</span> a <span style=color:#a31515>&#34;b=&#34;</span> b <span style=color:#a31515>&#34;the-rest=&#34;</span> the-rest))
</span></span><span style=display:flex><span><span style=color:green>;a= 1 b= 2 the-rest= (3)</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[[<span style=color:#a31515>:as</span> all] my-vec]
</span></span><span style=display:flex><span>  (println all))
</span></span><span style=display:flex><span><span style=color:green>;[1 2 3]</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[[a <span style=color:#a31515>:as</span> all] my-vec]
</span></span><span style=display:flex><span>  (println a all))
</span></span><span style=display:flex><span><span style=color:green>;1 [1 2 3]</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[[a b &amp; the-rest <span style=color:#a31515>:as</span> all] my-vec]
</span></span><span style=display:flex><span>  (println a b the-rest all))
</span></span><span style=display:flex><span><span style=color:green>;1 2 (3) [1 2 3]</span>
</span></span><span style=display:flex><span><span style=color:green>;note: &amp; the-rest convert vector to list,</span>
</span></span><span style=display:flex><span><span style=color:green>;but :as preserves them (as a list, or as a vector)</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>my-vec [<span style=color:#a31515>&#34;first&#34;</span> <span style=color:#a31515>&#34;second&#34;</span>])
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[{a 0 b 1} my-vec]
</span></span><span style=display:flex><span>  (println a b))                                            <span style=color:green>;=&gt; &#34;first second&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;optional arguments to functions</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>foo [a b &amp; more-args]
</span></span><span style=display:flex><span>  (println a b more-args))
</span></span><span style=display:flex><span>(foo <span style=color:#a31515>:a</span> <span style=color:#a31515>:b</span>)                                                 <span style=color:green>;; =&gt; :a :b nil</span>
</span></span><span style=display:flex><span>(foo <span style=color:#a31515>:a</span> <span style=color:#a31515>:b</span> <span style=color:#a31515>:x</span>)                                              <span style=color:green>;; =&gt; :a :b (:x)</span>
</span></span><span style=display:flex><span>(foo <span style=color:#a31515>:a</span> <span style=color:#a31515>:b</span> <span style=color:#a31515>:x</span> <span style=color:#a31515>:y</span> <span style=color:#a31515>:z</span>)                                        <span style=color:green>;; =&gt; :a :b (:x :y :z)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;map destructuring</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>my-hashmap {<span style=color:#a31515>:a</span> <span style=color:#a31515>&#34;A&#34;</span> <span style=color:#a31515>:b</span> <span style=color:#a31515>&#34;B&#34;</span> <span style=color:#a31515>:c</span> <span style=color:#a31515>&#34;C&#34;</span> <span style=color:#a31515>:d</span> <span style=color:#a31515>&#34;D&#34;</span>})
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>my-nested-hashmap {<span style=color:#a31515>:a</span> <span style=color:#a31515>&#34;A&#34;</span> <span style=color:#a31515>:b</span> <span style=color:#a31515>&#34;B&#34;</span> <span style=color:#a31515>:c</span> <span style=color:#a31515>&#34;C&#34;</span> <span style=color:#a31515>:d</span> <span style=color:#a31515>&#34;D&#34;</span> <span style=color:#a31515>:q</span> {<span style=color:#a31515>:x</span> <span style=color:#a31515>&#34;X&#34;</span> <span style=color:#a31515>:y</span> <span style=color:#a31515>&#34;Y&#34;</span> <span style=color:#a31515>:z</span> <span style=color:#a31515>&#34;Z&#34;</span>}})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[{a <span style=color:#a31515>:a</span> d <span style=color:#a31515>:d</span>} my-hashmap]
</span></span><span style=display:flex><span>  (println a d))
</span></span><span style=display:flex><span><span style=color:green>;; =&gt; A D</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[{a <span style=color:#a31515>:a</span>, b <span style=color:#a31515>:b</span>, {x <span style=color:#a31515>:x</span>, y <span style=color:#a31515>:y</span>} <span style=color:#a31515>:q</span>} my-nested-hashmap]
</span></span><span style=display:flex><span>  (println a b x y))
</span></span><span style=display:flex><span><span style=color:green>;; =&gt; A B X Y</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[{a <span style=color:#a31515>:a</span>, b <span style=color:#a31515>:b</span>, not-found <span style=color:#a31515>:not-found</span>, <span style=color:#a31515>:or</span> {not-found <span style=color:#a31515>&#34;:)&#34;</span>}, <span style=color:#a31515>:as</span> all} my-hashmap]
</span></span><span style=display:flex><span>  (println a b not-found all))
</span></span><span style=display:flex><span><span style=color:green>;; =&gt; A B :) {:a A :b B :c C :d D}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;!!! There is no &amp; rest for maps.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;everything but false and nil evaluates to true in Clojure.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;:as bind entire map to param</span>
</span></span><span style=display:flex><span><span style=color:green>;See https://github.com/ring-clojure/ring/wiki/File-Uploads for explanation</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>file-handler
</span></span><span style=display:flex><span>  <span style=color:green>;表示入参是一个map,里面有:params这个key,将:params</span>
</span></span><span style=display:flex><span>  <span style=color:green>;[{{{tempfile :tempfile filename :filename} &#34;file&#34;} :params :as request}]</span>
</span></span><span style=display:flex><span>  [{{{tempfile <span style=color:#a31515>:tempfile</span> filename <span style=color:#a31515>:filename</span>} <span style=color:#a31515>&#34;file&#34;</span>} <span style=color:#a31515>:params</span> <span style=color:#a31515>:as</span> request}]
</span></span><span style=display:flex><span>  (println request)
</span></span><span style=display:flex><span>  (<span style=color:#00f>let </span>[n (num-lines tempfile)]
</span></span><span style=display:flex><span>    (response (str <span style=color:#a31515>&#34;File &#34;</span> filename <span style=color:#a31515>&#34; has &#34;</span> n <span style=color:#a31515>&#34; lines &#34;</span>))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;a simple example</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>first-first
</span></span><span style=display:flex><span>  [[[i _] _]]
</span></span><span style=display:flex><span>  i)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(first-first [[1 2] [3 4]])
</span></span><span style=display:flex><span><span style=color:green>;return 1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;(defn name doc-string? attr-map? [params*] prepost-map? body)</span>
</span></span><span style=display:flex><span><span style=color:green>;(defn name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?)</span>
</span></span><span style=display:flex><span><span style=color:green>;function can have params type hint</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>round
</span></span><span style=display:flex><span>  <span style=color:#a31515>&#34;^double here is type hint&#34;</span>
</span></span><span style=display:flex><span>  [^double d ^long precision]
</span></span><span style=display:flex><span>  (<span style=color:#00f>let </span>[factor (Math/pow 10 precision)]
</span></span><span style=display:flex><span>    (/ (Math/floor (* d factor)) factor)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;不定长参数</span>
</span></span><span style=display:flex><span><span style=color:green>;重载函数</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>bar
</span></span><span style=display:flex><span>  ([a b] (bar a b 100))
</span></span><span style=display:flex><span>  ([a b c] (* a b c)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(bar 5 6)
</span></span><span style=display:flex><span>(bar 5 6 3)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>keyworded-map [&amp; {<span style=color:#a31515>:keys</span> [function sequence]}]
</span></span><span style=display:flex><span>  (map function sequence))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(keyworded-map <span style=color:#a31515>:sequence</span> [1 2 3] <span style=color:#a31515>:function</span> #(+ % 2))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;trampoline</span>
</span></span><span style=display:flex><span><span style=color:green>;trampoline</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;namespace</span>
</span></span><span style=display:flex><span><span style=color:green>;create-ns create a namespace</span>
</span></span><span style=display:flex><span>(create-ns <span style=color:#a31515>&#39;zhi.moe.clj</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;in-ns move to a namespace</span>
</span></span><span style=display:flex><span><span style=color:green>;require loads a namespace and</span>
</span></span><span style=display:flex><span><span style=color:green>;refer refers the namespace.</span>
</span></span><span style=display:flex><span><span style=color:green>;To do these at once, you can use use</span>
</span></span><span style=display:flex><span>(require <span style=color:#a31515>&#39;clojure.by.example</span>)
</span></span><span style=display:flex><span>(clojure.by.example/favorite-language)
</span></span><span style=display:flex><span>(use <span style=color:#a31515>&#39;clojure.by.example</span>)
</span></span><span style=display:flex><span><span style=color:green>;you can rename namespace</span>
</span></span><span style=display:flex><span>(require &#39;[clojure.by.example <span style=color:#a31515>:as</span> temp-ns])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;ns macro creates a new namespace and gives you an opportunity to load other namespaces at the creation time</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;import java class</span>
</span></span><span style=display:flex><span>(import java.util.Date)
</span></span><span style=display:flex><span>(println (str  (<span style=color:#00f>new </span>Date)))
</span></span><span style=display:flex><span><span style=color:green>;Wed Jul 24 22:55:24 CST 2019</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;boolean</span>
</span></span><span style=display:flex><span><span style=color:green>;In Clojure, everything except false and nil are true.</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>if </span>1
</span></span><span style=display:flex><span>  (println <span style=color:#a31515>&#34;it is true&#34;</span>)
</span></span><span style=display:flex><span>  (println <span style=color:#a31515>&#34;will never print&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;if</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>if </span>true
</span></span><span style=display:flex><span>  (println <span style=color:#a31515>&#34;executed when true&#34;</span>)
</span></span><span style=display:flex><span>  (println <span style=color:#a31515>&#34;executed when false&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;use do to execute multi expressions</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>if </span>true
</span></span><span style=display:flex><span>  (do
</span></span><span style=display:flex><span>    (println <span style=color:#a31515>&#34;one&#34;</span>)
</span></span><span style=display:flex><span>    (println <span style=color:#a31515>&#34;two&#34;</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;if-let:</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>positive-number [numbers]
</span></span><span style=display:flex><span>  (if-let [pos-nums (not-empty (filter pos? numbers))]
</span></span><span style=display:flex><span>    pos-nums
</span></span><span style=display:flex><span>    <span style=color:#a31515>&#34;no positive numbers&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;when when-let case cond condp</span>
</span></span><span style=display:flex><span><span style=color:green>;</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>cond-test
</span></span><span style=display:flex><span>  [n]
</span></span><span style=display:flex><span>  (cond
</span></span><span style=display:flex><span>    (= n 1) <span style=color:#a31515>&#34;n is 1&#34;</span>
</span></span><span style=display:flex><span>    (and (&gt; n 3) (&lt; n 10)) <span style=color:#a31515>&#34;n is over 3 and under 10&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a31515>:else</span> <span style=color:#a31515>&#34;n is other&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(cond-test 1000)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;string</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[first <span style=color:#a31515>&#34;Hirokuni&#34;</span>
</span></span><span style=display:flex><span>      last <span style=color:#a31515>&#34;Kim&#34;</span>]
</span></span><span style=display:flex><span>  (str <span style=color:#a31515>&#34;My name is &#34;</span> first <span style=color:#a31515>&#34; &#34;</span> last))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;format</span>
</span></span><span style=display:flex><span>(format <span style=color:#a31515>&#34;My name is %s %s&#34;</span> <span style=color:#a31515>&#34;Hirokuni&#34;</span> <span style=color:#a31515>&#34;Kim&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;power function</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>power
</span></span><span style=display:flex><span>  [x n]
</span></span><span style=display:flex><span>  (reduce * (repeat n x)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;bigint,N is a literal for bigint</span>
</span></span><span style=display:flex><span>(+ 9223372036854775807 10N)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;list conj nth count</span>
</span></span><span style=display:flex><span>&#39;(1 2 3)
</span></span><span style=display:flex><span><span style=color:green>;vector conj nth count .indexOf</span>
</span></span><span style=display:flex><span>[1 2 3]
</span></span><span style=display:flex><span>(.indexOf [1 2 3] 4)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(count [1 2])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;set conj nth count disj sort contains? subset? superset?</span>
</span></span><span style=display:flex><span>#{1 2 3}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;map assoc merge keys vals</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[os {<span style=color:#a31515>:Apple</span> <span style=color:#a31515>&#34;Mac&#34;</span> <span style=color:#a31515>:Microsoft</span> <span style=color:#a31515>&#34;Windows&#34;</span>}]
</span></span><span style=display:flex><span>  (get os <span style=color:#a31515>:Apple</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(assoc {<span style=color:#a31515>:Apple</span> <span style=color:#a31515>&#34;Mac&#34;</span> <span style=color:#a31515>:Microsoft</span> <span style=color:#a31515>&#34;Windows&#34;</span>} <span style=color:#a31515>:Commodore</span> <span style=color:#a31515>&#34;Amiga&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;Sequences are data types that abstract all more concrete data types with unified functions. </span>
</span></span><span style=display:flex><span><span style=color:green>;These functions are called the Seq library in Clojure.</span>
</span></span><span style=display:flex><span><span style=color:green>;seq first rest cons concat map reduce into</span>
</span></span><span style=display:flex><span><span style=color:green>;To add an element to the head of sequence, use cons.</span>
</span></span><span style=display:flex><span>(cons 4 [1 2 3])
</span></span><span style=display:flex><span>(into [] `(1 2 3))
</span></span><span style=display:flex><span>(reverse [1 2 3])
</span></span><span style=display:flex><span><span style=color:green>;get a sequence of infinite integers with iterate. Be careful, </span>
</span></span><span style=display:flex><span><span style=color:green>;though. Running this example will freeze your terminal since the evaluation of this expression never returns.</span>
</span></span><span style=display:flex><span>(doc iterate)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(doc range)
</span></span><span style=display:flex><span>(repeatedly 5 (<span style=color:#00f>fn </span>[] (println <span style=color:#a31515>&#34;hi!&#34;</span>)))
</span></span><span style=display:flex><span><span style=color:green>;for each</span>
</span></span><span style=display:flex><span>(doseq [animal [<span style=color:#a31515>&#34;cat&#34;</span> <span style=color:#a31515>&#34;dog&#34;</span> <span style=color:#a31515>&#34;horse&#34;</span>]] (println animal))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(take 5 (range 0 100))
</span></span><span style=display:flex><span>(take-while neg? [-3 -2 -1 0 1 2 3])
</span></span><span style=display:flex><span><span style=color:green>;drop will remove the first n elements</span>
</span></span><span style=display:flex><span>(drop 5 (range 0 10))
</span></span><span style=display:flex><span>(drop-while neg? [-3 -2 -1 0 1 2 3])
</span></span><span style=display:flex><span><span style=color:green>;(0 1 2 3)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(remove pos? [-1 -2 3 4])
</span></span><span style=display:flex><span><span style=color:green>;(-1 -2)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(filter pos? [-1 2 3])
</span></span><span style=display:flex><span>(partition-by #(&lt; 3 %) [1 2 3 4 5 6])
</span></span><span style=display:flex><span>(group-by #(&lt; 3 %) [1 2 3 4 5 6 1 2 3])
</span></span><span style=display:flex><span>(println (take 5 (iterate inc 0)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;for compression</span>
</span></span><span style=display:flex><span>(for [x &#39;(1 2 3)]
</span></span><span style=display:flex><span>  (+ 10 x))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(doc for)
</span></span><span style=display:flex><span><span style=color:green>;双重for 循环</span>
</span></span><span style=display:flex><span>(for [x (range 10)
</span></span><span style=display:flex><span>      y (range 20)
</span></span><span style=display:flex><span>      <span style=color:#a31515>:while</span> (&lt; y x)]
</span></span><span style=display:flex><span>  [x y])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;&lt;==&gt; {x | x &gt;0}</span>
</span></span><span style=display:flex><span>(for [x &#39;(-1 1 2)
</span></span><span style=display:flex><span>      <span style=color:#a31515>:when</span> (&gt; x 0)]
</span></span><span style=display:flex><span>  x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(for [x [0 1 2 3 4 5]
</span></span><span style=display:flex><span>      <span style=color:#a31515>:let</span> [y (* x 3)]
</span></span><span style=display:flex><span>      <span style=color:#a31515>:when</span> (even? y)]
</span></span><span style=display:flex><span>  y)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;meta data for function parameters</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>round
</span></span><span style=display:flex><span>  [^double d ^long precision]
</span></span><span style=display:flex><span>  (<span style=color:#00f>let </span>[factor (Math/pow 10 precision)]
</span></span><span style=display:flex><span>    (/ (Math/floor (* d factor)) factor)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;# is Dispatch character that tells the Clojure reader how to interpret the next character using a read table</span>
</span></span><span style=display:flex><span><span style=color:green>;set</span>
</span></span><span style=display:flex><span>#{1 2 3}
</span></span><span style=display:flex><span><span style=color:green>;discard</span>
</span></span><span style=display:flex><span>{<span style=color:#a31515>:a</span> 1, #_#_<span style=color:#a31515>:b</span> 2, <span style=color:#a31515>:c</span> 3}
</span></span><span style=display:flex><span><span style=color:green>;regular expression</span>
</span></span><span style=display:flex><span>(re-matches #<span style=color:#a31515>&#34;^test$&#34;</span> <span style=color:#a31515>&#34;test&#34;</span>)
</span></span><span style=display:flex><span><span style=color:green>;anonymous function</span>
</span></span><span style=display:flex><span>#(println %)
</span></span><span style=display:flex><span><span style=color:green>;var quote</span>
</span></span><span style=display:flex><span>(read-string <span style=color:#a31515>&#34;#&#39;foo&#34;</span>)
</span></span><span style=display:flex><span><span style=color:green>;symbolic values</span>
</span></span><span style=display:flex><span>(/ 1.0 0.0)                                                 <span style=color:green>;##Inf</span>
</span></span><span style=display:flex><span><span style=color:green>;tagged literals</span>
</span></span><span style=display:flex><span>(type #inst <span style=color:#a31515>&#34;2014-05-19T19:12:37.925-00:00&#34;</span>)                <span style=color:green>;java.util.Date</span>
</span></span><span style=display:flex><span><span style=color:green>;meta</span>
</span></span><span style=display:flex><span>(meta #<span style=color:#a31515>&#39;fn-name</span>)
</span></span><span style=display:flex><span><span style=color:green>;reader conditionals </span>
</span></span><span style=display:flex><span>#?(<span style=color:#a31515>:clj</span>     (Clojure expression)
</span></span><span style=display:flex><span>   <span style=color:#a31515>:cljs</span>    (ClojureScript expression)
</span></span><span style=display:flex><span>   <span style=color:#a31515>:cljr</span>    (Clojure CLR expression)
</span></span><span style=display:flex><span>   <span style=color:#a31515>:default</span> (fallthrough expression))
</span></span><span style=display:flex><span><span style=color:green>;#?@ splicing reader conditional</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>build-list []
</span></span><span style=display:flex><span>  (list #?@(<span style=color:#a31515>:clj</span>  [5 6 7 8]
</span></span><span style=display:flex><span>            <span style=color:#a31515>:cljs</span> [1 2 3 4])))                              <span style=color:green>;return [5 6 7 8] when run on clojure</span>
</span></span><span style=display:flex><span><span style=color:green>;#= allows the reader to evaluate an arbitrary form during read time</span>
</span></span><span style=display:flex><span>(read-string <span style=color:#a31515>&#34;#=(+ 3 4)&#34;</span>)                                   <span style=color:green>;7</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;Recursion</span>
</span></span><span style=display:flex><span><span style=color:green>;simple recursion</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>fibo
</span></span><span style=display:flex><span>  <span style=color:#a31515>&#34;this is recursion function&#34;</span>
</span></span><span style=display:flex><span>  [n]
</span></span><span style=display:flex><span>  (<span style=color:#00f>if </span>(or (= n 0) (= n 1))
</span></span><span style=display:flex><span>    n
</span></span><span style=display:flex><span>    (+ (fibo (- n 1)) (fibo (- n 2)))))
</span></span><span style=display:flex><span><span style=color:green>;do not do this!!! take a long time to finish</span>
</span></span><span style=display:flex><span>(fibo 1000)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;use recur</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>fibo-recur [iteration]
</span></span><span style=display:flex><span>  (<span style=color:#00f>let </span>[fibo (<span style=color:#00f>fn </span>[one two n]
</span></span><span style=display:flex><span>               (<span style=color:#00f>if </span>(= iteration n)
</span></span><span style=display:flex><span>                 one
</span></span><span style=display:flex><span>                 (recur two (+ one two) (inc n))))]
</span></span><span style=display:flex><span>    <span style=color:green>;recur re-binds it&#39;s arguments to new values and call the function with the new values</span>
</span></span><span style=display:flex><span>    <span style=color:green>;fibo is an inner function</span>
</span></span><span style=display:flex><span>    (fibo 0N 1N 0)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(fibo-recur 1000)
</span></span><span style=display:flex><span><span style=color:green>;it is really fast</span>
</span></span><span style=display:flex><span><span style=color:green>;notes</span>
</span></span><span style=display:flex><span><span style=color:green>;with simple recursion, each recursive call creates a stack frame which is </span>
</span></span><span style=display:flex><span><span style=color:green>;a data to store the information of the called function on memory.</span>
</span></span><span style=display:flex><span><span style=color:green>;Doing deep recursion requires large memory for stack frames, but since it cannot, </span>
</span></span><span style=display:flex><span><span style=color:green>;we get StackOverflowError</span>
</span></span><span style=display:flex><span><span style=color:green>;尾递归</span>
</span></span><span style=display:flex><span><span style=color:green>;A function is tail recursive when the recursion is happening at the end of it&#39;s definition</span>
</span></span><span style=display:flex><span><span style=color:green>;In other words, a tail recursive function must return itself as it&#39;s returned value.</span>
</span></span><span style=display:flex><span><span style=color:green>;When you use recur, it makes sure you are doing tail recursion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(doc loop)
</span></span><span style=display:flex><span><span style=color:green>;loop/recur is merely a friendly way to write recursion code.</span>
</span></span><span style=display:flex><span><span style=color:green>;All imperative loops can be converted to recursions and all recursions can be converted to loops,</span>
</span></span><span style=display:flex><span><span style=color:green>;so Clojure chose recursions.</span>
</span></span><span style=display:flex><span><span style=color:green>;Although you can write code that looks like an imperative loop with loop/recur,</span>
</span></span><span style=display:flex><span><span style=color:green>;Clojure is doing recursion under the hood.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defmacro </span>unless [test then]
</span></span><span style=display:flex><span>  <span style=color:#a31515>&#34;Evaluates then when test evaluates to be falsey&#34;</span>
</span></span><span style=display:flex><span>  (list <span style=color:#a31515>&#39;if</span> (list <span style=color:#a31515>&#39;not</span> test)
</span></span><span style=display:flex><span>        then))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(macroexpand &#39;(unless false (println <span style=color:#a31515>&#34;hi&#34;</span>)))
</span></span><span style=display:flex><span><span style=color:green>;&#39; quoting</span>
</span></span><span style=display:flex><span><span style=color:green>;` syntax-quoting returns the fully qualified namespace.</span>
</span></span><span style=display:flex><span><span style=color:green>;Using fully qualified namespace is very important in order to avoid name conflicts when defining macro.</span>
</span></span><span style=display:flex><span><span style=color:green>;~ unquote</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>`(+ ~(list 1 2 3))
</span></span><span style=display:flex><span><span style=color:green>;(clojure.core/+ (1 2 3))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>`(+ ~@(list 1 2 3))
</span></span><span style=display:flex><span><span style=color:green>;(clojure.core/+ 1 2 3)</span>
</span></span><span style=display:flex><span><span style=color:green>;The ~@ unquote splice works just like ~ unquote,</span>
</span></span><span style=display:flex><span><span style=color:green>;except it expands a sequence and splice the contents of </span>
</span></span><span style=display:flex><span><span style=color:green>;the sequence into the enclosing syntax-quoted data structure</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;thread first macro</span>
</span></span><span style=display:flex><span>(-&gt; []
</span></span><span style=display:flex><span>    (conj 1)
</span></span><span style=display:flex><span>    (conj 2)
</span></span><span style=display:flex><span>    (conj 3))
</span></span><span style=display:flex><span><span style=color:green>;[1 2 3]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(first (.split (.replace (.toUpperCase <span style=color:#a31515>&#34;a b c d&#34;</span>) <span style=color:#a31515>&#34;A&#34;</span> <span style=color:#a31515>&#34;X&#34;</span>) <span style=color:#a31515>&#34; &#34;</span>))
</span></span><span style=display:flex><span><span style=color:green>;&#34;X&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;;Perhaps easier to read:</span>
</span></span><span style=display:flex><span><span style=color:green>;-&gt; 后面是初始参数,第2行开始每一行是一个函数调用,</span>
</span></span><span style=display:flex><span><span style=color:green>;且上一行的返回值会作为这一行第一个参数(这就是thread first)的first含义</span>
</span></span><span style=display:flex><span><span style=color:green>;这里的thread是管道的意思,而不是并发编程的线程</span>
</span></span><span style=display:flex><span><span style=color:green>;如果省略(),那么野生符号(bare symbol)和keyword都会当作一个函数调用,</span>
</span></span><span style=display:flex><span><span style=color:green>;例如,这里的.toUpperCase是bare symbol,等效于(.toUpperCase ,,,)</span>
</span></span><span style=display:flex><span><span style=color:green>;clojure中 逗号等于空白符,所以上面用,,,表示将会插入的参数(即&#34;a b c d&#34;)</span>
</span></span><span style=display:flex><span>(-&gt; <span style=color:#a31515>&#34;a b c d&#34;</span>
</span></span><span style=display:flex><span>    .toUpperCase
</span></span><span style=display:flex><span>    (.replace <span style=color:#a31515>&#34;A&#34;</span> <span style=color:#a31515>&#34;X&#34;</span>)
</span></span><span style=display:flex><span>    (.split <span style=color:#a31515>&#34; &#34;</span>)
</span></span><span style=display:flex><span>    first)
</span></span><span style=display:flex><span><span style=color:green>;same as follow, ,,, is equals whitespace</span>
</span></span><span style=display:flex><span>(-&gt; <span style=color:#a31515>&#34;a b c d&#34;</span>
</span></span><span style=display:flex><span>    (.toUpperCase,,,)
</span></span><span style=display:flex><span>    (.replace <span style=color:#a31515>&#34;A&#34;</span> <span style=color:#a31515>&#34;X&#34;</span>)
</span></span><span style=display:flex><span>    (.split <span style=color:#a31515>&#34; &#34;</span>)
</span></span><span style=display:flex><span>    first)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;suppose a function</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>calculate []
</span></span><span style=display:flex><span>  (reduce + (map #(* % %) (filter odd? (range 10)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;same as</span>
</span></span><span style=display:flex><span><span style=color:green>;上一行的结果作为最后一个参数插入,这叫thread last</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>calculate* []
</span></span><span style=display:flex><span>  (-&gt;&gt; (range 10)
</span></span><span style=display:flex><span>       (filter odd?,,,)
</span></span><span style=display:flex><span>       (map #(* % %),,,)
</span></span><span style=display:flex><span>       (reduce +,,,)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;如果想要指定每次插入的位置那么需要用 as-&gt;</span>
</span></span><span style=display:flex><span><span style=color:green>;v是每一行的返回值的名称,这样你可以在下一行任意参数位置指定</span>
</span></span><span style=display:flex><span>(as-&gt; [<span style=color:#a31515>:foo</span> <span style=color:#a31515>:bar</span>] v
</span></span><span style=display:flex><span>      (map name v)
</span></span><span style=display:flex><span>      (first v)
</span></span><span style=display:flex><span>      (.substring v 1))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;</span>
</span></span><span style=display:flex><span><span style=color:green>;destructing</span>
</span></span><span style=display:flex><span>({<span style=color:#a31515>:keys</span> [firstname lastname] <span style=color:#a31515>:as</span> person} {<span style=color:#a31515>:firstname</span> <span style=color:#a31515>&#34;John&#34;</span> <span style=color:#a31515>:lastname</span> <span style=color:#a31515>&#34;Smith&#34;</span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;future and deref</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[future-val (future (inc 1))]
</span></span><span style=display:flex><span>  (println (deref future-val)))
</span></span><span style=display:flex><span><span style=color:green>;deref == @</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[future-val (future (inc 1))]
</span></span><span style=display:flex><span>  (println @future-val))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>my-future (future (Thread/sleep 5000)))
</span></span><span style=display:flex><span>(repeatedly 6
</span></span><span style=display:flex><span>            (<span style=color:#00f>fn </span>[]
</span></span><span style=display:flex><span>              (println (realized? my-future))
</span></span><span style=display:flex><span>              (Thread/sleep 1000)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(doc future)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;promise</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>my-promise (promise))
</span></span><span style=display:flex><span><span style=color:green>;you define a promise</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>listen-and-callback (<span style=color:#00f>fn </span>[]
</span></span><span style=display:flex><span>                           (println <span style=color:#a31515>&#34;Start listening...&#34;</span>)
</span></span><span style=display:flex><span>                           (future (println <span style=color:#a31515>&#34;Callback fired: &#34;</span> @my-promise))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>do-time-consuming-job []
</span></span><span style=display:flex><span>  (Thread/sleep 5000)
</span></span><span style=display:flex><span>  (deliver my-promise <span style=color:#a31515>&#34;delivered value&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(listen-and-callback)
</span></span><span style=display:flex><span>(do-time-consuming-job)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;atom is like mutable var in other languages but atom is thread safe</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;ref dosync ref-set alter</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>my-ref (ref 0))
</span></span><span style=display:flex><span>(dosync
</span></span><span style=display:flex><span>  (alter my-ref
</span></span><span style=display:flex><span>         (<span style=color:#00f>fn </span>[current_ref]
</span></span><span style=display:flex><span>           (inc current_ref))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(print @my-ref)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>user (ref {}))
</span></span><span style=display:flex><span>(dosync
</span></span><span style=display:flex><span>  (alter user merge {<span style=color:#a31515>:name</span> <span style=color:#a31515>&#34;Kim&#34;</span>})
</span></span><span style=display:flex><span>  (throw (Exception. <span style=color:#a31515>&#34;something wrong happens!&#34;</span>))
</span></span><span style=display:flex><span>  (alter user merge {<span style=color:#a31515>:age</span> 32}))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>user-record (atom {}))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>do </span>(swap! user-record merge {<span style=color:#a31515>:name</span> <span style=color:#a31515>&#34;Kim&#34;</span>})
</span></span><span style=display:flex><span>    (throw (Exception. <span style=color:#a31515>&#34;something wrong happens!&#34;</span>))
</span></span><span style=display:flex><span>    (swap! user-record merge {<span style=color:#a31515>:age</span> 32}))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;Java</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>new </span>java.util.Date <span style=color:#a31515>&#34;2016/2/19&#34;</span>)
</span></span><span style=display:flex><span>(java.util.Date.)
</span></span><span style=display:flex><span>(java.util.Date. <span style=color:#a31515>&#34;2016/2/19&#34;</span>)
</span></span><span style=display:flex><span>(Math/pow 2 3)                                              <span style=color:green>;static method</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>def </span>rnd (<span style=color:#00f>new </span>java.util.Random))
</span></span><span style=display:flex><span>(<span style=color:#00f>. </span>rnd nextInt 10)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[date1 (<span style=color:#00f>new </span>java.util.Date)
</span></span><span style=display:flex><span>      date2 (<span style=color:#00f>new </span>java.util.Date)]
</span></span><span style=display:flex><span>  (.equals date1 date2))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;(.instanceMember instance args*)</span>
</span></span><span style=display:flex><span><span style=color:green>;(.instanceMember Classname args*)</span>
</span></span><span style=display:flex><span><span style=color:green>;(.-instanceField instance)</span>
</span></span><span style=display:flex><span><span style=color:green>;(Classname/staticMethod args*)</span>
</span></span><span style=display:flex><span><span style=color:green>;Classname/staticField</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;;;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>defn </span>geohash [lat lng]
</span></span><span style=display:flex><span>  (println <span style=color:#a31515>&#34;geohash:&#34;</span> lat lng)
</span></span><span style=display:flex><span>  <span style=color:green>;;this function take two separate values as params.</span>
</span></span><span style=display:flex><span>  <span style=color:green>;;and it return a geohash for that position</span>
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#00f>let </span>[{<span style=color:#a31515>:strs</span> [lat lng] <span style=color:#a31515>:as</span> coord} {<span style=color:#a31515>&#34;lat&#34;</span> 51.503331, <span style=color:#a31515>&#34;lng&#34;</span> -0.119500}]
</span></span><span style=display:flex><span>  (println <span style=color:#a31515>&#34;calculating geohash for coordinates: &#34;</span> coord)
</span></span><span style=display:flex><span>  (geohash lat lng))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>;assoc-in associate使加入</span>
</span></span></code></pre></div></div><footer class=post-footer><div class=post-tags><a href=https://zhimoe.github.io/tags/code rel=tag title=code>#code#</a>
<a href=https://zhimoe.github.io/tags/clojure rel=tag title=clojure>#clojure#</a></div><div class=post-nav><div class=article-copyright><div class=article-copyright-info><p><span>文章：</span><a href=https://zhimoe.github.io/post/learn-clojure-by-example/> 通过例子学习Clojure by zhimoe</a></p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作不易，打赏作者 ^_^</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=https://zhimoe.github.io/img/wechat-pay.jpg alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=https://zhimoe.github.io/img/ali-pay.jpg alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://zhimoe.github.io/post/spring-factorybean-contextaware/ rel=next title="Spring FactoryBean and ContextAware"><i class="fa fa-chevron-left"></i> Spring FactoryBean and ContextAware</a></div><div class="post-nav-prev post-nav-item"><a href=https://zhimoe.github.io/post/elasticsearch-query-dsl/ rel=prev title="理解Elasticsearch Query DSL中的JSON结构">理解Elasticsearch Query DSL中的JSON结构
<i class="fa fa-chevron-right"></i></a></div></div><div id=disqus_thread></div><script>var disqus_config=function(){this.page.url="https://zhimoe.github.io/post/learn-clojure-by-example/",this.page.identifier="https://zhimoe.github.io/post/learn-clojure-by-example/"};(function(){var e=document,t=e.createElement("script");t.src="https://zhimoe.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>文章目录</li><li class=sidebar-nav-overview data-target=site-overview>站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=https://zhimoe.github.io/img/avatar.png alt=zhimoe><p class=site-author-name itemprop=name>zhimoe</p><p class="site-description motion-element" itemprop=description>Captain your own Ship.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=https://zhimoe.github.io/post/><span class=site-state-item-count>64</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=https://zhimoe.github.io/categories/><span class=site-state-item-count>4</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=https://zhimoe.github.io/tags/><span class=site-state-item-count>41</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/zhimoe/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span>
<span class=links-of-author-item><a href=https://www.zhihu.com/question/21142149/answer/52383396 target=_blank title=ZhiHu><i class="fa fa-fw fa-globe"></i>
ZhiHu</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class=links-of-blogroll-title><i class="fa fa-fw fa-external-link"></i>
书签</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://learngitbranching.js.org/ title=可视化学习Git target=_blank>可视化学习Git</a></li><li class=links-of-blogroll-item><a href=https://tech.meituan.com/ title=美团技术团队 target=_blank>美团技术团队</a></li><li class=links-of-blogroll-item><a href=https://gallerix.asia/ title=艺术绘画 target=_blank>艺术绘画</a></li><li class=links-of-blogroll-item><a href=https://500px.com/ title=500px target=_blank>500px</a></li><li class=links-of-blogroll-item><a href=https://cheats.rs/ title=RustCheatsheet target=_blank>RustCheatsheet</a></li><li class=links-of-blogroll-item><a href=https://developers.google.com/machine-learning/crash-course/ title=谷歌机器学习课程 target=_blank>谷歌机器学习课程</a></li></ul></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/code>Code</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/java>Java</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/scala>Scala</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/python>Python</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/rust>Rust</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/spring>Spring</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/docker>Docker</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/git>Git</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/wsl>Wsl</a></li><li class=tagcloud-of-blogroll-item><a href=https://zhimoe.github.io/tags/aop>Aop</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#clojure-入门>clojure 入门</a></li></ul></nav></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>zhimoe</span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/jquery@2.1.4/dist/jquery.min.js></script>
<script type=text/javascript src=https://zhimoe.github.io/js/search.js></script>
<script type=text/javascript src=https://zhimoe.github.io/js/affix.js></script>
<script type=text/javascript src=https://zhimoe.github.io/js/scrollspy.js></script>
<script type=text/javascript>function detectIE(){let e=window.navigator.userAgent,t=e.indexOf("MSIE "),n=e.indexOf("Trident/"),s=e.indexOf("Edge/");return t>0||n>0||s>0?-1:1}function getCntViewHeight(){let t=$("#content").height(),e=$(window).height();return t>e?t-e:$(document).height()-e}function getScrollbarWidth(){let e=$("<div />").addClass("scrollbar-measure").prependTo("body"),t=e[0],n=t.offsetWidth-t.clientWidth;return e.remove(),n}function registerBackTop(){let t=50,e=$(".back-to-top");$(window).on("scroll",function(){e.toggleClass("back-to-top-on",window.pageYOffset>t);let s=$(window).scrollTop(),o=getCntViewHeight(),i=s/o,n=Math.round(i*100),a=n>100?100:n;$("#scrollpercent>span").html(a)}),e.on("click",function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){let e=".post-toc",s=$(e),t=".active-current";s.on("activate.bs.scrollspy",function(){let t=$(e+" .active").last();n(),t.addClass("active-current")}).on("clear.bs.scrollspy",n),$("body").scrollspy({target:e});function n(){$(e+" "+t).removeClass(t.substring(1))}}function initAffix(){let e=$(".header-inner").height(),t=parseInt($(".main").css("padding-bottom"),10),n=e+10;$(".sidebar-inner").affix({offset:{top:n,bottom:t}}),$(document).on("affixed.bs.affix",function(){updateTOCHeight(document.body.clientHeight-100)})}function initTOCDimension(){let e;$(window).on("resize",function(){e&&clearTimeout(e),e=setTimeout(function(){let e=document.body.clientHeight-100;updateTOCHeight(e)},0)}),updateTOCHeight(document.body.clientHeight-100);let t=getScrollbarWidth();$(".post-toc").css("width","calc(100% + "+t+"px)")}function updateTOCHeight(e){e=e||"auto",$(".post-toc").css("max-height",e)}$(function(){let t=$(".header-inner").height()+10;$("#sidebar").css({"margin-top":t}).show();let n=parseInt($("#sidebar").css("margin-top")),s=parseInt($(".sidebar-inner").css("height")),e=n+s,o=$(".content-wrap").height();o<e&&$(".content-wrap").css("min-height",e),$(".site-nav-toggle").on("click",function(){let e=$(".site-nav"),o=$(".toggle"),t="site-nav-on",i="toggle-close",n=e.hasClass(t),a=n?"slideUp":"slideDown",s=n?"removeClass":"addClass";e.stop()[a]("normal",function(){e[s](t),o[s](i)})}),registerBackTop(),initScrollSpy(),initAffix(),initTOCDimension(),$(".sidebar-nav-toc").click(function(){$(this).addClass("sidebar-nav-active"),$(this).next().removeClass("sidebar-nav-active"),$("."+$(this).next().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)}),$(".sidebar-nav-overview").click(function(){$(this).addClass("sidebar-nav-active"),$(this).prev().removeClass("sidebar-nav-active"),$("."+$(this).prev().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)})})</script><script src=https://cdn.jsdelivr.net/npm/imageviewer@1.1.0/dist/viewer.min.js></script>
<script type=text/javascript>$(function(){$(".post-body").viewer()})</script><script>(function(){let e=document.createElement("script"),n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js";let t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()</script></body></html>
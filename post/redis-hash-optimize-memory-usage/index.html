<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用 Redis 的 hash 优化内存使用[翻译] - 香取海</title>
<meta property="og:title" content="使用 Redis 的 hash 优化内存使用[翻译] - 香取海"><meta name=twitter:card content="summary"><meta property="description" content="使用 redis 的 hash 优化内存使用
[&amp;hellip;] 场景：有 3 亿张图片放在对象存储 (DELL ECS/AMAZON EC2) 上面，现在需要保存图片的 id-&amp;gt;用户 id 的映射。最直接的思路是：
[&amp;hellip;] set &amp;#34;media:1155220&amp;#34; &amp;#34;user1&amp;#34; set &amp;#34;media:1155221&amp;#34; &amp;hellip;"><meta property="og:description" content="使用 redis 的 hash 优化内存使用
[&amp;hellip;] 场景：有 3 亿张图片放在对象存储 (DELL ECS/AMAZON EC2) 上面，现在需要保存图片的 id-&amp;gt;用户 id 的映射。最直接的思路是：
[&amp;hellip;] set &amp;#34;media:1155220&amp;#34; &amp;#34;user1&amp;#34; set &amp;#34;media:1155221&amp;#34; &amp;hellip;"><link rel=stylesheet href=../../css/style.css><link rel=stylesheet href=../../css/fonts.css><link rel=stylesheet href=../../css/custom.css><link rel=icon type=image/png href=../../img/logo.png><link rel=apple-touch-icon href=../../img/logo.png><link rel=apple-touch-icon-precomposed href=../../img/logo.png></head><body class="single post"><div class=crop-h></div><div class=crop-v></div><div class=crop-c></div><nav class="nav-top small"><div class=logo><a href=../../>香取海</a></div><div class=menu><span class=active><a href=../../post/>博客</a></span>
<span><a href=../../categories/%E7%BC%96%E7%A8%8B/>编程</a></span>
<span><a href=../../categories/%E7%BF%BB%E8%AF%91/>翻译</a></span>
<span><a href=../../categories/%E9%9A%8F%E6%83%B3/>随想</a></span>
<span><a href=../../search/>搜索</a></span></div></nav><div class=article-meta><h1 class=title>使用 Redis 的 hash 优化内存使用[翻译]</h1><h3 class=meta-line><span><span class=date>2019-03-31</span>
</span><span class=term><a href=../../categories/%E7%BF%BB%E8%AF%91/ class=term-cat>翻译</a>
<a href=../../tags/code/ class=term-tag>#code </a><a href=../../tags/redis/ class=term-tag>#redis</a></span></h3></div><div class=main><p>使用 redis 的 hash 优化内存使用</p><h3 id=问题和方案>问题和方案</h3><p>场景：有 3 亿张图片放在对象存储 (DELL ECS/AMAZON EC2) 上面，现在需要保存图片的 id->用户 id 的映射。最直接的思路是：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#c41a16>&#34;media:1155220&#34;</span> <span style=color:#c41a16>&#34;user1&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#c41a16>&#34;media:1155221&#34;</span> <span style=color:#c41a16>&#34;user2&#34;</span>
</span></span></code></pre></div><p>这样设计 key 之后 3 亿张图片需要 21GB 的内存，因为 redis 的 string 是线性增长的。</p><p>此时可以使用 hash 优化内存使用. hash 是类似 java hashmap 的数据结构：key field1 value1 field2 value2 &mldr;<br>hash 的强大在于它可以只获取一个 field 的 value，而无需返回整个 key.<br>再仔细想想，hash 的 key 可以类比于分库分表的 bucket 概念。</p><p>回到上面的问题，Mike Krieger,Instagram 的创始人<a href=https://engineering.instagram.com/storing-hundreds-of-millions-of-simple-key-value-pairs-in-redis-1091ae80f74c>提出</a>将图片的 id 除以 1000 分片 (sharding) 到 1000 个 hash key 上：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>HSET <span style=color:#c41a16>&#34;mda-bkt:1155&#34;</span> <span style=color:#c41a16>&#34;1155220&#34;</span> <span style=color:#c41a16>&#34;user1&#34;</span> <span style=color:#c41a16>&#34;1155221&#34;</span> <span style=color:#c41a16>&#34;user2&#34;</span>
</span></span><span style=display:flex><span><span style=color:#177500># mda-bkt:1155 是1155220/1000之后得到的bucket.</span>
</span></span><span style=display:flex><span>HGET <span style=color:#c41a16>&#34;mda-bkt:1155&#34;</span> <span style=color:#c41a16>&#34;1155220&#34;</span>
</span></span><span style=display:flex><span><span style=color:#177500># 这里key的前缀*mda-bkt:)只重复了1000次,而上面的string方式重复了3亿次.</span>
</span></span></code></pre></div><p>因为 redis 针对<code>hash list zset</code>三种结构使用了<code>ziplist</code>高效存储方案。</p><p>新的问题又来了，redis 对于<code>ziplist</code>结构的 key 数量有限制的，即<code>hash-max-ziplist-entries</code>的含义是：可使用内部空间优化存储的最多 hash key</p><p>使用<code>ziplist</code>的数据结构有三个<code>list hash zset</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>list-max-ziplist-entries <span style=color:#1c01ce>512</span>
</span></span><span style=display:flex><span>list-max-ziplist-value <span style=color:#1c01ce>64</span>
</span></span><span style=display:flex><span><span style=color:#177500>#Limits for ziplist use with LISTs.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hash-max-ziplist-entries <span style=color:#1c01ce>512</span>
</span></span><span style=display:flex><span>hash-max-ziplist-value <span style=color:#1c01ce>64</span>
</span></span><span style=display:flex><span><span style=color:#177500>#Limits for ziplist use with HASHes (previous versions of Redis used a different name and encoding for this)</span>
</span></span><span style=display:flex><span><span style=color:#177500>#hash-max-zipmap-entries 512 (for Redis &lt; 2.6).</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>zset-max-ziplist-entries <span style=color:#1c01ce>128</span>
</span></span><span style=display:flex><span>zset-max-ziplist-value <span style=color:#1c01ce>64</span>
</span></span><span style=display:flex><span><span style=color:#177500>#Limits for ziplist use with ZSETs.</span>
</span></span></code></pre></div><p>你可以使用<code>debug_object(key)</code>查看你的 key 是否使用了<code>ziplist</code>结构。<br>建议<code>hash-max-ziplist-entries</code>最大设置为 1000，过大会影响 redis 性能。</p><h3 id=参考资料>参考资料</h3><p><a href=https://redis.io/topics/memory-optimization>redis moemory optimize</a><br><a href=https://redislabs.com/ebook/part-2-core-concepts/01chapter-9-reducing-memory-use/9-1-short-structures/9-1-1-the-ziplist-representation/>9.1.1 The ziplist representation-EBOOK – REDIS IN ACTION</a></p><p>source:<a href=https://www.peterbe.com/plog/understanding-redis-hash-max-ziplist-entries>Understanding Redis hash-max-ziplist-entries</a></p><nav class="post-nav fullwidth"><span>&larr; <a href=../../post/scala2-notes/>Scala 学习笔记</a></span>
<span class=post-nav-next><a href=../../post/scala-implicit/>Scala 2 Implicit</a> &rarr;</span></nav></div><footer class=small><link rel=stylesheet href=//cdn.jsdelivr.net/gh/rstudio/markdown/inst/resources/prism-xcode.css><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js defer></script><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/copy-button.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/copy-button.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/key-buttons.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/key-buttons.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/heading-anchor.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/external-link.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fullwidth.min.js defer></script><hr><p class=nav-bottom><span><a href=https://zhi.moe>xdh</a> © 2024</span>
<span class=menu-bottom><a href=../../categories/>分类</a> <a href=../../tags/>标签</a>
<a href=../../post/index.xml type=application/rss+xml title="RSS feed">订阅</a>
<a href=#>回到顶部</a></span></p></footer></body></html>
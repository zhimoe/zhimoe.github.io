<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>单例模式和序列化 - 香取海</title>
<meta property="og:title" content="单例模式和序列化 - 香取海"><meta name=twitter:card content="summary"><meta property="description" content="Java 单例模式的各种写法和序列化
参考资料
[&amp;hellip;] public class Singleton { private static Singleton instance = null private Singleton (){} public static Singleton getInstance() { if(instance == null) instance = new &amp;hellip;"><meta property="og:description" content="Java 单例模式的各种写法和序列化
参考资料
[&amp;hellip;] public class Singleton { private static Singleton instance = null private Singleton (){} public static Singleton getInstance() { if(instance == null) instance = new &amp;hellip;"><link rel=stylesheet href=../../css/style.css><link rel=stylesheet href=../../css/fonts.css><link rel=stylesheet href=../../css/custom.css><link rel=icon type=image/png href=../../img/logo.png><link rel=apple-touch-icon href=../../img/logo.png><link rel=apple-touch-icon-precomposed href=../../img/logo.png></head><body class="single post"><div class=crop-h></div><div class=crop-v></div><div class=crop-c></div><nav class="nav-top small"><div class=logo><a href=../../>香取海</a></div><div class=menu><span class=active><a href=../../post/>博客</a></span>
<span><a href=../../categories/%E7%BC%96%E7%A8%8B/>编程</a></span>
<span><a href=../../categories/%E7%BF%BB%E8%AF%91/>翻译</a></span>
<span><a href=../../categories/%E9%9A%8F%E6%83%B3/>随想</a></span>
<span><a href=../../search/>搜索</a></span></div></nav><div class=article-meta><h1 class=title>单例模式和序列化</h1><h3 class=meta-line><span><span class=date>2016-01-01</span>
</span><span class=term><a href=../../categories/%E7%BC%96%E7%A8%8B/ class=term-cat>编程</a>
<a href=../../tags/java/ class=term-tag>#java </a><a href=../../tags/code/ class=term-tag>#code</a></span></h3></div><div class=main><nav id=TableOfContents><ul><li><a href=#饱汉式>饱汉式</a></li><li><a href=#饿汉式>饿汉式</a></li><li><a href=#静态内部类>静态内部类</a></li><li><a href=#枚举类>枚举类</a></li><li><a href=#双重校验锁>双重校验锁</a></li><li><a href=#序列化>序列化</a></li></ul></nav><p>Java 单例模式的各种写法和序列化<br><a href=http://www.hollischuang.com/archives/205>参考资料</a></p><h3 id=饱汉式>饱汉式</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a90d91>public</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Singleton</span> {  
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#a90d91>static</span> <span style=color:#000>Singleton</span> <span style=color:#000>instance</span> <span style=color:#000>=</span> <span style=color:#a90d91>null</span>  
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#000>Singleton</span> (){}   
</span></span><span style=display:flex><span>	    <span style=color:#a90d91>public</span> <span style=color:#a90d91>static</span> <span style=color:#000>Singleton</span> <span style=color:#000>getInstance</span>() {  
</span></span><span style=display:flex><span>	        <span style=color:#a90d91>if</span>(<span style=color:#000>instance</span> <span style=color:#000>==</span> <span style=color:#a90d91>null</span>)             <span style=color:#000>instance</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>Singleton</span>();         <span style=color:#a90d91>return</span> <span style=color:#000>instance</span>;  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}  <span style=color:#177500>//饱汉式，使用时创建</span>
</span></span></code></pre></div><h3 id=饿汉式>饿汉式</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#177500>//加载时创建对象 static</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>public</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Singleton</span> {  
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#000>Singleton</span> <span style=color:#000>instance</span> <span style=color:#000>=</span> <span style=color:#a90d91>null</span>;  
</span></span><span style=display:flex><span>    <span style=color:#a90d91>static</span> {  
</span></span><span style=display:flex><span>        <span style=color:#000>instance</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>Singleton</span>();  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#000>Singleton</span> (){}  
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#a90d91>static</span> <span style=color:#000>Singleton</span> <span style=color:#000>getInstance</span>() {  
</span></span><span style=display:flex><span>        <span style=color:#a90d91>return</span> <span style=color:#a90d91>this</span>.<span style=color:#836c28>instance</span>;  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><h3 id=静态内部类>静态内部类</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>public class Singleton { 
</span></span><span style=display:flex><span>	private Singleton (){} 
</span></span><span style=display:flex><span>	private static class SingletonHolder {  
</span></span><span style=display:flex><span>            private static final Singleton INSTANCE = new Singleton();  
</span></span><span style=display:flex><span>     }  
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>    public static final Singleton getInstance() {  
</span></span><span style=display:flex><span>      return SingletonHolder.INSTANCE;  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  //这个比较好,线程安全,也达到了延迟加载效果.
</span></span></code></pre></div><h3 id=枚举类>枚举类</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#000>//</span><span style=color:#000>这个是最好的</span> <span style=color:#000>这种方式是</span><span style=color:#000>Effective</span> <span style=color:#000>Java作者Josh</span> <span style=color:#000>Bloch</span> <span style=color:#000>提倡的方式</span>,<span style=color:#000>它不仅能避免多线程同步问题</span>,<span style=color:#000>而且还能防止反序列化重新创建新的对象</span>,<span style=color:#000>可谓是很坚强的壁垒啊</span>
</span></span><span style=display:flex><span>	<span style=color:#000>public</span> <span style=color:#a90d91>enum</span> <span style=color:#000>Singleton</span> {  
</span></span><span style=display:flex><span>    <span style=color:#000>INSTANCE</span>;  
</span></span><span style=display:flex><span>    <span style=color:#000>public</span> <span style=color:#000>void</span> <span style=color:#000>whateverMethod</span>() {  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#000>访问这个单例</span> <span style=color:#000>Singleton</span><span style=color:#000>.</span><span style=color:#000>INSTANCE</span> 
</span></span></code></pre></div><h3 id=双重校验锁>双重校验锁</h3><p>其实是不安全的，多线程开销很大，甚至死锁。原因在于指令重排序。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>	public class Singleton {  
</span></span><span style=display:flex><span>    private volatile static Singleton singleton;  
</span></span><span style=display:flex><span>    private Singleton (){}  
</span></span><span style=display:flex><span>    public static Singleton getSingleton() {  
</span></span><span style=display:flex><span>    if (singleton == null) {  
</span></span><span style=display:flex><span>        synchronized (Singleton.class) {  
</span></span><span style=display:flex><span>        if (singleton == null) {  
</span></span><span style=display:flex><span>            singleton = new Singleton();  
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>    return singleton;  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>	
</span></span></code></pre></div><h3 id=序列化>序列化</h3><p>使用静态内部类举例，只要提供一个 readResolve 方法</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>public class Singleton { 
</span></span><span style=display:flex><span>		private Singleton (){} 
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	     private static class SingletonHolder {  
</span></span><span style=display:flex><span>        private static final Singleton INSTANCE = new Singleton();  
</span></span><span style=display:flex><span>     }  
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>    public static final Singleton getInstance() {  
</span></span><span style=display:flex><span>      return SingletonHolder.INSTANCE;  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>    private Object readResolve() throws ObjectStreamException{         
</span></span><span style=display:flex><span>           return SingletonHolder.INSTANCE;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>无论是实现 Serializable 接口，或是 Externalizable 接口，当从 I/O 流中读取对象时，readResolve() 方法都会被调用到。实际上就是用 readResolve() 中返回的对象直接替换在反序列化过程中创建的对象，而被创建的对象则会被垃圾回收掉。</p><nav class="post-nav fullwidth"><span>&larr; <a href=../../post/java-class-load-super-method-call/>Java类加载过程和子类重写父类方法的调用</a></span>
<span class=post-nav-next><a href=../../post/gradle-buildscript/>理解 Gradle build 脚本结构与语法</a> &rarr;</span></nav></div><footer class=small><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fix-toc.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/gh/rstudio/markdown/inst/resources/prism-xcode.css><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js defer></script><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/copy-button.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/copy-button.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/heading-anchor.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/external-link.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fullwidth.min.js defer></script><hr><p class=nav-bottom><span><a href=https://zhi.moe>xdh</a> © 2024</span>
<span class=menu-bottom><a href=../../categories/>分类</a> <a href=../../tags/>标签</a>
<a href=../../post/index.xml type=application/rss+xml title="RSS feed">订阅</a>
<a href=#>回到顶部</a></span></p></footer></body></html>
<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Java 并发 5-虚拟线程（VirtualThread） - 新街记事</title>
<meta property="og:title" content="Java 并发 5-虚拟线程（VirtualThread） - 新街记事"><meta name=twitter:card content="summary"><meta property="description" content="回调和反应式编程都可以实现系统吞吐量有效提升，但是这两种编程模式存在阅读、编写、调试困难的问题，所以实际项目中还是以线程池为主。但是 java 的线程是平台线程，可以理解为并行线程数最多等于 CPU 核数 (macOS 查看核数sysctl hw.physicalcpu hw.logicalcpu)，并且存在线程内存占用大，上下文切换耗时高问题，所以在高并发请求中表现不如前面两种模式（spring &amp;hellip;"><meta property="og:description" content="回调和反应式编程都可以实现系统吞吐量有效提升，但是这两种编程模式存在阅读、编写、调试困难的问题，所以实际项目中还是以线程池为主。但是 java 的线程是平台线程，可以理解为并行线程数最多等于 CPU 核数 (macOS 查看核数sysctl hw.physicalcpu hw.logicalcpu)，并且存在线程内存占用大，上下文切换耗时高问题，所以在高并发请求中表现不如前面两种模式（spring &amp;hellip;"><meta name=twitter:image content="https://blog.rockthejvm.com/images/virtual-threads/virtual-thread-states.png"><link rel=stylesheet href=../../css/style.css><link rel=stylesheet href=../../css/fonts.css><link rel=stylesheet href=../../css/custom.css><link rel=stylesheet href=https://indestructibletype.com/fonts/Jost.css></head><body class="single post"><div class=crop-h></div><div class=crop-v></div><div class=crop-c></div><nav class="nav-top small"><div class=logo><a href=../../>新街记事</a></div><div class=menu><span class=active><a href=../../post/>博客</a></span>
<span><a href=../../categories/%E7%BC%96%E7%A8%8B/>编程</a></span>
<span><a href=../../categories/%E7%BF%BB%E8%AF%91/>翻译</a></span>
<span><a href=../../categories/%E9%9A%8F%E6%83%B3/>随想</a></span>
<span><a href=../../search/>搜索</a></span></div></nav><div class=article-meta><h1 class=title>Java 并发 5-虚拟线程（VirtualThread）</h1><h3 class=meta-line><span><span class=date>2023-09-13</span>
</span><span class=term><a href=../../categories/%E7%BC%96%E7%A8%8B/ class=term-cat>编程</a>
<a href=../../tags/java/ class=term-tag>#java </a><a href=../../tags/%E5%B9%B6%E5%8F%91/ class=term-tag>#并发 </a><a href=../../tags/virtual-thread/ class=term-tag>#virtual thread</a></span></h3></div><div class=main><nav id=TableOfContents><ul><li><a href=#virtualthread-api>VirtualThread API</a></li><li><a href=#limitations-of-virtualthread>limitations of VirtualThread</a></li><li><a href=#use-virtualthread-in-spring-boot>use VirtualThread in Spring Boot</a></li><li><a href=#use-virtualthread-in-quarkus>use VirtualThread in Quarkus</a></li><li><a href=#internal-and-compare-to-kotlin-coroutine>internal and compare to kotlin coroutine</a></li><li><a href=#参考>参考</a></li></ul></nav><p>回调和反应式编程都可以实现系统吞吐量有效提升，但是这两种编程模式存在阅读、编写、调试困难的问题，所以实际项目中还是以线程池为主。但是 java 的线程是平台线程，可以理解为并行线程数最多等于 CPU 核数 (macOS 查看核数<code>sysctl hw.physicalcpu hw.logicalcpu</code>)，并且存在线程内存占用大，上下文切换耗时高问题，所以在高并发请求中表现不如前面两种模式（spring reactive 和 vertx 模式并没有流行起来）。<br><a href=https://openjdk.org/jeps/444>JEP 444: Virtual Threads</a> 主要目标在优化 IO 密集型任务时创建平台线程会消耗过多内存以及线程上下文切换耗时问题。</p><p>虚拟线程的优势：1. 和线程 API 兼容（大部分兼容）2. 降低应用内存使用，提升系统可用性，减少内存不足异常 OutOfMemoryError: unable to create new native thread 3. 提升代码可读性（相比 reactive 编程）。</p><p>本文是 VirtualThread 快速笔记，包含 API 使用、限制和在 Spring Boot 的实际使用以及与 Kotlin 协程的对比。</p><h3 id=virtualthread-api>VirtualThread API</h3><p>创建虚拟线程有以下方法</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#177500>// 1</span>
</span></span><span style=display:flex><span><span style=color:#000>Runnable</span> <span style=color:#000>task</span> <span style=color:#000>=</span> () <span style=color:#000>-&gt;</span> { <span style=color:#000>System</span>.<span style=color:#836c28>out</span>.<span style=color:#836c28>println</span>(<span style=color:#c41a16>&#34;Hello Virtual Thread!&#34;</span>); };
</span></span><span style=display:flex><span><span style=color:#000>Thread</span>.<span style=color:#836c28>startVirtualThread</span>(<span style=color:#000>task</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>// 2 </span>
</span></span><span style=display:flex><span><span style=color:#000>Thread</span> <span style=color:#000>vThread</span> <span style=color:#000>=</span> <span style=color:#000>Thread</span>.<span style=color:#836c28>ofVirtual</span>().<span style=color:#836c28>start</span>(<span style=color:#000>task</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>// 3</span>
</span></span><span style=display:flex><span><span style=color:#000>Thread</span> <span style=color:#000>vThread</span> <span style=color:#000>=</span> <span style=color:#000>Thread</span>.<span style=color:#836c28>ofVirtual</span>().<span style=color:#836c28>unstarted</span>(<span style=color:#000>task</span>);
</span></span><span style=display:flex><span><span style=color:#000>vThread</span>.<span style=color:#836c28>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>// 4 </span>
</span></span><span style=display:flex><span><span style=color:#000>Executor</span> <span style=color:#000>vExecutor</span> <span style=color:#000>=</span> <span style=color:#000>Executors</span>.<span style=color:#836c28>newVirtualThreadPerTaskExecutor</span>();
</span></span><span style=display:flex><span><span style=color:#000>vExecutor</span>.<span style=color:#836c28>execute</span>(<span style=color:#000>task</span>); <span style=color:#177500>// unlimited virtual threads</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>// 5 newThreadPerTaskExecutor but with VirtualThreadFactory</span>
</span></span><span style=display:flex><span><span style=color:#000>ThreadFactory</span> <span style=color:#000>vThreadFactory</span> <span style=color:#000>=</span> <span style=color:#000>Thread</span>.<span style=color:#836c28>ofVirtual</span>().<span style=color:#836c28>name</span>(<span style=color:#c41a16>&#34;vt-&#34;</span>, <span style=color:#000>1</span>).<span style=color:#836c28>factory</span>();
</span></span><span style=display:flex><span><span style=color:#000>Executor</span> <span style=color:#000>vExecutor</span> <span style=color:#000>=</span> <span style=color:#000>Executors</span>.<span style=color:#836c28>newThreadPerTaskExecutor</span>(<span style=color:#000>vThreadFactory</span>);
</span></span><span style=display:flex><span><span style=color:#000>vExecutor</span>.<span style=color:#836c28>execute</span>(<span style=color:#000>task</span>);
</span></span></code></pre></div><p>虚拟线程相比平台线程，在创建耗时和内存占用具有很大优势。作为对比，同一台机器上创建 1W 个平台线程和虚拟线程。</p><table><thead><tr><th>类型</th><th>创建时间</th><th>内存占用</th></tr></thead><tbody><tr><td>virtual thread</td><td>91 ms</td><td>4.4mb</td></tr><tr><td>platform thread</td><td>998 ms</td><td>14.3gb</td></tr></tbody></table><h3 id=limitations-of-virtualthread>limitations of VirtualThread</h3><p>下面说的 carrier thread 就是执行虚拟线程的系统线程（platform thread）。</p><ol><li><p>Avoid synchronized blocks/methods, use <code>ReentrantLock</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>Object</span> <span style=color:#000>monitor</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>Object</span>();
</span></span><span style=display:flex><span>     <span style=color:#177500>//...</span>
</span></span><span style=display:flex><span>     <span style=color:#a90d91>public</span> <span style=color:#a90d91>void</span> <span style=color:#000>aMethodThatPinTheCarrierThread</span>() <span style=color:#a90d91>throws</span> <span style=color:#000>Exception</span> {
</span></span><span style=display:flex><span>     <span style=color:#177500>// The virtual thread cannot be unmounted because it holds a lock,</span>
</span></span><span style=display:flex><span>     <span style=color:#177500>// so the carrier thread is blocked.</span>
</span></span><span style=display:flex><span>     <span style=color:#177500>// also called pinned thread or pinning</span>
</span></span><span style=display:flex><span>     <span style=color:#a90d91>synchronized</span>(<span style=color:#000>monitor</span>) {
</span></span><span style=display:flex><span>         <span style=color:#000>Thread</span>.<span style=color:#836c28>sleep</span>(<span style=color:#000>1000</span>); 
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span> }
</span></span></code></pre></div></li><li><p>Avoid monopolization. 即避免 CPU 密集型的任务使用虚拟线程。如果一个 task 耗时非常长，那么该虚拟线程对应的 platform thread（即 the carrier thread）无法让出去执行其他任务，JVM 会创建新的线程。这种场景应该使用线程池技术。</p></li><li><p>Cation the carrier thread pool elasticity. 当前发生 1 或者 2 的情况时，JVM 会创建新的系统线程，容易导致系统内存被耗尽。</p></li><li><p>Avoid Object pooling, or reduce <code>ThreadLocal</code> Usage: 因为线程池数量有限制且线程会复用，所以创建比较耗时的对象会被池化以复用。但是虚拟线程不满足线程的这两个假设，池化对象并不能被复用。更糟糕的是，由于虚拟线程个数一般没有限制，每个虚拟线程都有 ThreadLocal 对象的话，可能耗尽 JVM 堆内存。<a href=https://openjdk.org/jeps/429>JEP 429: Scoped Values</a> will fix this.</p></li><li><p>关注线程安全，虚拟线程本质还是多线程编程，和多线程一样需要关注共享状态问题。</p></li></ol><h3 id=use-virtualthread-in-spring-boot>use VirtualThread in Spring Boot</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>@SpringBootApplication</span>
</span></span><span style=display:flex><span><span style=color:#000>@Slf4j</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>public</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>VirtualthreadApplication</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>void</span> <span style=color:#000>main</span>(<span style=color:#000>String</span><span style=color:#000>[]</span> <span style=color:#000>args</span>) {
</span></span><span style=display:flex><span>        <span style=color:#000>SpringApplication</span>.<span style=color:#836c28>run</span>(<span style=color:#000>VirtualthreadApplication</span>.<span style=color:#836c28>class</span>, <span style=color:#000>args</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#000>TomcatProtocolHandlerCustomizer</span><span style=color:#000>&lt;?&gt;</span> <span style=color:#000>protocolHandlerVirtualThreadExecutorCustomizer</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a90d91>return</span> <span style=color:#000>protocolHandler</span> <span style=color:#000>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#000>log</span>.<span style=color:#836c28>info</span>(<span style=color:#c41a16>&#34;Configuring &#34;</span> <span style=color:#000>+</span> <span style=color:#000>protocolHandler</span> <span style=color:#000>+</span> <span style=color:#c41a16>&#34; to use VirtualThreadPerTaskExecutor&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#000>protocolHandler</span>.<span style=color:#836c28>setExecutor</span>(<span style=color:#000>Executors</span>.<span style=color:#836c28>newVirtualThreadPerTaskExecutor</span>());
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=use-virtualthread-in-quarkus>use VirtualThread in Quarkus</h3><p>Using virtual threads in Quarkus is straightforward. You only need to use the <code>@RunOnVirtualThread</code> annotation. It indicates to Quarkus to invoke the annotated method on a virtual thread instead of a regular platform thread.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>@Path</span>(<span style=color:#c41a16>&#34;/greetings&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a90d91>public</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>VirtualThreadApp</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#000>@RestClient</span> <span style=color:#000>RemoteService</span> <span style=color:#000>service</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#000>@GET</span>
</span></span><span style=display:flex><span>  <span style=color:#000>@RunOnVirtualThread</span>
</span></span><span style=display:flex><span>  <span style=color:#a90d91>public</span> <span style=color:#000>String</span> <span style=color:#000>process</span>() {
</span></span><span style=display:flex><span>    <span style=color:#177500>// Runs on a virtual thread because the</span>
</span></span><span style=display:flex><span>    <span style=color:#177500>// method uses the @RunOnVirtualThread annotation.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#177500>// `service` is a rest client, it executes an I/O operation</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>var</span> <span style=color:#000>response</span> <span style=color:#000>=</span> <span style=color:#000>service</span>.<span style=color:#836c28>greetings</span>(); <span style=color:#177500>// Blocking, but this time, it</span>
</span></span><span style=display:flex><span>                                        <span style=color:#177500>// does neither block the carrier thread</span>
</span></span><span style=display:flex><span>                                        <span style=color:#177500>// nor the OS thread.</span>
</span></span><span style=display:flex><span>                                        <span style=color:#177500>// Only the virtual thread is blocked.</span>
</span></span><span style=display:flex><span>	<span style=color:#a90d91>return</span> <span style=color:#000>response</span>.<span style=color:#836c28>toUpperCase</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://quarkus.io/blog/virtual-thread-1/#five-things-you-need-to-know-before-using-virtual-threads-for-everything>When Quarkus meets Virtual Threads</a>)</p><h3 id=internal-and-compare-to-kotlin-coroutine>internal and compare to kotlin coroutine</h3><blockquote><p>A coroutine is an instance of suspendable computation. - Kotlin doc<br>和 kotlin 的协程类似，java 的虚拟线程同样不能自己执行，而是需要挂载到平台线程上面才能执行。下面是虚拟线程的生命周期：</p></blockquote><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#177500>/*
</span></span></span><span style=display:flex><span><span style=color:#177500>    * Virtual thread state and transitions:
</span></span></span><span style=display:flex><span><span style=color:#177500>    *
</span></span></span><span style=display:flex><span><span style=color:#177500>    *      NEW -&gt; STARTED         // Thread.start
</span></span></span><span style=display:flex><span><span style=color:#177500>    *  STARTED -&gt; TERMINATED      // failed to start
</span></span></span><span style=display:flex><span><span style=color:#177500>    *  STARTED -&gt; RUNNING         // first run
</span></span></span><span style=display:flex><span><span style=color:#177500>    *
</span></span></span><span style=display:flex><span><span style=color:#177500>    *  RUNNING -&gt; PARKING         // Thread attempts to park
</span></span></span><span style=display:flex><span><span style=color:#177500>    *  PARKING -&gt; PARKED          // cont.yield successful, thread is parked
</span></span></span><span style=display:flex><span><span style=color:#177500>    *  PARKING -&gt; PINNED          // cont.yield failed, thread is pinned
</span></span></span><span style=display:flex><span><span style=color:#177500>    *
</span></span></span><span style=display:flex><span><span style=color:#177500>    *   PARKED -&gt; RUNNABLE        // unpark or interrupted
</span></span></span><span style=display:flex><span><span style=color:#177500>    *   PINNED -&gt; RUNNABLE        // unpark or interrupted
</span></span></span><span style=display:flex><span><span style=color:#177500>    *
</span></span></span><span style=display:flex><span><span style=color:#177500>    * RUNNABLE -&gt; RUNNING         // continue execution
</span></span></span><span style=display:flex><span><span style=color:#177500>    *
</span></span></span><span style=display:flex><span><span style=color:#177500>    *  RUNNING -&gt; YIELDING        // Thread.yield
</span></span></span><span style=display:flex><span><span style=color:#177500>    * YIELDING -&gt; RUNNABLE        // yield successful
</span></span></span><span style=display:flex><span><span style=color:#177500>    * YIELDING -&gt; RUNNING         // yield failed
</span></span></span><span style=display:flex><span><span style=color:#177500>    *
</span></span></span><span style=display:flex><span><span style=color:#177500>    *  RUNNING -&gt; TERMINATED      // done
</span></span></span><span style=display:flex><span><span style=color:#177500>    */</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>final</span> <span style=color:#a90d91>int</span> <span style=color:#000>NEW</span>      <span style=color:#000>=</span> <span style=color:#000>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>final</span> <span style=color:#a90d91>int</span> <span style=color:#000>STARTED</span>  <span style=color:#000>=</span> <span style=color:#000>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>final</span> <span style=color:#a90d91>int</span> <span style=color:#000>RUNNABLE</span> <span style=color:#000>=</span> <span style=color:#000>2</span>;     <span style=color:#177500>// runnable-unmounted</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>final</span> <span style=color:#a90d91>int</span> <span style=color:#000>RUNNING</span>  <span style=color:#000>=</span> <span style=color:#000>3</span>;     <span style=color:#177500>// runnable-mounted</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>final</span> <span style=color:#a90d91>int</span> <span style=color:#000>PARKING</span>  <span style=color:#000>=</span> <span style=color:#000>4</span>;
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>final</span> <span style=color:#a90d91>int</span> <span style=color:#000>PARKED</span>   <span style=color:#000>=</span> <span style=color:#000>5</span>;     <span style=color:#177500>// unmounted</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>final</span> <span style=color:#a90d91>int</span> <span style=color:#000>PINNED</span>   <span style=color:#000>=</span> <span style=color:#000>6</span>;     <span style=color:#177500>// mounted</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>final</span> <span style=color:#a90d91>int</span> <span style=color:#000>YIELDING</span> <span style=color:#000>=</span> <span style=color:#000>7</span>;     <span style=color:#177500>// Thread.yield</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>final</span> <span style=color:#a90d91>int</span> <span style=color:#000>TERMINATED</span> <span style=color:#000>=</span> <span style=color:#000>99</span>;  <span style=color:#177500>// final state</span>
</span></span></code></pre></div><p><img src=https://blog.rockthejvm.com/images/virtual-threads/virtual-thread-states.png alt="state of virtual thread"><br>绿色表示虚拟线程挂载（mounted）在 平台线程（carrier thread）。蓝色表示 unmounted 并让出线程（去执行其他虚拟线程或者任务）。紫色表示 pinned。<br>核心代码解读参考<a href=https://blog.rockthejvm.com/ultimate-guide-to-java-virtual-threads/#8-some-virtual-threads-internals>Some Virtual Threads InternalsPermalink</a></p><h3 id=参考>参考</h3><p><a href=https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html#GUID-DC4306FC-D6C1-4BCC-AECE-48C32C1A8DAA>java 21 doc</a></p><p><a href=https://openjdk.org/jeps/444>JEP 444: Virtual Threads</a></p><p><a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html>Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a></p><p><a href=https://blog.rockthejvm.com/ultimate-guide-to-java-virtual-threads/>The Ultimate Guide to Java Virtual Threads</a></p><p><a href=https://quarkus.io/blog/virtual-thread-1/#five-things-you-need-to-know-before-using-virtual-threads-for-everything>When Quarkus meets Virtual Threads</a>)</p><nav class="post-nav fullwidth"><span>&larr; <a href=../../post/python-async-programming/>Python 异步编程</a></span>
<span><a href=../../post/git-internal/>Git 内部原理-对象、分支以及底层命令[翻译]</a> &rarr;</span></nav></div><footer class=small><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fix-toc.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/center-img.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/alt-title.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/gh/rstudio/markdown/inst/resources/prism-xcode.css><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js defer></script><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/copy-button.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/copy-button.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/key-buttons.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/key-buttons.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/heading-anchor.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/external-link.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/ol-id.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fullwidth.min.js defer></script><hr><p class=nav-bottom><span><a href=https://zhi.moe>ZhiMoe</a> © 2024</span>
<span class=menu-bottom><a href=../../categories/>Categories</a> <a href=../../tags/>Tags</a>
<a href=../../post/index.xml type=application/rss+xml title="RSS feed">Subscribe</a>
<a href=#>Back to Top</a></span></p></footer></body></html>
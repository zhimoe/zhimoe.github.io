<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Java 并发 4-线程池与执行器 - 新街记事</title>
<meta property="og:title" content="Java 并发 4-线程池与执行器 - 新街记事"><meta name=twitter:card content="summary"><meta property="description" content="java thread pool class hierarchy Executor (java.util.concurrent) |---ExecutorService (java.util.concurrent) |---AbstractExecutorService (java.util.concurrent) | |---ForkJoinPool (java.util.concurrent) &amp;hellip;"><meta property="og:description" content="java thread pool class hierarchy Executor (java.util.concurrent) |---ExecutorService (java.util.concurrent) |---AbstractExecutorService (java.util.concurrent) | |---ForkJoinPool (java.util.concurrent) &amp;hellip;"><meta name=twitter:image content="https://jsd.cdn.zzko.cn/gh/zhimoe/zhimoe.pic@main/pic/threadpool.5d6mli4zovs0.svg"><link rel=stylesheet href=../../css/style.css><link rel=stylesheet href=../../css/fonts.css><link rel=stylesheet href=../../css/custom.css><link rel=stylesheet href=https://indestructibletype.com/fonts/Jost.css></head><body class="single post"><div class=crop-h></div><div class=crop-v></div><div class=crop-c></div><nav class="nav-top small"><div class=logo><a href=../../>新街记事</a></div><div class=menu><span class=active><a href=../../post/>博客</a></span>
<span><a href=../../categories/%E7%BC%96%E7%A8%8B/>编程</a></span>
<span><a href=../../categories/%E7%BF%BB%E8%AF%91/>翻译</a></span>
<span><a href=../../categories/%E9%9A%8F%E6%83%B3/>随想</a></span>
<span><a href=../../search/>搜索</a></span></div></nav><div class=article-meta><h1 class=title>Java 并发 4-线程池与执行器</h1><h3 class=meta-line><span><span class=date>2018-06-13</span>
</span><span class=term><a href=../../categories/%E7%BC%96%E7%A8%8B/ class=term-cat>编程</a>
<a href=../../tags/java/ class=term-tag>#java </a><a href=../../tags/%E5%B9%B6%E5%8F%91/ class=term-tag>#并发 </a><a href=../../tags/thread-pool/ class=term-tag>#thread-pool</a></span></h3></div><div class=main><nav id=TableOfContents><ul><li><a href=#thread-pool-classes-hierarchy>thread pool classes hierarchy</a></li><li><a href=#three-thread-pool-interfaces>three thread pool interfaces</a></li><li><a href=#common-thread-pool-implements>common thread pool implements</a></li><li><a href=#任务提交执行流程>任务提交执行流程</a></li><li><a href=#forkjoin-框架>fork/join 框架</a></li></ul></nav><h3 id=thread-pool-classes-hierarchy>thread pool classes hierarchy</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>java thread pool class hierarchy
</span></span><span style=display:flex><span>Executor (java.util.concurrent)
</span></span><span style=display:flex><span>|---ExecutorService (java.util.concurrent)
</span></span><span style=display:flex><span>    |---AbstractExecutorService (java.util.concurrent)
</span></span><span style=display:flex><span>    |   |---ForkJoinPool (java.util.concurrent)
</span></span><span style=display:flex><span>    |   |---ThreadPoolExecutor (java.util.concurrent)
</span></span><span style=display:flex><span>    |   |   |---ScheduledThreadPoolExecutor (java.util.concurrent)
</span></span><span style=display:flex><span>    |---DelegatedExecutorService in Executors (java.util.concurrent)
</span></span><span style=display:flex><span>    |---ScheduledExecutorService (java.util.concurrent)
</span></span></code></pre></div><h3 id=three-thread-pool-interfaces>three thread pool interfaces</h3><p><code>Executor</code>, a simple interface that supports launching new tasks.</p><p><code>ExecutorService</code>, a sub-interface of Executor, which adds features that help manage the life cycle, both of the<br>individual tasks and of the executor itself.</p><p><code>ScheduledExecutorService</code>, a sub-interface of ExecutorService, supports future and/or periodic execution of tasks.</p><h3 id=common-thread-pool-implements>common thread pool implements</h3><p><code>ThreadPoolExecutor</code>是 thread pool 最常用的实现。一般通过<code>Executors</code>静态工厂方法来创建。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#177500>//Executors.newFixedThreadPool</span>
</span></span><span style=display:flex><span><span style=color:#177500>//Executors.newCachedThreadPool</span>
</span></span><span style=display:flex><span><span style=color:#177500>//Executors.newSingleThreadExecutor</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>//同样的，Executors 还提供了 ScheduledExecutorService 的工具方法</span>
</span></span><span style=display:flex><span><span style=color:#177500>//Executors.newSingleThreadScheduledExecutor</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#177500>/**
</span></span></span><span style=display:flex><span><span style=color:#177500> * corePoolSize - 保留存活的线程个数
</span></span></span><span style=display:flex><span><span style=color:#177500> * maximumPoolSize - 最大线程个数
</span></span></span><span style=display:flex><span><span style=color:#177500> * keepAliveTime - 线程数超过 corePoolSize 时，空闲线程存活时间
</span></span></span><span style=display:flex><span><span style=color:#177500> * unit - keepAliveTime 的单位，毫秒秒分等
</span></span></span><span style=display:flex><span><span style=color:#177500> * workQueue – 任务队列，只保存通过 execute() 方法提交的 Runnable 任务
</span></span></span><span style=display:flex><span><span style=color:#177500> * threadFactory – 给自己创建一个线程的工厂方法
</span></span></span><span style=display:flex><span><span style=color:#177500> * handler – 当线程池达到数量限制或者任务队列满了，对新任务提交的处理策略
</span></span></span><span style=display:flex><span><span style=color:#177500> */</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>class</span> <span style=color:#3f6e75>ThreadPoolExecutor</span> {
</span></span><span style=display:flex><span>  <span style=color:#a90d91>public</span> <span style=color:#000>ThreadPoolExecutor</span>(<span style=color:#a90d91>int</span> <span style=color:#000>corePoolSize</span>,
</span></span><span style=display:flex><span>                            <span style=color:#a90d91>int</span> <span style=color:#000>maximumPoolSize</span>,
</span></span><span style=display:flex><span>                            <span style=color:#a90d91>long</span> <span style=color:#000>keepAliveTime</span>,
</span></span><span style=display:flex><span>                            <span style=color:#000>TimeUnit</span> <span style=color:#000>unit</span>,
</span></span><span style=display:flex><span>                            <span style=color:#000>BlockingQueue</span><span style=color:#000>&lt;</span><span style=color:#000>Runnable</span><span style=color:#000>&gt;</span> <span style=color:#000>workQueue</span>,
</span></span><span style=display:flex><span>                            <span style=color:#000>ThreadFactory</span> <span style=color:#000>threadFactory</span>,
</span></span><span style=display:flex><span>                            <span style=color:#000>RejectedExecutionHandler</span> <span style=color:#000>handler</span>) {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>JDK 默认的拒绝策略 RejectedExecutionHandler 有：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#177500>/**
</span></span></span><span style=display:flex><span><span style=color:#177500> * ThreadPoolExecutor.AbortPolicy - 默认的 handler，抛出一个 RejectedExecutionException
</span></span></span><span style=display:flex><span><span style=color:#177500> * ThreadPoolExecutor.CallerRunsPolicy - 提交任务的线程自己执行这个任务
</span></span></span><span style=display:flex><span><span style=color:#177500> * ThreadPoolExecutor.DiscardPolicy - 抛弃这个任务
</span></span></span><span style=display:flex><span><span style=color:#177500> * ThreadPoolExecutor.DiscardOldestPolicy - 抛弃任务队列中最早提交上来的任务，然后尝试重新提交当前这个任务
</span></span></span><span style=display:flex><span><span style=color:#177500> */</span>
</span></span></code></pre></div><h3 id=任务提交执行流程>任务提交执行流程</h3><p><img src=https://jsd.cdn.zzko.cn/gh/zhimoe/zhimoe.pic@main/pic/threadpool.5d6mli4zovs0.svg alt=任务提交执行流程></p><h3 id=forkjoin-框架>fork/join 框架</h3><p>fork/join和上面ThreadPoolExecutor的区别在于使用了任务窃取算法，工作线程完成自己的任务后可以从其他线程偷取任务，提高整体的任务效率.<br>核心是一个<code>ForkJoinPool</code> class 和一个扩展的<code>AbstractExecutorService</code>. 执行<code>ForkJoinTask</code> 任务。<br>在 JDK8 中有个<code>java.util.Arrays.parallelSort()</code>使用的就是 fork/join.</p><p>当然，<a href=http://coopsoft.com/ar/CalamityArticle.html>不是所有人都满意 JDK7 引入的 Fork/Join 框架</a>.</p><nav class="post-nav fullwidth"><span>&larr; <a href=../../post/python-jupyter-notebook-install-new-package/>Jupyter Notebook Install New Package[翻译]</a></span>
<span><a href=../../post/spark-basic/>Spark Basic</a> &rarr;</span></nav></div><footer class=small><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fix-toc.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/center-img.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/alt-title.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/gh/rstudio/markdown/inst/resources/prism-xcode.css><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js defer></script><script src=//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/copy-button.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/copy-button.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/key-buttons.min.js defer></script><link rel=stylesheet href=//cdn.jsdelivr.net/npm/@xiee/utils/css/key-buttons.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/heading-anchor.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/external-link.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/fullwidth.min.js defer></script><hr><p class=nav-bottom><span><a href=https://zhi.moe>ZhiMoe</a> © 2024</span>
<span class=menu-bottom><a href=../../categories/>Categories</a> <a href=../../tags/>Tags</a>
<a href=../../post/index.xml type=application/rss+xml title="RSS feed">Subscribe</a>
<a href=#>Back to Top</a></span></p></footer></body></html>
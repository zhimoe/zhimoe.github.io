<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>[ç¿»è¯‘]Gitå†…éƒ¨åŸç†å›¾è§£â€”â€”å¯¹è±¡ã€åˆ†æ”¯ä»¥åŠå¦‚ä½•ä»é›¶å¼€å§‹å»ºä»“åº“</title><url>https://zhimoe.github.io/post/git-internal/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>git</tag><tag>ç¿»è¯‘</tag></tags><content type="html"> æˆ‘ä»¬ä¸­çš„è®¸å¤šäººæ¯å¤©éƒ½åœ¨ä½¿ç”¨ gitï¼Œä½†æ˜¯æœ‰å¤šå°‘äººçŸ¥é“å®ƒçš„å†…éƒ¨æ˜¯æ€ä¹ˆè¿ä½œçš„å‘¢ï¼Ÿ
ä¾‹å¦‚æˆ‘ä»¬ä½¿ç”¨ git commit æ—¶å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿæäº¤ï¼ˆcommitï¼‰ä¸æäº¤ä¹‹é—´ä¿å­˜çš„æ˜¯ä»€ä¹ˆï¼Ÿä¸¤æ¬¡æäº¤ä¹‹é—´éš¾é“åªæ˜¯æ–‡ä»¶çš„å·®å¼‚ï¼ˆdiffï¼‰å—ï¼Ÿå¦‚æœæ˜¯ï¼Œè¿™ä¸ªå·®å¼‚æ˜¯å¦‚ä½•ç¼–ç çš„ï¼Ÿè¿˜æ˜¯è¯´æ¯æ¬¡æäº¤éƒ½ä¼šä¿å­˜ä¸€ä¸ªå½“å‰ä»“åº“çš„å®Œæ•´å¿«ç…§ï¼ˆsnapshotï¼‰å‘¢ï¼Ÿæˆ‘ä»¬ä½¿ç”¨ git init æ—¶åˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ
å‘ç°ä¸€ç¯‡éå¸¸ç²¾å½©çš„Gitå†…éƒ¨åŸç†æ–‡ç« Gitå†…éƒ¨åŸç†å›¾è§£â€”â€”å¯¹è±¡ã€åˆ†æ”¯ä»¥åŠå¦‚ä½•ä»é›¶å¼€å§‹å»ºä»“åº“ï¼Œä¸­æ–‡ç¿»è¯‘ã€‚æ–‡ç« ä½œè€…ç”šè‡³åˆ¶ä½œäº†é…å¥—è®²è§£è§†é¢‘
Gitå¯¹è±¡ gitå†…éƒ¨æœ‰ä¸‰ç§å¯¹è±¡ï¼š
blob: æ–‡ä»¶çš„å†…å®¹ï¼Œä¸åŒ…å«metadataä¿¡æ¯ï¼ˆåˆ›å»ºæ—¶é—´ï¼Œä¿®æ”¹æ—¶é—´ï¼Œä½œè€…ç­‰ï¼‰ tree: ä¸€ä¸ªç›®å½•ï¼ŒåŒ…å«blobsæˆ–è€…trees commit: a snapshot of the working treeï¼Œä¸€ä¸ªtreeçš„å¿«ç…§ã€‚ ä¸‰ç§gitå¯¹è±¡éƒ½æ˜¯é€šè¿‡SHA-1å“ˆå¸Œå€¼æ¥å”¯ä¸€æ ‡è¯†ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚æ¯ä¸ªcommitå¯¹è±¡ä¸­ï¼Œå¯¹äºtreeé‡Œé¢é‚£äº›æ²¡æœ‰æ”¹åŠ¨çš„å†…å®¹ï¼Œç»§ç»­é€šè¿‡åŸhashå¼•ç”¨ã€‚
åˆ†æ”¯ A branch is just a named reference to a commit.
åœ¨ä¸Šé¢çš„å›¾ç‰‡ä¸­ï¼Œå¯ä»¥é€šè¿‡å“ˆå¸Œå€¼æ¥å¼•ç”¨ä¸€ä¸ªcommitï¼Œä½†æ˜¯ä¸æ–¹ä¾¿ï¼Œæ‰€ä»¥åˆ†æ”¯ç”¨æ¥å¼•ç”¨commitã€‚å¯ä»¥ç†è§£ä¸ºåˆ†æ”¯æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘ä¸€ä¸ªcommitï¼Œä¸€èˆ¬é»˜è®¤æ˜¯æŒ‡å‘æœ€åä¸€ä¸ªcommitï¼ˆä¹Ÿå¯ä»¥ä¸æ˜¯æœ€åä¸€ä¸ªcommitï¼‰ã€‚
gité€šè¿‡HEADæŒ‡é’ˆæ¥ç¡®è®¤å½“å‰æ‰€åœ¨åˆ†æ”¯ã€‚HEADæŒ‡é’ˆå…¶å®æ˜¯.gitç›®å½•ä¸‹çš„ä¸€ä¸ªHEADæ–‡ä»¶,å†…å®¹å¦‚ä¸‹
> cat .git/HEAD ref: refs/heads/master gitå¦‚ä½•è®°å½•å˜åŒ– repositoryæ˜¯ä¸€ç³»åˆ—commitçš„é›†åˆ working diræ˜¯ä¸€ä¸ªåŒ…å«.gitçš„ç›®å½• staging areaæ˜¯å­˜æ”¾é‚£äº›è¢«gitè·Ÿè¸ªä½†æ˜¯æ²¡æœ‰commitçš„å†…å®¹ ä¸‰è€…çš„å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤º
gitåº•å±‚å‘½ä»¤(plumbing)å’Œä¸Šå±‚å‘½ä»¤(porcelain) åŒºåˆ† åº•å±‚ï¼ˆplumbingï¼‰ å’Œ ä¸Šå±‚ï¼ˆporcelainï¼‰ ä¸¤ç±» git å‘½ä»¤ä¼šå¯¹ä½ å¾ˆæœ‰å¸®åŠ©ã€‚è¿™ä¸¤ä¸ªæœ¯è¯­çš„åº”ç”¨å¥‡æ€ªåœ°æ¥è‡ªäºé©¬æ¡¶ï¼ˆæ²¡é”™ï¼Œå°±æ˜¯ğŸš½ï¼‰ã€‚é©¬æ¡¶é€šå¸¸æ˜¯ç”¨é™¶ç“·ï¼ˆporcelainï¼‰åšçš„ï¼Œå®ƒçš„åŸºæœ¬ç»“æ„æ˜¯ç®¡é“ï¼ˆplumbingï¼Œä¸Šæ°´é“å’Œä¸‹æ°´é“ï¼‰ã€‚
ä¸Šå±‚å‘½ä»¤å°±æ˜¯git initã€git addã€ git commitç­‰,ä¸‹é¢ä»‹ç»ä¸€ä¸‹åº•å±‚å‘½ä»¤.
# åˆ›å»ºgitå¯¹è±¡ >echo "git is awesome" | git hash-object --stdin -w # æŸ¥çœ‹.gitç›®å½•çš„å˜åŒ– >tree .git # æŸ¥çœ‹ä¸€ä¸ªgit objectç±»å‹ -t type >git cat-file -t [obj-hash] # blob|tree|commit # æŸ¥çœ‹ä¸€ä¸ªgit objectå†…å®¹ -p pretty-print >git cat-file -p [obj-hash] # æ·»åŠ objectåˆ°staging area >git update-index --add --cacheinfo 100644 &lt;blob-hash> &lt;filename> # åˆ›å»ºä¸€ä¸ªtreeå¯¹è±¡,åœ¨treeå¯¹è±¡ä¸­è®°å½•indexå†…å®¹ >git write-tree # ä¸ºtreeå¯¹è±¡åˆ›å»ºä¸€ä¸ªcommitå¯¹è±¡ >git commit-tree &lt;tree-hash> -m &lt;commit message> git å®é™…ä¸Šæ˜¯ä½¿ç”¨ SHA-1 å“ˆå¸Œå€¼çš„å‰ä¸¤ä¸ªå­—ç¬¦ä½œä¸ºç›®å½•çš„åå­—ï¼Œå‰©ä½™å­—ç¬¦ç”¨ä½œ blob æ‰€åœ¨æ–‡ä»¶çš„æ–‡ä»¶åã€‚
.gitç›®å½• ä¸€ä¸ª.gitç›®å½•è‡³å°‘åŒ…å«ä¸‰ä¸ªå†…å®¹
âœ” tree .git .git â”œâ”€â”€ HEAD å½“å‰æŒ‡å‘åˆ†æ”¯ï¼Œé»˜è®¤å†…å®¹æ˜¯ ref: refs/heads/main â”œâ”€â”€ objects gitå¯¹è±¡ blobã€treeã€commitçš„ä¸€ç§ï¼Œå…¶ä¸­å¯¹è±¡çš„hashå€¼å‰ä¸¤ä¸ªå­—ç¬¦ç”¨äºç›®å½•åï¼Œå‰©ä½™çš„ç”¨äºå¯¹è±¡å â””â”€â”€ refs åˆ†æ”¯å’Œtag â””â”€â”€ heads å½“å‰working diræ‰€æœ‰åˆ†æ”¯ é»˜è®¤åˆ†æ”¯ä¸å±•ç¤ºï¼Œåªæœ‰å¤šäºä¸€ä¸ªåˆ†æ”¯æ‰ä¼šå±•ç¤º æ·»åŠ ä¸€ä¸ªæ–‡ä»¶å¹¶commitï¼Œç„¶ååˆ›å»ºä¸€ä¸ªæ–°åˆ†æ”¯ï¼Œå†æ¬¡æ£€æŸ¥.gitç›®å½•
âœ” tree .git .git â”œâ”€â”€ HEAD â”œâ”€â”€ index â”œâ”€â”€ objects â”‚ â”œâ”€â”€ 8d â”‚ â”‚ â””â”€â”€ 0e41234f24b6da002d962a26c2495ea16a425f â”‚ â”œâ”€â”€ af â”‚ â”‚ â””â”€â”€ 7e0d93b83f49f601f5ef35edf5f9330fb4d7fd â”‚ â””â”€â”€ c8 â”‚ â””â”€â”€ bcfef1da123a980537a5fa4cf9b7c4f387d451 â””â”€â”€ refs â””â”€â”€ heads â”œâ”€â”€ main â””â”€â”€ test_branch 7 directories, 7 files ä¸Šé¢åˆ é™¤äº†logsç›®å½•,indexæ–‡ä»¶ä¿å­˜çš„æ˜¯staging areaä¿¡æ¯ã€‚æ‰“å°objectsç›®å½•ä¸‹çš„ä¸‰ä¸ªæ–‡ä»¶
âœ” git cat-file -p 8d0e41234f24b6da002d962a26c2495ea16a425f hello git :~/code/temp (main) âœ” git cat-file -p c8bcfef1da123a980537a5fa4cf9b7c4f387d451 100644 blob 8d0e41234f24b6da002d962a26c2495ea16a425f file.txt :~/code/temp (main) âœ” git cat-file -p af7e0d93b83f49f601f5ef35edf5f9330fb4d7fd tree c8bcfef1da123a980537a5fa4cf9b7c4f387d451 author zhimoe &lt;xx@gmail.com> 1691313901 +0800 committer zhimoe &lt;xx@gmail.com> 1691313901 +0800 first commit å¯ä»¥çœ‹åˆ°åˆ†åˆ«æ˜¯ä¸€ä¸ªblobå¯¹è±¡ï¼ˆfile.txt)ã€ä¸€ä¸ªtreeå¯¹è±¡å’Œä¸€ä¸ªcommitå¯¹è±¡ï¼Œåè€…ä¾æ¬¡å¼•ç”¨å‰è€…ã€‚
å‚è€ƒ æ–‡ç« é‡Œé¢æåˆ°äº†å¾ˆå¤šgitå†…éƒ¨åŸç†å’Œæ¦‚å¿µ:
Git å†…éƒ¨åŸç† - åº•å±‚å‘½ä»¤ä¸ä¸Šå±‚å‘½ä»¤
Git å†…éƒ¨åŸç† - Git å¯¹è±¡</content></entry><entry><title>Rust Error Handling Notes</title><url>https://zhimoe.github.io/post/rust-error-handling-notes/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>rust</tag><tag>notes</tag></tags><content type="html"> åˆå­¦rustçš„æ—¶å€™ï¼Œä¸Šæ‰‹å†™ä»£ç æ€»æ˜¯é‡åˆ°å¾ˆå¤šä¸ä¸€æ ·çš„rustçš„Resultç±»å‹ï¼Œä¸åŒcrateä¸­çš„å‡½æ•°è¿”å›çš„Result&lt;T, E>çš„Eéƒ½ä¸ä¸€æ ·ï¼Œåˆšå¼€å§‹éƒ½æ˜¯unwrapæˆ–è€…expectæ¥å¤„ç†ã€‚å¦‚æœä½¿ç”¨try!æˆ–è€…?çš„è¯æ€»æ˜¯ç¼–è¯‘ä¸é€šè¿‡ï¼Œè¿˜æ˜¯å¯¹Errorè½¬æ¢å’Œå¤„ç†ä¸ç†Ÿç»ƒã€‚
Errorè½¬æ¢ åœ¨ä¸€ä¸ªæ–¹æ³•ä¸­ï¼Œè°ƒç”¨ä¸åŒçš„å‡½æ•°ä¼šè¿”å›ä¸åŒçš„errorç±»å‹ï¼Œéœ€è¦ä½ å°†è¿™äº›ç±»å‹è½¬æ¢æˆç»Ÿä¸€çš„è‡ªå®šä¹‰errorç±»å‹å†è¿”å›ã€‚ä½ æœ‰ä»¥ä¸‹å‡ ç§é€”å¾„
ä½¿ç”¨map_err fn cook_pasta() -> Result&lt;Pasta, CookingError> { let water = boil_water().map_err(|_| CookingError::BoilWaterError)?; let pasta = add_pasta(&amp;water).map_err(|_| CookingError::AddPastaError)?; Ok(pasta) } // é€šè¿‡map_errå°†boil_water()å’Œadd_pasta(&amp;water)è¿”å›çš„erroréƒ½è½¬æ¢æˆäº†CookingErrorç±»å‹ ä½¿ç”¨std::error::Error+From trait å®šä¹‰è‡ªå·±çš„Errorç±»å‹å¹¶å®ç°From traitã€‚ From traitç”¨äºå°†boil_water()å’Œadd_pasta(&amp;water)çš„errorè½¬æ¢æˆè‡ªå®šä¹‰çš„Errorã€‚å…¶å®å°±æ˜¯å°†map_errçš„é€»è¾‘ç§»åŠ¨åˆ°From traitä¸­å®ç°ï¼Œä½¿å¾—æ–¹æ³•è°ƒç”¨å¤„çœ‹èµ·æ¥æ›´ç®€æ´ã€‚
pub enum CookingError{ BoilWaterError(String), AddPastaError } impl std::error::Error for CookingError{ // ... } impl Display for CookingError{ // ... } // å‡è®¾boil_waterè¿”å›çš„erroræ˜¯NoWaterError impl From&lt;NoWaterError> for CookingError { fn from(s: NoWaterError) -> Self { CookingError::BoilWaterError(s) } } // å‡è®¾add_pastaè¿”å›çš„erroræ˜¯IoError impl From&lt;IoError> for CustomError { fn from(s: std::io::Error) -> Self { CookingError::AddPastaError(s) } } // æ— éœ€map_err fn cook_pasta() -> Result&lt;Pasta, CookingError> { let water = boil_water()?; // å¦‚æœæŠ›å‡ºNoWaterErrorï¼Œè‡ªåŠ¨è½¬æˆCookingError::BoilWaterErrorï¼Œä¸‹é¢åŒç† let pasta = add_pasta(&amp;water)?; Ok(pasta) } thiserror thiserror å¯ä»¥çœ‹ä½œæ˜¯å®šä¹‰ Error çš„ä¸€ä¸ªå·¥å…·ï¼Œå®ƒåªå¸®ä½ ç”Ÿæˆä¸€äº›å®šä¹‰ Error çš„ä»£ç ï¼Œåˆ«çš„ä»€ä¹ˆéƒ½ä¸åšï¼Œç›¸å½“çº¯ç²¹ã€‚å¦‚æœä½ åœ¨å¼€å‘ä¸€ä¸ªcrateï¼Œé‚£ä¹ˆå»ºè®®ä½¿ç”¨thiserrorã€‚
fn render() -> Result&lt;String, std::io::Error> { let file = std::env::var("MARKDOWN")?; let source = read_to_string(file)?; Ok(source) } ä¸Šé¢çš„ä»£ç æ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œå› ä¸ºenv::var() è¿”å›çš„æ˜¯ std::env::VarErrorï¼Œè€Œ read_to_string() è¿”å›çš„æ˜¯ std::io::Errorã€‚
ä¸ºäº†æ»¡è¶³ render å‡½æ•°çš„ç­¾åï¼Œæˆ‘ä»¬å°±éœ€è¦å°† env::VarError å’Œ io::Error å½’ä¸€åŒ–ä¸ºåŒä¸€ç§é”™è¯¯ç±»å‹ã€‚è¦å®ç°è¿™ä¸ªç›®çš„æœ‰ä¸‰ç§æ–¹å¼:
ä½¿ç”¨ç‰¹å¾å¯¹è±¡ Box&lt;dyn Error>ã€‚ å®é™…ä¸Šå°±æ˜¯é”™è¯¯ç±»å‹æ³›åŒ–ï¼Œå¤±å»äº†å…·ä½“é”™è¯¯ç±»å‹çš„ä¿¡æ¯ï¼Œç±»ä¼¼äºåœ¨Javaä¸­ä½¿ç”¨Objectç±»å‹ã€‚ è‡ªå®šä¹‰é”™è¯¯ç±»å‹ã€‚ æ¯”è¾ƒç¹çï¼Œä¸Šé¢çš„ä¾‹å­åœ¨è‡ªå®šä¹‰Errorç±»å‹åï¼Œéœ€è¦åˆ†åˆ«ä¸ºenv::VarError å’Œ io::Errorå®ç°From traitæ‰è¡Œã€‚ ä½¿ç”¨ thiserrorã€‚ ç®€åŒ–è‡ªå®šä¹‰é”™è¯¯ç±»å‹çš„ç¹çï¼š use std::fs::read_to_string; fn main() -> Result&lt;(), MyError> { let html = render()?; println!("{}", html); Ok(()) } fn render() -> Result&lt;String, MyError> { let file = std::env::var("MARKDOWN")?; let source = read_to_string(file)?; Ok(source) } #[derive(thiserror::Error, Debug)] enum MyError { #[error("Environment variable not found")] EnvironmentVariableNotFound(#[from] std::env::VarError), #[error(transparent)] IOError(#[from] std::io::Error), } thiserroræä¾›#[from] #[error]ç­‰æ³¨è§£ç®€åŒ–é”™è¯¯ç±»å‹è‡ªå®šä¹‰å·¥ä½œã€‚
#[derive(Error)] { // Attributes available to this derive: #[backtrace] // #[error] #[from] #[source] } error(transparent) è¡¨ç¤ºè½¬å‘åº•å±‚errorçš„ç›¸å…³ä¿¡æ¯ï¼Œä¸ä¿®æ”¹sourceå’ŒDisplayç›¸å…³æ–¹æ³•ã€‚
anyhow anyhow ä¸ºä½ å®šä¹‰å¥½äº†ä¸€ä¸ª Error ç±»å‹ï¼ŒåŸºæœ¬å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ª Box ï¼ŒåŒæ—¶è¿˜æä¾›äº†ä¸€äº›å¦‚ context ç­‰æ‰©å±•åŠŸèƒ½ï¼Œç”¨èµ·æ¥æ›´åŠ æ— è„‘ã€‚ å¦‚æœä½ åœ¨å¼€å‘ä¸€ä¸ªä¸šåŠ¡appï¼Œå»ºè®®ä½¿ç”¨anyhowæ›´åŠ æ–¹ä¾¿ã€‚
use anyhow::Result; fn main() -> Result&lt;()> { let html = render()?; println!("{}", html); Ok(()) } fn render() -> Result&lt;String> { let file = std::env::var("MARKDOWN")?; let source = read_to_string(file).with_context(|| format!("read string from {} failed", &amp;file))? Ok(source) } å¯ä»¥çœ‹åˆ°è¿™é‡Œä½¿ç”¨çš„æ˜¯Result&lt;String>,å®é™…ä¸Šè¿™æ˜¯anyhowçš„type aliasï¼špub type Result&lt;T, E = Error> = core::result::Result&lt;T, E>;
anyhow è¿˜æä¾›äº†with_contextç»™erroræ·»åŠ ä¿¡æ¯ï¼Œçœ‹ä¸Šå»å’Œexpectç±»ä¼¼ï¼Œåªä¸è¿‡é‚£æ˜¯panicã€‚
å¯¹äºä¸€ä¸ªappæœåŠ¡ï¼Œä¸€äº›æ ¸å¿ƒç™»å½•ç­‰åŠŸèƒ½å¯èƒ½ä¹Ÿéœ€è¦è‡ªå®šä¹‰errorç±»å‹ï¼Œè¿™æ—¶å¯ä»¥å°†anyhow::Errorä½œä¸ºå…¶ä¸­ä¸€ç§errorç±»å‹ï¼Œå³thiserror + anyhowï¼š
#[derive(Error, Debug)] pub enum AppError { ... #[error(transparent)] Other(#[from] anyhow::Error), // source and Display delegate to anyhow::Error } å‚è€ƒï¼š
rust by example - å¤„ç†å¤šç§é”™è¯¯ç±»å‹
Optionå’ŒResultçš„ä¸€äº›æ–¹æ³•
rust doc Error Handling
ç®€è°ˆ Rust ä¸­çš„é”™è¯¯å¤„ç†
ç»†è¯´rusté”™è¯¯å¤„ç†
?åœ¨Resultä¸­çš„ä½¿ç”¨
èš‚èšé›†å›¢ CeresDB å›¢é˜Ÿ | å…³äº Rust é”™è¯¯å¤„ç†çš„æ€è€ƒ</content></entry><entry><title>ä½¿ç”¨OpenPyXLè¯»å†™excelå¤§æ–‡ä»¶</title><url>https://zhimoe.github.io/post/read-large-excel-file-with-openpyxl/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>python</tag></tags><content type="html"> ä½¿ç”¨python OpenPyXLè¯»å†™excelå¤§æ–‡ä»¶æ—¶ï¼Œæœ‰ä¸“é—¨çš„read_only write-onlyæ¨¡å¼æ¥æå‡è¯»å†™æ•ˆç‡ã€‚
openpyxl read_only mode from openpyxl import load_workbook wb = load_workbook(filename='large_file.xlsx', read_only=True) ws = wb['big_data'] # min_col&amp;max_col: åªå¤„ç†Båˆ—, min_row=2: ä»ç¬¬äºŒè¡Œå¼€å§‹, åªè¯»å–å€¼ col_index_B = openpyxl.utils.column_index_from_string('B') for cell_value in ws.iter_rows(min_row=2, min_col=col_index_B, max_col=col_index_B, values_only=True): print(cell_value) # Close the workbook after reading wb.close() åªè¯»å–ç¬¬ä¸€è¡Œçš„é”™è¯¯ å¦‚æœä½ çš„excelæ–‡ä»¶æ˜¯é€šè¿‡ç¬¬ä¸‰æ–¹è½¯ä»¶(æ•°æ®åº“å®¢æˆ·ç«¯)æˆ–è€…ä»£ç ç”Ÿæˆçš„ï¼Œå¾ˆå®¹æ˜“é‡åˆ°ä¸€ä¸ªé—®é¢˜å°±æ˜¯ä¸Šé¢çš„ws.iter_rowsæˆ–ws.rowséå†åªä¼šè¯»å–ç¬¬ä¸€è¡Œã€‚ è¿™æ˜¯å› ä¸ºread onlyæ¨¡å¼åœ¨load_workbookæ—¶åªè¯»å–äº†æ–‡ä»¶çš„å…ƒä¿¡æ¯ï¼Œåœ¨éå†æ—¶ä¹Ÿä¾èµ–worksheetçš„å…ƒä¿¡æ¯ï¼Œå¾ˆå¤šéofficeç”Ÿæˆçš„excelæ²¡æœ‰æ­£ç¡®è®¾ç½®å…ƒä¿¡æ¯ã€‚ ä½ å¯ä»¥é€šè¿‡ws.calculate_dimension()æ£€æŸ¥excelè¡Œåˆ—ä¿¡æ¯ï¼Œå¦‚æœè¿”å›çš„æ˜¯A1:A1ç­‰ä¸å®é™…å¤§å°ä¸ä¸€è‡´çš„æƒ…å†µï¼Œå¯ä»¥é€šè¿‡ws.reset_dimensions()æ¥é‡ç½®wsçš„max_row and max_columnå±æ€§ã€‚
æ³¨æ„ï¼Œws.reset_dimensions()ä¼šè¯»å–æ•´ä¸ªæ–‡ä»¶ï¼Œæ•ˆç‡ä¼šé™ä½åˆ°éread_onlyæ¨¡å¼ä¸€æ ·ã€‚
å“ï¼Œè¿™ä¸ªå‘èŠ±äº†ä¸€ä¸‹åˆçš„æ’æŸ¥ï¼Œå°±æ˜¯ä¸è®¤çœŸçœ‹ä¸€ä¸‹æ–‡æ¡£
openpyxl write_only mode ç¡®ä¿å®‰è£…äº†lxml openpyxlä¸¤ä¸ªåº“ ä½¿ç”¨write_onlyå†™å¤§æ•°æ® from openpyxl import Workbook wb = Workbook(write_only=True) ws = wb.create_sheet() # now we'll fill it with 100 rows x 200 columns for irow in range(100): ws.append(['%d' % i for i in range(200)]) # save the file wb.save('new_big_file.xlsx') # doctest: +SKIP å®˜æ–¹æ–‡æ¡£ openpyxl Optimised Modes
openpyxl vs xlsxwriter ä¸¤ä¸ªå¸¸ç”¨åŠŸèƒ½å’Œæ€§èƒ½ä¸Šå·®åˆ«ä¸å¤§ï¼Œéƒ¨åˆ†æ ·å¼è®¾ç½®æœ‰å·®åˆ«ã€‚ pandasæ”¯æŒä¸¤ä¸ªï¼Œå¯ä»¥é€šè¿‡engineå‚æ•°åˆ‡æ¢ã€‚ ä½¿ç”¨polars polarsæ˜¯ä½¿ç”¨rustè¯­è¨€ç¼–å†™çš„DataFrameåº“ï¼ŒåŸºäºarrowæ ¼å¼ï¼Œæä¾›rustã€pythonã€nodejsä¸‰ç§ç¼–ç¨‹è¯­è¨€æ¥å£ã€‚ ç›®å‰polarsæ”¯æŒè¯»å–æ•´ä¸ªexcelæ–‡ä»¶ï¼Œä½†æ˜¯å†™æ–‡ä»¶ä¸è¡Œï¼Œåªèƒ½é€šè¿‡è½¬æ¢æˆpandasçš„dfå†å¤„ç†ã€‚æœ¬åœ°æµ‹è¯•ä¸€ä¸‹polarsè¯»å–æ•´ä¸ªexcelæ–‡ä»¶ï¼Œé€Ÿåº¦å¤§çº¦æ˜¯pandasæ™®é€šæ¨¡å¼çš„ä¸¤å€ï¼Œå†…å­˜ä½¿ç”¨æ˜¯pandasçš„2/3ï¼Œè¿™ä¸ªæ€§èƒ½å’Œå†…å­˜ï¼Œæ„Ÿè§‰åœ¨pythoné¢†åŸŸå¸Œæœ›ä¸å¤§ï¼Œçœ‹rusté‚£è¾¹çš„å‘å±•äº†ã€‚
polarsçš„APIä¸€èˆ¬æ˜¯å°½å¯èƒ½å’Œpandasä¿æŒä¸€è‡´ï¼Œæ‰€ä»¥ä½¿ç”¨èµ·æ¥ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œé‡åˆ°APIç¼ºå¤±çš„ï¼Œå¯ä»¥ç›´æ¥è½¬æ¢æˆpandasçš„dfä½¿ç”¨df.to_pandas()
import pandas as pd import polars as pl # read_excelè¿˜éœ€è¦xlsx2csv lib df = pl.read_excel( "test.xlsx", sheet_id=1, xlsx2csv_options={"skip_empty_lines": True}, read_csv_options={"has_header": True}, ) print(f'{type(df)=}') # class 'polars.dataframe.frame.DataFrame' print(f'{df.shape=}') print(f'{df.head()=}') for cell in df['Courses']: print(f'{cell=}') polarsçš„è¾“å‡ºæ ¼å¼æ¯”pandasçš„å¥½çœ‹å¤šäº†ï¼Œä½¿ç”¨äº†box-drawingç›¸å…³çš„unicodeå­—ç¬¦æ‰“å°è¡¨æ ¼ï¼Œä¸è¿‡éœ€è¦ç¼–ç¨‹å­—ä½“æ”¯æŒæ‰èƒ½å¯¹é½ã€‚</content></entry><entry><title>Kotlin Coroutine</title><url>https://zhimoe.github.io/post/kotlin-coroutine/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag></tags><content type="html"> A coroutine is an instance of suspendable computation. åç¨‹æ˜¯å¯è¢«æŒ‚èµ·çš„è®¡ç®—çš„å®ä¾‹. æ¢å¥è¯è¯´åç¨‹æ˜¯ä¸€ä¸ªå¯¹è±¡, è¿™ä¸ªå¯¹è±¡ä¿å­˜ç€ä¸€æ®µå¯ä»¥åˆ‡æ¢çº¿ç¨‹çš„ä»»åŠ¡ + å½“å‰æ‰§è¡Œçš„çŠ¶æ€ä¸¤éƒ¨åˆ†ä¿¡æ¯.
æ—¥å¸¸æ¶‰åŠåç¨‹çš„ç¼–ç , ä¸»è¦æ˜¯æè¿°åç¨‹çš„ä»»åŠ¡å’Œç®¡ç†å¤šä¸ªåç¨‹çš„ç”Ÿå‘½å‘¨æœŸã€å¼‚å¸¸å¤„ç†ç­‰.
Kotlin ä½¿ç”¨å †æ ˆå¸§ç®¡ç†è¦è¿è¡Œå“ªä¸ªå‡½æ•°ä»¥åŠæ‰€æœ‰å±€éƒ¨å˜é‡. æŒ‚èµ·åç¨‹æ—¶, ç³»ç»Ÿä¼šå¤åˆ¶å¹¶ä¿å­˜å½“å‰çš„å †æ ˆå¸§ä»¥ä¾›ç¨åä½¿ç”¨. æ¢å¤æ—¶, ä¼šå°†å †æ ˆå¸§ä»å…¶ä¿å­˜ä½ç½®å¤åˆ¶å›æ¥, ç„¶åå‡½æ•°å†æ¬¡å¼€å§‹è¿è¡Œ. å³ä½¿ä»£ç å¯èƒ½çœ‹èµ·æ¥åƒæ™®é€šçš„é¡ºåºé˜»å¡è¯·æ±‚, åç¨‹ä¹Ÿèƒ½ç¡®ä¿ç½‘ç»œè¯·æ±‚é¿å…é˜»å¡ä¸»çº¿ç¨‹.
é—®é¢˜åœºæ™¯ å‡è®¾ç°åœ¨æœ‰ä¸ªåœºæ™¯, æ ¹æ®ç”¨æˆ·idè°ƒç”¨ä¸¤ä¸ªå¤–éƒ¨æ¥å£è·å–ç”¨æˆ·çš„å§“åå’Œå…¬å¸åç§°, æ‹¼æ¥åè¿”å›.
ç”±äºä¸¤ä¸ªå¤–éƒ¨æ¥å£è€—æ—¶è¾ƒé«˜, ç›´æ¥çš„æ€è·¯å°±æ˜¯ä½¿ç”¨ä¸¤ä¸ªçº¿ç¨‹æ¥å‘é€è¯·æ±‚ç„¶åç­‰å¾…è¯·æ±‚å…¨éƒ¨å“åº”åæ‹¼æ¥å“åº”å€¼.
æ–¹å¼1 Javaçš„Callable // å®šä¹‰ä¸¤ä¸ªCallableæ¥å¼‚æ­¥æ‰§è¡Œæ–¹æ³• Callable&lt;String> getUserName = () -> { // æ¨¡æ‹Ÿè°ƒç”¨è€—æ—¶æ–¹æ³•è·å–ç”¨æˆ·å Thread.sleep(1000); return "John"; }; Callable&lt;String> getCompany = () -> { // æ¨¡æ‹Ÿè°ƒç”¨è€—æ—¶æ–¹æ³•è·å–å…¬å¸å Thread.sleep(1000); return "Doe Corp."; }; // ä½¿ç”¨ExecutorServiceæ‰§è¡Œä¸¤ä¸ªCallableå¹¶è·å–Future ExecutorService executor = Executors.newFixedThreadPool(2); Future&lt;String> nameFuture = executor.submit(getUserName); Future&lt;String> companyFuture = executor.submit(getCompany); // åœ¨ä¸»çº¿ç¨‹ä¸­è·å–ç»“æœå¹¶åˆå¹¶ String name = nameFuture.get(); String company = companyFuture.get(); String info = name + ", " + company; System.out.println(info); // John, Doe Corp. executor.shutdown(); æ–¹å¼2 Javaçš„CompletableFuture // å®šä¹‰ä¸¤ä¸ªå¼‚æ­¥æ“ä½œ CompletableFuture&lt;String> getUserName = CompletableFuture.supplyAsync(() -> { Thread.sleep(1000); return "John"; }); CompletableFuture&lt;String> getCompany = CompletableFuture.supplyAsync(() -> { Thread.sleep(1000); return "Doe Corp."; }); // ä½¿ç”¨thenCombineåˆå¹¶ä¸¤ä¸ªå¼‚æ­¥æ“ä½œçš„ç»“æœ CompletableFuture&lt;String> combined = getUserName.thenCombine(getCompany, (name, company) -> name + ", " + company); // è·å–æœ€ç»ˆç»“æœ String result = combined.get(); System.out.println(result); // John, Doe Corp. æ–¹å¼3 Kotlinçš„Coroutine suspend fun getUserName(): String { delay(1000) // æ¨¡æ‹Ÿè°ƒç”¨è€—æ—¶æ–¹æ³• return "John" } suspend fun getCompany(): String { delay(1000) // æ¨¡æ‹Ÿè°ƒç”¨è€—æ—¶æ–¹æ³• return "Doe Corp." } fun main() { // ä½¿ç”¨asyncå¹¶å‘è°ƒç”¨ä¸¤ä¸ªsuspendå‡½æ•° val name = async { getUserName() } val company = async { getCompany() } // ä½¿ç”¨awaitç­‰å¾…ä¸¤ä¸ªä»»åŠ¡å®Œæˆå¹¶è·å–ç»“æœ val nameResult = name.await() val companyResult = company.await() println("$nameResult, $companyResult") // John, Doe Corp. } // æˆ–è€…ä½¿ç”¨awaitAll suspend fun fetchTwoDocs() = // called on any Dispatcher (any thread, possibly Main) coroutineScope { val deferreds = listOf( // fetch two docs at the same time async { fetchDoc(1) }, // async returns a result for the first doc async { fetchDoc(2) } // async returns a result for the second doc ) deferreds.awaitAll() // use awaitAll to wait for both network requests // The awaitAll function should be preferred over map { it.await() } } suspendå…³é”®å­— suspendå‡½æ•°æ˜¯åç¨‹ä¸­çš„ä»»åŠ¡æè¿°éƒ¨åˆ†, suspendå…³é”®å­—åªæ˜¯ä¸€ä¸ªè¯­æ³•æç¤º, å‘Šè¯‰å‡½æ•°è°ƒç”¨è€…è¯¥å‡½æ•°å¯èƒ½è¢«åˆ‡æ¢çº¿ç¨‹, åŒç†, ä¹Ÿåªèƒ½åœ¨suspendå‡½æ•°å†…éƒ¨è°ƒç”¨å…¶ä»–suspendå‡½æ•°, ä¾‹å¦‚ä¸Šé¢çš„delay.
ç¼–è¯‘å™¨å’ŒIDEæ ¹æ®suspendå…³é”®å­—æ¥åšä¸€ä¸ªè¯­æ³•æç¤ºä¸æ ¡éªŒ.
coroutine builder åˆ©ç”¨suspend funåªèƒ½æè¿°ä»»åŠ¡/å‡½æ•°, è¿˜éœ€è¦ä½¿ç”¨coroutine builderæ¥åˆ›å»ºåç¨‹.
launchå‡½æ•°ä¼šåˆ›å»ºä¸€ä¸ªåç¨‹è¿”å›ä¸€ä¸ªJobä¸åŒ…å«åç¨‹ç»“æœä¿¡æ¯. asyncå‡½æ•°ä¹Ÿåˆ›å»ºä¸€ä¸ªåç¨‹è¿”å›Deferred-ç±»ä¼¼FutureåŒ…å«åç¨‹çš„æœªæ¥è®¡ç®—ç»“æœ. å¯ä»¥é€šè¿‡Deferredå¯¹è±¡çš„awaitæ–¹æ³•è·å–ç»“æœå€¼.
æ‰€æœ‰çš„coroutine builderéƒ½æ˜¯CoroutineScopeçš„æ‰©å±•å‡½æ•°, å› ä¸ºä»»ä½•åç¨‹çš„ç”Ÿå‘½å‘¨æœŸéƒ½ç”±å¯¹åº”çš„CoroutineScopeå¯¹è±¡ç®¡ç†ã€‚åé¢ä¼šçœ‹åˆ°æœ‰äº›æ–¹æ³•ä¼šé»˜è®¤åˆ›å»ºCoroutineScopeå¯¹è±¡ã€‚
val time = measureTimeMillis { val one = async { doSomethingUsefulOne() } val two = async { doSomethingUsefulTwo() } println("The answer is ${one.await() + two.await()}") } println("Completed in $time ms") start = CoroutineStart.LAZYçš„asyncåç¨‹åªæœ‰åœ¨è¢«è°ƒç”¨startæˆ–è€…awaitæ—¶æ‰ä¼šå¯åŠ¨.
val time = measureTimeMillis { val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() } val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() } one.start() // ä¸ä¼šé˜»å¡ï¼Œç›´æ¥ä¸‹ä¸€è¡Œæ‰§è¡Œ two.start() println("The answer is ${one.await() + two.await()}") //æ³¨æ„, å¦‚æœæ²¡æœ‰ä¸Šé¢ä¸¤ä¸ªstartçš„è¯, é‚£ä¹ˆè¿™ä¸¤ä¸ªawaitæ˜¯å…ˆåè°ƒç”¨ï¼Œå¯¼è‡´ä¸¤ä¸ªåç¨‹é¡ºåºæ‰§è¡Œè€Œä¸æ˜¯å¼‚æ­¥ } println("Completed in $time ms") ç»“æ„åŒ–å¹¶å‘ è¿˜æ˜¯ä¸Šé¢æ–¹å¼3çš„ä¸¤ä¸ªsuspendå‡½æ•°, å¦‚æœå…¶ä¸­ä¸€ä¸ªæ–¹æ³•å¼‚å¸¸, å¦ä¸€ä¸ªæ–¹æ³•ä¹Ÿå°±æ²¡æœ‰å¿…è¦ç»§ç»­æ‰§è¡Œäº†, åœ¨Javaå¤šçº¿ç¨‹ç›®å‰éš¾ä»¥åšåˆ°ï¼ˆJEP 428å·²ç»å®ç°, å‚è€ƒjdk19çš„StructuredTaskScopeç±»ï¼‰,
è€Œåœ¨kotlinåç¨‹ä¸­, åªéœ€è¦å°†ä¸¤ä¸ªçº¿ç¨‹æ”¾åœ¨åŒä¸€ä¸ªCoroutineScopeå³å¯å®ç°:
fun main() = runBlocking&lt;Unit> { try { failedConcurrentSum() } catch(e: ArithmeticException) { println("Computation failed with ArithmeticException") } } suspend fun failedConcurrentSum(): Int = coroutineScope { //coroutineScopeå‡½æ•°åˆ›å»ºä¸€ä¸ªæ–°çš„scope val one = async&lt;Int> { try { delay(Long.MAX_VALUE) // Emulates very long computation 42 } finally { println("First child was cancelled") } } val two = async&lt;Int> { println("Second child throws an exception") throw ArithmeticException() } one.await() + two.await() } ç»“æ„åŒ–å¹¶å‘æ˜¯kotlinåç¨‹çš„æ ¸å¿ƒä¼˜åŠ¿ä¹‹ä¸€, åªæœ‰åœ¨ä½ é‡åˆ°å¤æ‚çš„åœºæ™¯æ—¶æ‰èƒ½æ„Ÿå—åˆ°ç»“æ„åŒ–å¹¶å‘çš„å¨åŠ›ä¸ä¼˜é›….
Dispatcher CoroutineDispatcherç”¨æ¥å†³å®šå“ªä¸ªï¼ˆæˆ–å‡ ä¸ªï¼‰çº¿ç¨‹æ¥è¿è¡Œè¯¥åç¨‹, å¯ä»¥å°†åç¨‹çš„æ‰§è¡Œé™åˆ¶åœ¨ä¸€ä¸ªçº¿ç¨‹æˆ–è€…æŸä¸ªçº¿ç¨‹æ± , æˆ–è€…ä¸é™åˆ¶. è‡ªå¸¦çš„å‡ ä¸ªdispatcher:
Dispatchers.Main: A coroutine dispatcher that is confined to the Main thread operating with UI objects. Usually such dispatcher is single-threaded.
Dispatchers.Default: The default CoroutineDispatcher that is used by all standard builders like launch, async, etc. if no dispatcher nor any other ContinuationInterceptor is specified in their context.
Dispatchers.IO: The CoroutineDispatcher that is designed for offloading blocking IO tasks to a shared pool of threads.
Dispatchers.Unconfined: A coroutine dispatcher that is not confined to any specific thread. It executes initial continuation of the coroutine in the current call-frame and lets the coroutine resume in whatever thread that is used by the corresponding suspending function, without mandating any specific threading policy.
æ³¨æ„, å³ä½¿æ˜¯åŒä¸€ä¸ªå‡½æ•°å†…çš„ä¸åŒè¡Œä»£ç ä¹Ÿä¸ä¸€å®šåœ¨åŒä¸€ä¸ªçº¿ç¨‹ä¸Šé¢æ‰§è¡Œ.
æ³¨æ„, Dispatcherå®ç°äº†CoroutineContextæ¥å£, æ‰€ä»¥ä¼šçœ‹åˆ°withContext(Dispatchers.IO) {}ç”¨æ³•.
CoroutineContext åç¨‹æ‰§è¡Œæ—¶æ€»æœ‰å¸¦æœ‰ä¸€ä¸ªCoroutineContext, å¯ä»¥ç†è§£ä¸ºå°±æ˜¯ä¸€ä¸ªå…ƒä¿¡æ¯Map, ä¿å­˜äº†Jobã€coroutine dispatcher ç­‰ä¿¡æ¯:
Job: æ§åˆ¶åç¨‹çš„ç”Ÿå‘½å‘¨æœŸ.
CoroutineDispatcher: å°†å·¥ä½œåˆ†æ´¾åˆ°é€‚å½“çš„çº¿ç¨‹.
CoroutineName: åç¨‹çš„åç§°, å¯ç”¨äºè°ƒè¯•.
CoroutineExceptionHandler: å¤„ç†æœªæ•è·çš„å¼‚å¸¸.
coroutine builderï¼ˆasyncã€launchï¼‰æ¥æ”¶å¯é€‰çš„CoroutineContextå¯¹è±¡å‚æ•°. CoroutineContextæœ€å¸¸è§çš„ç”¨é€”å°±æ˜¯æŒ‡å®šåç¨‹çš„dispatcher.
åœ¨kotlinä¸­, CoroutineContextè¡¨ç¤ºåç¨‹çš„context, åŒ…å«äº†å¤šä¸ªå…ƒç´ . è€ŒCoroutineContext.Elementè¡¨ç¤ºcontextçš„ä¸€ä¸ªå…ƒç´ . ç±»ä¼¼mapå’Œkvçš„å…³ç³».
ä½†æ˜¯CoroutineContext.Elementç»§æ‰¿äº†CoroutineContext, å³ä¸€ä¸ªelementä¹Ÿæ˜¯ä¸€ä¸ªcontext. è¿™ç§æŠ½è±¡å¯ä»¥ç®€åŒ–ä¸€äº›APIè®¾è®¡, ä¾‹å¦‚,withContextå‡½æ•°çš„å‚æ•°ç±»å‹æ˜¯CoroutineContext,ä½†æ˜¯æˆ‘ä»¬å¸¸å¸¸ä¼šä¼ å…¥ä¸€ä¸ªCoroutineContext.Elementçš„å®ç°ç±»å¦‚Dispatchers. ç”±äºåè€…ç»§æ‰¿äº†å‰è€…,æ‰€ä»¥è¿™æ ·çš„ä½¿ç”¨æ–¹å¼ä¹Ÿæ˜¯è¢«å…è®¸çš„.
ç”±äºå®ç°äº†plusæ“ä½œç¬¦æ–¹æ³•ï¼ŒJob() + Dispatchers.Mainä¹Ÿè¡¨ç¤ºä¸€ä¸ªCoroutineContextã€‚
CoroutineScope CoroutineScopeæ˜¯åç¨‹æœ€é‡è¦ä¹Ÿæ˜¯æœ€éš¾ç†è§£çš„ç‚¹. CoroutineScope ç»™æ¯ä¸ªåç¨‹éƒ½å®šä¹‰äº†ä¸€ä¸ªscope,ç”¨æ¥ç»„ç»‡å’Œç®¡ç†ä¸€ç»„åç¨‹çš„ç”Ÿå‘½å‘¨æœŸ.
asyncå’Œlaunchä¹Ÿæ˜¯CoroutineScopeçš„æ‰©å±•å‡½æ•°. å¾ˆå¤šæ•™ç¨‹é‡Œé¢ç›´æ¥è°ƒç”¨asyncå‡½æ•°å…¶å®æ˜¯ä½¿ç”¨äº†GlobalScopeå¯¹è±¡.
è·å–ç‹¬ç«‹çš„scopeå¯¹è±¡æœ€ä½³å®è·µæ˜¯é€šè¿‡ CoroutineScope() å’Œ MainScope() å·¥å‚å‡½æ•°. ä¸€èˆ¬ä¸å»ºè®®è‡ªå·±å®ç°CoroutineScopeæ¥å£.
suspend withContextå’Œsuspend coroutineScopeå‡½æ•°ä¹Ÿå«scoping function.
withContext: Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result.
coroutineScope: Creates a CoroutineScope and calls the specified suspend block with this scope. The provided scope inherits its coroutineContext from the outer scope, but overrides the context&rsquo;s Job.
withContextæ¯”coroutineScopeå¤šäº†ä¸€ä¸ªcontext:CoroutineContextå‚æ•°.
withContextå‡ ä¸ªä½¿ç”¨ç¤ºä¾‹
åˆ‡æ¢åˆ°IOä¸Šä¸‹æ–‡æ‰§è¡ŒIOæ“ä½œ suspend fun doSomething() { withContext(Dispatchers.IO) { // åœ¨IOä¸Šä¸‹æ–‡ä¸­æ‰§è¡ŒIOå¯†é›†å‹ä»£ç  doNetworkRequest() } } åˆ‡æ¢åˆ°ä¸»çº¿ç¨‹æ›´æ–°UI suspend fun doSomething() { val result = withContext(Dispatchers.Default) { // åœ¨é»˜è®¤ä¸Šä¸‹æ–‡ä¸­è¿›è¡Œè®¡ç®— calculateResult() } withContext(Dispatchers.Main) { // åœ¨ä¸»çº¿ç¨‹ä¸­æ›´æ–°UI updateUI(result) } } åŒæ—¶åœ¨ä¸¤ä¸ªä¸åŒä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œä»»åŠ¡ suspend fun doSomething() { val job1 = GlobalScope.launch(Dispatchers.IO) { // ... } val job2 = GlobalScope.launch(Dispatchers.Main) { // ... } withContext(Dispatchers.IO) { job1.join() // ç­‰å¾…IOä¸Šä¸‹æ–‡çš„ä»»åŠ¡ç»“æŸ } withContext(Dispatchers.Main) { job2.join() // ç­‰å¾…ä¸»çº¿ç¨‹çš„ä»»åŠ¡ç»“æŸ } } å–æ¶ˆä¸Šä¸‹æ–‡åˆ‡æ¢ suspend fun doSomething() { withContext(NonCancellable) { // ä½¿ç”¨NonCancellableä¸Šä¸‹æ–‡ // è¿™é‡Œçš„ä»£ç å—ä¸ä¼šè¢«å–æ¶ˆ doSomething() } // ... } withContext vs async çœ‹ä¸Šå»é™¤äº†è¿”å›å€¼ä¸ä¸€æ ·, ä¸¤è€…çš„åŠŸèƒ½éå¸¸ç›¸ä¼¼,éƒ½æ˜¯æ¥æ”¶contextå’Œblockå‚æ•°.
// async fun asyncDemo() = runBlocking { println("I am working") val opOne = async(IO) { operationOne() }.await() //æ³¨æ„ è¿™é‡Œä¼šé˜»å¡ç­‰åˆ°operationOneè¿”å›æ‰èƒ½ç»§ç»­ä¸‹ä¸€è¡Œæ‰§è¡Œ val opTwo = async(IO) { operationTwo() }.await() println("Done working.") println("The multiplied result is ${opOne * opTwo}") } // withContext fun withContextDemo() = runBlocking { println("I am working") val opOne = withContext(IO) { operationOne() } val opTwo = withContext(IO) { operationTwo() } println("Done working.") println("The multiplied result is ${opOne * opTwo}") } å…¶å®asyncæ˜¯ç”¨äºå¹¶å‘å¼‚æ­¥ç¼–ç¨‹çš„, ä¸Šé¢çš„asyncä½¿ç”¨æ–¹å¼æ˜¯ä¸æ¨èçš„, å› ä¸ºåœ¨åˆ›å»ºä¸€ä¸ªåç¨‹åç«‹å³è°ƒç”¨awaitä¼šé˜»å¡å½“å‰çº¿ç¨‹, æ‰€ä»¥ä¸Šé¢opOneå’ŒopTwoæ˜¯é¡ºåºæ‰§è¡Œ.
withContextåªæ˜¯ç”¨äºContextåˆ‡æ¢. ä¸Šé¢çš„ä»£ç å…¶å®ä¹Ÿå¯ä»¥å†™æˆ
val result = withContext(IO) { operationOne() + operationTwo() } Flow fun simple(): Flow&lt;Int> = flow { // flow builder, no suspend keyword before fun for (i in 1..3) { delay(1000) // pretend we are doing something useful here emit(i) // emit next value } } // Collect the flow simple().collect { value -> println(value) } // We can replace delay with Thread.sleep in the body of simple's flow { ... } and see that the main thread is blocked in this case. Flowåªæœ‰åœ¨collectè°ƒç”¨æ—¶æ‰è®¡ç®—, ä¹Ÿå¯ä»¥ä¸­é€”å–æ¶ˆ:
fun simple(): Flow&lt;Int> = flow { for (i in 1..3) { delay(100) println("Emitting $i") emit(i) } } fun main() = runBlocking&lt;Unit> { withTimeoutOrNull(250) { // Timeout after 250ms simple().collect { value -> println(value) } } println("Done") } // only collected 1 2 é™¤äº† flow è¿˜æœ‰ flowOf(1,2,3) ã€ coll.asFlow() ç­‰flow builderå‡½æ•°.
operator: transform take collect toList/toSet first reduce fold - reduce with initial value
flowOn change the context of a flow:
fun simple(): Flow&lt;Int> = flow { for (i in 1..3) { Thread.sleep(100) // pretend we are computing it in CPU-consuming way log("Emitting $i") emit(i) // emit next value } }.flowOn(Dispatchers.Default) // RIGHT way to change context for CPU-consuming code in flow builder fun main() = runBlocking&lt;Unit> { simple().collect { value -> log("Collected $value") } } å¦‚æœcollectå‡½æ•°æ¯”flowçš„emitè¿˜æ…¢çš„è¯, å¯ä»¥ä½¿ç”¨bufferå°†flowæå‰ç”Ÿæˆ
val time = measureTimeMillis { simple() // 100ms for each element .buffer() // buffer emissions, don't wait .collect { value -> delay(300) // pretend we are processing it for 300 ms println(value) } } println("Collected in $time ms") Channel val channel = Channel&lt;Int>() launch { for (x in 1..5) channel.send(x * x) channel.close() // we're done sending } // here we print received values using `for` loop (until the channel is closed) for (y in channel) println(y) println("Done!") å…¶ä»–å¸¸ç”¨å‡½æ•° runBlockingçš„ç­¾åactual fun &lt;T> runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -> T): T
çœ‹ç€å’ŒwithContextéå¸¸ç›¸ä¼¼, ä½†æ˜¯withContextæ˜¯suspendå‡½æ•°, runBlockingä¸æ˜¯.
runBlocking è¿è¡Œä¸€ä¸ªæ–°çš„åç¨‹, å¹¶å¯ä¸­æ–­åœ°é˜»å¡å½“å‰çº¿ç¨‹, ç›´åˆ°åç¨‹å®Œæˆ. æ­¤å‡½æ•°ä¸åº”åœ¨åç¨‹ä¸­ä½¿ç”¨. å®ƒæ—¨åœ¨å°†å¸¸è§„çš„é˜»å¡ä»£ç ä¸æŒ‚èµ·é£æ ¼ç¼–å†™çš„åº“è¿æ¥èµ·æ¥, ä»¥ä¾¿åœ¨mainå‡½æ•°å’Œæµ‹è¯•ä¸­ä½¿ç”¨.
å‰é¢è¯´è¿‡ï¼Œæ‰€æœ‰çš„åç¨‹éƒ½åº”è¯¥åœ¨ä¸€ä¸ªCoroutineScopeä¸‹é¢è¢«ç®¡ç†ã€‚åœ¨runBlocking {}å¤§æ‹¬å·å†…éƒ¨å†™ä»£ç æ—¶IDEä¼šæç¤ºä½ å½“å‰thisçš„typeæ˜¯CoroutineScopeï¼Œè¿™ä¸ªscopeå®é™…æ˜¯runBlockingæ–¹æ³•å†…æ„å»ºçš„BlockingCoroutineå¯¹è±¡ã€‚
ç”±äºAbstractCoroutineæ¥å£ç»§æ‰¿äº†CoroutineScope,æ‰€ä»¥BlockingCoroutineä¹Ÿæ˜¯ä¸€ä¸ªCoroutineScopeå®ä¾‹ã€‚
kotlin.system.measureTimeMillis Executes the given block and returns elapsed time in milliseconds.
delay Delays coroutine for a given time without blocking a thread and resumes it after a specified time.
suspend fun yield() Yields the thread (or thread pool) of the current coroutine dispatcher to other coroutines on the same dispatcher to run if possible.
Coroutine.startå‡½æ•° public fun &lt;R> start(start: CoroutineStart, receiver: R, block: suspend R.() -> T) { start(block, receiver, this) //è¿™é‡Œå®é™…è°ƒç”¨çš„æ˜¯CoroutineStart.invokeæ–¹æ³•ã€‚thisæŒ‡çš„æ˜¯å½“å‰coroutine }</content></entry><entry><title>åœ¨macOSé€šè¿‡SSHè®¿é—®Windowsçš„WSL2 Ubuntu</title><url>https://zhimoe.github.io/post/access-into-wsl2-ubuntu-from-macos/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>macOS</tag><tag>WSL2</tag></tags><content type="html"> é…ç½®Windowså’ŒWSL2, ä½¿å¾—èƒ½é€šè¿‡å…¶ä»–ç”µè„‘è¿œç¨‹SSHåˆ°WSL2 Ubuntu.
èƒŒæ™¯ ä¹‹å‰çš„ç”µè„‘é…ç½®æ˜¯LinuxMintå°å¼æœº + M1 macbookç¬”è®°æœ¬. ä½¿ç”¨Linuxä¸»è¦åŸå› æ˜¯å‘½ä»¤è¡Œå’ŒDocker. æœ€è¿‘ç”±äºäºŒåå¤§, å·¥ä½œVPNåœ¨macOSä¸è®©ç”¨, åªèƒ½å°†å°å¼æœºå®‰è£…ä¸ŠWin10, å‘ç°dockeråœ¨WSL2è¿è¡Œéå¸¸ä¸æ»‘, è¿™æ ·æ­£å¥½å¯ä»¥å½“ä½œmacbookçš„DockeræœåŠ¡å™¨. åˆ‡æ¢åˆ°Windowsè¿˜æœ‰ä¸€ä¸ªåŸå› å°±æ˜¯, Linuxçš„æ¡Œé¢çœŸçš„ä¸è¡Œ, æœ€è¿‘ä¸‰å¹´å„ç§ç‰ˆæœ¬çš„æ¡Œé¢ä½¿ç”¨ä¸€åœˆ, Budgie,Gnome,Cinnamon,Xfceè¿™äº›æ¡Œé¢æ€»æ˜¯å¶å°”ç•Œé¢å¤±å»å“åº”,KDEç”¨çš„ä¸å¤š, å¡é¡¿æ²¡é‡åˆ°ä½†æ˜¯å¯åŠ¨æ€»æ˜¯æ…¢åŠç§’. Win10é™¤äº†æ²¡æœ‰Bash/Zsh, ä¸­æ–‡å­—ä½“åƒåœ¾ç‚¹, å…¶ä»–çš„éƒ½å®ŒèƒœLinux.
ä¸‹é¢çš„æ•™ç¨‹ä¸»è¦å‚è€ƒ:Configuring SSH access into WSL 1 and WSL 2
1 Win10 å®‰è£… WSL2 Ubuntu æ³¨æ„, æ˜¯å®‰è£…WSL2. æ–¹æ³•å‚è€ƒè¿™ä¸ªenable-virtual-machine-feature:
ä»¥ç®¡ç†å‘˜èº«ä»½æ‰“å¼€ PowerShellï¼ˆâ€œå¼€å§‹â€èœå• >â€œPowerShellâ€ >å•å‡»å³é”® >â€œä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œâ€ï¼‰, ç„¶åè¾“å…¥ä»¥ä¸‹å‘½ä»¤:
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart; å®‰è£… &ldquo;é€‚ç”¨äº x64 è®¡ç®—æœºçš„ WSL2 Linux å†…æ ¸æ›´æ–°åŒ…&rdquo;; å°†WSLè®¾ç½®é»˜è®¤version 2, in PowerShell: wsl --set-default-version 2; å®‰è£…Ubuntu, in PowerShell: wsl --install -d Ubuntu-22.04; æ›´å¤šå‚è€ƒ .
2 é…ç½®SSH serverï¼ˆåœ¨Ubuntuæ‰§è¡Œï¼‰ è¿›å…¥Ubuntu
#ä¿®æ”¹è½¯ä»¶æº sudo sed -i "s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g" /etc/apt/sources.list sudo sed -i "s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g" /etc/apt/sources.list sudo apt update &amp;&amp; sudo apt upgrade -y å®‰è£…é…ç½®sshæœåŠ¡
sudo apt install openssh-server sudo vim /etc/ssh/sshd_config # ä¿®æ”¹ä¸‹é¢å‡ ä¸ªé…ç½® # Port 2222 # AddressFamily any # ListenAddress 0.0.0.0 # PasswordAuthentication yes # å¦‚æœå¯åŠ¨é‡åˆ°è¿™ä¸ªé”™è¯¯, è¯·æ‰§è¡Œä¸‹é¢å‘½ä»¤: sshd: no hostkeys available -- exiting sudo ssh-keygen -A # å¯åŠ¨sshæœåŠ¡ sudo /usr/sbin/service ssh start 3 Win10é˜²ç«å¢™è®¾ç½® æ‰“å¼€æ§åˆ¶é¢æ¿\ç³»ç»Ÿå’Œå®‰å…¨\Windows Defender é˜²ç«å¢™.
æœ€å·¦è¾¹æœ‰é«˜çº§è®¾ç½® å³é”®ç‚¹å‡»å…¥ç«™è§„åˆ™ æ–°å»ºå…¥ç«™è§„åˆ™ ç‚¹å‡»ç«¯å£,ç‰¹å®šç«¯å£è®¾ç½®2222 ç„¶åå‘½åä¹‹åä¸€è·¯ä¸‹ä¸€æ­¥å°±è¡Œ æˆ–è€…é€šè¿‡shellè®¾ç½®,ä»¥ç®¡ç†å‘˜èº«ä»½æ‰“å¼€ PowerShell:
New-NetFirewallRule -Name sshd -DisplayName 'sshd for WSL' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 2222 4 æœ¬åœ°éªŒè¯SSHè®¿é—®Ubuntu æ‰“å¼€Windows Terminal, å°è¯•sshè®¿é—®Ubuntu
ssh -p 2222 wsluser@localhost å¦‚æœè¿æ¥ä¸Šè¯´æ˜sshé…ç½®å·²ç»å®Œæˆ.
5 Ubuntu sshæœåŠ¡å¼€æœºè‡ªåŠ¨å¯åŠ¨ WSL2 Ubuntu çš„sshæœåŠ¡ä¸æ˜¯è·Ÿç€Win10å¼€æœºè‡ªåŠ¨å¯åŠ¨çš„. åœ¨Win10çš„%USERPROFILE%ç›®å½•ä¸‹é¢æ–°å»ºæ–‡ä»¶sshd.bat
rem sshd.bat @echo off setlocal C:\Windows\System32\bash.exe -c "sudo /usr/sbin/service ssh start" rem C:\Windows\System32\wsl.exe -e "sudo /usr/sbin/service ssh start" endlocal æ³¨æ„ä¸Šé¢ bash.exe -c å’Œ wsl.exe -e ä¸¤ä¸ªåŠŸèƒ½æ˜¯ä¸€æ ·çš„. bashåé¢ä¸ç»´æŠ¤äº†, wslæ˜¯å®˜æ–¹æ¨èå‘½ä»¤, ä½†æ˜¯bashæœ‰è¾“å‡º.
æ¥ä¸‹æ¥æŠŠä¸Šé¢çš„è„šæœ¬é…ç½®æˆå¼€æœºè‡ªåŠ¨æ‰§è¡Œ:
æŒ‰ä¸‹Winé”®, æœç´¢â€œä»»åŠ¡è®¡åˆ’ç¨‹åºâ€, å³è¾¹ç‚¹å‡»â€œåˆ›å»ºä»»åŠ¡â€, å¸¸è§„:è®¾ç½®ä»»åŠ¡åå­—â€œStart WSL SSHâ€, å‹¾é€‰ä¸Šâ€œä½¿ç”¨æœ€é«˜æƒé™è¿è¡Œâ€ï¼ˆè¿™æ˜¯ç»™åé¢ç½‘å¡æ˜ å°„å‘½ä»¤çš„æƒé™ï¼‰ è§¦å‘å™¨: æ–°å»º, é€‰æ‹©â€œå¯åŠ¨æ—¶â€ æ“ä½œ: é€‰æ‹©ä¸Šé¢çš„sshd.batè„šæœ¬æ–‡ä»¶. ä¿å­˜, é‡å¯ç”µè„‘, æ‰“å¼€Terminal, é‡æ–°è¯•è¯•ssh -p 2222 wsluser@localhost
6 ç½‘å¡æ˜ å°„ åˆ°ç›®å‰ä¸ºæ­¢, åœ¨Win10æœ¬åœ°å·²ç»å¯ä»¥åœ¨å¼€æœºåç›´æ¥é€šè¿‡SSHè®¿é—®Ubuntuäº†, ä½†æ˜¯ä½ å¦‚æœåœ¨å±€åŸŸç½‘å†…çš„å…¶ä»–ç”µè„‘è®¿é—®, è¿˜æ˜¯è¿ä¸ä¸Šçš„. è¿™æ˜¯å› ä¸ºWSL2æ˜¯ä¸ªè™šæ‹Ÿæœº.
WSL 2 is a well-hidden virtual machine, but it is still a virtual machineâ€”and the consequences of this design are leaky. The network interface we see within WSL is a virtual interface that does not match the physical interface that Windows manages. Windows does a good job at hiding this fact when operating directly on the local machine (e.g. you can SSH into WSL from localhost and it will work), but attempts to reach WSL from a separate machine will fail.
è®¾ç½®å¼€æœºè‡ªåŠ¨æ‰§è¡Œç½‘å¡æ˜ å°„å‘½ä»¤, å°†ä¸Šé¢çš„sshd.batæ–‡ä»¶æ”¹æˆå¦‚ä¸‹:
rem sshd.bat @echo off setlocal C:\Windows\System32\bash.exe -c "sudo /usr/sbin/service ssh start" rem C:\Windows\System32\wsl.exe -e "sudo /usr/sbin/service ssh start" C:\Windows\System32\netsh.exe interface portproxy delete v4tov4 listenport=2222 listenaddress=0.0.0.0 protocol=tcp for /f %%i in ('wsl hostname -I') do set IP=%%i C:\Windows\System32\netsh.exe interface portproxy add v4tov4 listenport=2222 listenaddress=0.0.0.0 connectport=2222 connectaddress=%IP% endlocal ä¿å­˜åå¯åŠ¨, åœ¨macbookè¯•è¯•, æˆåŠŸ.</content></entry><entry><title>äº‘åŸç”ŸJavaå¼€å‘æ¡†æ¶Quarkuså­¦ä¹ ç¬”è®°</title><url>https://zhimoe.github.io/post/quarkus-notes/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>quarkus</tag></tags><content type="html"> ä»€ä¹ˆæ˜¯ MicroProfile MicroProfileæ˜¯ä¸€ä¸ªå¾®æœåŠ¡çš„å¹³å°å®šä¹‰, ç›®æ ‡æ˜¯é’ˆå¯¹å¾®æœåŠ¡æ¶æ„ä¼˜åŒ–ä¼ä¸šJavaå¼€å‘. ç”±äºJavaEEçš„æ ‡å‡†æ›´æ–°è¶Šæ¥è¶Šæ…¢, è·Ÿä¸ä¸ŠWebæŠ€æœ¯ä¸K8Sçš„å‘å±•, äºæ˜¯ä¸€ç»„ä¾›åº”å•†ï¼ˆåŒ…æ‹¬Tomitribeï¼‰å†³å®šåˆ›å»ºMicroProfile, è¿™æ˜¯ä¸€ä¸ªä¼˜åŒ–çš„å¾®æœåŠ¡æ¶æ„å¹³å°, åœ¨2016å¹´åŠ å…¥EclipseåŸºé‡‘ä¼š.
MicroProfileæ˜¯ä¸€ç»„è§„èŒƒ, åŒ…å«å¦‚OpenTracing ã€OpenAPI ã€RestClientã€Configã€ FaultToleranceã€ CDIç­‰ä¸€ç»„æ ‡å‡†.å½“å‰æœ€æ–°æ ‡å‡†æ˜¯5.0. å„å¤§Javaå‚å•†æœ‰å¾ˆå¤šå®ç°, æœ€æœ‰åçš„å°±æ˜¯çº¢å¸½çš„Quarkus, å…¶ä»–å®ç°æœ‰Open Libertyå’ŒPayara Enterprise.
æ³¨æ„SpringBootä¸æ˜¯MicroProfileè§„èŒƒå®ç°, Bootæ˜¯ç‹¬ç«‹äºMicroProfileå’ŒJavaEEè§„èŒƒçš„, ä½†æ˜¯åŠŸèƒ½ä¸Šå¤§åŒå°å¼‚, Quarkusä¹Ÿæä¾›äº†Springæ³¨è§£çš„æ”¯æŒ.
Quarkus Quarkusæ˜¯ä¸€ä¸ªMicroProfileè§„èŒƒçš„å®ç°, ä¸“é—¨ä¸ºäº‘æ—¶ä»£æ‰“é€ .æœ‰ï¼šå¯åŠ¨æ—¶é—´çŸ­, å†…å­˜å ç”¨å°, æ”¯æŒnativeç¼–è¯‘ï¼ˆéƒ¨ç½²åœ¨GraalVM), æ”¯æŒK8Sç‰¹æ€§(ä¸ä»…æ˜¯éƒ¨ç½², è¿˜åŒ…æ‹¬è‡ªåŠ¨ç”ŸæˆK8Sèµ„æºæ–‡ä»¶ç­‰)ä¼˜åŠ¿. æœ¬è´¨ä¸Šæ˜¯ç²¾é€‰äº†ä¸€äº›ä¼˜è´¨ç»„ä»¶, é€šè¿‡æ‰©å±•(extensions)æ¨¡å¼æä¾›å¿«é€Ÿä¸šåŠ¡å¼€å‘çš„èƒ½åŠ›.
åˆ›å»ºé¡¹ç›® Quarkusæä¾›äº†å¼ºå¤§Cliã€Mavenæ’ä»¶ã€Gradleæ’ä»¶æ”¯æŒ. ä»¥ä¸‹ä¸»è¦ä½¿ç”¨maven.
mvn io.quarkus.platform:quarkus-maven-plugin:2.10.2.Final:create \ -DprojectGroupId=moe.zhi \ -DprojectArtifactId=quarkus-demo \ -Dextensions="resteasy-reactive-jackson" cd quarkus-demo æ‰“å¼€IDE,å¯ä»¥çœ‹åˆ°è‡ªåŠ¨åŒ…å«pom.xmlå’ŒDockerfile(åˆ†ä¸ºä¸åŒç›®æ ‡éƒ¨ç½²ç¯å¢ƒ, æ¯ä¸ªæ–‡ä»¶æä¾›äº†è¯¦ç»†ä½¿ç”¨è¯´æ˜).é¡¹ç›®ç›´æ¥è¿è¡Œå°±æ˜¯ä¸€ä¸ªhello world apiæœåŠ¡. å¦‚æœéœ€è¦å¢åŠ ä¸€ä¸ªæ‰©å±•, é€šè¿‡maven add-extensionæ’ä»¶çš„extensionså‚æ•°æ·»åŠ , æ’ä»¶è‡ªåŠ¨ä¼šä¿®æ”¹pom.xmlæ–‡ä»¶, æ·»åŠ å¯¹åº”çš„maven lib.
# add Caffeine cache support mvn quarkus:add-extension -Dextensions="cache" quarkus ç›®å‰å·²ç»æœ‰ä¸Šç™¾ä¸ªextension, å¯ä»¥é€šè¿‡mvn quarkus:list-extensionsæŸ¥çœ‹æ‰€æœ‰.ä¹Ÿå¯ä»¥åœ¨quarkus docæŸ¥çœ‹.
æ³¨è§£ Quarkusçš„æ³¨è§£ç¬¦åˆJava CDIè§„èŒƒ. DIéƒ¨åˆ†çš„æ³¨è§£åŸºæœ¬å¯ä»¥å’ŒSpringçš„åšä¸€ä¸€å¯¹ä¸Š.
//Spring -> CDI/MicroProfile @Autowired -> @Inject @Qualifier -> @Named @Value -> @ConfigProperty(ConfigMapç”¨äºåˆ†ç»„é…ç½®keyçš„å…¬å…±å‰ç¼€,ConfigPropertieså·²ç»åºŸå¼ƒ) @Component -> @Singleton @Configuration -> @ApplicationScoped @Bean -> @Produces é…ç½® å’ŒSpringç±»ä¼¼, Quarkusä½¿ç”¨ä¸€ä¸ªapplication.propertiesæ–‡ä»¶é…ç½®å±æ€§.
ä½¿ç”¨@ConfigPropertyè¯»å–é…ç½®å±æ€§.å¦‚æœå±æ€§æ˜¯list, ä½¿ç”¨é€—å·åˆ†éš”.
é…ç½®æ–‡ä»¶ä¸­éƒ½æ˜¯Stringå’ŒInt, MicroProfile Configurationè‡ªå¸¦äº†ä¸€ç³»åˆ—çš„è½¬æ¢å™¨ï¼š
boolean: trueã€1ã€YESã€Yã€ONä¸ºtrue, å…¶ä»–ä¸ºfalse Byte,Short,Integer,Long,Float,Double,Character,Class(Class.forName)è‡ªåŠ¨è½¬æ¢ ç›®æ ‡ç±»å‹æœ‰ public static T of(String) æˆ–è€…public static T valueOf(String) æ–¹æ³• ç›®æ ‡ç±»å‹æœ‰ public static T parse(CharSequence) æ–¹æ³• ç›®æ ‡ç±»å‹æœ‰ public constructor(String)æ„é€ å‡½æ•° è‡ªå®šä¹‰è½¬æ¢å™¨å‚è€ƒorg.eclipse.microprofile.config.spi.Converter
é…ç½®å±æ€§çš„éªŒè¯ éœ€è¦quarkus-hibernate-validatoræ‰©å±•, ç„¶åä½¿ç”¨@Maxã€@Digitsã€@Emailã€@NotNullå’Œ@NotBlankç­‰æ ¡éªŒæ³¨è§£.
è‡ªå®šä¹‰æ ¡éªŒå™¨éœ€è¦å®ç°javax.validation.ConstraintValidatoræ¥å£.
è‡ªå®šä¹‰é…ç½®æº å‚è€ƒorg.eclipse.microprofile.config.spi.ConfigSource
è·å–ç¯å¢ƒå˜é‡ ä½¿ç”¨@Inject Config configçš„getPropertyNames()è·å¾—æ‰€æœ‰å±æ€§.
å±æ€§æ¥æºä¼˜å…ˆçº§ Profile Quarkusè‡ªå¸¦ä¸‰ä¸ªprofileç¯å¢ƒ:dev, test, prod.
è®¾ç½®ä¸åŒçš„profileå±æ€§ä½¿ç”¨%{profile}.config.key=value.ä¾‹å¦‚
%dev.quarkus.http.port=8181 logging level Quarkuså†…éƒ¨ä½¿ç”¨ JBoss Logging, å¦‚æœéœ€è¦ä½¿ç”¨Slf4j,æ·»åŠ ä¾èµ–:
&lt;dependency> &lt;groupId>org.jboss.slf4j&lt;/groupId> &lt;artifactId>slf4j-jboss-logmanager&lt;/artifactId> &lt;/dependency> quarkus.log.level=DEBUG quarkus.log.file.enable=true # è°ƒæ•´packageä¸‹é¢çš„log level, æ³¨æ„åŒå¼•å· quarkus.log.category."io.undertow.request.security".level=TRACE æ”¯æŒé›†ä¸­ç®¡ç†æ—¥å¿—, å‚è€ƒlogging-jsonæ‰©å±•.
quarkusç”Ÿå‘½å‘¨æœŸäº‹ä»¶ æ³¨å…¥io.quarkus.runtime.StartupEventå’Œio.quarkus.runtime.ShutdownEventäº‹ä»¶å³å¯å“åº”.
@ApplicationScoped @Slf4j public class AppEventListener { void onStart(@Observes StartupEvent event) { log.info("#### app started..."); } void onShutdown(@Observes ShutdownEvent event) { log.info("### app shutdown..."); } } æ‹¦æˆªå™¨ é¦–å…ˆé€šè¿‡@javax.interceptor.InterceptorBindingåˆ›å»ºä¸€ä¸ªæ‹¦æˆªå™¨æ³¨è§£.
@Inherited @InterceptorBinding @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD, ElementType.TYPE}) public @interface Logit { } ç„¶åé€šè¿‡@javax.init.AroundInvokeå’Œ@javax.init.AroundConstructä¸¤ä¸ªå…·æœ‰ç›¸åº”æ‹¦æˆªç»‘å®šåŠŸèƒ½çš„æ‹¦æˆªå™¨.
@Logit @Interceptor public class LogitInterceptor { @AroundInvoke public Object invoke(InvocationContext ctx) throws Exception { System.out.println("#### interceptor" + ctx.getMethod().getName()); return ctx.proceed(); } } RestfulæœåŠ¡ Quarkuså®ç°äº†JAX-RSè§„èŒƒ, æ”¯æŒ@GET,@POST, @PUTç­‰httpåŠ¨è¯æ³¨è§£.é»˜è®¤è®¾ç½®ä¸‹, quarkusä½¿ç”¨RESTEasyå’ŒVertxæ¡†æ¶, è€Œä¸æ˜¯Servletè§„èŒƒ.å¦‚æœéœ€è¦ä½¿ç”¨Servlet, åˆ™å¢åŠ quarkus-undertowæ‰©å±•, è¿™æ˜¯JBOSSï¼ˆwildfly)çš„ServletæœåŠ¡å™¨çš„å¼•æ“.
é€šè¿‡@Pathæ³¨è§£åŒ¹é…URI.
é€šè¿‡@Context UriInfo uriInfoè·å–urlå†…å®¹.
é€šè¿‡@QueryParam("p")å‚æ•°æ³¨è§£è·å–QueryStringä¸­çš„å‚æ•°.
å…¶ä»–å‚æ•°ï¼šè¡¨å•å‚æ•° (@FormParam)ã€çŸ©é˜µå‚æ•°(@MatrixParam)æˆ–cookieå€¼ (@CookieParam).
æ­¤å¤–, ä½¿ç”¨@Contextæ³¨è§£, ä½ è¿˜å¯ä»¥æ³¨å…¥å…¶ä»–ä¸ JAX-RSç›¸å…³çš„å…ƒç´ , å¦‚javax.ws.rs.core.SecurityContextã€
javax.ws.rs.sse.SseEventSinkæˆ–javax.ws.rs.sse.Sse.
json-p(processing)å’Œjson-b(binding)æ˜¯JavaEEè§„èŒƒ.å¦‚æœAPIéœ€è¦è¿”å›json,éœ€è¦å¢åŠ quarkus-testeasy-jsonbæ‰©å±•.
å¦‚æœdata modelçš„å­—æ®µä¸jsonå­—æ®µä¸åŒå, éœ€è¦ä½¿ç”¨javax.json.bind.annotation.JsonbPropertyæ³¨è§£ç»‘å®š.
class Stu { @Jsonbproperty("first-name") String firstNm; } å¦‚æœä½¿ç”¨jackson, åˆ™éœ€è¦quarkus-resteasy-jackonæ‰©å±•, ä½¿ç”¨com.fasterxml.jackson.databind.ObjectMapperåšjsonè½¬æ¢.
Restå®¢æˆ·ç«¯ ä½¿ç”¨restå®¢æˆ·ç«¯è°ƒç”¨å¤–éƒ¨æœåŠ¡æ¥å£, éœ€è¦å¢åŠ "rest-client"å’Œ"resteasy-jsonb"æ‰©å±•.
private Client rest=ClientBuilder.newClient(); public String getTime(){ Response resp=rest.target("http://worldclockapi.com") .path("/api/json/{timezone}/now") .resolveTemplate("timezone","GMT") .request(MediaType.APPLICATION_JSON) .get(Response.class); return resp.readEntity(String.class); } æŒä¹…åŒ– Agroalæ˜¯Quarkusä¸­é¦–é€‰çš„æ•°æ®æºå’Œè¿æ¥æ± å®ç°,ä¸å®‰å…¨ã€äº‹åŠ¡ç®¡ ç†å’Œå¥åº·æŒ‡æ ‡è¿›è¡Œäº†é›†æˆ. è™½ç„¶å®ƒæ˜¯ä¸€ä¸ªæ‰©å±•ç¨‹åº,ä½†å¦‚æœä½ æ­£åœ¨ä½¿ ç”¨Hibernate ORMæˆ–Panache,Agroalæ‰©å±•ä¼šè¢«é¡ºå¸¦åŠ è½½è¿›æ¥. ä¹‹åä½  è¿˜éœ€è¦ä¸€ä¸ªæ•°æ®åº“é©±åŠ¨æ‰©å±•,ç›®å‰,H2ã€PostgreSQLã€MariaDBã€ MySQLã€Microsoft SQL Serverå’ŒDerbyéƒ½æœ‰æ”¯æŒçš„æ‰©å±•,å¯ä»¥é€šè¿‡ Maven add-extensionæ·»åŠ æ­£ç¡®çš„æ•°æ®åº“é©±åŠ¨æ‰©å±•
å¦‚æœä½ æƒ³è¦ä½¿ç”¨å“åº”å¼ç¼–ç¨‹, ä¹Ÿå¯ä»¥ä½¿ç”¨Vert.x reactive drivers.
# é…ç½®å¤šä¸ªæ•°æ®æºçš„è¯åœ¨ quarkus.datasourceåé¢è·Ÿç€ä¸€ä¸ªè‡ªå®šä¹‰çš„ds nameå³å¯.ä¾‹å¦‚ # configure your datasource quarkus.datasource.url = jdbc:postgresql://localhost:5432/library-database quarkus.datasource.driver = org.postgresql.Driver quarkus.datasource.username = melvil quarkus.datasource.password = dewey # é…ç½®ç¬¬äºŒä¸ªæ•°æ®æº æŒ‡å®šds name ä¸º orders quarkus.datasource.orders.url = jdbc:postgresql://localhost:5432/library-database quarkus.datasource.orders.driver = org.postgresql.Driver quarkus.datasource.orders.username = melvil quarkus.datasource.orders.password = dewey éé»˜è®¤æ•°æ®æºéœ€è¦ä½¿ç”¨@DataSource(&ldquo;ds name&rdquo;)æŒ‡å®š:
import javax.inject.Inject; @Inject DataSource("orders") AgroalDatasource ordersDs; å®¹é”™ éœ€è¦æ·»åŠ quarkus-smallrye-fault-toleranceæ‰©å±•.
å›é€€ä¸é‡è¯•ï¼š@org.eclipse.microprofile.faulttolerance.Retry, @org.eclipse.microprofile.faulttolerance.Fallback. Fallbackçš„handleréœ€è¦å®ç°org.eclipse.micropro file.faulttolerance.FallbackHandleræ¥å£
è¶…æ—¶ï¼š @org.eclipse.microprofile.faultttoler ance.Timeout.
è¿‡è½½ä¿æŠ¤(å¹¶å‘è¯·æ±‚ä¸ªæ•°)ï¼š @org.eclipse.microprofile.faultttolerance.Bulkhead.
å‹æµ‹ >siege -r 1 -c 4 -v http:localhost:8080/hello/bulkhead
æ–­è·¯å™¨ï¼š @CircuitBreaker
@CircuitBreaker(requestVolumeThreshold = 4, // &lt;1> æ»šåŠ¨çª—å£ failureRatio = 0.75, // &lt;2>æ–­è·¯é˜ˆå€¼ delay = 2000) // &lt;3> é‡æ–°æ‰“å¼€æ—¶é•¿ms å¦‚æœä½¿ç”¨@Fallback, ä¸”CircuitBreakerOpenExceptionè¢«æŠ›å‡º, å› é€€é€»è¾‘å°†è¢«æ‰§è¡Œ. å¦‚æœä½¿ç”¨@Retry, æ¯æ¬¡é‡è¯•éƒ½ç”±æ–­è·¯å™¨å¤„ç†, å¹¶è®°å½•æˆåŠŸæˆ–å¤± è´¥. å¦‚æœä½¿ç”¨@Bulkhead, åˆ™åœ¨è¯•å›¾è¿›å…¥bulkheadä¹‹å‰æ£€æŸ¥æ–­è·¯å™¨. å¯è§‚å¯Ÿ health healthï¼š æ·»åŠ äº†quarkus-smallrye-healthè‡ªåŠ¨æ³¨å†Œ q/health/liveå’Œq/health/readyä¸¤ä¸ªæ¢é’ˆ è‡ªå®šä¹‰ï¼šå®ç°ä¸€ä¸ª org.eclipse.microprofile.health.HealthCheckæ¥å£, å¹¶åŠ ä¸Š@org.eclipse.microprofile.health.Liveness
æˆ–@org.eclipse.microprofile.health.Readinessæ³¨è§£ æŒ‡æ ‡ æ·»åŠ quarkus-smallrye-metricsæ‰©å±•, è‡ªåŠ¨æš´éœ²q/metricsç«¯ç‚¹. è‡ªå®šä¹‰æŒ‡æ ‡ï¼š @Counted @Gauge @Metered @Timed OpenTelemetry Quarkus Opentelemetry configuration
Reactiveç¼–ç¨‹ Quarkusæ”¯æŒä¸¤ç§å“åº”å¼ç¼–ç¨‹æ–¹å¼ï¼š
Reactive Programming with Mutiny Coroutines with Kotlin Quarkusæ”¯æŒæ··åˆå‘½ä»¤å¼ä¸å“åº”å¼ç¼–ç¨‹, æ‰€ä»¥ä¸éœ€è¦åˆ»æ„å°†æ‰€æœ‰ä»£ç æ”¹é€ æˆå“åº”å¼å°±å¯ä»¥äº«å—åˆ°é«˜æ€§èƒ½.æ›´å¤šè§ï¼š
unification-of-imperative-and-reactive
class loading in quarkus productionæ¨¡å¼å’Œnative imageæ¨¡å¼ä¸‹, quarkusçš„ç±»åŠ è½½å™¨éƒ½æ˜¯ system ClassLoader(nativeæ¨¡å¼ä¸æ”¯æŒå¤šClassLoaders)
æ‰€æœ‰quarkus appéƒ½æ˜¯é€šè¿‡QuarkusBootstrap classåˆ›å»º.è¿™ä¸ªç±»è§£æappæ‰€æœ‰çš„ç›¸å…³ä¾èµ–(ç¼–è¯‘æˆ–è¿è¡Œæ—¶çš„ä¾èµ–),æœ€ç»ˆå¾—åˆ°ä¸€ä¸ªCuratedApplication class, è¿™ä¸ªç±»åŒ…å«è¿™ä¸ªappæ‰€æœ‰çš„ç±»åŠ è½½ä¿¡æ¯.
CuratedApplication å¯ä»¥ç”¨äºåˆ›å»ºä¸€ä¸ªAugmentAction å®ä¾‹, è¿™ä¸ªå®ä¾‹ç”¨äºåˆ›å»ºappå¹¶å¯åŠ¨/é‡å¯.
åœ¨devæ¨¡å¼ä¸‹, quarkusé€šè¿‡classloaderæ”¯æŒçƒ­åŠ è½½, åœ¨prodæ¨¡å¼ä¸‹, åªæœ‰ system ClassLoader.
é™¤äº†çƒ­åŠ è½½, åœ¨devæ¨¡å¼ä¸‹, æä¾›äº†q/dev DEV UI,æ”¯æŒé…ç½®åº”ç”¨, æŸ¥çœ‹ç¼“å­˜, æŸ¥çœ‹ç±»ä¿¡æ¯, æŸ¥çœ‹/æ‰§è¡Œå®šæ—¶ä»»åŠ¡, æŸ¥çœ‹å¥åº·çŠ¶æ€, æ‰§è¡Œæ•°æ®è„šæœ¬è¿ç§»ç­‰ç­‰.</content></entry><entry><title>Git çš„ detatched Headæ¨¡å¼å’Œè§£å†³é—®é¢˜æ–¹æ³•</title><url>https://zhimoe.github.io/post/git-detatched-head/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>git</tag></tags><content type="html"> æœ‰æ—¶å€™commitå®Œä»£ç ågit pushä¼šé‡åˆ°ä¸‹é¢çš„é”™è¯¯
To push the history leading to the current (detached HEAD) é”™è¯¯æç¤ºè¯´å½“å‰HEADæ²¡æœ‰æŒ‡å‘ä»»ä½•åˆ†æ”¯ï¼Œä½†æ˜¯ä½ è®°å¾—æ˜æ˜æœ‰æŒ‡å‘ä¸€ä¸ªåˆ†æ”¯çš„
å¤ç°é—®é¢˜ 1ã€å‡è®¾ä½ å½“å‰åœ¨masteråˆ†æ”¯ï¼Œä¸”æœ‰ä¸¤æ¬¡æäº¤
Prj on î‚  master â¯ git log --oneline --graph --decorate * 314c9df (HEAD -> master) 2nd commit * ae15845 initial commit 2ã€åˆ‡å›åˆ°ç¬¬ä¸€æ¬¡æäº¤
Prj on î‚  master â¯ git checkout ae15845 Note: switching to 'ae15845'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by switching back to a branch. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -c with the switch command. Example: git switch -c &lt;new-branch-name> Or undo this operation with: git switch - Turn off this advice by setting config variable advice.detachedHead to false HEAD is now at ae15845 initial commit gitç›´æ¥ä¼šæç¤ºä½ å½“å‰HEADå·²ç»detachedã€‚è¿™æ˜¯å› ä¸ºå½“HEADç¦»å¼€å½“å‰åˆ†æ”¯ï¼ˆmasterï¼‰çš„æœ«ç«¯commitæ—¶ï¼ŒGitä¼šé»˜è®¤ä½ æƒ³è¦ç¦»å¼€å½“å‰åˆ†æ”¯ï¼Œä½†æ˜¯Gitä¸ä¼šè‡ªåŠ¨åˆ›å»ºä¸€ä¸ªæ–°åˆ†æ”¯ï¼ˆå› ä¸ºæ²¡æœ‰æä¾›åˆ†æ”¯åç§°ï¼‰ã€‚
æ‰€ä»¥HEADå˜æˆæ²¡æœ‰æŒ‡å‘ä»»ä½•åˆ†æ”¯çš„çª˜å¢ƒï¼Œå³ä½¿ä½ å†æ¬¡å›åˆ°åˆšæ‰é‚£ä¸ªåˆ†æ”¯çš„æœ«ç«¯commitï¼Œè¿˜æ˜¯å¤„äºdetachedçŠ¶æ€ã€‚
3ã€åˆ‡å›masteråˆ†æ”¯çš„æœ«ç«¯commitå¹¶æäº¤æ–°å†…å®¹
Prj (ae15845) # æ³¨æ„ zshé…ç½®è¿™é‡Œå±•ç¤ºçš„æ˜¯å½“å‰HEADï¼Œä¸‹é¢ä¹Ÿç»™äº†æç¤º â¯ git checkout 314c9df Previous HEAD position was ae15845 initial commit HEAD is now at 314c9df 2nd commit # æäº¤ç‚¹æ–°ä¸œè¥¿ Prj (314c9df) â¯ echo "3nd file " > 3.txt Prj (314c9df) [?] â¯ git add . &amp;&amp; git commit -m "3nd commit" [detached HEAD 09fb4a5] 3nd commit 1 file changed, 1 insertion(+) create mode 100644 3.txt Prj (09fb4a5) â¯ git log --oneline --graph --decorate * 09fb4a5 (HEAD) 3nd commit * 314c9df (master) 2nd commit * ae15845 initial commit å¯ä»¥çœ‹åˆ°æ­¤æ—¶HEADå’Œmasteråˆ†æ”¯è¿˜æ˜¯åˆ†ç¦»çš„ã€‚
çœŸå®åœºæ™¯å¤ç° ä¸Šé¢å¤ç°çš„æ–¹å¼å¾ˆåˆ»æ„ï¼Œæ¯•ç«Ÿæå°‘æƒ…å†µä½ ä¼šcheckoutä¸€ä¸ªå…·ä½“çš„commitè€Œä¸æ‰‹åŠ¨åˆ›å»ºä¸€ä¸ªåˆ†æ”¯ã€‚æ—¥å¸¸å·¥ä½œä¸­æœ€å¯èƒ½é‡åˆ°è¿™ä¸ªdetached HEADçš„åœºæ™¯æ˜¯ä½ ä½¿ç”¨Git submoduleçš„æ—¶å€™ã€‚
æ•¢è¯´æ¯ä¸ªæ–°æ‰‹åœ¨ä½¿ç”¨submoduleéƒ½ä¼šç¢°åˆ°detached HEADé—®é¢˜ã€‚
åŸå› æ˜¯ä½ çš„submoduleæ²¡æœ‰è®°å½•æ­£ç¡®çš„åˆ†æ”¯ï¼Œå³ä½ åœ¨ä½¿ç”¨git submodule addæ—¶æ²¡æœ‰æŒ‡å®š-b &lt;branch>å‚æ•°ã€‚
git submodule add -b main https://github.com/zhimoe/hugo-theme-next.git themes/next æˆ–è€…ç›´æ¥åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹çš„.gitmodulesæ–‡ä»¶ä¸­åŠ ä¸Šä¸€è¡Œ
branch = main # or branch = master è§£å†³æ–¹æ³• 1ã€é¢„é˜²çš„æ–¹æ³•å°±æ˜¯æ²¡æœ‰commitçš„æ—¶å€™åŠæ—¶åˆ‡å›ä¸€ä¸ªå…·ä½“åˆ†æ”¯git checkout master
2.1ã€ å¦‚æœå·²ç»æäº¤äº†çš„è¯ï¼Œç»™å½“å‰æ¸¸ç¦»çš„commitåˆ›å»ºä¸€ä¸ªåˆ†æ”¯ï¼Œåˆ‡æ¢åˆ°è¯¥åˆ†æ”¯
Prj (09fb4a5) â¯ git branch oops 09fb4a5 Prj (09fb4a5) â¯ git log --oneline --graph --decorate * 09fb4a5 (HEAD, oops) 3nd commit * 314c9df (master) 2nd commit * ae15845 initial commit Prj (09fb4a5) â¯ git checkout oops Switched to branch 'oops' 2.2ã€ æ¥ç€ä½¿ç”¨rebaseå°†oopsåˆ†æ”¯æ¥åœ¨masteråˆ†æ”¯çš„æœ«å°¾commitä¹‹å
Prj on î‚  oops â¯ git rebase master Current branch oops is up to date. Prj on î‚  oops â¯ git log --oneline --graph --decorate * 09fb4a5 (HEAD -> oops) 3nd commit * 314c9df (master) 2nd commit * ae15845 initial commit Prj on î‚  oops â¯ git checkout master &amp;&amp; git merge oops Switched to branch 'master' Updating 314c9df..09fb4a5 Fast-forward 3.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 3.txt Prj on î‚  master â¯ git log --oneline --graph --decorate * 09fb4a5 (HEAD -> master, oops) 3nd commit * 314c9df 2nd commit * ae15845 initial commit æœ€ååˆ é™¤oopsåˆ†æ”¯ï¼šgit branch -d oops.
å‚è€ƒä¸€ä¸ªå®Œç¾çš„GitFlowæ¨¡å‹</content></entry><entry><title>Scala3 ç¼©è¿›è¯­æ³•æ€»ç»“è¡¨</title><url>https://zhimoe.github.io/post/scala3-indent-syntax/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>scala3</tag><tag>cheatsheet</tag></tags><content type="html"> Scala 3 åœ¨è¯­æ³•ä¸Šé¢æ–°å¢äº†ä¸€ç§Pythonçš„ç¼©è¿›æ ¼å¼,ä¸¤ç§æ ¼å¼éƒ½å¯ä»¥ä½¿ç”¨. ä½†æ˜¯ç›®å‰éƒ¨åˆ†æƒ…å†µè¿˜æ˜¯éœ€è¦ä½¿ç”¨æ‹¬å·.
ä¸ªäººå¯¹æ–°è¯­æ³•æ˜¯æ”¯æŒçš„. ç¼©è¿›å¯ä»¥æå¤§åœ°æä¾›ä»£ç çš„å¯è¯»æ€§å’Œæ•´æ´, æœ€å¤§çš„ä½“ä¼šå°±æ˜¯SparkStreamingçš„rddå¤„ç†ä»£ç ,æ–°æ‰‹å®¹æ˜“å†™å‡ºåå‡ ä¸ª}æ‹¬å·åµŒå¥—ä»£ç .
å½“ç„¶ç¼ºç‚¹æ˜¯ç¼©è¿›ä¸åˆ©äºä»£ç å¤åˆ¶å’Œæ ¼å¼åŒ–.
ä¸‹é¢æ˜¯ä¹¦æœ¬ä¸Šå…³äºScala3çš„è¯­æ³•å¯¹æ¯”. æ³¨æ„,ä¸¤ä¸ªè¯­æ³•æ ¼å¼éƒ½æ˜¯æ”¯æŒçš„. forå’Œifå»æ‰å°æ‹¬å·çœŸçš„æ˜¯å¤ªæ£’äº†.</content></entry><entry><title>Python Tips for Impatient Dev</title><url>https://zhimoe.github.io/post/py-tips-for-impatient-dev/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>python</tag></tags><content type="html"> Python tricks f-stringçš„å¦™ç”¨ py3.6å¼€å§‹,æ¨èä½¿ç”¨f-string,ä¸è¦ä½¿ç”¨ %sæˆ–è€… "".format().å¦‚æœæ¥æ”¶ç”¨æˆ·è¾“å…¥,ä½¿ç”¨Templateåšå®‰å…¨æ ¡éªŒã€‚
åœ¨python f-stringä¸­å¯ä»¥é€šè¿‡å˜é‡æˆ–è€…è¡¨è¾¾å¼åé¢åŠ =å®ç°æ‰“å°å˜é‡åæˆ–è€…è¡¨è¾¾å¼:
print(f'{v=}') # ç­‰ä»·print(f'v={v}') print(f'{(len(arr),v)=}') æšä¸¾ç±»Enumç•¥å»valueæ–¹æ³• å‡è®¾ä½ æƒ³è¦è·å¾—ä¸‹é¢Colorçš„#000, éœ€è¦ä½¿ç”¨Color.WHITE.valueã€‚ä½†æ˜¯å¯ä»¥é€šè¿‡StrEnumçœå»è¿™ä¸ª.value
class Color(Enum): WHITE = "#000" # tips from enum import StrEnum class Directions(StrEnum): NORTH = 'north', # notice the trailing comma SOUTH = 'south', print(Directions.NORTH) # no need .value ä½¿ç”¨withç®¡ç†éœ€è¦å…³é—­çš„èµ„æº with open(file_path, 'w') as file, get_connection(config) as conn: file.write('Hello, World!') ç®€åŒ–ifçš„ä¸€äº›æŠ€å·§ if variable == a or variable == b: res = do_something(variable) # better if variable in {a, b}: res = do_something(variable) if b > 10: a = 0 else: a = 5 # better a = 0 if b > 10 else 5 if data: lst = data else: lst = [0, 0, 0] # better, only use this when data type is collection, # cuz if data is int, then data=0 will make lst = [0,0,0] lst = data or [0, 0, 0] Instead of asking for permission, ask for forgiveness Pythonçš„å¼‚å¸¸æ¯”è¾ƒè½»é‡ï¼Œæ‰€ä»¥ä¸€èˆ¬æ¨èçš„å†™æ³•æ˜¯ä¸å…¶æå‰åˆ¤æ–­æ¡ä»¶æ˜¯å¦æ»¡è¶³ï¼Œä¸å¦‚åœ¨try catchä¸­å¤„ç†å¼‚å¸¸
try: with open(filename, 'w') as file: file.write('Hello, World!') except FileNotFoundError: print('File does not exist.') except PermissionError: print('You dont have write permission.') except OSError as exc: print(f'An OSError has occurred:\n{exc}') é‡è¦çš„std lib functools contextlib atexit pathlib collections itertools isinstance isinstanceå¯ä»¥ä¸€æ¬¡åˆ¤æ–­å¤šä¸ªClassç±»å‹:
# no need or conditions isinstance(foo, (Class1, Class2, ...)) æµ·è±¡è¿ç®—ç¬¦(walrus operator) python3.8å¼•å…¥æµ·è±¡è¿ç®—ç¬¦ï¼Œè§£å†³ä¸€ä¸ªåœºæ™¯:è·å–ä¸€ä¸ªå€¼ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦ä¸ºéé›¶ï¼Œç„¶åä½¿ç”¨å®ƒã€‚åœ¨python3.8ä¹‹å‰éœ€è¦ä¸‰è¡Œ:
count = fresh_fruit.get('lemon', 0) if count: make_lemonade(count) else: out_of_stock() ä¸Šé¢çš„ä»£ç ä¼šå¼•å…¥ä¸€ä¸ªçœ‹ä¸Šå»éå¸¸é‡è¦çš„å˜é‡ï¼Œä½†å®é™…æƒ…å†µå¹¶éå¦‚æ­¤ã€‚ä½¿ç”¨æµ·è±¡è¿ç®—ç¬¦å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚
if count := fresh_fruit.get('lemon', 0): make_lemonade(count) else: out_of_stock() è™½ç„¶åªæ˜¯å‡å°‘äº†ä¸€è¡Œä»£ç ï¼Œä½†æ˜¯å¯è¯»æ€§æå‡äº†å·¨å¤§ï¼Œå¯ä»¥æ¸…æ¥šåœ°çŸ¥é“countåªæœ‰åœ¨ifæˆç«‹æ—¶æ‰ä½¿ç”¨åˆ°ã€‚ç”šè‡³è¿˜å¯ä»¥åœ¨ifä¸­åˆ¤æ–­
if (count := fresh_fruit.get('apple', 0)) >= 4: make_cider(count) else: out_of_stock() å¦ä¸€ä¸ªå¸¸è§çš„åœºæ™¯æ˜¯do-while,ä¾‹å¦‚å¤„ç†ä¸€ä¸ªåˆ†é¡µè¯·æ±‚ï¼Œç›´åˆ°è¯·æ±‚è¿”å›ä¸ºNoneï¼Œç”±äºpythonä¸æ”¯æŒdo-whileè¯­æ³•ï¼Œä¸€èˆ¬æœ‰ä¸¤ç§å†™æ³•:
page_data = get_page() while page_data: process_page(page_data) page_data = get_page() # æ–¹æ³•2 loop-and-a-half while True: page_data = get_page() if not page_data: break process_page(page_data) æµ·è±¡è¿ç®—ç¬¦å®Œç¾è§£å†³äº†è¿™ä¸ªé—®é¢˜:
while page_data := get_page(): process_page(page_data) è¯»å†™æ–‡ä»¶æ—¶ä¹Ÿç»å¸¸é‡åˆ°è¿™ä¸ªåœºæ™¯:
fp = open("test.txt", "r") while line := fp.readline(): print(line.strip()) å¤šè¿›ç¨‹çš„ä½¿ç”¨ from multiprocessing import Pool requests = [req1, req2] with Pool as p: results = p.map(process_request, requests) pythonçš„dictä¸­å…³äºequalå’Œhashè®¡ç®—æ–¹å¼ä¼šæœ‰æ„å¤–çš„æ•ˆæœ ['no', 'yes'][True] # output? {True: 'yes', 1: 'no', 1.0: 'maybe'} # output? â€œå¸ƒå°”ç±»å‹æ˜¯æ•´æ•°ç±»å‹çš„å­ç±»å‹,å¸ƒå°”å€¼åœ¨å‡ ä¹æ‰€æœ‰ç¯å¢ƒä¸­çš„è¡Œä¸ºéƒ½ç±»ä¼¼äºå€¼ 0 å’Œ 1,ä½†åœ¨è½¬æ¢ä¸ºå­—ç¬¦ä¸²æ—¶,åˆ†åˆ«å¾—åˆ°çš„æ˜¯å­—ç¬¦ä¸² False æˆ– True.â€
&ndash; The Standard Type Hierarchy
ç”±äºTrue,1, 1.0çš„__eq__å’Œ__hash__éƒ½ä¸€æ ·,æ‰€ä»¥å‡ºç°äº†ç¥å¥‡çš„ç»“æœ.
(1) != (1,) ç¬¬ä¸€ä¸ªæ˜¯int,ç¬¬äºŒä¸ªæ˜¯tuple é¿å…å¯å˜çš„é»˜è®¤å‚æ•°, ä¾‹å¦‚: def fun(count=[]): count.append(2) #è¿™é‡Œcountä¸¤æ¬¡è°ƒç”¨å¦‚æœéƒ½ä½¿ç”¨é»˜è®¤å‚æ•°çš„è¯,åˆ™æ˜¯åŒä¸€ä¸ªæ•°ç»„,éå¸¸å±é™©! return count fun() #[2] fun() #[2,2] staticmethod classmethod staticmethodå’Œclassmethodéƒ½å¯ä»¥é€šè¿‡Cls.m()æˆ–instance.m()æ–¹å¼è®¿é—®,éƒ½å¯ä»¥è¢«ç»§æ‰¿,éƒ½å¯ä»¥è®¿é—®å…¨å±€å˜é‡.åŒºåˆ«æ˜¯
classmethodè®¿é—®çš„classå˜é‡ä¿¡æ¯ä¼šè‡ªåŠ¨åœ¨Deriveå­ç±»ä¸­æ”¹å˜,è€Œstaticmethodå› ä¸ºç¼ºå°‘ç¬¬ä¸€ä¸ªclså‚æ•°,æ‰€ä»¥è®¿é—®çš„å…¨å±€å˜é‡å§‹ç»ˆæ˜¯çˆ¶ç±»çš„å˜é‡.
staticmethodå¯ä»¥ç†è§£ä¸ºJavaçš„StringUtilsç±»,åªæ˜¯å’ŒClsæ”¾åœ¨ä¸€èµ·æ–¹ä¾¿ä»£ç é˜…è¯»å’Œç»„ç»‡.
classmethodåˆ™æ˜¯å¯ä»¥é€šè¿‡clså‚æ•°è®¿é—®åˆ°å½“å‰ç±»ä¿¡æ¯çš„.
å®¹å™¨æ–¹æ³• åˆå¹¶å­—å…¸ d1.update(d2) # éå†d2,æ›´æ–°åˆ°d1 d = dict(**profile, **ext_info) #è§£æ„é‡æ–°åˆ›å»ºdict,å³è¾¹çš„ä¼˜å…ˆçº§é«˜ d = dict(profile.items() | ext_info.items()) #åŒç† d = d1 | d2 # æ–°è¯­æ³• {k: v for d in [profile, ext_info] for k, v in d.items()} # æ¨å¯¼å¼ py3.6å¼€å§‹ dicté»˜è®¤æ’å…¥æœ‰åº,æ— éœ€ä½¿ç”¨OrderDict
dict get and pop d.get(k,default) d.setdefault(k,default) d.pop(k) #åˆ é™¤ä¸å­˜åœ¨çš„é”®æ—¶,ä½¿ç”¨del d[k]æœ‰å¼‚å¸¸æŠ›å‡º,popåˆ™ä¸ä¼š è‡ªå®šä¹‰dict è‡ªå®šä¹‰è‡ªå·±çš„dictä¸èƒ½ç»§æ‰¿dict,è€Œæ˜¯collections.abc.MutableMapping, å› ä¸ºè‡ªå¸¦çš„listå’Œdictæœ‰ä¸€äº›ç‰¹æ®Šè¡Œä¸ºæ— æ³•è¦†ç›–
sort dict by key: print(sorted(dic, key=dic.get)) #output: key in asc order
å¸¦ç´¢å¼•éå† for idx, item in enumerate(x):
æµ…å¤åˆ¶ list(l)ç­‰æ–¹å¼æ„å»ºçš„list dict setå±äºæµ…å¤åˆ¶,å¦‚æœå®¹å™¨çš„å…ƒç´ è¿˜æ˜¯å®¹å™¨,é‚£ä¹ˆå…ƒç´ å±äºå¼•ç”¨.
æ·±åº¦å¤åˆ¶éœ€è¦ä½¿ç”¨copy module
import copy xs = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] zs = copy.deepcopy(xs) # å¯¹è±¡åŒæ ·å¯ä»¥ä½¿ç”¨copy,è¿˜æœ‰__copy__ç­‰é­”æ³•æ–¹æ³•å¯ä»¥æ¢ç´¢ ä½¿ç”¨namedtuple namedtupleå¯ä»¥è®©ä»£ç æ›´å®¹æ˜“é˜…è¯»,å½“ç„¶ç°åœ¨å¯ä»¥æ˜¯æ‰€æœ‰dataclass,ç‰¹æ€§æ›´ä¸°å¯Œ
from collections import namedtuple class Car: """you do not modify the name and date attributes """ def __init__(self, name, date): self._name = name self._date = date # use namedtuple Car = namedtuple('Car', 'name date') # æ³¨æ„,è¿™é‡Œå¤šä¸ªå±æ€§å¯ä»¥ä¸€æ¬¡æ€§ä¼ å…¥,ä½¿ç”¨ç©ºæ ¼åˆ†å‰² # ç„¶åä½ å¯ä»¥å°†Carä½œä¸ºdata classä½¿ç”¨ #è¿˜æœ‰ä¸€ä¸ªtype hintçš„ç‰ˆæœ¬ from typing import NamedTuple list vs array listçš„å…ƒç´ å¯ä»¥ä¸åŒ,æ›´ä¸ºç´§å‡‘çš„å•ä¸€ç±»å‹æ˜¯arrayç±»å‹
Counter Counter(string).most_common(3)
deque from collections import deque names = deque(['raymond', 'rachel', 'matthew', 'roger', 'betty', 'melissa', 'judith', 'charlie']) names.popleft() names.appendleft('mark') ä¸€äº›ä¸å¸¸ç”¨çš„å®¹å™¨ CountedObject,ChainMap,MappingProxyType,frozenset,defaultdict
åœ¨éå†ä¸­ä¿®æ”¹list ä½¿ç”¨for i in range(len(a))æˆ–è€…for i, v in enumerate(a)éƒ½æ˜¯å±é™©çš„.
# æ–¹æ³•1 å°†listæ‹·è´ä¸€ä¸‹,éå†æ–°æ•°ç»„çš„è¿‡ç¨‹ä¸­,ä¿®æ”¹åŸlist: num_list = [1, 2, 3, 4, 5] print(num_list) for item in num_list[:]: # è¿™é‡Œlist[:]æ˜¯å¯¹åŸæ•°ç»„çš„æ‹·è´,trick!!! if item == 2: num_list.remove(item) else: print(item) print(num_list) # æ–¹æ³•2 å¦‚æœæ•°ç»„å¾ˆå¤§,é‚£åº”è¯¥ä½¿ç”¨å€’åºéå†: for i in range(len(num_list)-1, -1, -1): if num_list[i] == 2: num_list.pop(i) else: print(num_list[i]) # æ–¹æ³•3 è¿˜æ˜¯ä½¿ç”¨foræ¨å¯¼å¼ [4 if x==3 else x for x in num_list] æ‰“å°å®¹å™¨å¯ä»¥ä½¿ç”¨pprint.pprint
strå’Œbytes bytes å’Œ bytesarray bytesæ˜¯ä¸å¯å˜çš„æ•°ç»„,æ¯ä¸ªå…ƒç´ å¿…é¡»åœ¨0ï½255ä¹‹é—´.
bytearrayæ˜¯å¯å˜çš„,å¯ä»¥ä¿®æ”¹,å¢åŠ ,åˆ é™¤å…ƒç´ .
è½¬æ¢ bytes(ba)
å¤šè¡Œstring my_very_big_string = ( "For a long time I used to go to bed early. Sometimes, " "when I had put out my candle, my eyes would close so quickly " "that I had not even time to say â€œIâ€™m going to sleep.â€" ) å¤šè¡Œæ–‡æœ¬å»é™¤ç¼©è¿›å¯ä»¥ä½¿ç”¨ textwrap.deden("""\your text""")
stré‡å¤næ¬¡ print(s * n);
int/string intern å°æ•´æ•°æ± æ˜¯[-5,256], stringä¹Ÿæœ‰ string intern
str.partition/str.translate æœ‰æ—¶ä½¿ç”¨str.partitionæ–¹æ³•æ‹†åˆ†stræˆ–è€…str.translateæ‰¹é‡replaceå­ä¸²æ›´æ–¹ä¾¿
é‡è¦æ ‡å‡†åº“ bisect äºŒåˆ†æ³•æœç´¢
pathlib vs os.pathlib use pathlib over os.pathlib. åè€…æ–¹æ³•ä¸å…¨.
os vs sys os module is for system, sys this module provides access to some variables used or maintained by
the interpreter and to functions that interact strongly with the interpreter.
è¿­ä»£å™¨ è¿­ä»£å™¨:__iter__ å’Œ __next__ ä¸¤ä¸ªæ–¹æ³• å¯è¿­ä»£å¯¹è±¡:__iter__ æ–¹æ³• å¦‚æœå¸Œæœ›å¯è¿­ä»£å¯¹è±¡å¯ä»¥é‡å¤ä½¿ç”¨,åº”è¯¥åœ¨ __iter__ æ¯æ¬¡è¿”å›æ–°çš„è¿­ä»£å™¨å¯¹è±¡ã€‚ yieldç”Ÿæˆå™¨ä¹Ÿæ˜¯è¿­ä»£å™¨ã€‚itertoolsç®€åŒ–å¾ªç¯,ä¾‹å¦‚product pythonicçš„ä»£ç  ä½¿ç”¨foræ¨å¯¼å¼,ä¸è¦for..inéå†,ä¹Ÿå°‘ç”¨map,filter
å¤šä½¿ç”¨destructing,è¿™ç‚¹åœ¨Java/Goéƒ½ä¸æ”¯æŒ,å¯ä»¥åœ¨æ–¹æ³•å†…éƒ¨çœå¾ˆå¤šä»£ç 
long_list = [x for x in range(100)] a, b, *c, d, e, f = long_list #e==98 f=99 ä½¿ç”¨if x is None,è€Œä¸æ˜¯ if x == None å¼‚å¸¸å¤„ç†
æ¸…æ¥šexceptå’Œassertåœºåˆ,logging.error(&lsquo;xxxxxxx&rsquo;, exc_info=True).
è‡ªå®šä¹‰å¼‚å¸¸å¿…é¡»é‡å†™__init__() å’Œ str()
use reversed(lis) over lis[::-1]
@property make a method to class&rsquo;s property. can not use () when access the method cuz it is prop.
use assert protect your code. ä¸è¦ä½¿ç”¨assertæ£€æŸ¥æ•°æ®, æ–­è¨€å¯èƒ½è¢«å…¨å±€ç¦ç”¨,å¯¼è‡´æ•°æ®æ£€æŸ¥ï¼ˆæˆ–è€…æ›´ææ€–çš„æƒé™æ£€æŸ¥ï¼‰è¢«è·³è¿‡
@functools.wraps(func)
__var åœ¨classç¯å¢ƒä¸­ä¼šè¢«æ”¹å†™
ä½¿ç”¨abcæ¨¡å—å¯ä»¥é¿å…æŠ½è±¡ç±»åªæœ‰åœ¨æœªå®ç°æ–¹æ³•è¢«è°ƒç”¨æ—¶æ‰æŠ›å‡ºNotImplementedError
ç†è§£pythonçš„dunderæ–¹æ³•,å¯ä»¥å†™å‡ºè¶…çº§ç®€æ´çš„æ–¹æ³•:
import collections Card = collections.namedtuple('Card', ['rank', 'suit']) class FrenchDeck: ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split() def __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self, position): return self._cards[position] deck = new FrenchDeck() from random import choice choice(deck) # Card(rank='3', suit='hearts') ä¸Šé¢çš„ä¾‹å­æˆ‘ä»¬ä½¿ç”¨äº†__len__æ–¹æ³•å’Œ__getitem__æ–¹æ³•,å¥½å¤„å°±æ˜¯ä½ å¯ä»¥ä½¿ç”¨pythonçš„len(deck),deck[1]è¿™ç§è¯­æ³•,ä¹Ÿå°±æ˜¯è¯´FrenchDeckå‡ ä¹å°±æ˜¯ä¸€ä¸ªå®¹å™¨ç±»å‹,è¿˜å¯ä»¥ä½¿ç”¨foréå†.
æ›´å¤šæŸ¥çœ‹&lt;fluent python 2nd>.
å…¶ä»– ä½¿ç”¨help(),dir()è·å–ä¿¡æ¯ pythonä¸­çš„æ¯ä¸ªå‡½æ•°éƒ½æœ‰__code__å±æ€§,åŒ…å«å­—èŠ‚ç ä¿¡æ¯ ä½¿ç”¨disæ¨¡å—çš„diså‡½æ•°å¯ä»¥æŸ¥çœ‹æ›´å®¹æ˜“é˜…è¯»çš„æ±‡ç¼–(dis == disassembler) sys.getsizeof(x)è·å–å¯¹è±¡å¤§å° ...å’Œpasså‡ ä¹ç­‰æ•ˆçš„,è¿™æ˜¯ä¸€ä¸ªellipsis typeçš„å•ä¾‹. æ— é™å¤§ float(&lsquo;inf&rsquo;) float(&rsquo;-inf&rsquo;) disæŸ¥çœ‹å­—èŠ‚ç  ==ä¼šè¢«__eq__æ–¹æ³•æ”¹å˜,åˆ¤æ–­æ˜¯å¦Noneæ—¶åº”è¯¥ä½¿ç”¨isåˆ¤æ–­idæ˜¯å¦ä¸€è‡´ pythonçš„tryå¯ä»¥é…åˆelse:å½“æ²¡æœ‰ä»»ä½•å¼‚å¸¸æˆ–è€…tryé‡Œé¢æ²¡æœ‰return break,æ‰æ‰§è¡Œelseéƒ¨åˆ†ã€‚è¿™ä¸ªå’Œfinallyæœ‰å¾ˆé‡è¦çš„ä¸åŒ withéœ€è¦å®ç°__enter__ __exit__ä¸¤ä¸ªæ–¹æ³• withè¯­å¥å¯ä»¥åŒæ—¶æ‰“å¼€å¤šä¸ªæ–‡ä»¶,ä¸è¦åµŒå¥—with,æ›´å¤šåŠŸèƒ½æŸ¥çœ‹contextlib ä¸è¦æ‰‹åŠ¨åšæ•°æ®æ ¡éªŒ,ä½¿ç”¨pydanticè¿™ä¸ªåº“ ä¸è¦ä½¿ç”¨assertæ ¡éªŒå‚æ•°åˆæ³•æ€§,å› ä¸ºå¯ä»¥é€šè¿‡-Oå‚æ•°è·³è¿‡ å‚è€ƒèµ„æ–™ Python å·¥åŒ ç³»åˆ—
RealPythonå­¦ä¹ è·¯å¾„
ä¸€ä»½éå¸¸è¯¦å°½çš„Pythonå°æŠ„
Fluent Python 2nd</content></entry><entry><title>ä½¿ç”¨speed-measure-webpack-pluginå’ŒHappypackä¼˜åŒ–webpackæ‰“åŒ…é€Ÿåº¦</title><url>https://zhimoe.github.io/post/speed-up-angular-build-use-happypack/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>JS</tag><tag>webpack</tag></tags><content type="html"> é—®é¢˜ ä¸€ä¸ªionic appæœ¬åœ°ç¼–è¯‘éœ€è¦8åˆ†é’Ÿ,æäº¤åˆ°æµæ°´çº¿ç¼–è¯‘è€—æ—¶éœ€è¦è¿‘40åˆ†é’Ÿ,ä»æ—¥å¿—çœ‹åˆ°webpackæ‰“åŒ…æ­¥éª¤è€—æ—¶æœ€ä¸¥é‡.
æ’æŸ¥ä¸è§£å†³ åˆæ­¥åˆ¤æ–­æ˜¯æµæ°´çº¿ä½¿ç”¨çš„å®¹å™¨CPUæ€§èƒ½è¾ƒå¼±æˆ–è€…å­˜å‚¨mountæ€§èƒ½å¯¼è‡´çš„.æ‰¾æµæ°´çº¿åŒäº‹æ”¯æŒé…ç½®äº†ä¸€ä¸ªçº¯å†…å­˜ç¼–è¯‘æµæ°´çº¿,å‘ç°è¿˜æ˜¯å¾ˆæ…¢. æ¥ä¸‹æ¥ä½¿ç”¨webpackçš„æ’ä»¶speed-measure-webpack-pluginç›‘æ§æ€§èƒ½.
åœ¨webpack.config.jsé…ç½®ï¼š
// webpack.config.js // npm i --save-dev speed-measure-webpack-plugin const SpeedMeasurePlugin = require("speed-measure-webpack-plugin"); const smp = new SpeedMeasurePlugin(); // ...the webpack configuration const prodConfig = {/*...*/} module.exports = { prod: smp.wrap(prodConfig) }; å¾—åˆ°ä¸‹å›¾å·¦ä¾§çš„ç»“æœ,å¯ä»¥çœ‹åˆ°ä¸»è¦è€—æ—¶éƒ½åœ¨angularçš„PurifyPluginä¸Š.æœç´¢äº†ä¸€ç•ªåæ‰¾åˆ°HappPackè¿™ä¸ªå¤šæ ¸æ‰§è¡Œçš„æ’ä»¶.
é…ç½®happypack,ç”±äºä¸»è¦è€—æ—¶éƒ½åœ¨const PurifyPlugin = require('@angular-devkit/build-optimizer').PurifyPlugin;æ’ä»¶ä¸Š,è¿™é‡Œåªéœ€è¦é’ˆå¯¹è¿™ä¸€ä¸ªæ’ä»¶é…ç½®happypackå³å¯.
// webpack.config.js // const HappyPack = require('happypack'); const os = require('os');//è·å–cpu coreæ•°é‡ //loadersé…ç½® { test: /\.ts$/, use: [ { loader: 'happypack/loader?id=ts', // åœ¨æ‰€æœ‰loaderä¹‹å‰åŠ ä¸Šhappypack/loader,idæ˜¯pluginsä¸­å®šä¹‰çš„ }, { loader: process.env.IONIC_CACHE_LOADER }, { loader: '@angular-devkit/build-optimizer/webpack-loader', options: { sourceMap: true } }, { loader: process.env.IONIC_WEBPACK_LOADER } ] } // åœ¨pluginsä¸­é…ç½®happypackæ’ä»¶ plugins: [ ionicWebpackFactory.getIonicEnvironmentPlugin(), ionicWebpackFactory.getCommonChunksPlugin(), new ModuleConcatPlugin(), new PurifyPlugin(), new HappyPack({ id: 'js', threads: os.cpus().length, loaders: ['@angular-devkit/build-optimizer/webpack-loader'] }), new HappyPack({ id: 'ts', // åœ¨loaderä¸­ä½¿ç”¨ threads: os.cpus().length, // å¼€å¯æ“ä½œç³»ç»Ÿcpuçš„æœ€å¤§æ ¸å¿ƒæ•° loaders: ['@angular-devkit/build-optimizer/webpack-loader'] }) ] å†æ¬¡æœ¬åœ°æ‰§è¡Œ,æ€§èƒ½æå‡å·¨å¤§.åœ¨æµæ°´çº¿ä¸Šæµ‹è¯•,ä¸¤æ¬¡buildéƒ½åœ¨15åˆ†é’Ÿå·¦å³.</content></entry><entry><title>åœ¨githookä¸­è°ƒç”¨nodejsè„šæœ¬</title><url>https://zhimoe.github.io/post/nodejs-as-githook/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>nodejs</tag></tags><content type="html"> å¦‚ä½•åœ¨git hookä¸­è°ƒç”¨nodejsè„šæœ¬.ä¸»è¦è¸©å‘åœ¨äºä¸çŸ¥é“å¦‚ä½•åœ¨bashä¸­è·å–nodeè„šæœ¬è¿”å›å€¼,æœäº†å¥½å¤§ä¸€åœˆ.
èƒŒæ™¯ å¾®æœåŠ¡æ¨¡å¼å¼€å‘ä¸­,æ¯ä¸ªå°ç»„ç»´æŠ¤è‡ªå·±çš„åº”ç”¨,é€šè¿‡ä¸€ä¸ªnginxå…¥å£åå‘ä»£ç†æ‰€æœ‰çš„å­åº”ç”¨,å‘ç”¨æˆ·å¼€æ”¾ä¸€ä¸ªç«™ç‚¹.nginxåº”ç”¨ä¸­éœ€è¦ç»´æŠ¤å„ä¸ªå­åº”ç”¨çš„ä»£ç†,å³ng.confä¸­çš„location.
æ­¤å¤–,ä¸€ä¸ªåº”ç”¨éœ€è¦é…ç½®DEV,ST,UAT,PRDå››ä¸ªç¯å¢ƒçš„location.ç›®å‰çš„åšæ³•æ˜¯www/ngconf/ç›®å½•ä¸‹é¢åˆ†ä¸ºdevã€stã€uatã€prdå››ä¸ªæ–‡ä»¶å¤¹,åœ¨æ–‡ä»¶å¤¹å†…éƒ¨æ¯ä¸ªå°ç»„å„è‡ªç»´æŠ¤ä¸€ä¸ªconfæ–‡ä»¶.
æ¯å¢åŠ ä¸€ä¸ªåº”ç”¨,éœ€è¦åœ¨å››ä¸ªæ–‡ä»¶å¤¹ä¸­è‡ªå·±å°ç»„çš„é…ç½®æ–‡ä»¶æ·»åŠ é…ç½®.éšç€åº”ç”¨è¶Šæ¥è¶Šå¤š,ä»¥åŠäººå‘˜æµåŠ¨,ä¼šå‘ç”Ÿä¸åŒæ–‡ä»¶é…ç½®ç›¸åŒçš„location entry.
ä¾‹å¦‚Aåº”ç”¨ä¸Šçº¿ä¸€ä¸ªåŠŸèƒ½éœ€è¦ä¾èµ–Båº”ç”¨,ä½†æ˜¯æ–°äººä¸çŸ¥é“Bå·²ç»é…ç½®è¿‡äº†,æ‰€ä»¥åˆé‡å¤æ·»åŠ äº†ä¸€ä¸ª,å¯¼è‡´å¯åŠ¨æŠ¥é”™.
éœ€æ±‚ å…¥å£åº”ç”¨æ˜¯ä¸€ä¸ªnodejsåº”ç”¨,è‡ªç„¶é€‰æ‹©äº†jsè„šæœ¬æ£€æŸ¥confæ–‡ä»¶location pathé…ç½®æ˜¯å¦é‡å¤.
å®ç° åœ¨git hookç›®å½•ä¸‹,æ–°å¢ä¸€ä¸ªpre-commitæ–‡ä»¶,æ·»åŠ å†…å®¹ï¼š
#!/usr/bin/sh # æ£€æŸ¥é¡¹ç›®ä¸­åŒä¸€ä¸ªç›®å½•ä¸‹é¢çš„nginx conf æ‰€æœ‰locationæ˜¯å¦é‡å¤ if [ -e ./ngconf_check.js ]; then node ngconf_check.js if [[ $? != 0 ]]; then echo >&amp;2 fix duplicate location entry in nginx conf exit 1 fi fi # å¦‚æœé¡¹ç›®æœ‰è‡ªå®šä¹‰pre-commit,æ‰§è¡Œ if [ -e ./.git/hooks/pre-commit ]; then ./.git/hooks/pre-commit "$@" fi exit 0 è¦ç‚¹ï¼š bashä¸­$?è¡¨ç¤ºè·å–ä¸Šå‘½ä»¤çš„è¿”å›å€¼.è¿™é‡Œè·å¾—çš„æ˜¯jsè„šæœ¬çš„process.exit(code)è¿”å›çš„code. é»˜è®¤è¿”å›æ˜¯0.
ngconf_check.jsï¼š
// æ£€æŸ¥ng confæ˜¯å¦æœ‰é‡å¤çš„location entry const fs = require('fs'); const path = require('path'); const ConfEnvDirs = new Set(); ConfEnvDirs.add('dev'); ConfEnvDirs.add('st'); ConfEnvDirs.add('uat'); ConfEnvDirs.add('prd'); const NgconfPath = 'www/ngconf'; let result = 'pass'; countLocationInDir(NgconfPath); if(result !== 'pass'){ process.exit(1);//å‘bashè¿”å›1 } /** * * @param rootPath */ function countLocationInDir(rootPath) { if (!fs.existsSync(rootPath)) return; let dirs = fs.readdirSync(rootPath); dirs.forEach(dir => { let envDir = path.join(rootPath, dir); //åªå¤„ç†å››ä¸ªç¯å¢ƒç›®å½•ä¸‹çš„confæ–‡ä»¶,æ¯ä¸ªç›®å½•ç”¨ä¸€ä¸ªmapè®°å½• const LocationEntryMap = new Map();//location entry -> file,line if (!(fs.statSync(envDir).isDirectory() &amp;&amp; ConfEnvDirs.has(dir))) { return; } let confFiles = fs.readdirSync(envDir); confFiles.forEach(filename => { let fullPath = path.join(envDir, filename); if (fs.lstatSync(fullPath).isFile() &amp;&amp; /[\w\W.].conf$/.test(filename)) { countLocationsInFile(fullPath, LocationEntryMap); } }); }); } /** * * @param confFile * @param countMap */ function countLocationsInFile(confFile, countMap) { let lines = fs.readFileSync(confFile, "utf-8") .split("\n") .filter(Boolean); lines.forEach((line, lineNumber) => { if (line.trim().startsWith("location")) { const arr = line.trim().split(' '); const locationEntry = arr[1]; const entryInfo = `${confFile}, at line:${lineNumber}`; if (countMap.has(locationEntry)) { console.log(`ERROR: duplicate location entry: ${locationEntry}`); console.log(`location 1:${countMap.get(locationEntry)}`); console.log(`location 2:${entryInfo}`); //ä¿®æ”¹resultå˜é‡ result='error'; } else { countMap.set(locationEntry, entryInfo); } } }); }</content></entry><entry><title>Typescript Comprehensive Cheatsheet</title><url>https://zhimoe.github.io/post/ts-comprehensive-notes/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>typescript</tag></tags><content type="html"> ä¸€ä»½è¯¦å°½çš„tsè¯­æ³•ç¬”è®°. è¿™å‘¨åœ¨çœ‹ç»„é‡Œå‰ç«¯åŒäº‹çš„ä»£ç ,æ„Ÿè§‰å®Œå…¨è¿˜æ˜¯åœ¨å†™JS,ä»¥æˆ‘æœ‰é™çš„JS/TSçŸ¥è¯†,ä¹ŸçŸ¥é“å¯ä»¥å†™å¾—æ›´åŠ è§„èŒƒä¸€ç‚¹.ä½†æ˜¯ä¸€ä¸Šæ‰‹å¼€å§‹æ”¹,è¿˜çœŸæ˜¯æ‰‹ç”Ÿ.
åˆé‡æ–°è¿‡äº†ä¸€éæ–‡æ¡£,åšäº†ä¸€ç‚¹ç¬”è®°.
install # Install npm install typescript # Run npx tsc # Run with a specific config npx tsc --project configs/my_tsconfig.json # Triple slash directives # Reference built-in types /// &lt;reference lib="es2016.array.include" /> # Reference other types /// &lt;reference path="../my_types" /> /// &lt;reference types="jquery" /> # AMD /// &lt;amd-module name="Name" /> /// &lt;amd-dependency path="app/foo" name="foo" /> # Compiler comments # Donâ€™t check this file // @ts-nocheck # Check this file (JS) // @ts-check # Ignore the next line // @ts-ignore # Expect an error on the next line // @ts-expect-error # ignore ts type error tsc --noEmitOnError hello.ts # tsconfig.json "strict": true "noImplicitAny" "strictNullChecks" ts syntax cheatsheet //-------------------------------- Basic type any // untyped, use as js, disables all further type checking unknown // The unknown type represents any value. This is similar to the any type, but is safer because itâ€™s not legal to do anything with an unknown value: void // void is not the same as undefined. // a contextual function type with a void return type (type vf = () => void), when implemented, can return any other value, but it will be ignored. null // prefer use undefined undefined // check optional param? if undefined before use it never // unreachable see: https://www.typescriptlang.org/docs/handbook/2/narrowing.html#exhaustiveness-checking object // object is not Object. Always use object! object also diff from {} // In compile time {} doesn't have Object's members and Object has more strict behavior boolean number string // The type names String , Number , and Boolean (starting with capital letters) are legal, but refer to // some special built-in types that will very rarely appear in your code. Always use string , number , or // boolean for types. bigint //ES2020 // Creating a bigint via the BigInt function const oneHundred: bigint = BigInt(100); // Creating a BigInt via the literal syntax const anotherHundred: bigint = 100n; string[] // or Array&lt;string> // ReadonlyArray // error: new ReadonlyArray("red", "green", "blue"); // use: const roArray: ReadonlyArray&lt;string> = ["red", "green", "blue"]; // Just as TypeScript provides a shorthand syntax for Array&lt;Type> with Type[], // it also provides a shorthand syntax for ReadonlyArray&lt;Type> with readonly Type[] let x: readonly string[] = []; let y: string[] = []; [string, number] // tuple string | null | undefined // union type // use isArray function narrowing the array type function welcomePeople(x: string[] | string) { if (Array.isArray(x)) { console.log("Hello, " + x.join(" and ")); } else { console.log("Welcome lone traveler " + x); } } // use in operator narrowing method structual type // instanceof narrowing type direction= 'left' | 'right'; // Literal types type roll= 1 | 2 | 3 | 4 | 5 | 6; // ?? (nullish coalescing) function getValue(val?: number): number | 'nil' { // Will only return 'nil' if `val` is null or undefined return val ?? 'nil'; } // ?. (optional chaining) function countCaps(value?: string) { // The `value` expression be undefined if `value` is null or // undefined, or if the `match` call doesn't find anything. return value?.match(/[A-Z]/g)?.length ?? 0; } // ! (null assertion) skip the null/undefined check let value: string | undefined; // ... Code that we're sure will initialize `value` ... // Assert that `value` is defined console.log(`value is ${value!.length} characters long`); // &amp;&amp;= assign a value only if current value is truthy let a; let b = 1; a &amp;&amp;= 'default'; // a is still undefined b &amp;&amp;= 5; // b is now 5 // ||= assign a value only if current value is falsy let a; let b = 1; a ||= 'default'; // a is 'default' now b ||= 5; // b is still 1 // ??= assign a value only if current value is null or undefined let a; let b = 0; a ??= 'default'; // a is now 'default' b ??= 5; // b is still 0 // Object { requiredStringVal: string; optionalNum?: number; readonly readOnlyBool: bool; } // Index signature: object with arbitrary string properties (like a hashmap or dictionary) { [key: string]: Type; } { [key: number]: Type; } { [key: symbol]: Type; } { [key: `data-${string}`]: Type; } // Array of functions that return strings (() => string)[] // or { (): string; }[] // or Array&lt;() => string> // Basic tuples let myTuple: [ string, number, boolean? ]; myTuple = [ 'test', 42 ]; // Variadic tuples type Numbers = [number, number]; type Strings = [string, string]; type NumbersAndStrings = [...Numbers, ...Strings]; // [number, number, string, string] type NumberAndRest = [number, ...string[]]; // [number, varying number of string] type RestAndBoolean = [...any[], boolean]; // [varying number of any, boolean] // Named tuples type Vector2D = [x: number, y: number]; function createVector2d(...args: Vector2D) {} // function createVector2d(x: number, y: number): void // !!!cation, you can not use v2d.x the name is just for hint, not for compiler // Interface interface Child extends Parent, SomeClass { property: Type; optionalProp?: Type; optionalMethod?(arg1: Type): ReturnType; } // Class class Child extends Parent implements Child, OtherChild { property: Type; defaultProperty = 'default value'; private _privateProperty: Type; private readonly _privateReadonlyProperty: Type; static staticProperty: Type; static { try { Child.staticProperty = calcStaticProp(); } catch { Child.staticProperty = defaultValue; } } constructor(arg1: Type) { super(arg1); } private _privateMethod(): Type {} methodProperty: (arg1: Type) => ReturnType; overloadedMethod(arg1: Type): ReturnType; overloadedMethod(arg1: OtherType): ReturnType; overloadedMethod(arg1: CommonT): CommonReturnT {} static staticMethod(): ReturnType {} subclassedMethod(arg1: Type): ReturnType { super.subclassedMethod(arg1); } } //-------------------------------- Function // Function type (arg1: Type, argN: Type) => Type; // or { (arg1: Type, argN: Type): Type; } // Function type with optional param (arg1: Type, optional?: Type) => ReturnType // Function type with rest param (arg1: Type, ...allOtherArgs: Type[]) => ReturnType // Function type with static property { (): Type; staticProp: Type; } // Default argument function fn(arg1 = 'default'): ReturnType {} // Arrow function (arg1: Type): ReturnType => { ...; return value; } // or (arg1: Type): ReturnType => value; // this typing function fn(this: Foo, arg1: string) {} // Overloads function conv(a: string): number; function conv(a: number): string; function conv(a: string | number): string | number { ... } // Call Signatures type DescribableFunction = { description: string; (someArg: number): boolean; }; function doSomething(fn: DescribableFunction) { console.log(fn.description + " returned " + fn(6)); } // Construct Signatures type SomeConstructor = { new (s: string): SomeObject; }; function fn(ctor: SomeConstructor) { return new ctor("hello"); } // Generic Functions function firstElement&lt;Type>(arr: Type[]): Type | undefined { return arr[0]; } // Constraints function longest&lt;Type extends { length: number }>(a: Type, b: Type) { if (a.length >= b.length) { return a; } else { return b; } } // longerArray is of type 'number[]' const longerArray = longest([1, 2], [1, 2, 3]); // longerString is of type 'alice' | 'bob' const longerString = longest("alice", "bob"); // Error! Numbers don't have a 'length' property const notOK = longest(10, 100); // Working with Constrained Values // æœŸæœ›è¿”å›Type,è€Œä¸æ˜¯å…·æœ‰{ length: number }çº¦æŸçš„ç±»å‹.å³æœŸæœ›å­ç±»,è¿”å›äº†çˆ¶ç±»,ä¼šå¯¼è‡´å±æ€§å˜å°‘ function minimumLength&lt;Type extends { length: number }>( obj: Type, minimum: number ): Type { if (obj.length >= minimum) { return obj; } else { return { length: minimum }; // Type '{ length: number; }' is not assignable to type 'Type'. // '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }' } } // Rule: If a type parameter only appears in one location, strongly reconsider if you actually need it // Rule: Always use as few type parameters as possible // Rule: When possible, use the type parameter itself rather than constraining it // å‡½æ•°é‡è½½ function makeDate(timestamp: number): Date; function makeDate(m: number, d: number, y: number): Date; // ä¸Šé¢ä¸¤ä¸ªä¸ºå‡½æ•°é‡è½½ç­¾å function makeDate(mOrTimestamp: number, d?: number, y?: number): Date { if (d !== undefined &amp;&amp; y !== undefined) { return new Date(y, mOrTimestamp, d); } else { return new Date(mOrTimestamp); } } const d1 = makeDate(12345678); const d2 = makeDate(5, 5, 5); const d3 = makeDate(1, 3); // Always prefer parameters with union types instead of overloads when possible //-------------------------------- Enum // Unlike most TypeScript features, this is not a type-level addition to JavaScript but something added to the language and runtime. // Because of this, itâ€™s a feature which you should know exists, but maybe hold off on using unless you are sure enum Color {Red, Green, Blue = 4} // default get Red=0, all of the following members are auto-incremented Green=1, except you give. let c: Color = Color.Green // enumæœ‰ä¸¤ç§, valueæ˜¯numberï¼ˆé»˜è®¤ï¼‰æˆ–stringçš„. // !!!numeric enums members also get a reverse mapping from enum values to enum names, for example: // !!! careful with numeric enum iteration enum LogLevel { ERROR, WARN, INFO } for (let element in LogLevel) { // å…ˆéå†index,å†éå†value console.log(element +" - "+ LogLevel[element]);// output // [LOG]: "0 - ERROR" // [LOG]: "1 - WARN" // [LOG]: "2 - INFO" // [LOG]: "ERROR - 0" // [LOG]: "WARN - 1" // [LOG]: "INFO - 2" } // string value enumæ²¡æœ‰ä¸Šé¢è¿™ä¸ªé—®é¢˜. // åœ¨ç¼–è¯‘å†…éƒ¨, tsç¼–è¯‘å¾—åˆ°ä¸€ä¸ªname->value value->nameçš„åŒå‘map enum Enum { VAL, } // tsc output "use strict"; var Enum; (function (Enum) { Enum[Enum["VAL"] = 0] = "VAL"; })(Enum || (Enum = {})); // for inæ˜¯ES5æ ‡å‡†,éå†key. inä¼šéå†åŸå‹é“¾prototypeä¸Šé¢çš„å±æ€§.éåº•å±‚ä»£ç ,ç¦æ­¢ä½¿ç”¨for..in. // for ofæ˜¯ES6æ ‡å‡†,éå†value. // è¯­æ³•ä¸Šenumå…è®¸ string value å’Œ numeric valueå¹¶å­˜,ä½†æ˜¯ä»£ç ä¸šåŠ¡å«ä¹‰ enum BooleanLikeHeterogeneousEnum { No = 0, Yes = "YES", } // Try to use ts.forEach, ts.map, and ts.filter instead of loops when it is not strongly inconvenient. //-------------------------------- Type alias type Name = string; type Direction = 'left' | 'right'; type ElementCreator = (type: string) => Element; type Point = { x: number, y: number }; type Point3D = Point &amp; { z: number }; type PointProp = keyof Point; // 'x' | 'y' const point: Point = { x: 1, y: 2 }; type PtValProp = keyof typeof point; // 'x' | 'y' // Extending a type via intersections type Animal = { name: string } type Bear = Animal &amp; { honey: boolean } // type alias , interface åŒºåˆ« //-------------------------------- Generics // Function using type parameters &lt;T>(items: T[], callback: (item: T) => T): T[] // Interface with multiple types interface Pair&lt;T1, T2> { first: T1; second: T2; } // Constrained type parameter &lt;T extends ConstrainedType>(): T // Default type parameter &lt;T = DefaultType>(): T // Constrained and default type parameter &lt;T extends ConstrainedType = DefaultType>(): T // Generic tuples type Arr = readonly any[]; function concat&lt;U extends Arr, V extends Arr>(a: U, b: V): [...U, ...V] { return [...a, ...b] } const strictResult = concat([1, 2] as const, ['3', '4'] as const); const relaxedResult = concat([1, 2], ['3', '4']); // strictResult is of type [1, 2, '3', '4'] // relaxedResult is of type (string | number)[] //-------------------------------- Index, mapped, and conditional types // Index type query (keyof) type Point = { x: number, y: number }; let pointProp: keyof Point = 'x'; function getProp&lt;T, K extends keyof T>( val: T, propName: K ): T[K] { ... } // Mapped types // see more: https://www.typescriptlang.org/docs/handbook/utility-types.html type Stringify&lt;T> = { [P in keyof T]: string; } type Partial&lt;T> = { [P in keyof T]?: T[P]; } // Conditional types type Swapper = &lt;T extends number | string> (value: T) => T extends number ? string : number; // is equivalent to (value: number) => string // if T is number, or (value: string) => number // if T is string // Conditional mapped types interface Person { firstName: string; lastName: string; age: number; } type StringProps&lt;T> = { [K in keyof T]: T[K] extends string ? K : never; }; type PersonStrings = StringProps&lt;Person>; // PersonStrings is "firstName" | "lastName" // Utility types // Partial Partial&lt;{ x: number; y: number; z: number; }> // is equivalent to { x?: number; y?: number; z?: number; } // Readonly Readonly&lt;{ x: number; y: number; z: number; }> // is equivalent to { readonly x: number; readonly y: number; readonly z: number; } //-------------------------------- Pick Pick&lt;{ x: number; y: number; z: number; }, 'x' | 'y'> // is equivalent to { x: number; y: number; } // Record, å’Œ index signatureåŒºåˆ«æ˜¯ åè€…keyé™åˆ¶åœ¨ string number symbol Record&lt;'x' | 'y' | 'z', number> // is equivalent to { x: number; y: number; z: number; } // Exclude type Excluded = Exclude&lt;string | number, string>; // is equivalent to number // Extract type Extracted = Extract&lt;string | number, string>; // is equivalent to string // NonNullable type NonNull = NonNullable&lt;string | number | void>; // is equivalent to string | number // ReturnType type ReturnValue = ReturnType&lt;() => string>; // is equivalent to string // InstanceType class Renderer() {} type Instance = InstanceType&lt;typeof Renderer>; // is equivalent to Renderer // Type guards // Type predicates function isThing(val: unknown): val is Thing { // return true if val is a Thing } if (isThing(value)) { // value is of type Thing } //-------------------------------- typeof // "string" // "number" // "bigint" // "boolean" // "symbol" // "undefined" // "object" // "function" declare value: string | number | boolean; const isBoolean = typeof value === "boolean"; if (typeof value === "number") { // value is of type Number } else if (isBoolean) { // value is of type Boolean } else { // value is a string } // False // 0 // NaN // "" (the empty string) // 0n (the bigint version of zero) // null // undefined // instanceof declare value: Date | Error | MyClass; const isMyClass = value instanceof MyClass; if (value instanceof Date) { // value is a Date } else if (isMyClass) { // value is an instance of MyClass } else { // value is an Error } // in å±æ€§å’Œæ–¹æ³• interface Dog { woof(): void; } interface Cat { meow(): void; } function speak(pet: Dog | Cat) { if ('woof' in pet) { pet.woof() } else { pet.meow() } } //-------------------------------- Assertions // Type let val = someValue as string; // or let val = &lt;string>someValue; Const (immutable value) let point = { x: 20, y: 30 } as const; // or let point = &lt;const>{ x: 20, y: 30 }; function handle(url:string,method: "GET"|"POST"){ console.log("handle") } const req = { url: "https://example.com", method: "GET" }; handle(req.url, req.method as "GET"); // remove as "GET", throw: Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.(2345) // or const req = { url: "https://example.com", method: "GET" as "GET" }; // or convert to type literals const req = { url: "https://example.com", method: "GET" } as const; //-------------------------------- Indexed Access Types type Person = { age: number; name: string; alive: boolean }; type Age = Person["age"]; // number type I1 = Person["age" | "name"]; // type I1 = string | number type I2 = Person[keyof Person]; // type I2 = string | number | boolean type AliveOrName = "alive" | "name"; type I3 = Person[AliveOrName]; // type I3 = string | boolean //-------------------------------- Ambient declarations // Global declare const $: JQueryStatic; // Module declare module "foo" { export class Bar { ... } } // Wildcard module declare module "text!*" { const value: string; export default value; }</content></entry><entry><title>å¼€æºä¸å¿ƒç†å¥åº·[ç¿»è¯‘]</title><url>https://zhimoe.github.io/post/open-source-mental-health/</url><categories><category>ç¿»è¯‘</category></categories><tags><tag>å¼€æº</tag><tag>å¿ƒç†å¥åº·</tag></tags><content type="html"> æˆ‘ä¸€ä½äº²çˆ±çš„æœ‹å‹,ä¹Ÿæ˜¯é«˜äº§çš„Redox OSè´¡çŒ®è€…jD91mZM2åœ¨2021å¹´3æœˆå»ä¸–äº†,å¹´ä»…18å².ä»–å‚ä¸äº†2018ã€2019å’Œ2020å¹´çš„Redox OSå¤å­£ä»£ç æ´»åŠ¨.ä»–åœ¨å¼€å‘Redox OSçš„å„ä¸ªæ–¹é¢éƒ½åšå‡ºäº†è´¡çŒ®,ä»å†…æ ¸,åˆ°relibc,åˆ°ç§»æ¤ç¨‹åº.ä»–çš„å·¥ä½œè¯¦ç»†ä»‹ç»å¯ä»¥åœ¨Redox OSæ–°é—»ä¸­ç½²åä¸ºjD91mZM2çš„å¸–å­çœ‹åˆ°.
è¿™ä¸ªå¸–å­å¯èƒ½æ˜¯é»‘æš—çš„ã€æ·±æ²‰çš„ã€æ²‰é‡çš„ã€åŸå§‹çš„ã€æœªç»ç¼–è¾‘çš„.å¦‚æœä½ å’Œæˆ‘ä»¬ä¸­çš„è®¸å¤šäººä¸€æ ·æœ‰è‡ªå·±çš„é—®é¢˜,è¯·éšæ—¶ä¸æˆ‘è”ç³»ï¼šhttps://twitter.com/jeremy_soller.åœ¨è¿™ç§æƒ…å†µä¸‹,æˆ‘ä¸å»ºè®®é˜…è¯»è¿™ç¯‡æ–‡ç« çš„å…¶ä»–å†…å®¹.æˆ‘çš„ç»“è®ºæ˜¯,å¼€æºè¦æˆä¸ºå¯æŒç»­å‘å±•,è¿˜æœ‰å¤§é‡çš„å·¥ä½œè¦åš,è€Œå…¶ä¸­å¾ˆå¤§ä¸€éƒ¨åˆ†æ˜¯å¯¹ç¤¾åŒºåŠå…¶æˆå‘˜çš„å¥åº·çš„å…³æ€€.
åæ€ æ˜¨å¤©,å¦ä¸€ä¸ªè´¡çŒ®è€…ç»™æˆ‘å‘äº†æ¶ˆæ¯,è¯´jD91mZM2å·²ç»é•¿æ—¶é—´ç¦»çº¿,è€Œä¸”ä¹Ÿæ²¡æœ‰å›å¤é‚®ä»¶.æˆ‘é€šè¿‡æˆ‘æ‰€æŒæ¡çš„ä¿¡æ¯è¿›è¡Œäº†è”ç³»,ä½†æ— æµäºäº‹.æˆ‘æŠŠä»–çš„çœŸå®å§“åå‘Šè¯‰äº†å¦ä¸€ä½è´¡çŒ®è€…,åè€…æ‰¾åˆ°äº†ä»–çš„è®£å‘Š.æˆ‘ä»¬éªŒè¯äº†ä»–çš„åå­—ã€åœ°ç‚¹å’Œå‡ºç”Ÿæ—¥æœŸæ˜¯å¦ç›¸ç¬¦.è™½ç„¶æ²¡æœ‰åˆ—å‡ºæ­»å› ,ä½†æˆ‘ç›¸ä¿¡æˆ‘ä»¬æ‰¾åˆ°çš„è¯æ®è¡¨æ˜ä»–æ˜¯åœ¨ç²¾ç¥ç–¾ç—…å‘ä½œåè‡ªæ€.
åœ¨å¾—çŸ¥è¿™ä¸€åˆ‡å,æˆ‘æ„Ÿåˆ°å¾ˆéœ‡æƒŠ.è¿™æ ·ä¸€ä¸ªå¤šäº§çš„è´¡çŒ®è€…,ä¸ä»…å¯¹Redox,è€Œä¸”å¯¹è®¸å¤šé¡¹ç›®éƒ½æœ‰è´¡çŒ®,æ€ä¹ˆä¼šè§‰å¾—æ­»äº¡æ¯”ç”Ÿå‘½æ›´é‡è¦ï¼Ÿè¿™æ˜¯ä¸€ä¸ªèƒ½åŠ›æ— ç©·çš„äºº,è€Œä¸”ç›´åˆ°æœ€è¿‘,ä»–ä¼¼ä¹è¿˜èƒ½å¾ˆå¥½åœ°æŠŠæ¡è‡ªå·±çš„ç”Ÿæ´».ä½†æˆ‘æ´»å¾—è¶Šä¹…,å°±è¶Šæ„è¯†åˆ°è¿™å¯èƒ½æ˜¯ä¸€ä¸ªæå¤§çš„å¹»è§‰,äº‹æƒ…ä¼šè¿…é€Ÿæ¶åŒ–.
æˆ‘æœ€åä¸€æ¬¡ä¸jD91mZM2äº¤æµæ˜¯åœ¨äºŒæœˆ,åœ¨ä»–å»ä¸–å‰ä¸€ä¸ªæœˆ.è¿™æ¬¡äº¤æµçº¯ç²¹æ˜¯æŠ€æœ¯æ€§çš„,å…³äºRedoxå†…æ ¸çš„arch64ç«¯å£.æˆ‘ä¸ç¦æƒ³åˆ°,è¿™ä¹Ÿè®¸æ˜¯ä»–å†³å®šé€‰æ‹©æ­»äº¡çš„ä¸€ä¸ªå› ç´ .
åœ¨å¼€æºå·¥ä½œä¸­,æˆ‘ä»¬ç»å¸¸å¼ºè°ƒå¥½ä»£ç çš„é‡è¦æ€§.æ¯•ç«Ÿ,æ¯ä¸ªå¼€æºé¡¹ç›®çš„äº¤ä»˜ç‰©,éƒ½æ˜¯æºä»£ç ,å¯¹å§ï¼Ÿ ä½†æˆ‘ä»¬å¸¸å¸¸å¿˜è®°,å¥½çš„ä»£ç æ˜¯ç”±ä¼˜ç§€çš„äººç¼–å†™çš„,è€Œç•™ä½è¿™äº›äººå¹¶è®©ä»–ä»¬ä¿æŒå¿«ä¹,åº”è¯¥æ˜¯ä»»ä½•é¡¹ç›®ç»´æŠ¤è€…çš„é¦–è¦è€ƒè™‘.
å¿ƒç†å¥åº·é—®é¢˜çš„å‘ä½œæœ‰å¾ˆå¤šæ–¹é¢.ä¸€æ–¹é¢,ç²¾ç¥ç–¾ç—…é€šå¸¸æœ‰é—ä¼ å› ç´ .å¦ä¸€æ–¹é¢,è¿™äº›é—ä¼ çš„å‰å…†é€šå¸¸éœ€è¦æ…¢æ€§å’Œæ€¥æ€§çš„ç¯å¢ƒè§¦å‘å› ç´ .è¿™äº›æ…¢æ€§è¯±å› å¯ä»¥æ˜¯é•¿æœŸçš„ä¸è‰¯å®¶åº­æˆ–å·¥ä½œç¯å¢ƒ,å¹¶å¯¼è‡´ç²¾ç¥ç–¾ç—…æœ¬èº«çš„è¡¨ç°.æ€¥æ€§è¯±å› å¯èƒ½æ˜¯,ä¾‹å¦‚,ä¸æŸäººå‘ç”Ÿäº‰æ‰§,å¯¼è‡´ç²¾ç¥ç–¾ç—…å‘ä½œ.è¿™äº›å‘ä½œå¯èƒ½ä¸¥é‡åˆ°è¶³ä»¥å…‹æœç”Ÿå­˜çš„æç«¯æœ¬èƒ½,å¯¼è‡´è‡ªæ€.
åœ¨è¿™ç§æƒ…å†µä¸‹,è‡ªæ€å¹¶ä¸æ˜¯ä¸€ç§è½¯å¼±çš„è¡¨ç°.äº‹å®ä¸Š,å®ƒæ˜¯ä¸€ç§æç«¯ä¿¡å¿µå’ŒåŠ›é‡çš„å±•ç¤º.å³ä½¿åœ¨ç²¾ç¥ç–¾ç—…çš„èƒŒæ™¯ä¸‹,å¤§è„‘çš„æŸäº›éƒ¨åˆ†é€šå¸¸ä¸å—å½±å“.è¿™äº›éƒ¨åˆ†åœ¨è¿›åŒ–è¿‡ç¨‹ä¸­éå¸¸åŸå§‹,æˆ‘ä»¬å‡ ä¹æ²¡æœ‰æ„è¯†åˆ°å¯¹å®ƒä»¬çš„æ§åˆ¶.ä¼å›¾è‡ªæ€éœ€è¦å…‹æœæœ‰æ„è¯†çš„æ±‚ç”Ÿæ¬²æœ›.è¦æˆåŠŸ,å°±æ˜¯è¦å…‹æœæç«¯çš„æ½œæ„è¯†æ¬²æœ›.è¿™æ„å‘³ç€,å¯¹äºè‡ªæ€,å¾€å¾€æ˜¯æœ€èªæ˜ã€æœ€æœ‰èƒ½åŠ›çš„äººæ‰èƒ½å¤Ÿåšåˆ°.
è¿™ç§å¯¹æœ‰èƒ½åŠ›çš„äººçš„åé€‰æ‹©æ˜¯ä¸€ç§å¯æ€•çš„æµè¡Œç—….äººç±»æ€»ä½“ä¸Šè¿«åˆ‡éœ€è¦äººä¸ºåœ°è§£å†³é•¿æœŸå­˜åœ¨çš„é—®é¢˜.ä»¥æ°”å€™å˜åŒ–ä¸ºä¾‹.åœ¨æ¯å¹´80ä¸‡è‡ªæ€çš„äººä¸­,å¹³å‡æ¥è¯´ä¹Ÿè®¸æ¯”æˆ‘ä»¬å…¶ä»–äººæ›´æœ‰èƒ½åŠ›,å¦‚æœæœ‰å‡ ä¸ªäººåœ¨å¼€å‘æ ¸èšå˜å‘ç”µæ–¹é¢èµ·åˆ°äº†ä½œç”¨,é‚£ä¼šæ€ä¹ˆæ ·ï¼Ÿ
ç„¶è€Œ,æˆ‘ä»¬ä½œä¸ºä¸€ä¸ªç¤¾ä¼šå·²ç»é‡‡å–äº†è¿™æ ·çš„ç«‹åœºï¼šè¿™äº›äº‹ä»¶æ˜¯ä¸€ç§ä¸å¯é˜»æŒ¡çš„åŠ›é‡.å¯¼è‡´è‡ªæ€çš„å› ç´ æ˜¯å†…éƒ¨çš„,è€Œä¸æ˜¯å¤–éƒ¨çš„.åŸåˆ™ä¸Š,æˆ‘æ‹’ç»ç›¸ä¿¡è¿™ä¸€ç‚¹.å¯¹äºæ¯ä¸€ä¸ªé—®é¢˜,æˆ‘ä»¬éƒ½å¿…é¡»å¯»æ‰¾åŸå› å¹¶åŠ ä»¥ç¼“è§£,å³ä½¿æœ€åä¸å¯èƒ½åšåˆ°.
å› æ­¤,æˆ‘ä¸å¾—ä¸å®¡è§†è‡ªå·±çš„è¡Œä¸º,çœ‹çœ‹æœ‰ä»€ä¹ˆå¯ä»¥åšå¾—ä¸åŒ.çœ‹çœ‹æˆ‘æ˜¯å¦å¯ä»¥æŒ½æ•‘ä¸€ä¸ªäººçš„ç”Ÿå‘½,ä»¥åŠçœ‹çœ‹æˆ‘åœ¨æœªæ¥å¯ä»¥æŒ½æ•‘å“ªäº›ç”Ÿå‘½.
å¼€æºä¸å¿ƒç†å¥åº· å¼€æºçš„æŸäº›æ–¹é¢ä¼¼ä¹å¸å¼•äº†æœ€å¥‡æ€ªçš„äººç±»,åŒ…æ‹¬æˆ‘è‡ªå·±.è¿™ç¾¤äººåšæŒæ‰€æœ‰çš„ä¸œè¥¿éƒ½æ˜¯å¯æ£€æŸ¥çš„,è¿™ä¹Ÿè®¸æ˜¯ç”±å¼ºè¿«ç—‡è¡Œä¸ºæ‰€é©±åŠ¨çš„.è€Œé‚£äº›å®¹æ˜“å‡ºç°è¿™ç§è¡Œä¸ºçš„äºº,å¾€å¾€ä¼šä»å…¶ä»–ç–¾ç—…ä¸­ç»§æ‰¿ä¸‹æ¥.å¤šåŠ¨ç—‡ã€è‡ªé—­ç—‡ã€åŒç›¸æƒ…æ„Ÿéšœç¢ã€æŠ‘éƒç—‡å’Œå…¶ä»–ç–¾ç—…åœ¨å¼€æ”¾æºç è´¡çŒ®è€…ä¸­éå¸¸æ™®é.
å› æ­¤,å¼€æºç¤¾åŒºä¸­ä¹Ÿæ˜æ˜¾ç¼ºä¹è½¯æŠ€èƒ½.è¿™æ˜¾ç„¶æœ‰åˆ†è£‚ç¤¾åŒºå’Œå°†å¼€æºæœ¬èº«ä¸ &ldquo;æ­£å¸¸ &ldquo;ä¸–ç•Œéš”ç¦»çš„æ•ˆæœ.å¯¹æˆ‘ä»¬æ¥è¯´,å¹¸è¿çš„æ˜¯,å¼€æ”¾æºä»£ç æœ€ç»ˆæˆä¸ºä¸€ä¸ªæœ‰åˆ©å¯å›¾çš„è¡Œä¸š.è¿™ç§èµ„æœ¬çš„æ³¨å…¥å¯¼è‡´äº†å¼€æºé¢†åŸŸäººæ‰çš„æ˜¾è‘—å¤šæ ·åŒ–.
ç„¶è€Œ,è¿™ä¹Ÿæ˜¯æœ‰ä»£ä»·çš„.é‚£äº›ä¸ç¬¦åˆå¼€æºé¡¹ç›®æ–°çš„å•†ä¸šåˆ©ç›Šçš„äººå¾€å¾€è¢«æŠ›åœ¨ä¸€è¾¹.ç”±äºä¸åŸå§‹ç»´æŠ¤è€…çš„åˆ†æ­§å¯¼è‡´é¡¹ç›®æœ¬èº«å‡ºç°éš¾ä»¥å…‹æœçš„å˜åŒ–,é¡¹ç›®è¢«è¿›ä¸€æ­¥åˆ’åˆ†ä¸ºåˆ†å‰ä¸Šçš„åˆ†å‰.æˆ‘è‡ªå·±ä¹Ÿå‚ä¸äº†æ‰€æœ‰è¿™äº›æ–¹é¢çš„å·¥ä½œ.
åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹,éƒ½ç¼ºä¹å¯¹äººç±»æˆæœ¬çš„è°ƒæŸ¥.è°ƒæŸ¥å¼€æºè´¡çŒ®è€…ä¸­ä¼—å¤šçš„å¿ƒç†å¥åº·äº‹ä»¶,å¹¶è¯•å›¾æ‰¾å‡ºä¸€äº›å…±åŒçš„å› ç´ .æœ‰æ—¶è¿™äº›äº‹ä»¶ä¼šå¯¼è‡´æ–°çš„é¡¹ç›®,æœ‰æ—¶ä¼šå¯¼è‡´è´¡çŒ®è€…ç²¾ç–²åŠ›å°½,ç„¶åç¦»å¼€å¼€æ”¾æºç ,æœ‰æ—¶ä¼šå¯¼è‡´è‡ªæ€.
æˆ‘ä»¬å¿…é¡»è®¤è¯†åˆ°æˆ‘ä»¬åœ¨åˆ›é€ å¯¼è‡´ç²¾ç¥ç–¾ç—…çš„æ…¢æ€§å‹åŠ›ä»¥åŠå¯¼è‡´å±é™©å‘ä½œçš„æ€¥æ€§å‹åŠ›æ–¹é¢çš„ä½œç”¨.
æˆ‘è‡ªå·±çš„æ—…ç¨‹ æˆ‘å¯¹ç²¾ç¥ç–¾ç—…æ²¡æœ‰å…ç–«åŠ›.æˆ‘ç»å¸¸æ”¶åˆ°è¿™æ ·çš„ä¿¡æ¯ï¼š&ldquo;ä½ ä¼¼ä¹æŠŠä½ çš„äº‹æƒ…éƒ½æ§åˆ¶ä½äº†,ä½ æ˜¯æ€ä¹ˆåšåˆ°çš„ï¼Ÿ&rdquo; æ®‹é…·çš„äº‹å®æ˜¯,æˆ‘æ€€ç–‘æˆ‘ä»¬ä¸­æ˜¯å¦æœ‰äººçœŸçš„åšåˆ°äº†.è€Œæˆ‘ä»¬å¯¹ &ldquo;æ§åˆ¶ &ldquo;çš„å®šä¹‰å¯èƒ½æ˜¯éå¸¸ä¸åŒçš„.æ‹¥æœ‰æˆåŠŸçš„é¡¹ç›®å¹¶ä¸ç­‰åŒäºæ‹¥æœ‰æ™®éçš„å¹¸ç¦.
æˆ‘ä¸å¾—ä¸æ‰¿è®¤,æˆ‘ç°åœ¨æ¯”ä»¥å‰å¹¸ç¦å¤šäº†.å› æ­¤,ä¹Ÿè®¸ä¸ä¸€èˆ¬äººç›¸æ¯”,æˆ‘ç¡®å®æœ‰äº‹æƒ…åœ¨æ§åˆ¶ä¹‹ä¸­.æˆ‘çš„ç”Ÿæ´»ä¸€ç›´æ˜¯æ²»ç–—å¸ˆã€ç²¾ç¥ç—…åŒ»ç”Ÿã€è¯ç‰©å’Œéš”ç¦»çš„å¥¥å¾·èµ›.å®ƒæœ¬æ¥å¾ˆå®¹æ˜“åƒå…¶ä»–äººä¸€æ ·ç»“æŸ.æˆ‘å¾ˆå¹¸è¿åœ°æ‰¾åˆ°äº†æˆ‘çš„æ…¢æ€§å‹åŠ›æº,å¹¶å°½èŒå°½è´£åœ°æ¶ˆé™¤å®ƒä»¬.
æˆ‘çš„å¤§å­¦ä¸€å¹´&ndash;ä¸jD91mZM2å†³å®šç»“æŸè‡ªå·±ç”Ÿå‘½çš„æ—¶é—´å·®ä¸&ndash;ç‰¹åˆ«è‰°éš¾.æˆ‘çš„ä½“é‡å¢åŠ äº†è¿‘50ç£….æˆ‘å’Œå¦å¤–ä¸‰ä¸ªå®¤å‹ä½åœ¨ä¸€èµ·,å…¶ä¸­ä¸¤ä¸ªä¹Ÿæ—©é€äº†.æˆ‘äº¤æ›¿ä½¿ç”¨å¤šåŠ¨ç—‡è¯ç‰©ã€æŠ—æŠ‘éƒè¯,ç”šè‡³å¸çƒŸ&ndash;ä»¥å¯»æ‰¾èƒ½ &ldquo;ä¿®å¤ &ldquo;æˆ‘çš„æ–¹æ³•.åœ¨æ•´ä¸ªè¿‡ç¨‹ä¸­,æˆ‘ä¸€ç›´åœ¨ç¼–ç¨‹,ä¸ºæ­¤å¸¸å¸¸å¿½ç•¥äº†æˆ‘çš„å­¦æ ¡å·¥ä½œ.
åœ¨ä¸Šå¤§å­¦ä¹‹å‰,æˆ‘æ›¾åœ¨å“å°”åŒ»ç–—å…¬å¸æ‹…ä»»å®ä¹ ç”Ÿ,ç¼–å†™é™¤é¢¤å™¨è½¯ä»¶.æˆ‘åœ¨è¿™é¡¹å·¥ä½œä¸­æ‹¥æœ‰ä¸¤é¡¹ä¸“åˆ©.è€å®è¯´,åœ¨å¯¹è®¡ç®—æœºçš„ç†è§£ä¸Š,æˆ‘æ¯”åˆ«äººé«˜å‡ºä¸€æˆª.æˆ‘ä¹Ÿå¯¹è‡ªå·±è¯´å®è¯,åœ¨å¯¹äººçš„ç†è§£æ–¹é¢,æˆ‘æ¯”åˆ«äººå·®äº†ä¸€å¤§æˆª,åŒ…æ‹¬æˆ‘è‡ªå·±.
åœ¨é‚£æ®µæ—¶é—´é‡Œ,æˆ‘ä¸ç ”å‘éƒ¨çš„å‰¯æ€»è£å»ºç«‹äº†å…³ç³»,ä»–æˆäº†æˆ‘äº‹å®ä¸Šçš„è€æ¿.å¤§ä¸€å¿«ç»“æŸæ—¶,ä»–è”ç³»æˆ‘,é—®æˆ‘æ˜¯å¦æƒ³ç»§ç»­å·¥ä½œ.æˆ‘ç­”åº”äº†.
å¤§äºŒçš„æ—¶å€™,æˆ‘çš„æƒ…å†µéå¸¸ä¸åŒ.æˆ‘æŠŠå¤§éƒ¨åˆ†æ—¶é—´èŠ±åœ¨å†™è½¯ä»¶ä¸Š,å¹¶ä¸”èµšäº†ä¸å°‘é’±.æˆ‘å¯¹å­¦æ ¡æ²¡æœ‰å…´è¶£.æˆ‘æœ‰å‡ é—¨è¯¾ä¸åŠæ ¼,ä½†é«˜åˆ†é€šè¿‡äº†è®¸å¤šé«˜æ°´å¹³çš„CSè¯¾ç¨‹.æˆ‘å¾ˆå¿«å°±ä»å¤§å­¦é€€å­¦,å…¨èŒä»äº‹è½¯ä»¶å·¥ç¨‹.
è¿™å¯¹æˆ‘çš„å¿ƒç†å¥åº·äº§ç”Ÿäº†å·¨å¤§çš„ç§¯æå½±å“.æˆ‘é™äº†ä½“é‡.ä¸æˆ‘å¤§å­¦çš„å…¶ä»–æ ¡å‹ä¿æŒè”ç³»,å¹¶æœ€ç»ˆé€šè¿‡ä»–ä»¬è®¤è¯†äº†æˆ‘çš„å¦»å­.æˆ‘ä»¬ä¸€èµ·ä¹°äº†ä¸€å¥—æˆ¿å­.æˆ‘å¼€å§‹äº†Redoxæ“ä½œç³»ç»Ÿ.æˆ‘çš„å¦»å­å’Œæˆ‘ç»“å©šäº†.æˆ‘å¼€å§‹åœ¨System76å·¥ä½œ.æˆ‘çš„å¦»å­å’Œæˆ‘æœ‰ä¸€ä¸ªæ¼‚äº®çš„å¥³å„¿.ä»å¤§äºŒå¼€å§‹,æˆ‘ä»æ¥æ²¡æœ‰æƒ³è¿‡è‡ªå·±çš„å¿ƒç†å¥åº·é—®é¢˜,ä¹Ÿä¸éœ€è¦å»æ²»ç–—æˆ–ç”¨è¯.æˆ‘æ‰€æœ‰çš„å‹åŠ›éƒ½æ¶ˆå¤±äº†.
ä¸€ä¸ªäººçš„å¿ƒç†å¥åº·æˆåŠŸå¹¶ä¸æ€»æ˜¯èƒ½å¤åˆ»æˆå…¶ä»–äººçš„æˆåŠŸ.åœ¨è¿™ä¸€å†ç¨‹ä¸­,æˆ‘åˆ›é€ å’Œç ´åäº†ï¼ˆé€šè¿‡å¿½è§†ï¼‰æ•°ç™¾ç§å…³ç³».æˆ‘ä¸å¾—ä¸æ‰¿è®¤,è™½ç„¶æˆ‘å¾ˆå¿«ä¹,ä½†æˆ‘æœ‰ä¸€ç§å€¾å‘,ä¼šåœ¨åˆ«äººèº«ä¸Šé€ æˆç›¸å½“å¤§çš„åå·®.æˆ‘ä¿ç•™äº†ç»™æˆ‘å¸¦æ¥å¿«ä¹çš„å…³ç³»,è€Œå¿½ç•¥äº†é‚£äº›éœ€è¦åŠªåŠ›çš„å…³ç³».è€Œåœ¨æŸäº›æ—¶å€™,ä¹Ÿè®¸æˆ‘å¿˜è®°äº†ä¸jD91mZM2ä¿æŒè”ç³»,ç¡®ä¿ä»–æ‰¾åˆ°ä¸æˆ‘ä¸€æ ·çš„å¹¸ç¦.
ä¸€ä¸ªè§£å†³æ–¹æ¡ˆï¼Ÿ æ²¡æœ‰è§£å†³æ–¹æ¡ˆ,æ¯ä¸ªæ¡ˆä¾‹éƒ½æ˜¯ä¸åŒçš„.ä½†æˆ‘è§‰å¾—æœ‰å¿…è¦æ£€æŸ¥ä¸€ä¸‹è¿™äº›å¹´æ¥æˆ‘å¤±å»çš„è®¸å¤šäºº,æˆ‘å¸Œæœ›ä½ ä¹Ÿè¿™æ ·åš.æˆ‘ä»¬ä»ç„¶å¤„äºäº†è§£äººç±»æ€æƒ³çš„é»‘æš—æ—¶ä»£,æˆ‘ä»¬è¶Šæ˜¯äº’ç›¸æ£€æŸ¥,æˆ‘ä»¬å°±ä¼šåšå¾—è¶Šå¥½.æˆ‘çŸ¥é“æˆ‘æœ¬å¯ä»¥æœ‰æ‰€ä½œä¸º,å¦‚æœæˆ‘å¤šåšä¸€ç‚¹çš„è¯.ä¹Ÿè®¸ä¸æ˜¯ä¸ºäº†jD91mZM2,è€Œæ˜¯ä¸ºäº†æœ‰åŒæ ·æ„Ÿè§‰çš„äºº.æˆ‘ä¸ä¼šå†ä»¥ä»–ä»¬æ‰€å†™çš„ä»£ç æ¥è¯„ä»·è´¡çŒ®è€….ä»£ç ä¸ä¼šè‡ªå·±å†™,è€Œå†™ä»£ç çš„äººç”šè‡³æ¯” &ldquo;å¼€æº &ldquo;æœ¬èº«æ›´éœ€è¦ç»´æŠ¤.
åŸæ–‡-Open Source and Mental Health</content></entry><entry><title>ä¹°æˆ¿è£…ä¿®æ€»ç»“</title><url>https://zhimoe.github.io/post/hangzhou-house-tip/</url><categories><category>ç”Ÿæ´»</category></categories><tags><tag>ä¹°æˆ¿</tag></tags><content type="html"> ç®€å•è®°å½•ä¸€ä¸‹è‡ªå·±ä¹°æˆ¿å’Œè£…ä¿®çš„ä¸€ç‚¹ç»éªŒ.
ä¹°æˆ¿ è‡ªå·±ä¹°æˆ¿æ¯”è¾ƒç¦»å¥‡,æ­å·å¼€å§‹å®è¡Œæ‘‡å·çš„åŠå¹´å,ç«¯åˆèŠ‚åœ¨è€å®¶åˆ·å¾®ä¿¡,çœ‹åˆ°æœ‰ä¸ªçº¢ç›˜æœ‰6000å¤šäººæŠ¥å,æ„Ÿè§‰ä¹°æˆ¿éƒ½è¦å¼€å§‹ç¢°è¿æ°”äº†æƒ³åˆ°äº†è½¦ç‰Œçš„æ‚²å‰§,äºæ˜¯è¿”æ­åä¸‹è½¦å°±å»é‚£ä¸ªæ¥¼ç›˜çœ‹äº†ä¸€ä¸‹,å°åŒºæ—è¾¹åœ¨ä¿®åœ°é“,çœ‹äº†å‡ çœ¼æ²™ç›˜,ç¬¬äºŒå¤©å°±å€Ÿé’±ç™»è®°æ‘‡å·äº†,æ²¡æƒ³åˆ°ç¬¬ä¸€æ¬¡å°±ä¸­äº†.ç°åœ¨å›æƒ³èµ·å°±åšæ¢¦ä¸€æ ·.ç½‘ä¸Šå…³äºå¦‚ä½•ä¹°æˆ¿çš„ç»éªŒç‰¹åˆ«å¤š,ä¾‹å¦‚æ­å·æˆ¿äº§çŸ¥è¯†æ‰«ç›²,ä¸Šæµ·ä¹°æˆ¿ç­‰ç­‰. è¿™äº›æˆ‘éƒ½æ²¡ç”¨ä¸Š. è¿™é‡Œè¯´è¯´è‡ªå·±çš„ä¸€äº›ç»éªŒå’Œè¸©å‘.
æˆ·å‹æ–¹æ­£é€šé€å¹²æ¹¿åˆ†ç¦»è¿™äº›ç½‘ä¸Šéƒ½ä¼šè¯´.æé†’çš„æ˜¯è®¤çœŸçœ‹æ²™ç›˜æ—è¾¹æ¯æ ‹æ¥¼çš„è¯´æ˜æŒ‚å¹…. æŒ‚å¹…ä¸‹é¢ä¼šæœ‰å°å­—,è¯´æ˜æ¯æ ‹æ¥¼çš„ä¸€äº›å‘,ä¾‹å¦‚ä¸€äº›è®¾å¤‡å¹³å°åœ¨å“ªæ ‹æ¥¼ï¼ˆå™ªéŸ³ï¼‰,æ¥¼çš„è…°çº¿åœ¨å‡ æ¥¼ï¼ˆè…°çº¿åªæ˜¯ä¸ºäº†æ¥¼å¤–è§‚å¥½çœ‹,ä½†æ˜¯éå¸¸å½±å“è¯¥å±‚çš„é‡‡å…‰ï¼‰,é€‰çš„æ—¶å€™è¦é¿å¼€é‚£äº›æ¥¼å±‚. å¦‚æœé€‰æ‹©ä½å±‚çš„è¯,æˆ–è€…ä½ çš„å·ç é ååªèƒ½ä¹°ä½å±‚,çœ‹ä¸‹å…‰ç…§æ—¶é—´æµ‹è¯„,åŒä¸€æ ‹æ¥¼çš„ä¸åŒå•å…ƒçš„å…‰ç…§æ—¶é—´éƒ½ä¼šæœ‰æ‰€ä¸åŒçš„,ç‰¹åˆ«æ˜¯ä¸€äº›å‡¹å‡¸é€ å‹çš„æ¥¼é¢.æˆ‘è‡ªå·±çš„æˆ¿å­å°±æ˜¯å®¢å…é‡‡å…‰ä¸å¥½,å§å®¤å¾ˆå¥½.ä¼˜å…ˆåº”è¯¥è€ƒè™‘å®¢å…é‡‡å…‰å¥½çš„æˆ·å‹. ä¹°æˆ¿çš„æ—¶å€™å¦‚æœé¢„ç®—è¶³å¤Ÿ,ä¸€å®šä¹°è¾¹å¥—,å› ä¸ºä¸­é—´å¥—çš„å°æˆ·å‹å®¢å…é‡‡å…‰å’Œéš”éŸ³ï¼ˆæ¥¼ä¸Šæ¥¼ä¸‹ç”µæ¢¯è¿‡é“çš„èµ°è·¯è¯´è¯å£°éƒ½ä¼šä»å¨æˆ¿æˆ–è€…å•æ‰€çª—æˆ·é—¯è¿›æ¥,éå¸¸æ¸…æ™°ï¼‰,å•æ‰€éšç§æ€§ç­‰éƒ½æœ‰å¾ˆå¤§é—®é¢˜.è¿™ç‚¹æ˜¯æˆ‘æœ€åæ‚”çš„,å½“æ—¶æ²¡ç»éªŒä»¥ä¸ºè‡ªå·±è´·æ¬¾é¢åº¦æœ‰é™,é¦–ä»˜ä¹ŸåŸºæœ¬æ˜¯å€Ÿçš„,å‹åŠ›å¾ˆå¤§,æ»¡è„‘å­å°±æ˜¯è¦æ€»ä»·ä½çš„. å…¶å®éš”å£å¤¹è¾¹å¥—ï¼ˆä¸¤æ ‹æ¥¼è¿åœ¨ä¸€èµ·çš„è¾¹å¥—,å—åŒ—é€šé€ä½†æ˜¯æ²¡æœ‰ä¾§é¢çª—ï¼‰æ‰å¤š10å¹³,æ€»ä»·å¤š25ä¸‡è€Œå·²,å®¢å…é‡‡å…‰,ç§å¯†æ€§éƒ½å¥½å¾ˆå¤š.ä¸»è¦è¿˜æ˜¯å¤ªä»“ä¿ƒäº†. å½“ç„¶è¾¹å¥—å¾ˆå¤šæ˜¯90æ–¹ä»¥ä¸Šçš„,é™¤äº†æ€»ä»·,å¥‘ç¨å’Œå–å‡ºæ—¶å„ç§è´¹ç”¨ä¼šé«˜ä¸å°‘,è‡ªå·±é‡åŠ›è€Œè¡Œ,å¦‚æœè¾¹å¥—/å¤¹è¾¹å¥—æ˜¯89æ–¹çš„,ä¸è¦çŠ¹è±«,æ€»ä»·å¤šä¸ªäºŒä¸‰åä¸‡çš„æ¢æ¥çš„æ˜¯å®Œå…¨ä¸ä¸€æ ·çš„ä½“éªŒ. å¦‚æœå°åŒºé è¿‘åœ°é“æˆ–è€…äº¤é€šæ¯”è¾ƒä¾¿åˆ©, æŠ•èµ„å®¢åˆæ¯”è¾ƒå¤š,å»ºè®®å¼€ç›˜ä¸è¦ä¹°è½¦ä½, äº¤æˆ¿åä¼šæœ‰æŠ•èµ„å®¢æˆ–è€…å¼€å‘å•†æ‰“æŠ˜å–è½¦ä½. è£…ä¿® å› ä¸ºé™ä»·,æ­å·çš„æ–°æˆ¿ç²¾è£…ä¿®ç­‰äºæ¯›å¯,æˆ‘è¿™ä¸ªäº¤ä»˜çš„æ—¶å€™æ²¡æœ‰ç©ºè°ƒ,ç¯è¿˜æ˜¯ç™½ç‚½ç¯.
ç¬¬ä¸€æ¬¡ä¹°æˆ¿åŠ¡å¿…è¯·ä¸€ä¸ªéªŒæˆ¿å¸ˆ,æœ¯ä¸šæœ‰ä¸“æ”»,åƒä¸‡ä¸è¦ç½‘ä¸Šçœ‹äº†ç‚¹æ”¶æˆ¿éªŒæˆ¿æ”»ç•¥å°±è‡ªä¿¡æ»¡æ»¡è‡ªå·±å»æ”¶æˆ¿,ç­‰åˆ°è£…ä¿®ä¸€åŠåˆå‘ç°ä¸€å †é—®é¢˜. è£…ä¿®é¡ºåºå¾ˆé‡è¦,ä¼˜å…ˆè€ƒè™‘æ‰“å­”,å¾ˆå¤šä¸šä¸»éƒ½æ˜¯è£…ä¿®å°¾å£°å»ä¹°ç©ºè°ƒ,å®‰è£…æ—¶å‘ç°éœ€è¦é‡æ–°æ‰“å­”,å¢™å¸ƒå·²ç»è´´å¥½äº†,å¼„ç ´å¾ˆå¿ƒç–¼.è¿˜æœ‰ä¸šä¸»ç»™é˜³å°è´´äº†ç“·ç –ï¼ˆäº¤ä»˜æ˜¯ä¹³èƒ¶æ¼†ï¼‰,ä¹°äº†å¸¦æ–°é£çš„å®¢å…ç©ºè°ƒç®¡é“å¤ªå¤§éœ€è¦é‡æ–°æ‰“å­”,ä¸å°å¿ƒæ‰“ç ´æ°´ç®¡,éœ€è¦é‡æ–°æ•²æ‰2å—ç“·ç –.éå¸¸è´¹äº‹. æ‹¿åˆ°æ°´ç”µå›¾,å¦‚æœæ²¡æœ‰,æ‰“å­”å’Œç‰©ä¸š(æˆ–è€…æˆ¿ä¿®)è¯´ä¸€å£°,è®©ä»–ä»¬å‘Šè¯‰å“ªé‡Œæ‰“å­”,è¿™æ ·æ‰“ç ´æ°´ç®¡è®©ä»–ä»¬ä¿®. ç½‘ä¸Šä¹°å®¶ç”µä¸ä¸€å®šæ¯”å®ä½“åº—ä¾¿å®œ,æˆ‘åœ¨å›½ç¾ä¹°äº†ç¾çš„colmoçš„ç©ºè°ƒ,æ¯”æ·˜å®æœ€ä¾¿å®œçš„è¿˜ä¾¿å®œä¸‰åƒ. å¦‚æœä¸æ‡‚è®¾è®¡,åƒä¸‡ä¸è¦ä¹±é€‰å¢™çš„é¢œè‰²,è‡ªå·±å½“æ—¶æ™šä¸Šåœ¨ç¯å…‰ä¸‹é¢é€‰äº†ä¸€ä¸ªç°è“å¢™å¸ƒåšä¸»è‰², ç»“æœæ–½å·¥å½“å¤©å‘ç°åœ¨æ—¥å…‰ä¸‹æ˜¯æ°´è“,åªèƒ½æ–½å·¥å½“å¤©ä¸´æ—¶åŠ é’±æ¢é¢œè‰²,è¿˜è€½è¯¯äº†è¿›åº¦. å¢™å¸ƒæ ·å“å› ä¸ºé¢ç§¯å°,é¢œè‰²å’Œå®é™…ä¸Šå¢™æ•ˆæœç›¸å·®ç”šè¿œ,æ—¥å…‰å’Œç¯å…‰ä¸‹ä¹Ÿä¸ä¸€æ ·. è€Œä¸”,å¢™é¢çš„é¢œè‰²å¯¹äºåæœŸä¹°å®¶å…·,æ²™å‘å’Œçª—å¸˜çš„å½±å“éå¸¸å¤§. æ²¡æœ‰åè¶³æŠŠæ¡çš„ç›´æ¥é€‰ç™½è‰²æˆ–è€…ææµ…ç°. é‡‡å…‰ç‰¹åˆ«å¥½çš„æ‰å»ºè®®é€‰æµ…ç°, å› ä¸ºä¸Šå¢™åç°è‰²ä¼šå˜é‡ï¼ ä¼˜å…ˆè€ƒè™‘ä¹³èƒ¶æ¼†,è‡ªå·±é€‰äº†ç¡…è—»æ³¥è´¨æ„Ÿçš„å¢™å¸ƒ,ç¡®å®è´¨æ„Ÿå¾ˆå¥½,ä¹Ÿå¥½çœ‹.ä½†æ˜¯æ„Ÿè§‰å®¹æ˜“ç§¯ç°,è™½ç„¶é˜²æ°´,ä½†æ˜¯å¸ƒé¢ä¸å¹³å‡¹å¤„æ ¹æœ¬æ“¦ä¸æ‰. è€Œä¸”æ²¹æ¼†çš„ä¼˜åŠ¿è¿˜å¯ä»¥å•é¢å¢™ä¿®å¤. ç°åœ¨éƒ½æ˜¯æ™ºèƒ½å®¶å…·,é—¨é”å†°ç®±ç©ºè°ƒéƒ½æœ‰app,æ‰‹æœºé¥æ§èŠèƒœäºæ— ,æ‰€ä»¥å®¶é‡Œå®½å¸¦å¯ä»¥æå‰å¼€é€š. å¦‚æœæ˜¯è‡ªå·±å¸ƒç½®å®¶å…·, å»ºè®®ä¸è¦ç€æ€¥å®‰è£…é˜²å€’è£…ç½®,ç­‰å®¶å…·å…¨éƒ¨æ‘†æ”¾å®Œé€‚åº”å‡ å¤©å†å†³å®š,æå¤§å¯èƒ½ä¼šè°ƒæ•´å®¶å…·ä½ç½®. 2021.11.11 è’¸æ±½æ‹–æŠŠæ¯«æ— ç”¨å¤„,è’¸æ±½æ˜¯å‘ä¸Šçš„,åœ°æ¿å¾ˆéš¾åŠ çƒ­. ä¹°ä¸€ä¸ªå¥½ç‚¹çš„æ‹–æŠŠ,å¸¦æ°´æ¡¶çš„é‚£ç§å¯ä»¥æ–¹ä¾¿æ´—æŠ¹å¸ƒå’ŒæŒ¤å¹²çš„. ä¹°ä¸œè¥¿è¦æœ‰é¢„ç®—,ä¹°colmoå’Œå¢™å¸ƒéƒ½æ˜¯ä¸¥é‡è¶…é¢„ç®—çš„.å–å®¶å¾ˆå¿ƒæœºåœ°ä»‹ç»è´µçš„,ä¸€ä¸Šæ‰‹è´¨æ„Ÿç¡®å®ä¸ä¸€æ ·.é¢„ç®—å°±æ˜¯è¿™ä¹ˆè¶…çš„. ä¹°ä¸€äº›ç±³ç®±,ä¿é²œç›’,ç½®ç‰©æ¶.å¨æˆ¿æ˜¯æœ€éš¾æ”¶æ‹¾çš„,ç¬¬ä¸€æ­¥å°½é‡ä¿è¯ä¸è¦æŠŠè¶…å¸‚çš„ä¸œè¥¿è¿ç€å¡‘æ–™è¢‹æ”¾è¿›å†°ç®±/æŸœå­.åªæœ‰è¿™æ ·åç»­æ‰èƒ½ä¸ä¹±. æå‰è§„åˆ’ä¸€ä¸ªå·¥å…·é—´,ç›®å‰å®¶é‡Œæœ‰æˆ´æ£®,æ‹–æŠŠ,æ‰«æŠŠç•šæ–—,å°±å·²ç»ä¹±æ”¾äº†,æˆ´æ£®æ²¡åœ°æ–¹æŒ‚ç€å……ç”µæ¯æ¬¡æ‰£ç”µæ± å……ç”µ.è¿˜æœ‰èºä¸åˆ€,é”¤å­,æ‰³æ‰‹ç­‰åˆ°å¤„ä¹±æ‰”.</content></entry><entry><title>Tour of Rusts Standard Library Traits[ç¿»è¯‘]</title><url>https://zhimoe.github.io/post/tour-of-rusts-standard-library-traits/</url><categories><category>ç¿»è¯‘</category></categories><tags><tag>code</tag><tag>rust</tag></tags><content type="html"> å…³äºrust traitéå¸¸å¥½çš„ä»‹ç»,æ¯”rust bookè¯¦ç»†,ç³»ç»Ÿ.
Tour of Rust&rsquo;s Standard Library Traits Table of Contents
Intro Trait Basics Trait Items Self Functions Methods Associated Types Generic Parameters Generic Types vs Associated Types Scope Derive Macros Default Impls Generic Blanket Impls Subtraits &amp; Supertraits Trait Objects Marker Traits Auto Traits Unsafe Traits Auto Traits Send &amp; Sync Sized General Traits Default Clone Copy Any Formatting Traits Display &amp; ToString Debug Operator Traits Comparison Traits PartialEq &amp; Eq Hash PartialOrd &amp; Ord Arithmetic Traits Add &amp; AddAssign Closure Traits FnOnce, FnMut, &amp; Fn Other Traits Deref &amp; DerefMut Index &amp; IndexMut Drop Conversion Traits From &amp; Into Error Handling Error Conversion Traits Continued TryFrom &amp; TryInto FromStr AsRef &amp; AsMut Borrow &amp; BorrowMut ToOwned Iteration Traits Iterator IntoIterator FromIterator I/O Traits Read &amp; Write Conclusion Discuss Notifications Further Reading Intro Have you ever wondered what&rsquo;s the difference between:
Deref&lt;Target = T>, AsRef&lt;T>, and Borrow&lt;T>? Clone, Copy, and ToOwned? From&lt;T> and Into&lt;T>? TryFrom&lt;&amp;str> and FromStr? FnOnce, FnMut, Fn, and fn? Or ever asked yourself the questions:
&ldquo;When do I use associated types vs generic types in my trait?&rdquo; &ldquo;What are generic blanket impls?&rdquo; &ldquo;How do subtraits and supertraits work?&rdquo; &ldquo;Why does this trait not have any methods?&rdquo; Well then this is the article for you! It answers all of the above questions and much much more. Together we&rsquo;ll do a quick flyby tour of all of the most popular and commonly used traits from the Rust standard library!
You can read this article in order section by section or jump around to whichever traits interest you the most because each trait section begins with a list of links to Prerequisite sections that you should read to have adequate context to understand the current section&rsquo;s explanations.
Trait Basics We&rsquo;ll cover just enough of the basics so that the rest of the article can be streamlined without having to repeat the same explanations of the same concepts over and over as they reappear in different traits.
Trait Items Trait items are any items that are part of a trait declaration.
Self Self always refers to the implementing type.
trait Trait { // always returns i32 fn returns_num() -> i32; // returns implementing type fn returns_self() -> Self; } struct SomeType; struct OtherType; impl Trait for SomeType { fn returns_num() -> i32 { 5 } // Self == SomeType fn returns_self() -> Self { SomeType } } impl Trait for OtherType { fn returns_num() -> i32 { 6 } // Self == OtherType fn returns_self() -> Self { OtherType } } Functions A trait function is any function whose first parameter does not use the self keyword.
trait Default { // function fn default() -> Self; } Trait functions can be called namespaced by the trait or implementing type:
fn main() { let zero: i32 = Default::default(); let zero = i32::default(); } Methods A trait method is any function whose first parameter uses the self keyword and is of type Self, &amp;Self, &amp;mut Self. The former types can also be wrapped with a Box, Rc, Arc, or Pin.
trait Trait { // methods fn takes_self(self); fn takes_immut_self(&amp;self); fn takes_mut_self(&amp;mut self); // above methods desugared fn takes_self(self: Self); fn takes_immut_self(self: &amp;Self); fn takes_mut_self(self: &amp;mut Self); } // example from standard library trait ToString { fn to_string(&amp;self) -> String; } Methods can be called using the dot operator on the implementing type:
fn main() { let five = 5.to_string(); } However, similarly to functions, they can also be called namespaced by the trait or implementing type:
fn main() { let five = ToString::to_string(&amp;5); let five = i32::to_string(&amp;5); } Associated Types A trait can have associated types. This is useful when we need to use some type other than Self within function signatures but would still like the type to be chosen by the implementer rather than being hardcoded in the trait declaration:
trait Trait { type AssociatedType; fn func(arg: Self::AssociatedType); } struct SomeType; struct OtherType; // any type implementing Trait can // choose the type of AssociatedType impl Trait for SomeType { type AssociatedType = i8; // chooses i8 fn func(arg: Self::AssociatedType) {} } impl Trait for OtherType { type AssociatedType = u8; // chooses u8 fn func(arg: Self::AssociatedType) {} } fn main() { SomeType::func(-1_i8); // can only call func with i8 on SomeType OtherType::func(1_u8); // can only call func with u8 on OtherType } Generic Parameters &ldquo;Generic parameters&rdquo; broadly refers to generic type parameters, generic lifetime parameters, and generic const parameters. Since all of those are a mouthful to say people commonly abbreviate them to &ldquo;generic types&rdquo;, &ldquo;lifetimes&rdquo;, and &ldquo;generic consts&rdquo;. Since generic consts are not used in any of the standard library traits we&rsquo;ll be covering they&rsquo;re outside the scope of this article.
We can generalize a trait declaration using parameters:
// trait declaration generalized with lifetime &amp; type parameters trait Trait&lt;'a, T> { // signature uses generic type fn func1(arg: T); // signature uses lifetime fn func2(arg: &amp;'a i32); // signature uses generic type &amp; lifetime fn func3(arg: &amp;'a T); } struct SomeType; impl&lt;'a> Trait&lt;'a, i8> for SomeType { fn func1(arg: i8) {} fn func2(arg: &amp;'a i32) {} fn func3(arg: &amp;'a i8) {} } impl&lt;'b> Trait&lt;'b, u8> for SomeType { fn func1(arg: u8) {} fn func2(arg: &amp;'b i32) {} fn func3(arg: &amp;'b u8) {} } It&rsquo;s possible to provide default values for generic types. The most commonly used default value is Self but any type works:
// make T = Self by default trait Trait&lt;T = Self> { fn func(t: T) {} } // any type can be used as the default trait Trait2&lt;T = i32> { fn func2(t: T) {} } struct SomeType; // omitting the generic type will // cause the impl to use the default // value, which is Self here impl Trait for SomeType { fn func(t: SomeType) {} } // default value here is i32 impl Trait2 for SomeType { fn func2(t: i32) {} } // the default is overridable as we'd expect impl Trait&lt;String> for SomeType { fn func(t: String) {} } // overridable here too impl Trait2&lt;String> for SomeType { fn func2(t: String) {} } Aside from parameterizing the trait it&rsquo;s also possible to parameterize individual functions and methods:
trait Trait { fn func&lt;'a, T>(t: &amp;'a T); } Generic Types vs Associated Types Both generic types and associated types defer the decision to the implementer on which concrete types should be used in the trait&rsquo;s functions and methods, so this section seeks to explain when to use one over the other.
The general rule-of-thumb is:
Use associated types when there should only be a single impl of the trait per type. Use generic types when there can be many possible impls of the trait per type. Let&rsquo;s say we want to define a trait called Add which allows us to add values together. Here&rsquo;s an initial design and impl that only uses associated types:
trait Add { type Rhs; type Output; fn add(self, rhs: Self::Rhs) -> Self::Output; } struct Point { x: i32, y: i32, } impl Add for Point { type Rhs = Point; type Output = Point; fn add(self, rhs: Point) -> Point { Point { x: self.x + rhs.x, y: self.y + rhs.y, } } } fn main() { let p1 = Point { x: 1, y: 1 }; let p2 = Point { x: 2, y: 2 }; let p3 = p1.add(p2); assert_eq!(p3.x, 3); assert_eq!(p3.y, 3); } Let&rsquo;s say we wanted to add the ability to add i32s to Points where the i32 would be added to both the x and y members:
trait Add { type Rhs; type Output; fn add(self, rhs: Self::Rhs) -> Self::Output; } struct Point { x: i32, y: i32, } impl Add for Point { type Rhs = Point; type Output = Point; fn add(self, rhs: Point) -> Point { Point { x: self.x + rhs.x, y: self.y + rhs.y, } } } impl Add for Point { // âŒ type Rhs = i32; type Output = Point; fn add(self, rhs: i32) -> Point { Point { x: self.x + rhs, y: self.y + rhs, } } } fn main() { let p1 = Point { x: 1, y: 1 }; let p2 = Point { x: 2, y: 2 }; let p3 = p1.add(p2); assert_eq!(p3.x, 3); assert_eq!(p3.y, 3); let p1 = Point { x: 1, y: 1 }; let int2 = 2; let p3 = p1.add(int2); // âŒ assert_eq!(p3.x, 3); assert_eq!(p3.y, 3); } Throws:
error[E0119]: conflicting implementations of trait `Add` for type `Point`: --> src/main.rs:23:1 | 12 | impl Add for Point { | ------------------ first implementation here ... 23 | impl Add for Point { | ^^^^^^^^^^^^^^^^^^ conflicting implementation for `Point` Since the Add trait is not parameterized by any generic types we can only impl it once per type, which means we can only pick the types for both Rhs and Output once! To allow adding both Pointss and i32s to Point we have to refactor Rhs from an associated type to a generic type, which would allow us to impl the trait multiple times for Point with different type arguments for Rhs:
trait Add&lt;Rhs> { type Output; fn add(self, rhs: Rhs) -> Self::Output; } struct Point { x: i32, y: i32, } impl Add&lt;Point> for Point { type Output = Self; fn add(self, rhs: Point) -> Self::Output { Point { x: self.x + rhs.x, y: self.y + rhs.y, } } } impl Add&lt;i32> for Point { // âœ… type Output = Self; fn add(self, rhs: i32) -> Self::Output { Point { x: self.x + rhs, y: self.y + rhs, } } } fn main() { let p1 = Point { x: 1, y: 1 }; let p2 = Point { x: 2, y: 2 }; let p3 = p1.add(p2); assert_eq!(p3.x, 3); assert_eq!(p3.y, 3); let p1 = Point { x: 1, y: 1 }; let int2 = 2; let p3 = p1.add(int2); // âœ… assert_eq!(p3.x, 3); assert_eq!(p3.y, 3); } Let&rsquo;s say we add a new type called Line which contains two Points, and now there are contexts within our program where adding two Points should produce a Line instead of a Point. This is not possible given the current design of the Add trait where Output is an associated type but we can satisfy these new requirements by refactoring Output from an associated type into a generic type:
trait Add&lt;Rhs, Output> { fn add(self, rhs: Rhs) -> Output; } struct Point { x: i32, y: i32, } impl Add&lt;Point, Point> for Point { fn add(self, rhs: Point) -> Point { Point { x: self.x + rhs.x, y: self.y + rhs.y, } } } impl Add&lt;i32, Point> for Point { fn add(self, rhs: i32) -> Point { Point { x: self.x + rhs, y: self.y + rhs, } } } struct Line { start: Point, end: Point, } impl Add&lt;Point, Line> for Point { // âœ… fn add(self, rhs: Point) -> Line { Line { start: self, end: rhs, } } } fn main() { let p1 = Point { x: 1, y: 1 }; let p2 = Point { x: 2, y: 2 }; let p3: Point = p1.add(p2); assert!(p3.x == 3 &amp;&amp; p3.y == 3); let p1 = Point { x: 1, y: 1 }; let int2 = 2; let p3 = p1.add(int2); assert!(p3.x == 3 &amp;&amp; p3.y == 3); let p1 = Point { x: 1, y: 1 }; let p2 = Point { x: 2, y: 2 }; let l: Line = p1.add(p2); // âœ… assert!(l.start.x == 1 &amp;&amp; l.start.y == 1 &amp;&amp; l.end.x == 2 &amp;&amp; l.end.y == 2) } So which Add trait above is the best? It really depends on the requirements of your program! They&rsquo;re all good in the right situations.
Scope Trait items cannot be used unless the trait is in scope. Most Rustaceans learn this the hard way the first time they try to write a program that does anything with I/O because the Read and Write traits are not in the standard library prelude:
use std::fs::File; use std::io; fn main() -> Result&lt;(), io::Error> { let mut file = File::open("Cargo.toml")?; let mut buffer = String::new(); file.read_to_string(&amp;mut buffer)?; // âŒ read_to_string not found in File Ok(()) } read_to_string(buf: &amp;mut String) is declared by the std::io::Read trait and implemented by the std::fs::File struct but in order to call it std::io::Read must be in scope:
use std::fs::File; use std::io; use std::io::Read; // âœ… fn main() -> Result&lt;(), io::Error> { let mut file = File::open("Cargo.toml")?; let mut buffer = String::new(); file.read_to_string(&amp;mut buffer)?; // âœ… Ok(()) } The standard library prelude is a module in the standard library, i.e. std::prelude::v1, that gets auto imported at the top of every other module, i.e. use std::prelude::v1::*. Thus the following traits are always in scope and we never have to explicitly import them ourselves because they&rsquo;re part of the prelude:
AsMut AsRef Clone Copy Default Drop Eq Fn FnMut FnOnce From Into ToOwned IntoIterator Iterator PartialEq PartialOrd Send Sized Sync ToString Ord Derive Macros The standard library exports a handful of derive macros which we can use to quickly and conveniently impl a trait on a type if all of its members also impl the trait. The derive macros are named after the traits they impl:
Clone Copy Debug Default Eq Hash Ord PartialEq PartialOrd Example usage:
// macro derives Copy &amp; Clone impl for SomeType #[derive(Copy, Clone)] struct SomeType; Note: derive macros are just procedural macros and can do anything, there&rsquo;s no hard rule that they must impl a trait or that they can only work if all the members of the type impl a trait, these are just the conventions followed by the derive macros in the standard library.
Default Impls Traits can provide default impls for their functions and methods.
trait Trait { fn method(&amp;self) { println!("default impl"); } } struct SomeType; struct OtherType; // use default impl for Trait::method impl Trait for SomeType {} impl Trait for OtherType { // use our own impl for Trait::method fn method(&amp;self) { println!("OtherType impl"); } } fn main() { SomeType.method(); // prints "default impl" OtherType.method(); // prints "OtherType impl" } This is especially handy if some of the trait methods can be implemented solely using other trait methods.
trait Greet { fn greet(&amp;self, name: &amp;str) -> String; fn greet_loudly(&amp;self, name: &amp;str) -> String { self.greet(name) + "!" } } struct Hello; struct Hola; impl Greet for Hello { fn greet(&amp;self, name: &amp;str) -> String { format!("Hello {}", name) } // use default impl for greet_loudly } impl Greet for Hola { fn greet(&amp;self, name: &amp;str) -> String { format!("Hola {}", name) } // override default impl fn greet_loudly(&amp;self, name: &amp;str) -> String { let mut greeting = self.greet(name); greeting.insert_str(0, "Â¡"); greeting + "!" } } fn main() { println!("{}", Hello.greet("John")); // prints "Hello John" println!("{}", Hello.greet_loudly("John")); // prints "Hello John!" println!("{}", Hola.greet("John")); // prints "Hola John" println!("{}", Hola.greet_loudly("John")); // prints "Â¡Hola John!" } Many traits in the standard library provide default impls for many of their methods.
Generic Blanket Impls A generic blanket impl is an impl on a generic type instead of a concrete type. To explain why and how we&rsquo;d use one let&rsquo;s start by writing an is_even method for number types:
trait Even { fn is_even(self) -> bool; } impl Even for i8 { fn is_even(self) -> bool { self % 2_i8 == 0_i8 } } impl Even for u8 { fn is_even(self) -> bool { self % 2_u8 == 0_u8 } } impl Even for i16 { fn is_even(self) -> bool { self % 2_i16 == 0_i16 } } // etc #[test] // âœ… fn test_is_even() { assert!(2_i8.is_even()); assert!(4_u8.is_even()); assert!(6_i16.is_even()); // etc } Obviously, this is very verbose. Also, all of our impls are almost identical. Furthermore, in the unlikely but still possible event that Rust decides to add more number types in the future we have to remember to come back to this code and update it with the new number types. We can solve all these problems using a generic blanket impl:
use std::fmt::Debug; use std::convert::TryInto; use std::ops::Rem; trait Even { fn is_even(self) -> bool; } // generic blanket impl impl&lt;T> Even for T where T: Rem&lt;Output = T> + PartialEq&lt;T> + Sized, u8: TryInto&lt;T>, &lt;u8 as TryInto&lt;T>>::Error: Debug, { fn is_even(self) -> bool { // these unwraps will never panic self % 2.try_into().unwrap() == 0.try_into().unwrap() } } #[test] // âœ… fn test_is_even() { assert!(2_i8.is_even()); assert!(4_u8.is_even()); assert!(6_i16.is_even()); // etc } Unlike default impls, which provide an impl, generic blanket impls provide the impl, so they are not overridable.
use std::fmt::Debug; use std::convert::TryInto; use std::ops::Rem; trait Even { fn is_even(self) -> bool; } impl&lt;T> Even for T where T: Rem&lt;Output = T> + PartialEq&lt;T> + Sized, u8: TryInto&lt;T>, &lt;u8 as TryInto&lt;T>>::Error: Debug, { fn is_even(self) -> bool { self % 2.try_into().unwrap() == 0.try_into().unwrap() } } impl Even for u8 { // âŒ fn is_even(self) -> bool { self % 2_u8 == 0_u8 } } Throws:
error[E0119]: conflicting implementations of trait `Even` for type `u8`: --> src/lib.rs:22:1 | 10 | / impl&lt;T> Even for T 11 | | where 12 | | T: Rem&lt;Output = T> + PartialEq&lt;T> + Sized, 13 | | u8: TryInto&lt;T>, ... | 19 | | } 20 | | } | |_- first implementation here 21 | 22 | impl Even for u8 { | ^^^^^^^^^^^^^^^^ conflicting implementation for `u8` These impls overlap, hence they conflict, hence Rust rejects the code to ensure trait coherence. Trait coherence is the property that there exists at most one impl of a trait for any given type. The rules Rust uses to enforce trait coherence, the implications of those rules, and workarounds for the implications are outside the scope of this article.
Subtraits &amp; Supertraits The &ldquo;sub&rdquo; in &ldquo;subtrait&rdquo; refers to subset and the &ldquo;super&rdquo; in &ldquo;supertrait&rdquo; refers to superset. If we have this trait declaration:
trait Subtrait: Supertrait {} All of the types which impl Subtrait are a subset of all the types which impl Supertrait, or to put it in opposite but equivalent terms: all the types which impl Supertrait are a superset of all the types which impl Subtrait.
Also, the above is just syntax sugar for:
trait Subtrait where Self: Supertrait {} It&rsquo;s a subtle yet important distinction to understand that the bound is on Self, i.e. the type impling Subtrait, and not on Subtrait itself. The latter would not make any sense, since trait bounds can only be applied to concrete types which can impl traits. Traits cannot impl other traits:
trait Supertrait { fn method(&amp;self) { println!("in supertrait"); } } trait Subtrait: Supertrait { // this looks like it might impl or // override Supertrait::method but it // does not fn method(&amp;self) { println!("in subtrait") } } struct SomeType; // adds Supertrait::method to SomeType impl Supertrait for SomeType {} // adds Subtrait::method to SomeType impl Subtrait for SomeType {} // both methods exist on SomeType simultaneously // neither overriding or shadowing the other fn main() { SomeType.method(); // âŒ ambiguous method call // must disambiguate using fully-qualified syntax &lt;SomeType as Supertrait>::method(&amp;st); // âœ… prints "in supertrait" &lt;SomeType as Subtrait>::method(&amp;st); // âœ… prints "in subtrait" } Furthermore, there are no rules for how a type must impl both a subtrait and a supertrait. It can use the methods from either in the impl of the other.
trait Supertrait { fn super_method(&amp;mut self); } trait Subtrait: Supertrait { fn sub_method(&amp;mut self); } struct CallSuperFromSub; impl Supertrait for CallSuperFromSub { fn super_method(&amp;mut self) { println!("in super"); } } impl Subtrait for CallSuperFromSub { fn sub_method(&amp;mut self) { println!("in sub"); self.super_method(); } } struct CallSubFromSuper; impl Supertrait for CallSubFromSuper { fn super_method(&amp;mut self) { println!("in super"); self.sub_method(); } } impl Subtrait for CallSubFromSuper { fn sub_method(&amp;mut self) { println!("in sub"); } } struct CallEachOther(bool); impl Supertrait for CallEachOther { fn super_method(&amp;mut self) { println!("in super"); if self.0 { self.0 = false; self.sub_method(); } } } impl Subtrait for CallEachOther { fn sub_method(&amp;mut self) { println!("in sub"); if self.0 { self.0 = false; self.super_method(); } } } fn main() { CallSuperFromSub.super_method(); // prints "in super" CallSuperFromSub.sub_method(); // prints "in sub", "in super" CallSubFromSuper.super_method(); // prints "in super", "in sub" CallSubFromSuper.sub_method(); // prints "in sub" CallEachOther(true).super_method(); // prints "in super", "in sub" CallEachOther(true).sub_method(); // prints "in sub", "in super" } Hopefully the examples above show that the relationship between subtraits and supertraits can be complex. Before introducing a mental model that neatly encapsulates all of that complexity let&rsquo;s quickly review and establish the mental model we use for understanding trait bounds on generic types:
fn function&lt;T: Clone>(t: T) { // impl } Without knowing anything about the impl of this function we could reasonably guess that t.clone() gets called at some point because when a generic type is bounded by a trait that strongly implies it has a dependency on the trait. The mental model for understanding the relationship between generic types and their trait bounds is a simple and intuitive one: generic types depend on their trait bounds.
Now let&rsquo;s look the trait declaration for Copy:
trait Copy: Clone {} The syntax above looks very similar to the syntax for applying a trait bound on a generic type and yet Copy doesn&rsquo;t depend on Clone at all. The mental model we developed earlier doesn&rsquo;t help us here. In my opinion, the most simple and elegant mental model for understanding the relationship between subtraits and supertraits is: subtraits refine their supertraits.
&ldquo;Refinement&rdquo; is intentionally kept somewhat vague because it can mean different things in different contexts:
a subtrait might make its supertrait&rsquo;s methods&rsquo; impls more specialized, faster, use less memory, e.g. Copy: Clone a subtrait might make additional guarantees about the supertrait&rsquo;s methods&rsquo; impls, e.g. Eq: PartialEq, Ord: PartialOrd, ExactSizeIterator: Iterator a subtrait might make the supertrait&rsquo;s methods more flexible or easier to call, e.g. FnMut: FnOnce, Fn: FnMut a subtrait might extend a supertrait and add new methods, e.g. DoubleEndedIterator: Iterator, ExactSizeIterator: Iterator Trait Objects Generics give us compile-time polymorphism where trait objects give us run-time polymorphism. We can use trait objects to allow functions to dynamically return different types at run-time:
fn example(condition: bool, vec: Vec&lt;i32>) -> Box&lt;dyn Iterator&lt;Item = i32>> { let iter = vec.into_iter(); if condition { // Has type: // Box&lt;Map&lt;IntoIter&lt;i32>, Fn(i32) -> i32>> // But is cast to: // Box&lt;dyn Iterator&lt;Item = i32>> Box::new(iter.map(|n| n * 2)) } else { // Has type: // Box&lt;Filter&lt;IntoIter&lt;i32>, Fn(&amp;i32) -> bool>> // But is cast to: // Box&lt;dyn Iterator&lt;Item = i32>> Box::new(iter.filter(|&amp;n| n >= 2)) } } Trait objects also allow us to store heterogeneous types in collections:
use std::f64::consts::PI; struct Circle { radius: f64, } struct Square { side: f64 } trait Shape { fn area(&amp;self) -> f64; } impl Shape for Circle { fn area(&amp;self) -> f64 { PI * self.radius * self.radius } } impl Shape for Square { fn area(&amp;self) -> f64 { self.side * self.side } } fn get_total_area(shapes: Vec&lt;Box&lt;dyn Shape>>) -> f64 { shapes.into_iter().map(|s| s.area()).sum() } fn example() { let shapes: Vec&lt;Box&lt;dyn Shape>> = vec![ Box::new(Circle { radius: 1.0 }), // Box&lt;Circle> cast to Box&lt;dyn Shape> Box::new(Square { side: 1.0 }), // Box&lt;Square> cast to Box&lt;dyn Shape> ]; assert_eq!(PI + 1.0, get_total_area(shapes)); // âœ… } Trait objects are unsized so they must always be behind a pointer. We can tell the difference between a concrete type and a trait object at the type level based on the presence of the dyn keyword within the type:
struct Struct; trait Trait {} // regular struct &amp;Struct Box&lt;Struct> Rc&lt;Struct> Arc&lt;Struct> // trait objects &amp;dyn Trait Box&lt;dyn Trait> Rc&lt;dyn Trait> Arc&lt;dyn Trait> Not all traits can be converted into trait objects. A trait is object-safe if it meets these requirements:
trait doesn&rsquo;t require Self: Sized all of the trait&rsquo;s methods are object-safe A trait method is object-safe if it meets these requirements:
method requires Self: Sized or method only uses a Self type in receiver position Understanding why the requirements are what they are is not relevant to the rest of this article, but if you&rsquo;re still curious it&rsquo;s covered in Sizedness in Rust.
Marker Traits Marker traits are traits that have no trait items. Their job is to &ldquo;mark&rdquo; the implementing type as having some property which is otherwise not possible to represent using the type system.
// Impling PartialEq for a type promises // that equality for the type has these properties: // - symmetry: a == b implies b == a, and // - transitivity: a == b &amp;&amp; b == c implies a == c // But DOES NOT promise this property: // - reflexivity: a == a trait PartialEq { fn eq(&amp;self, other: &amp;Self) -> bool; } // Eq has no trait items! The eq method is already // declared by PartialEq, but "impling" Eq // for a type promises this additional equality property: // - reflexivity: a == a trait Eq: PartialEq {} // f64 impls PartialEq but not Eq because NaN != NaN // i32 impls PartialEq &amp; Eq because there's no NaNs :) Auto Traits Auto traits are traits that get automatically implemented for a type if all of its members also impl the trait. What &ldquo;members&rdquo; means depends on the type, for example: fields of a struct, variants of an enum, elements of an array, items of a tuple, and so on.
All auto traits are marker traits but not all marker traits are auto traits. Auto traits must be marker traits so the compiler can provide an automatic default impl for them, which would not be possible if they had any trait items.
Examples of auto traits:
// implemented for types which are safe to send between threads unsafe auto trait Send {} // implemented for types whose references are safe to send between threads unsafe auto trait Sync {} Unsafe Traits Traits can be marked unsafe to indicate that impling the trait might require unsafe code. Both Send and Sync are marked unsafe because if they aren&rsquo;t automatically implemented for a type that means it must contains some non-Send or non-Sync member and we have to take extra care as the implementers to make sure there are no data races if we want to manually mark the type as Send and Sync.
// SomeType is not Send or Sync struct SomeType { not_send_or_sync: *const (), } // but if we're confident that our impl doesn't have any data // races we can explicitly mark it as Send and Sync using unsafe unsafe impl Send for SomeType {} unsafe impl Sync for SomeType {} Auto Traits Send &amp; Sync Prerequisites
Marker Traits Auto Traits Unsafe Traits unsafe auto trait Send {} unsafe auto trait Sync {} If a type is Send that means it&rsquo;s safe to send between threads. If a type is Sync that means it&rsquo;s safe to share references of it between threads. In more precise terms some type T is Sync if and only if &amp;T is Send.
Almost all types are Send and Sync. The only notable Send exception is Rc and the only notable Sync exceptions are Rc, Cell, RefCell. If we need a Send version of Rc we can use Arc. If we need a Sync version of Cell or RefCell we can Mutex or RwLock. Although if we&rsquo;re using the Mutex or RwLock to just wrap a primitive type it&rsquo;s often better to use the atomic primitive types provided by the standard library such as AtomicBool, AtomicI32, AtomicUsize, and so on.
That almost all types are Sync might be a surprise to some people, but yup, it&rsquo;s true even for types without any internal synchronization. This is possible thanks to Rust&rsquo;s strict borrowing rules.
We can pass many immutable references to the same data to many threads and we&rsquo;re guaranteed there are no data races because as long as any immutable references exist Rust statically guarantees the underlying data cannot be mutated:
use crossbeam::thread; fn main() { let mut greeting = String::from("Hello"); let greeting_ref = &amp;greeting; thread::scope(|scoped_thread| { // spawn 3 threads for n in 1..=3 { // greeting_ref copied into every thread scoped_thread.spawn(move |_| { println!("{} {}", greeting_ref, n); // prints "Hello {n}" }); } // line below could cause UB or data races but compiler rejects it greeting += " world"; // âŒ cannot mutate greeting while immutable refs exist }); // can mutate greeting after every thread has joined greeting += " world"; // âœ… println!("{}", greeting); // prints "Hello world" } Likewise we can pass a single mutable reference to some data to a single thread and we&rsquo;re guaranteed there will be no data races because Rust statically guarantees aliased mutable references cannot exist and the underlying data cannot be mutated through anything other than the single existing mutable reference:
use crossbeam::thread; fn main() { let mut greeting = String::from("Hello"); let greeting_ref = &amp;mut greeting; thread::scope(|scoped_thread| { // greeting_ref moved into thread scoped_thread.spawn(move |_| { *greeting_ref += " world"; println!("{}", greeting_ref); // prints "Hello world" }); // line below could cause UB or data races but compiler rejects it greeting += "!!!"; // âŒ cannot mutate greeting while mutable refs exist }); // can mutate greeting after the thread has joined greeting += "!!!"; // âœ… println!("{}", greeting); // prints "Hello world!!!" } This is why most types are Sync without requiring any explicit synchronization. In the event we need to simultaneously mutate some data T across multiple threads the compiler won&rsquo;t let us until we wrap the data in a Arc&lt;Mutex&lt;T>> or Arc&lt;RwLock&lt;T>> so the compiler enforces that explicit synchronization is used when it&rsquo;s needed.
Sized Prerequisites
Marker Traits Auto Traits If a type is Sized that means its size in bytes is known at compile-time and it&rsquo;s possible to put instances of the type on the stack.
Sizedness of types and its implications is a subtle yet huge topic that affects a lot of different aspects of the language. It&rsquo;s so important that I wrote an entire article on it called Sizedness in Rust which I highly recommend reading for anyone who would like to understand sizedness in-depth. I&rsquo;ll summarize a few key things which are relevant to this article.
All generic types get an implicit Sized bound. fn func&lt;T>(t: &amp;T) {} // example above desugared fn func&lt;T: Sized>(t: &amp;T) {} Since there&rsquo;s an implicit Sized bound on all generic types, if we want to opt-out of this implicit bound we need to use the special &ldquo;relaxed bound&rdquo; syntax ?Sized which currently only exists for the Sized trait: // now T can be unsized fn func&lt;T: ?Sized>(t: &amp;T) {} There&rsquo;s an implicit ?Sized bound on all traits. trait Trait {} // example above desugared trait Trait: ?Sized {} This is so that trait objects can impl the trait. Again, all of the nitty gritty details are in Sizedness in Rust.
General traits Default Prerequisites
Self Functions Derive Macros trait Default { fn default() -> Self; } It&rsquo;s possible to construct default values of Default types.
struct Color { r: u8, g: u8, b: u8, } impl Default for Color { // default color is black fn default() -> Self { Color { r: 0, g: 0, b: 0, } } } This is useful for quick prototyping but also in any instance where we just need an instance of a type and aren&rsquo;t picky about what it is:
fn main() { // just give me some color! let color = Color::default(); } This is also an option we may want to explicitly expose to the users of our functions:
struct Canvas; enum Shape { Circle, Rectangle, } impl Canvas { // let user optionally pass a color fn paint(&amp;mut self, shape: Shape, color: Option&lt;Color>) { // if no color is passed use the default color let color = color.unwrap_or_default(); // etc } } Default is also useful in generic contexts where we need to construct generic types:
fn guarantee_length&lt;T: Default>(mut vec: Vec&lt;T>, min_len: usize) -> Vec&lt;T> { for _ in 0..min_len.saturating_sub(vec.len()) { vec.push(T::default()); } vec } Another way we can take advantage of Default types is for partial initialization of structs using Rust&rsquo;s struct update syntax. We may have a new constructor for Color which takes every member as an argument:
impl Color { fn new(r: u8, g: u8, b: u8) -> Self { Color { r, g, b, } } } However we can also have convenience constructors that only accept a particular struct member each and fall back to the default values for the other struct members:
impl Color { fn red(r: u8) -> Self { Color { r, ..Color::default() } } fn green(g: u8) -> Self { Color { g, ..Color::default() } } fn blue(b: u8) -> Self { Color { b, ..Color::default() } } } There&rsquo;s also a Default derive macro for so we can write Color like this:
// default color is still black // because u8::default() == 0 #[derive(Default)] struct Color { r: u8, g: u8, b: u8 } Clone Prerequisites
Self Methods Default Impls Derive Macros trait Clone { fn clone(&amp;self) -> Self; // provided default impls fn clone_from(&amp;mut self, source: &amp;Self); } We can convert immutable references of Clone types into owned values, i.e. &amp;T -> T. Clone makes no promises about the efficiency of this conversion so it can be slow and expensive. To quickly impl Clone on a type we can use the derive macro:
#[derive(Clone)] struct SomeType { cloneable_member1: CloneableType1, cloneable_member2: CloneableType2, // etc } // macro generates impl below impl Clone for SomeType { fn clone(&amp;self) -> Self { SomeType { cloneable_member1: self.cloneable_member1.clone(), cloneable_member2: self.cloneable_member2.clone(), // etc } } } Clone can also be useful in constructing instances of a type within a generic context. Here&rsquo;s an example from the previous section except using Clone instead of Default:
fn guarantee_length&lt;T: Clone>(mut vec: Vec&lt;T>, min_len: usize, fill_with: &amp;T) -> Vec&lt;T> { for _ in 0..min_len.saturating_sub(vec.len()) { vec.push(fill_with.clone()); } vec } People also commonly use cloning as an escape hatch to avoid dealing with the borrow checker. Managing structs with references can be challenging, but we can turn the references into owned values by cloning them.
// oof, we gotta worry about lifetimes ğŸ˜Ÿ struct SomeStruct&lt;'a> { data: &amp;'a Vec&lt;u8>, } // now we're on easy street ğŸ˜ struct SomeStruct { data: Vec&lt;u8>, } If we&rsquo;re working on a program where performance is not the utmost concern then we don&rsquo;t need to sweat cloning data. Rust is a low-level language that exposes a lot of low-level details so it&rsquo;s easy to get caught up in premature optimizations instead of actually solving the problem at hand. For many programs the best order of priorities is usually to build for correctness first, elegance second, and performance third, and only focus on performance after the program has been profiled and the performance bottlenecks have been identified. This is good general advice to follow, and if it doesn&rsquo;t apply to your particular program then you would know.
Copy Prerequisites
Marker Traits Subtraits &amp; Supertraits Derive Macros trait Copy: Clone {} We copy Copy types, e.g. T -> T. Copy promises the copy operation will be a simple bitwise copy so it will be very fast and efficient. We cannot impl Copy ourselves, only the compiler can provide an impl, but we can tell it to do so by using the Copy derive macro, together with the Clone derive macro since Copy is a subtrait of Clone:
#[derive(Copy, Clone)] struct SomeType; Copy refines Clone. A clone may be slow and expensive but a copy is guaranteed to be fast and cheap, so a copy is just a fast clone. If a type impls Copy that makes the Clone impl trivial:
// this is what the derive macro generates impl&lt;T: Copy> Clone for T { // the clone method becomes just a copy fn clone(&amp;self) -> Self { *self } } Impling Copy for a type changes its behavior when it gets moved. By default all types have move semantics but once a type impls Copy it gets copy semantics. To explain the difference between the two let&rsquo;s examine these simple scenarios:
// a "move", src: !Copy let dest = src; // a "copy", src: Copy let dest = src; In both cases, dest = src performs a simple bitwise copy of src&rsquo;s contents and moves the result into dest, the only difference is that in the case of &ldquo;a move&rdquo; the borrow checker invalidates the src variable and makes sure it&rsquo;s not used anywhere else later and in the case of &ldquo;a copy&rdquo; src remains valid and usable.
In a nutshell: Copies are moves. Moves are copies. The only difference is how they&rsquo;re treated by the borrow checker.
For a more concrete example of a move, imagine src was a Vec&lt;i32> and its contents looked something like this:
{ data: *mut [i32], length: usize, capacity: usize } When we write dest = src we end up with:
src = { data: *mut [i32], length: usize, capacity: usize } dest = { data: *mut [i32], length: usize, capacity: usize } At this point both src and dest have aliased mutable references to the same data, which is a big no-no, so the borrow checker invalidates the src variable so it can&rsquo;t be used again without throwing a compile error.
For a more concrete example of a copy, imagine src was an Option&lt;i32> and its contents looked something like this:
{ is_valid: bool, data: i32 } Now when we write dest = src we end up with:
src = { is_valid: bool, data: i32 } dest = { is_valid: bool, data: i32 } These are both usable simultaneously! Hence Option&lt;i32> is Copy.
Although Copy could be an auto trait the Rust language designers decided it&rsquo;s simpler and safer for types to explicitly opt into copy semantics rather than silently inheriting copy semantics whenever the type is eligible, as the latter can cause surprising confusing behavior which often leads to bugs.
Any Prerequisites
Self Generic Blanket Impls Subtraits &amp; Supertraits Trait Objects trait Any: 'static { fn type_id(&amp;self) -> TypeId; } Rust&rsquo;s style of polymorphism is parametric, but if we&rsquo;re looking to use a more ad-hoc style of polymorphism similar to dynamically-typed languages then we can emulate that using the Any trait. We don&rsquo;t have to manually impl this trait for our types because that&rsquo;s already covered by this generic blanket impl:
impl&lt;T: 'static + ?Sized> Any for T { fn type_id(&amp;self) -> TypeId { TypeId::of::&lt;T>() } } The way we get a T out of a dyn Any is by using the downcast_ref::&lt;T>() and downcast_mut::&lt;T>() methods:
use std::any::Any; #[derive(Default)] struct Point { x: i32, y: i32, } impl Point { fn inc(&amp;mut self) { self.x += 1; self.y += 1; } } fn map_any(mut any: Box&lt;dyn Any>) -> Box&lt;dyn Any> { if let Some(num) = any.downcast_mut::&lt;i32>() { *num += 1; } else if let Some(string) = any.downcast_mut::&lt;String>() { *string += "!"; } else if let Some(point) = any.downcast_mut::&lt;Point>() { point.inc(); } any } fn main() { let mut vec: Vec&lt;Box&lt;dyn Any>> = vec![ Box::new(0), Box::new(String::from("a")), Box::new(Point::default()), ]; // vec = [0, "a", Point { x: 0, y: 0 }] vec = vec.into_iter().map(map_any).collect(); // vec = [1, "a!", Point { x: 1, y: 1 }] } This trait rarely needs to be used because on top of parametric polymorphism being superior to ad-hoc polymorphism in most scenarios the latter can also be emulated using enums which are more type-safe and require less indirection. For example, we could have written the above example like this:
#[derive(Default)] struct Point { x: i32, y: i32, } impl Point { fn inc(&amp;mut self) { self.x += 1; self.y += 1; } } enum Stuff { Integer(i32), String(String), Point(Point), } fn map_stuff(mut stuff: Stuff) -> Stuff { match &amp;mut stuff { Stuff::Integer(num) => *num += 1, Stuff::String(string) => *string += "!", Stuff::Point(point) => point.inc(), } stuff } fn main() { let mut vec = vec![ Stuff::Integer(0), Stuff::String(String::from("a")), Stuff::Point(Point::default()), ]; // vec = [0, "a", Point { x: 0, y: 0 }] vec = vec.into_iter().map(map_stuff).collect(); // vec = [1, "a!", Point { x: 1, y: 1 }] } Despite Any rarely being needed it can still be convenient to use sometimes, as we&rsquo;ll later see in the Error Handling section.
Formatting Traits We can serialize types into strings using the formatting macros in std::fmt, the most well-known of the bunch being println!. We can pass formatting parameters to the {} placeholders used within format strs which are then used to select which trait impl to use to serialize the placeholder&rsquo;s argument.
Trait Placeholder Description Display {} display representation Debug {:?} debug representation Octal {:o} octal representation LowerHex {:x} lowercase hex representation UpperHex {:X} uppercase hex representation Pointer {:p} memory address Binary {:b} binary representation LowerExp {:e} lowercase exponential representation UpperExp {:E} uppercase exponential representation Display &amp; ToString Prerequisites
Self Methods Generic Blanket Impls trait Display { fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_>) -> Result; } Display types can be serialized into Strings which are friendly to the end users of the program. Example impl for Point:
use std::fmt; #[derive(Default)] struct Point { x: i32, y: i32, } impl fmt::Display for Point { fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_>) -> fmt::Result { write!(f, "({}, {})", self.x, self.y) } } fn main() { println!("origin: {}", Point::default()); // prints "origin: (0, 0)" // get Point's Display representation as a String let stringified_point = format!("{}", Point::default()); assert_eq!("(0, 0)", stringified_point); // âœ… } Aside from using the format! macro to get a type&rsquo;s display representation as a String we can use the ToString trait:
trait ToString { fn to_string(&amp;self) -> String; } There&rsquo;s no need for us to impl this ourselves. In fact we can&rsquo;t, because of this generic blanket impl that automatically impls ToString for any type which impls Display:
impl&lt;T: Display + ?Sized> ToString for T; Using ToString with Point:
#[test] // âœ… fn display_point() { let origin = Point::default(); assert_eq!(format!("{}", origin), "(0, 0)"); } #[test] // âœ… fn point_to_string() { let origin = Point::default(); assert_eq!(origin.to_string(), "(0, 0)"); } #[test] // âœ… fn display_equals_to_string() { let origin = Point::default(); assert_eq!(format!("{}", origin), origin.to_string()); } Debug Prerequisites
Self Methods Derive Macros Display &amp; ToString trait Debug { fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_>) -> Result; } Debug has an identical signature to Display. The only difference is that the Debug impl is called when we use the {:?} formatting specifier. Debug can be derived:
use std::fmt; #[derive(Debug)] struct Point { x: i32, y: i32, } // derive macro generates impl below impl fmt::Debug for Point { fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_>) -> fmt::Result { f.debug_struct("Point") .field("x", &amp;self.x) .field("y", &amp;self.y) .finish() } } Impling Debug for a type also allows it to be used within the dbg! macro which is superior to println! for quick and dirty print logging. Some of its advantages:
dbg! prints to stderr instead of stdout so the debug logs are easy to separate from the actual stdout output of our program. dbg! prints the expression passed to it as well as the value the expression evaluated to. dbg! takes ownership of its arguments and returns them so you can use it within expressions: fn some_condition() -> bool { true } // no logging fn example() { if some_condition() { // some code } } // println! logging fn example_println() { // ğŸ¤¦ let result = some_condition(); println!("{}", result); // just prints "true" if result { // some code } } // dbg! logging fn example_dbg() { // ğŸ˜ if dbg!(some_condition()) { // prints "[src/main.rs:22] some_condition() = true" // some code } } The only downside is that dbg! isn&rsquo;t automatically stripped in release builds so we have to manually remove it from our code if we don&rsquo;t want to ship it in the final executable.
Operator Traits All operators in Rust are associated with traits. If we&rsquo;d like to impl operators for our types we have to impl the associated traits.
Trait(s) Category Operator(s) Description Eq, PartialEq comparison == equality Ord, PartialOrd comparison &lt;, >, &lt;=, >= comparison Add arithmetic + addition AddAssign arithmetic += addition assignment BitAnd arithmetic &amp; bitwise AND BitAndAssign arithmetic &amp;= bitwise assignment BitXor arithmetic ^ bitwise XOR BitXorAssign arithmetic ^= bitwise XOR assignment Div arithmetic / division DivAssign arithmetic /= division assignment Mul arithmetic * multiplication MulAssign arithmetic *= multiplication assignment Neg arithmetic - unary negation Not arithmetic ! unary logical negation Rem arithmetic % remainder RemAssign arithmetic %= remainder assignment Shl arithmetic &lt;&lt; left shift ShlAssign arithmetic &lt;&lt;= left shift assignment Shr arithmetic >> right shift ShrAssign arithmetic >>= right shift assignment Sub arithmetic - subtraction SubAssign arithmetic -= subtraction assignment Fn closure (...args) immutable closure invocation FnMut closure (...args) mutable closure invocation FnOnce closure (...args) one-time closure invocation Deref other * immutable dereference DerefMut other * mutable derenence Drop other - type destructor Index other [] immutable index IndexMut other [] mutable index RangeBounds other .. range Comparison Traits Trait(s) Category Operator(s) Description Eq, PartialEq comparison == equality Ord, PartialOrd comparison &lt;, >, &lt;=, >= comparison PartialEq &amp; Eq Prerequisites
Self Methods Generic Parameters Default Impls Generic Blanket Impls Marker Traits Subtraits &amp; Supertraits Sized trait PartialEq&lt;Rhs = Self> where Rhs: ?Sized, { fn eq(&amp;self, other: &amp;Rhs) -> bool; // provided default impls fn ne(&amp;self, other: &amp;Rhs) -> bool; } PartialEq&lt;Rhs> types can be checked for equality to Rhs types using the == operator.
All PartialEq&lt;Rhs> impls must ensure that equality is symmetric and transitive. That means for all a, b, and c:
a == b implies b == a (symmetry) a == b &amp;&amp; b == c implies a == c (transitivity) By default Rhs = Self because we almost always want to compare instances of a type to each other, and not to instances of different types. This also automatically guarantees our impl is symmetric and transitive.
struct Point { x: i32, y: i32 } // Rhs == Self == Point impl PartialEq for Point { // impl automatically symmetric &amp; transitive fn eq(&amp;self, other: &amp;Point) -> bool { self.x == other.x &amp;&amp; self.y == other.y } } If all the members of a type impl PartialEq then it can be derived:
#[derive(PartialEq)] struct Point { x: i32, y: i32 } #[derive(PartialEq)] enum Suit { Spade, Heart, Club, Diamond, } Once we impl PartialEq for our type we also get equality comparisons between references of our type for free thanks to these generic blanket impls:
// this impl only gives us: Point == Point #[derive(PartialEq)] struct Point { x: i32, y: i32 } // all of the generic blanket impls below // are provided by the standard library // this impl gives us: &amp;Point == &amp;Point impl&lt;A, B> PartialEq&lt;&amp;'_ B> for &amp;'_ A where A: PartialEq&lt;B> + ?Sized, B: ?Sized; // this impl gives us: &amp;mut Point == &amp;Point impl&lt;A, B> PartialEq&lt;&amp;'_ B> for &amp;'_ mut A where A: PartialEq&lt;B> + ?Sized, B: ?Sized; // this impl gives us: &amp;Point == &amp;mut Point impl&lt;A, B> PartialEq&lt;&amp;'_ mut B> for &amp;'_ A where A: PartialEq&lt;B> + ?Sized, B: ?Sized; // this impl gives us: &amp;mut Point == &amp;mut Point impl&lt;A, B> PartialEq&lt;&amp;'_ mut B> for &amp;'_ mut A where A: PartialEq&lt;B> + ?Sized, B: ?Sized; Since this trait is generic we can define equality between different types. The standard library leverages this to allow checking equality between the many string-like types such as String, &amp;str, PathBuf, &amp;Path, OsString, &amp;OsStr, and so on.
Generally, we should only impl equality between different types if they contain the same kind of data and the only difference between the types is how they represent the data or how they allow interacting with the data.
Here&rsquo;s a cute but bad example of how someone might be tempted to impl PartialEq to check equality between different types that don&rsquo;t meet the above criteria:
#[derive(PartialEq)] enum Suit { Spade, Club, Heart, Diamond, } #[derive(PartialEq)] enum Rank { Ace, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King, } #[derive(PartialEq)] struct Card { suit: Suit, rank: Rank, } // check equality of Card's suit impl PartialEq&lt;Suit> for Card { fn eq(&amp;self, other: &amp;Suit) -> bool { self.suit == *other } } // check equality of Card's rank impl PartialEq&lt;Rank> for Card { fn eq(&amp;self, other: &amp;Rank) -> bool { self.rank == *other } } fn main() { let AceOfSpades = Card { suit: Suit::Spade, rank: Rank::Ace, }; assert!(AceOfSpades == Suit::Spade); // âœ… assert!(AceOfSpades == Rank::Ace); // âœ… } It works and kinda makes sense. A card which is an Ace of Spades is both an Ace and a Spade, and if we&rsquo;re writing a library to handle playing cards it&rsquo;s reasonable that we&rsquo;d want to make it easy and convenient to individually check the suit and rank of a card. However, something&rsquo;s missing: symmetry! We can Card == Suit and Card == Rank but we cannot Suit == Card or Rank == Card so let&rsquo;s fix that:
// check equality of Card's suit impl PartialEq&lt;Suit> for Card { fn eq(&amp;self, other: &amp;Suit) -> bool { self.suit == *other } } // added for symmetry impl PartialEq&lt;Card> for Suit { fn eq(&amp;self, other: &amp;Card) -> bool { *self == other.suit } } // check equality of Card's rank impl PartialEq&lt;Rank> for Card { fn eq(&amp;self, other: &amp;Rank) -> bool { self.rank == *other } } // added for symmetry impl PartialEq&lt;Card> for Rank { fn eq(&amp;self, other: &amp;Card) -> bool { *self == other.rank } } We have symmetry! Great. Adding symmetry just broke transitivity! Oops. This is now possible:
fn main() { // Ace of Spades let a = Card { suit: Suit::Spade, rank: Rank::Ace, }; let b = Suit::Spade; // King of Spades let c = Card { suit: Suit::Spade, rank: Rank::King, }; assert!(a == b &amp;&amp; b == c); // âœ… assert!(a == c); // âŒ } A good example of impling PartialEq to check equality between different types would be a program that works with distances and uses different types to represent different units of measurement.
#[derive(PartialEq)] struct Foot(u32); #[derive(PartialEq)] struct Yard(u32); #[derive(PartialEq)] struct Mile(u32); impl PartialEq&lt;Mile> for Foot { fn eq(&amp;self, other: &amp;Mile) -> bool { self.0 == other.0 * 5280 } } impl PartialEq&lt;Foot> for Mile { fn eq(&amp;self, other: &amp;Foot) -> bool { self.0 * 5280 == other.0 } } impl PartialEq&lt;Mile> for Yard { fn eq(&amp;self, other: &amp;Mile) -> bool { self.0 == other.0 * 1760 } } impl PartialEq&lt;Yard> for Mile { fn eq(&amp;self, other: &amp;Yard) -> bool { self.0 * 1760 == other.0 } } impl PartialEq&lt;Foot> for Yard { fn eq(&amp;self, other: &amp;Foot) -> bool { self.0 * 3 == other.0 } } impl PartialEq&lt;Yard> for Foot { fn eq(&amp;self, other: &amp;Yard) -> bool { self.0 == other.0 * 3 } } fn main() { let a = Foot(5280); let b = Yard(1760); let c = Mile(1); // symmetry assert!(a == b &amp;&amp; b == a); // âœ… assert!(b == c &amp;&amp; c == b); // âœ… assert!(a == c &amp;&amp; c == a); // âœ… // transitivity assert!(a == b &amp;&amp; b == c &amp;&amp; a == c); // âœ… assert!(c == b &amp;&amp; b == a &amp;&amp; c == a); // âœ… } Eq is a marker trait and a subtrait of PartialEq&lt;Self>.
trait Eq: PartialEq&lt;Self> {} If we impl Eq for a type, on top of the symmetry &amp; transitivity properties required by PartialEq, we&rsquo;re also guaranteeing reflexivity, i.e. a == a for all a. In this sense Eq refines PartialEq because it represents a stricter version of equality. If all members of a type impl Eq then the Eq impl can be derived for the type.
Floats are PartialEq but not Eq because NaN != NaN. Almost all other PartialEq types are trivially Eq, unless of course if they contain floats.
Once a type impls PartialEq and Debug we can use it in the assert_eq! macro. We can also compare collections of PartialEq types.
#[derive(PartialEq, Debug)] struct Point { x: i32, y: i32, } fn example_assert(p1: Point, p2: Point) { assert_eq!(p1, p2); } fn example_compare_collections&lt;T: PartialEq>(vec1: Vec&lt;T>, vec2: Vec&lt;T>) { // if T: PartialEq this now works! if vec1 == vec2 { // some code } else { // other code } } Hash Prerequisites
Self Methods Generic Parameters Default Impls Derive Macros PartialEq &amp; Eq trait Hash { fn hash&lt;H: Hasher>(&amp;self, state: &amp;mut H); // provided default impls fn hash_slice&lt;H: Hasher>(data: &amp;[Self], state: &amp;mut H); } This trait is not associated with any operator, but the best time to talk about it is right after PartialEq &amp; Eq so here it is. Hash types can be hashed using a Hasher.
use std:#ï¸âƒ£:Hasher; use std:#ï¸âƒ£:Hash; struct Point { x: i32, y: i32, } impl Hash for Point { fn hash&lt;H: Hasher>(&amp;self, hasher: &amp;mut H) { hasher.write_i32(self.x); hasher.write_i32(self.y); } } There&rsquo;s a derive macro which generates the same impl as above:
#[derive(Hash)] struct Point { x: i32, y: i32, } If a type impls both Hash and Eq those impls must agree with each other such that for all a and b if a == b then a.hash() == b.hash(). So we should always use the derive macro to impl both or manually impl both, but not mix the two, otherwise we risk breaking the above invariant.
The main benefit of impling Eq and Hash for a type is that it allows us to store that type as keys in HashMaps and HashSets.
use std::collections::HashSet; // now our type can be stored // in HashSets and HashMaps! #[derive(PartialEq, Eq, Hash)] struct Point { x: i32, y: i32, } fn example_hashset() { let mut points = HashSet::new(); points.insert(Point { x: 0, y: 0 }); // âœ… } PartialOrd &amp; Ord Prerequisites
Self Methods Generic Parameters Default Impls Subtraits &amp; Supertraits Derive Macros Sized PartialEq &amp; Eq enum Ordering { Less, Equal, Greater, } trait PartialOrd&lt;Rhs = Self>: PartialEq&lt;Rhs> where Rhs: ?Sized, { fn partial_cmp(&amp;self, other: &amp;Rhs) -> Option&lt;Ordering>; // provided default impls fn lt(&amp;self, other: &amp;Rhs) -> bool; fn le(&amp;self, other: &amp;Rhs) -> bool; fn gt(&amp;self, other: &amp;Rhs) -> bool; fn ge(&amp;self, other: &amp;Rhs) -> bool; } PartialOrd&lt;Rhs> types can be compared to Rhs types using the &lt;, &lt;=, >, and >= operators.
All PartialOrd impls must ensure that comparisons are asymmetric and transitive. That means for all a, b, and c:
a &lt; b implies !(a > b) (asymmetry) a &lt; b &amp;&amp; b &lt; c implies a &lt; c (transitivity) PartialOrd is a subtrait of PartialEq and their impls must always agree with each other.
fn must_always_agree&lt;T: PartialOrd + PartialEq>(t1: T, t2: T) { assert_eq!(t1.partial_cmp(&amp;t2) == Some(Ordering::Equal), t1 == t2); } PartialOrd refines PartialEq in the sense that when comparing PartialEq types we can check if they are equal or not equal, but when comparing PartialOrd types we can check if they are equal or not equal, and if they are not equal we can check if they are unequal because the first item is less than or greater than the second item.
By default Rhs = Self because we almost always want to compare instances of a type to each other, and not to instances of different types. This also automatically guarantees our impl is symmetric and transitive.
use std::cmp::Ordering; #[derive(PartialEq, PartialOrd)] struct Point { x: i32, y: i32 } // Rhs == Self == Point impl PartialOrd for Point { // impl automatically symmetric &amp; transitive fn partial_cmp(&amp;self, other: &amp;Point) -> Option&lt;Ordering> { Some(match self.x.cmp(&amp;other.x) { Ordering::Equal => self.y.cmp(&amp;other.y), ordering => ordering, }) } } If all the members of a type impl PartialOrd then it can be derived:
#[derive(PartialEq, PartialOrd)] struct Point { x: i32, y: i32, } #[derive(PartialEq, PartialOrd)] enum Stoplight { Red, Yellow, Green, } The PartialOrd derive macro orders types based on the lexicographical order of their members:
// generates PartialOrd impl which orders // Points based on x member first and // y member second because that's the order // they appear in the source code #[derive(PartialOrd, PartialEq)] struct Point { x: i32, y: i32, } // generates DIFFERENT PartialOrd impl // which orders Points based on y member // first and x member second #[derive(PartialOrd, PartialEq)] struct Point { y: i32, x: i32, } Ord is a subtrait of Eq and PartialOrd&lt;Self>:
trait Ord: Eq + PartialOrd&lt;Self> { fn cmp(&amp;self, other: &amp;Self) -> Ordering; // provided default impls fn max(self, other: Self) -> Self; fn min(self, other: Self) -> Self; fn clamp(self, min: Self, max: Self) -> Self; } If we impl Ord for a type, on top of the asymmetry &amp; transitivity properties required by PartialOrd, we&rsquo;re also guaranteeing that the asymmetry is total, i.e. exactly one of a &lt; b, a == b or a > b is true for any given a and b. In this sense Ord refines Eq and PartialOrd because it represents a stricter version of comparisons. If a type impls Ord we can use that impl to trivially impl PartialOrd, PartialEq, and Eq:
use std::cmp::Ordering; // of course we can use the derive macros here #[derive(Ord, PartialOrd, Eq, PartialEq)] struct Point { x: i32, y: i32, } // note: as with PartialOrd, the Ord derive macro // orders a type based on the lexicographical order // of its members // but here's the impls if we wrote them out by hand impl Ord for Point { fn cmp(&amp;self, other: &amp;Self) -> Ordering { match self.x.cmp(&amp;self.y) { Ordering::Equal => self.y.cmp(&amp;self.y), ordering => ordering, } } } impl PartialOrd for Point { fn partial_cmp(&amp;self, other: &amp;Self) -> Option&lt;Ordering> { Some(self.cmp(other)) } } impl PartialEq for Point { fn eq(&amp;self, other: &amp;Self) -> bool { self.cmp(other) == Ordering::Equal } } impl Eq for Point {} Floats impl PartialOrd but not Ord because both NaN &lt; 0 == false and NaN >= 0 == false are simultaneously true. Almost all other PartialOrd types are trivially Ord, unless of course if they contain floats.
Once a type impls Ord we can store it in BTreeMaps and BTreeSets as well as easily sort it using the sort() method on slices and any types which deref to slices such as arrays, Vecs, and VecDeques.
use std::collections::BTreeSet; // now our type can be stored // in BTreeSets and BTreeMaps! #[derive(Ord, PartialOrd, PartialEq, Eq)] struct Point { x: i32, y: i32, } fn example_btreeset() { let mut points = BTreeSet::new(); points.insert(Point { x: 0, y: 0 }); // âœ… } // we can also .sort() Ord types in collections! fn example_sort&lt;T: Ord>(mut sortable: Vec&lt;T>) -> Vec&lt;T> { sortable.sort(); sortable } Arithmetic Traits Trait(s) Category Operator(s) Description Add arithmetic + addition AddAssign arithmetic += addition assignment BitAnd arithmetic &amp; bitwise AND BitAndAssign arithmetic &amp;= bitwise assignment BitXor arithmetic ^ bitwise XOR BitXorAssign arithmetic ^= bitwise XOR assignment Div arithmetic / division DivAssign arithmetic /= division assignment Mul arithmetic * multiplication MulAssign arithmetic *= multiplication assignment Neg arithmetic - unary negation Not arithmetic ! unary logical negation Rem arithmetic % remainder RemAssign arithmetic %= remainder assignment Shl arithmetic &lt;&lt; left shift ShlAssign arithmetic &lt;&lt;= left shift assignment Shr arithmetic >> right shift ShrAssign arithmetic >>= right shift assignment Sub arithmetic - subtraction SubAssign arithmetic -= subtraction assignment Going over all of these would be very redundant. Most of these only apply to number types anyway. We&rsquo;ll only go over Add and AddAssign since the + operator is commonly overloaded to do other stuff like adding items to collections or concatenating things together, that way we cover the most interesting ground and don&rsquo;t repeat ourselves.
Add &amp; AddAssign Prerequisites
Self Methods Associated Types Generic Parameters Generic Types vs Associated Types Derive Macros trait Add&lt;Rhs = Self> { type Output; fn add(self, rhs: Rhs) -> Self::Output; } Add&lt;Rhs, Output = T> types can be added to Rhs types and will produce T as output.
Example Add&lt;Point, Output = Point> impl for Point:
#[derive(Clone, Copy)] struct Point { x: i32, y: i32, } impl Add for Point { type Output = Point; fn add(self, rhs: Point) -> Point { Point { x: self.x + rhs.x, y: self.y + rhs.y, } } } fn main() { let p1 = Point { x: 1, y: 2 }; let p2 = Point { x: 3, y: 4 }; let p3 = p1 + p2; assert_eq!(p3.x, p1.x + p2.x); // âœ… assert_eq!(p3.y, p1.y + p2.y); // âœ… } But what if we only had references to Points? Can we still add them then? Let&rsquo;s try:
fn main() { let p1 = Point { x: 1, y: 2 }; let p2 = Point { x: 3, y: 4 }; let p3 = &amp;p1 + &amp;p2; // âŒ } Unfortunately not. The compiler throws:
error[E0369]: cannot add `&amp;Point` to `&amp;Point` --> src/main.rs:50:25 | 50 | let p3: Point = &amp;p1 + &amp;p2; | --- ^ --- &amp;Point | | | &amp;Point | = note: an implementation of `std::ops::Add` might be missing for `&amp;Point` Within Rust&rsquo;s type system, for some type T, the types T, &amp;T, and &amp;mut T are all treated as unique distinct types which means we have to provide trait impls for each of them separately. Let&rsquo;s define an Add impl for &amp;Point:
impl Add for &amp;Point { type Output = Point; fn add(self, rhs: &amp;Point) -> Point { Point { x: self.x + rhs.x, y: self.y + rhs.y, } } } fn main() { let p1 = Point { x: 1, y: 2 }; let p2 = Point { x: 3, y: 4 }; let p3 = &amp;p1 + &amp;p2; // âœ… assert_eq!(p3.x, p1.x + p2.x); // âœ… assert_eq!(p3.y, p1.y + p2.y); // âœ… } However, something still doesn&rsquo;t feel quite right. We have two separate impls of Add for Point and &amp;Point and they happen to do the same thing currently but there&rsquo;s no guarantee that they will in the future! For example, let&rsquo;s say we decide that when we add two Points together we want to create a Line containing those two Points instead of creating a new Point, we&rsquo;d update our Add impl like this:
use std::ops::Add; #[derive(Copy, Clone)] struct Point { x: i32, y: i32, } #[derive(Copy, Clone)] struct Line { start: Point, end: Point, } // we updated this impl impl Add for Point { type Output = Line; fn add(self, rhs: Point) -> Line { Line { start: self, end: rhs, } } } // but forgot to update this impl, uh oh! impl Add for &amp;Point { type Output = Point; fn add(self, rhs: &amp;Point) -> Point { Point { x: self.x + rhs.x, y: self.y + rhs.y, } } } fn main() { let p1 = Point { x: 1, y: 2 }; let p2 = Point { x: 3, y: 4 }; let line: Line = p1 + p2; // âœ… let p1 = Point { x: 1, y: 2 }; let p2 = Point { x: 3, y: 4 }; let line: Line = &amp;p1 + &amp;p2; // âŒ expected Line, found Point } Our current impl of Add for &amp;Point creates an unnecessary maintenance burden, we want the impl to match Point&rsquo;s impl without having to manually update it every time we change Point&rsquo;s impl. We&rsquo;d like to keep our code as DRY (Don&rsquo;t Repeat Yourself) as possible. Luckily this is achievable:
// updated, DRY impl impl Add for &amp;Point { type Output = &lt;Point as Add>::Output; fn add(self, rhs: &amp;Point) -> Self::Output { Point::add(*self, *rhs) } } fn main() { let p1 = Point { x: 1, y: 2 }; let p2 = Point { x: 3, y: 4 }; let line: Line = p1 + p2; // âœ… let p1 = Point { x: 1, y: 2 }; let p2 = Point { x: 3, y: 4 }; let line: Line = &amp;p1 + &amp;p2; // âœ… } AddAssign&lt;Rhs> types allow us to add + assign Rhs types to them. The trait declaration:
trait AddAssign&lt;Rhs = Self> { fn add_assign(&amp;mut self, rhs: Rhs); } Example impls for Point and &amp;Point:
use std::ops::AddAssign; #[derive(Copy, Clone)] struct Point { x: i32, y: i32 } impl AddAssign for Point { fn add_assign(&amp;mut self, rhs: Point) { self.x += rhs.x; self.y += rhs.y; } } impl AddAssign&lt;&amp;Point> for Point { fn add_assign(&amp;mut self, rhs: &amp;Point) { Point::add_assign(self, *rhs); } } fn main() { let mut p1 = Point { x: 1, y: 2 }; let p2 = Point { x: 3, y: 4 }; p1 += &amp;p2; p1 += p2; assert!(p1.x == 7 &amp;&amp; p1.y == 10); } Closure Traits Trait(s) Category Operator(s) Description Fn closure (...args) immutable closure invocation FnMut closure (...args) mutable closure invocation FnOnce closure (...args) one-time closure invocation FnOnce, FnMut, &amp; Fn Prerequisites
Self Methods Associated Types Generic Parameters Generic Types vs Associated Types Subtraits &amp; Supertraits trait FnOnce&lt;Args> { type Output; fn call_once(self, args: Args) -> Self::Output; } trait FnMut&lt;Args>: FnOnce&lt;Args> { fn call_mut(&amp;mut self, args: Args) -> Self::Output; } trait Fn&lt;Args>: FnMut&lt;Args> { fn call(&amp;self, args: Args) -> Self::Output; } Although these traits exist it&rsquo;s not possible to impl them for our own types in stable Rust. The only types we can create which impl these traits are closures. Depending on what the closure captures from its environment determines whether it impls FnOnce, FnMut, or Fn.
An FnOnce closure can only be called once because it consumes some value as part of its execution:
fn main() { let range = 0..10; let get_range_count = || range.count(); assert_eq!(get_range_count(), 10); // âœ… get_range_count(); // âŒ } The .count() method on iterators consumes the iterator so it can only be called once. Hence our closure can only be called once. Which is why when we try to call it a second time we get this error:
error[E0382]: use of moved value: `get_range_count` --> src/main.rs:5:5 | 4 | assert_eq!(get_range_count(), 10); | ----------------- `get_range_count` moved due to this call 5 | get_range_count(); | ^^^^^^^^^^^^^^^ value used here after move | note: closure cannot be invoked more than once because it moves the variable `range` out of its environment --> src/main.rs:3:30 | 3 | let get_range_count = || range.count(); | ^^^^^ note: this value implements `FnOnce`, which causes it to be moved when called --> src/main.rs:4:16 | 4 | assert_eq!(get_range_count(), 10); | ^^^^^^^^^^^^^^^ An FnMut closure can be called multiple times and can also mutate variables it has captured from its environment. We might say FnMut closures perform side-effects or are stateful. Here&rsquo;s an example of a closure that filters out all non-ascending values from an iterator by keeping track of the smallest value it has seen so far:
fn main() { let nums = vec![0, 4, 2, 8, 10, 7, 15, 18, 13]; let mut min = i32::MIN; let ascending = nums.into_iter().filter(|&amp;n| { if n &lt;= min { false } else { min = n; true } }).collect::&lt;Vec&lt;_>>(); assert_eq!(vec![0, 4, 8, 10, 15, 18], ascending); // âœ… } FnMut refines FnOnce in the sense that FnOnce requires taking ownership of its arguments and can only be called once, but FnMut requires only taking mutable references and can be called multiple times. FnMut can be used anywhere FnOnce can be used.
An Fn closure can be called multiple times and does not mutate any variables it has captured from its environment. We might say Fn closures have no side-effects or are stateless. Here&rsquo;s an example closure that filters out all values less than some stack variable it captures from its environment from an iterator:
fn main() { let nums = vec![0, 4, 2, 8, 10, 7, 15, 18, 13]; let min = 9; let greater_than_9 = nums.into_iter().filter(|&amp;n| n > min).collect::&lt;Vec&lt;_>>(); assert_eq!(vec![10, 15, 18, 13], greater_than_9); // âœ… } Fn refines FnMut in the sense that FnMut requires mutable references and can be called multiple times, but Fn only requires immutable references and can be called multiple times. Fn can be used anywhere FnMut can be used, which includes anywhere FnOnce can be used.
If a closure doesn&rsquo;t capture anything from its environment it&rsquo;s technically not a closure, but just an anonymously declared inline function, and can be casted to, used, and passed around as a regular function pointer, i.e. fn. Function pointers can be used anywhere Fn can be used, which includes anwhere FnMut and FnOnce can be used.
fn add_one(x: i32) -> i32 { x + 1 } fn main() { let mut fn_ptr: fn(i32) -> i32 = add_one; assert_eq!(fn_ptr(1), 2); // âœ… // capture-less closure cast to fn pointer fn_ptr = |x| x + 1; // same as add_one assert_eq!(fn_ptr(1), 2); // âœ… } Example of passing a regular function pointer in place of a closure:
fn main() { let nums = vec![-1, 1, -2, 2, -3, 3]; let absolutes: Vec&lt;i32> = nums.into_iter().map(i32::abs).collect(); assert_eq!(vec![1, 1, 2, 2, 3, 3], absolutes); // âœ… } Other Traits Trait(s) Category Operator(s) Description Deref other * immutable dereference DerefMut other * mutable derenence Drop other - type destructor Index other [] immutable index IndexMut other [] mutable index RangeBounds other .. range Deref &amp; DerefMut Prerequisites
Self Methods Associated Types Subtraits &amp; Supertraits Sized trait Deref { type Target: ?Sized; fn deref(&amp;self) -> &amp;Self::Target; } trait DerefMut: Deref { fn deref_mut(&amp;mut self) -> &amp;mut Self::Target; } Deref&lt;Target = T> types can dereferenced to T types using the dereference operator *. This has obvious use-cases for smart pointer types like Box and Rc. However, we rarely see the dereference operator explicitly used in Rust code, and that&rsquo;s because of a Rust feature called deref coercion.
Rust automatically dereferences types when they&rsquo;re being passed as function arguments, returned from a function, or used as part of a method call. This is the reason why we can pass &amp;String and &amp;Vec&lt;T> to functions expecting &amp;str and &amp;[T] because String impls Deref&lt;Target = str> and Vec&lt;T> impls Deref&lt;Target = [T]>.
Deref and DerefMut should only be implemented for smart pointer types. The most common way people attempt to misuse and abuse these traits is to try to shoehorn some kind of OOP-style data inheritance into Rust. This does not work. Rust is not OOP. Let&rsquo;s examine a few different situations where, how, and why it does not work. Let&rsquo;s start with this example:
use std::ops::Deref; struct Human { health_points: u32, } enum Weapon { Spear, Axe, Sword, } // a Soldier is just a Human with a Weapon struct Soldier { human: Human, weapon: Weapon, } impl Deref for Soldier { type Target = Human; fn deref(&amp;self) -> &amp;Human { &amp;self.human } } enum Mount { Horse, Donkey, Cow, } // a Knight is just a Soldier with a Mount struct Knight { soldier: Soldier, mount: Mount, } impl Deref for Knight { type Target = Soldier; fn deref(&amp;self) -> &amp;Soldier { &amp;self.soldier } } enum Spell { MagicMissile, FireBolt, ThornWhip, } // a Mage is just a Human who can cast Spells struct Mage { human: Human, spells: Vec&lt;Spell>, } impl Deref for Mage { type Target = Human; fn deref(&amp;self) -> &amp;Human { &amp;self.human } } enum Staff { Wooden, Metallic, Plastic, } // a Wizard is just a Mage with a Staff struct Wizard { mage: Mage, staff: Staff, } impl Deref for Wizard { type Target = Mage; fn deref(&amp;self) -> &amp;Mage { &amp;self.mage } } fn borrows_human(human: &amp;Human) {} fn borrows_soldier(soldier: &amp;Soldier) {} fn borrows_knight(knight: &amp;Knight) {} fn borrows_mage(mage: &amp;Mage) {} fn borrows_wizard(wizard: &amp;Wizard) {} fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) { // all types can be used as Humans borrows_human(&amp;human); borrows_human(&amp;soldier); borrows_human(&amp;knight); borrows_human(&amp;mage); borrows_human(&amp;wizard); // Knights can be used as Soldiers borrows_soldier(&amp;soldier); borrows_soldier(&amp;knight); // Wizards can be used as Mages borrows_mage(&amp;mage); borrows_mage(&amp;wizard); // Knights &amp; Wizards passed as themselves borrows_knight(&amp;knight); borrows_wizard(&amp;wizard); } So at first glance the above looks pretty good! However it quickly breaks down to scrutiny. First of all, deref coercion only works on references, so it doesn&rsquo;t work when we actually want to pass ownership:
fn takes_human(human: Human) {} fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) { // all types CANNOT be used as Humans takes_human(human); takes_human(soldier); // âŒ takes_human(knight); // âŒ takes_human(mage); // âŒ takes_human(wizard); // âŒ } Furthermore, deref coercion doesn&rsquo;t work in generic contexts. Let&rsquo;s say we impl some trait only on humans:
trait Rest { fn rest(&amp;self); } impl Rest for Human { fn rest(&amp;self) {} } fn take_rest&lt;T: Rest>(rester: &amp;T) { rester.rest() } fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) { // all types CANNOT be used as Rest types, only Human take_rest(&amp;human); take_rest(&amp;soldier); // âŒ take_rest(&amp;knight); // âŒ take_rest(&amp;mage); // âŒ take_rest(&amp;wizard); // âŒ } Also, although deref coercion works in a lot of places it doesn&rsquo;t work everywhere. It doesn&rsquo;t work on operands, even though operators are just syntax sugar for method calls. Let&rsquo;s say, to be cute, we wanted Mages to learn Spells using the += operator:
impl DerefMut for Wizard { fn deref_mut(&amp;mut self) -> &amp;mut Mage { &amp;mut self.mage } } impl AddAssign&lt;Spell> for Mage { fn add_assign(&amp;mut self, spell: Spell) { self.spells.push(spell); } } fn example(mut mage: Mage, mut wizard: Wizard, spell: Spell) { mage += spell; wizard += spell; // âŒ wizard not coerced to mage here wizard.add_assign(spell); // oof, we have to call it like this ğŸ¤¦ } In languages with OOP-style data inheritance the value of self within a method is always equal to the type which called the method but in the case of Rust the value of self is always equal to the type which implemented the method:
struct Human { profession: &amp;'static str, health_points: u32, } impl Human { // self will always be a Human here, even if we call it on a Soldier fn state_profession(&amp;self) { println!("I'm a {}!", self.profession); } } struct Soldier { profession: &amp;'static str, human: Human, weapon: Weapon, } fn example(soldier: &amp;Soldier) { assert_eq!("servant", soldier.human.profession); assert_eq!("spearman", soldier.profession); soldier.human.state_profession(); // prints "I'm a servant!" soldier.state_profession(); // still prints "I'm a servant!" ğŸ¤¦ } The above gotcha is especially damning when impling Deref or DerefMut on a newtype. Let&rsquo;s say we want to create a SortedVec type which is just a Vec but it&rsquo;s always in sorted order. Here&rsquo;s how we might do that:
struct SortedVec&lt;T: Ord>(Vec&lt;T>); impl&lt;T: Ord> SortedVec&lt;T> { fn new(mut vec: Vec&lt;T>) -> Self { vec.sort(); SortedVec(vec) } fn push(&amp;mut self, t: T) { self.0.push(t); self.0.sort(); } } Obviously we cannot impl DerefMut&lt;Target = Vec&lt;T>> here or anyone using SortedVec would be able to trivially break the sorted order. However, impling Deref&lt;Target = Vec&lt;T>> surely must be safe, right? Try to spot the bug in the program below:
use std::ops::Deref; struct SortedVec&lt;T: Ord>(Vec&lt;T>); impl&lt;T: Ord> SortedVec&lt;T> { fn new(mut vec: Vec&lt;T>) -> Self { vec.sort(); SortedVec(vec) } fn push(&amp;mut self, t: T) { self.0.push(t); self.0.sort(); } } impl&lt;T: Ord> Deref for SortedVec&lt;T> { type Target = Vec&lt;T>; fn deref(&amp;self) -> &amp;Vec&lt;T> { &amp;self.0 } } fn main() { let sorted = SortedVec::new(vec![2, 8, 6, 3]); sorted.push(1); let sortedClone = sorted.clone(); sortedClone.push(4); } We never implemented Clone for SortedVec so when we call the .clone() method the compiler is using deref coercion to resolve that method call on Vec and so it returns a Vec and not a SortedVec!
fn main() { let sorted: SortedVec&lt;i32> = SortedVec::new(vec![2, 8, 6, 3]); sorted.push(1); // still sorted // calling clone on SortedVec actually returns a Vec ğŸ¤¦ let sortedClone: Vec&lt;i32> = sorted.clone(); sortedClone.push(4); // sortedClone no longer sorted ğŸ’€ } Anyway, none of the above limitations, constraints, or gotchas are faults of Rust because Rust was never designed to be an OO language or to support any OOP patterns in the first place.
The main takeaway from this section is do not try to be cute or clever with Deref and DerefMut impls. They&rsquo;re really only appropriate for smart pointer types, which can only be implemented within the standard library for now as smart pointer types currently require unstable features and compiler magic to work. If we want functionality and behavior similar to Deref and DerefMut then what we&rsquo;re actually probably looking for is AsRef and AsMut which we&rsquo;ll get to later.
Index &amp; IndexMut Prerequisites
Self Methods Associated Types Generic Parameters Generic Types vs Associated Types Subtraits &amp; Supertraits Sized trait Index&lt;Idx: ?Sized> { type Output: ?Sized; fn index(&amp;self, index: Idx) -> &amp;Self::Output; } trait IndexMut&lt;Idx>: Index&lt;Idx> where Idx: ?Sized { fn index_mut(&amp;mut self, index: Idx) -> &amp;mut Self::Output; } We can index [] into Index&lt;T, Output = U> types with T values and the index operation will return &amp;U values. For syntax sugar, the compiler auto inserts a deref operator * in front of any value returned from an index operation:
fn main() { // Vec&lt;i32> impls Index&lt;usize, Output = i32> so // indexing Vec&lt;i32> should produce &amp;i32s and yet... let vec = vec![1, 2, 3, 4, 5]; let num_ref: &amp;i32 = vec[0]; // âŒ expected &amp;i32 found i32 // above line actually desugars to let num_ref: &amp;i32 = *vec[0]; // âŒ expected &amp;i32 found i32 // both of these alternatives work let num: i32 = vec[0]; // âœ… let num_ref = &amp;vec[0]; // âœ… } It&rsquo;s kinda confusing at first, because it seems like the Index trait does not follow its own method signature, but really it&rsquo;s just questionable syntax sugar.
Since Idx is a generic type the Index trait can be implemented many times for a given type, and in the case of Vec&lt;T> not only can we index into it using usize but we can also index into its using Range&lt;usize>s to get slices.
fn main() { let vec = vec![1, 2, 3, 4, 5]; assert_eq!(&amp;vec[..], &amp;[1, 2, 3, 4, 5]); // âœ… assert_eq!(&amp;vec[1..], &amp;[2, 3, 4, 5]); // âœ… assert_eq!(&amp;vec[..4], &amp;[1, 2, 3, 4]); // âœ… assert_eq!(&amp;vec[1..4], &amp;[2, 3, 4]); // âœ… } To show off how we might impl Index ourselves here&rsquo;s a fun example which shows how we can use a newtype and the Index trait to impl wrapping indexes and negative indexes on a Vec:
use std::ops::Index; struct WrappingIndex&lt;T>(Vec&lt;T>); impl&lt;T> Index&lt;usize> for WrappingIndex&lt;T> { type Output = T; fn index(&amp;self, index: usize) -> &amp;T { &amp;self.0[index % self.0.len()] } } impl&lt;T> Index&lt;i128> for WrappingIndex&lt;T> { type Output = T; fn index(&amp;self, index: i128) -> &amp;T { let self_len = self.0.len() as i128; let idx = (((index % self_len) + self_len) % self_len) as usize; &amp;self.0[idx] } } #[test] // âœ… fn indexes() { let wrapping_vec = WrappingIndex(vec![1, 2, 3]); assert_eq!(1, wrapping_vec[0_usize]); assert_eq!(2, wrapping_vec[1_usize]); assert_eq!(3, wrapping_vec[2_usize]); } #[test] // âœ… fn wrapping_indexes() { let wrapping_vec = WrappingIndex(vec![1, 2, 3]); assert_eq!(1, wrapping_vec[3_usize]); assert_eq!(2, wrapping_vec[4_usize]); assert_eq!(3, wrapping_vec[5_usize]); } #[test] // âœ… fn neg_indexes() { let wrapping_vec = WrappingIndex(vec![1, 2, 3]); assert_eq!(1, wrapping_vec[-3_i128]); assert_eq!(2, wrapping_vec[-2_i128]); assert_eq!(3, wrapping_vec[-1_i128]); } #[test] // âœ… fn wrapping_neg_indexes() { let wrapping_vec = WrappingIndex(vec![1, 2, 3]); assert_eq!(1, wrapping_vec[-6_i128]); assert_eq!(2, wrapping_vec[-5_i128]); assert_eq!(3, wrapping_vec[-4_i128]); } There&rsquo;s no requirement that the Idx type has to be a number type or a Range, it could be an enum! Here&rsquo;s an example using basketball positions to index into a basketball team to retrieve players on the team:
use std::ops::Index; enum BasketballPosition { PointGuard, ShootingGuard, Center, PowerForward, SmallForward, } struct BasketballPlayer { name: &amp;'static str, position: BasketballPosition, } struct BasketballTeam { point_guard: BasketballPlayer, shooting_guard: BasketballPlayer, center: BasketballPlayer, power_forward: BasketballPlayer, small_forward: BasketballPlayer, } impl Index&lt;BasketballPosition> for BasketballTeam { type Output = BasketballPlayer; fn index(&amp;self, position: BasketballPosition) -> &amp;BasketballPlayer { match position { BasketballPosition::PointGuard => &amp;self.point_guard, BasketballPosition::ShootingGuard => &amp;self.shooting_guard, BasketballPosition::Center => &amp;self.center, BasketballPosition::PowerForward => &amp;self.power_forward, BasketballPosition::SmallForward => &amp;self.small_forward, } } } Drop Prerequisites
Self Methods trait Drop { fn drop(&amp;mut self); } If a type impls Drop then drop will be called on the type when it goes out of scope but before it&rsquo;s destroyed. We will rarely need to impl this for our types but a good example of where it&rsquo;s useful is if a type holds on to some external resources which needs to be cleaned up when the type is destroyed.
There&rsquo;s a BufWriter type in the standard library that allows us to buffer writes to Write types. However, what if the BufWriter gets destroyed before the content in its buffer has been flushed to the underlying Write type? Thankfully that&rsquo;s not possible! The BufWriter impls the Drop trait so that flush is always called on it whenever it goes out of scope!
impl&lt;W: Write> Drop for BufWriter&lt;W> { fn drop(&amp;mut self) { self.flush_buf(); } } Also, Mutexs in Rust don&rsquo;t have unlock() methods because they don&rsquo;t need them! Calling lock() on a Mutex returns a MutexGuard which automatically unlocks the Mutex when it goes out of scope thanks to its Drop impl:
impl&lt;T: ?Sized> Drop for MutexGuard&lt;'_, T> { fn drop(&amp;mut self) { unsafe { self.lock.inner.raw_unlock(); } } } In general, if you&rsquo;re impling an abstraction over some resource that needs to be cleaned up after use then that&rsquo;s a great reason to make use of the Drop trait.
Conversion Traits From &amp; Into Prerequisites
Self Functions Methods Generic Parameters Generic Blanket Impls trait From&lt;T> { fn from(T) -> Self; } From&lt;T> types allow us to convert T into Self.
trait Into&lt;T> { fn into(self) -> T; } Into&lt;T> types allow us to convert Self into T.
These traits are two different sides of the same coin. We can only impl From&lt;T> for our types because the Into&lt;T> impl is automatically provided by this generic blanket impl:
impl&lt;T, U> Into&lt;U> for T where U: From&lt;T>, { fn into(self) -> U { U::from(self) } } The reason both traits exist is because it allows us to write trait bounds on generic types slightly differently:
fn function&lt;T>(t: T) where // these bounds are equivalent T: From&lt;i32>, i32: Into&lt;T> { // these examples are equivalent let example: T = T::from(0); let example: T = 0.into(); } There are no hard rules about when to use one or the other, so go with whatever makes the most sense for each situation. Now let&rsquo;s look at some example impls on Point:
struct Point { x: i32, y: i32, } impl From&lt;(i32, i32)> for Point { fn from((x, y): (i32, i32)) -> Self { Point { x, y } } } impl From&lt;[i32; 2]> for Point { fn from([x, y]: [i32; 2]) -> Self { Point { x, y } } } fn example() { // using From let origin = Point::from((0, 0)); let origin = Point::from([0, 0]); // using Into let origin: Point = (0, 0).into(); let origin: Point = [0, 0].into(); } The impl is not symmetric, so if we&rsquo;d like to convert Points into tuples and arrays we have to explicitly add those as well:
struct Point { x: i32, y: i32, } impl From&lt;(i32, i32)> for Point { fn from((x, y): (i32, i32)) -> Self { Point { x, y } } } impl From&lt;Point> for (i32, i32) { fn from(Point { x, y }: Point) -> Self { (x, y) } } impl From&lt;[i32; 2]> for Point { fn from([x, y]: [i32; 2]) -> Self { Point { x, y } } } impl From&lt;Point> for [i32; 2] { fn from(Point { x, y }: Point) -> Self { [x, y] } } fn example() { // from (i32, i32) into Point let point = Point::from((0, 0)); let point: Point = (0, 0).into(); // from Point into (i32, i32) let tuple = &lt;(i32, i32)>::from(point); let tuple: (i32, i32) = point.into(); // from [i32; 2] into Point let point = Point::from([0, 0]); let point: Point = [0, 0].into(); // from Point into [i32; 2] let array = &lt;[i32; 2]>::from(point); let array: [i32; 2] = point.into(); } A popular use of From&lt;T> is to trim down boilerplate code. Let&rsquo;s say we add a Triangle type to our program which contains three Points, here&rsquo;s some of the many ways we can construct it:
struct Point { x: i32, y: i32, } impl Point { fn new(x: i32, y: i32) -> Point { Point { x, y } } } impl From&lt;(i32, i32)> for Point { fn from((x, y): (i32, i32)) -> Point { Point { x, y } } } struct Triangle { p1: Point, p2: Point, p3: Point, } impl Triangle { fn new(p1: Point, p2: Point, p3: Point) -> Triangle { Triangle { p1, p2, p3 } } } impl&lt;P> From&lt;[P; 3]> for Triangle where P: Into&lt;Point> { fn from([p1, p2, p3]: [P; 3]) -> Triangle { Triangle { p1: p1.into(), p2: p2.into(), p3: p3.into(), } } } fn example() { // manual construction let triangle = Triangle { p1: Point { x: 0, y: 0, }, p2: Point { x: 1, y: 1, }, p3: Point { x: 2, y: 2, }, }; // using Point::new let triangle = Triangle { p1: Point::new(0, 0), p2: Point::new(1, 1), p3: Point::new(2, 2), }; // using From&lt;(i32, i32)> for Point let triangle = Triangle { p1: (0, 0).into(), p2: (1, 1).into(), p3: (2, 2).into(), }; // using Triangle::new + From&lt;(i32, i32)> for Point let triangle = Triangle::new( (0, 0).into(), (1, 1).into(), (2, 2).into(), ); // using From&lt;[Into&lt;Point>; 3]> for Triangle let triangle: Triangle = [ (0, 0), (1, 1), (2, 2), ].into(); } There are no rules for when, how, or why we should impl From&lt;T> for our types so it&rsquo;s up to us to use our best judgement for every situation.
One popular use of Into&lt;T> is to make functions which need owned values generic over whether they take owned or borrowed values:
struct Person { name: String, } impl Person { // accepts: // - String fn new1(name: String) -> Person { Person { name } } // accepts: // - String // - &amp;String // - &amp;str // - Box&lt;str> // - Cow&lt;'_, str> // - char // since all of the above types can be converted into String fn new2&lt;N: Into&lt;String>>(name: N) -> Person { Person { name: name.into() } } } Error Handling The best time to talk about error handling and the Error trait is after going over Display, Debug, Any, and From but before getting to TryFrom hence why the Error Handling section awkwardly bisects the Conversion Traits section.
Error Prerequisites
Self Methods Default Impls Generic Blanket Impls Subtraits &amp; Supertraits Trait Objects Display &amp; ToString Debug Any From &amp; Into trait Error: Debug + Display { // provided default impls fn source(&amp;self) -> Option&lt;&amp;(dyn Error + 'static)>; fn backtrace(&amp;self) -> Option&lt;&amp;Backtrace>; fn description(&amp;self) -> &amp;str; fn cause(&amp;self) -> Option&lt;&amp;dyn Error>; } In Rust errors are returned, not thrown. Let&rsquo;s look at some examples.
Since dividing integer types by zero panics if we wanted to make our program safer and more explicit we could impl a safe_div function which returns a Result instead like this:
use std::fmt; use std::error; #[derive(Debug, PartialEq)] struct DivByZero; impl fmt::Display for DivByZero { fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_>) -> fmt::Result { write!(f, "division by zero error") } } impl error::Error for DivByZero {} fn safe_div(numerator: i32, denominator: i32) -> Result&lt;i32, DivByZero> { if denominator == 0 { return Err(DivByZero); } Ok(numerator / denominator) } #[test] // âœ… fn test_safe_div() { assert_eq!(safe_div(8, 2), Ok(4)); assert_eq!(safe_div(5, 0), Err(DivByZero)); } Since errors are returned and not thrown they must be explicitly handled, and if the current function cannot handle an error it should propagate it up to the caller. The most idiomatic way to propagate errors is to use the ? operator, which is just syntax sugar for the now deprecated try! macro which simply does this:
macro_rules! try { ($expr:expr) => { match $expr { // if Ok just unwrap the value Ok(val) => val, // if Err map the err value using From and return Err(err) => { return Err(From::from(err)); } } }; } If we wanted to write a function which reads a file into a String we could write it like this, propagating the io::Errors using ? everywhere they can appear:
use std::io::Read; use std::path::Path; use std::io; use std::fs::File; fn read_file_to_string(path: &amp;Path) -> Result&lt;String, io::Error> { let mut file = File::open(path)?; // â¬†ï¸ io::Error let mut contents = String::new(); file.read_to_string(&amp;mut contents)?; // â¬†ï¸ io::Error Ok(contents) } But let&rsquo;s say the file we&rsquo;re reading is actually a list of numbers and we want to sum them together, we&rsquo;d update our function like this:
use std::io::Read; use std::path::Path; use std::io; use std::fs::File; fn sum_file(path: &amp;Path) -> Result&lt;i32, /* What to put here? */> { let mut file = File::open(path)?; // â¬†ï¸ io::Error let mut contents = String::new(); file.read_to_string(&amp;mut contents)?; // â¬†ï¸ io::Error let mut sum = 0; for line in contents.lines() { sum += line.parse::&lt;i32>()?; // â¬†ï¸ ParseIntError } Ok(sum) } But what&rsquo;s the error type of our Result now? It can return either an io::Error or a ParseIntError. We&rsquo;re going to look at three approaches for solving this problem, starting with the most quick &amp; dirty way and finishing with the most robust way.
The first approach is recognizing that all types which impl Error also impl Display so we can map all the errors to Strings and use String as our error type:
use std::fs::File; use std::io; use std::io::Read; use std::path::Path; fn sum_file(path: &amp;Path) -> Result&lt;i32, String> { let mut file = File::open(path) .map_err(|e| e.to_string())?; // â¬†ï¸ io::Error -> String let mut contents = String::new(); file.read_to_string(&amp;mut contents) .map_err(|e| e.to_string())?; // â¬†ï¸ io::Error -> String let mut sum = 0; for line in contents.lines() { sum += line.parse::&lt;i32>() .map_err(|e| e.to_string())?; // â¬†ï¸ ParseIntError -> String } Ok(sum) } The obvious downside of stringifying every error is that we throw away type information which makes it harder for the caller to handle the errors.
One nonobvious upside to the above approach is we can customize the strings to provide more context-specific information. For example, ParseIntError usually stringifies to "invalid digit found in string" which is very vague and doesn&rsquo;t mention what the invalid string is or what integer type it was trying to parse into. If we were debugging this problem that error message would almost be useless. However we can make it significantly better by providing all the context relevant information ourselves:
sum += line.parse::&lt;i32>() .map_err(|_| format!("failed to parse {} into i32", line))?; The second approach takes advantage of this generic blanket impl from the standard library:
impl&lt;E: error::Error> From&lt;E> for Box&lt;dyn error::Error>; Which means that any Error type can be implicitly converted into a Box&lt;dyn error::Error> by the ? operator, so we can set to error type to Box&lt;dyn error::Error> in the Result return type of any function which produces errors and the ? operator will do the rest of the work for us:
use std::fs::File; use std::io::Read; use std::path::Path; use std::error; fn sum_file(path: &amp;Path) -> Result&lt;i32, Box&lt;dyn error::Error>> { let mut file = File::open(path)?; // â¬†ï¸ io::Error -> Box&lt;dyn error::Error> let mut contents = String::new(); file.read_to_string(&amp;mut contents)?; // â¬†ï¸ io::Error -> Box&lt;dyn error::Error> let mut sum = 0; for line in contents.lines() { sum += line.parse::&lt;i32>()?; // â¬†ï¸ ParseIntError -> Box&lt;dyn error::Error> } Ok(sum) } While being more concise, this seems to suffer from the same downside of the previous approach by throwing away type information. This is mostly true, but if the caller is aware of the impl details of our function they can still handle the different errors types using the downcast_ref() method on error::Error which works the same as it does on dyn Any types:
fn handle_sum_file_errors(path: &amp;Path) { match sum_file(path) { Ok(sum) => println!("the sum is {}", sum), Err(err) => { if let Some(e) = err.downcast_ref::&lt;io::Error>() { // handle io::Error } else if let Some(e) = err.downcast_ref::&lt;ParseIntError>() { // handle ParseIntError } else { // we know sum_file can only return one of the // above errors so this branch is unreachable unreachable!(); } } } } The third approach, which is the most robust and type-safe way to aggregate these different errors would be to build our own custom error type using an enum:
use std::num::ParseIntError; use std::fs::File; use std::io; use std::io::Read; use std::path::Path; use std::error; use std::fmt; #[derive(Debug)] enum SumFileError { Io(io::Error), Parse(ParseIntError), } impl From&lt;io::Error> for SumFileError { fn from(err: io::Error) -> Self { SumFileError::Io(err) } } impl From&lt;ParseIntError> for SumFileError { fn from(err: ParseIntError) -> Self { SumFileError::Parse(err) } } impl fmt::Display for SumFileError { fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_>) -> fmt::Result { match self { SumFileError::Io(err) => write!(f, "sum file error: {}", err), SumFileError::Parse(err) => write!(f, "sum file error: {}", err), } } } impl error::Error for SumFileError { // the default impl for this method always returns None // but we can now override it to make it way more useful! fn source(&amp;self) -> Option&lt;&amp;(dyn error::Error + 'static)> { Some(match self { SumFileError::Io(err) => err, SumFileError::Parse(err) => err, }) } } fn sum_file(path: &amp;Path) -> Result&lt;i32, SumFileError> { let mut file = File::open(path)?; // â¬†ï¸ io::Error -> SumFileError let mut contents = String::new(); file.read_to_string(&amp;mut contents)?; // â¬†ï¸ io::Error -> SumFileError let mut sum = 0; for line in contents.lines() { sum += line.parse::&lt;i32>()?; // â¬†ï¸ ParseIntError -> SumFileError } Ok(sum) } fn handle_sum_file_errors(path: &amp;Path) { match sum_file(path) { Ok(sum) => println!("the sum is {}", sum), Err(SumFileError::Io(err)) => { // handle io::Error }, Err(SumFileError::Parse(err)) => { // handle ParseIntError }, } } Conversion Traits Continued TryFrom &amp; TryInto Prerequisites
Self Functions Methods Associated Types Generic Parameters Generic Types vs Associated Types Generic Blanket Impls From &amp; Into Error TryFrom and TryInto are the fallible versions of From and Into.
trait TryFrom&lt;T> { type Error; fn try_from(value: T) -> Result&lt;Self, Self::Error>; } trait TryInto&lt;T> { type Error; fn try_into(self) -> Result&lt;T, Self::Error>; } Similarly to Into we cannot impl TryInto because its impl is provided by this generic blanket impl:
impl&lt;T, U> TryInto&lt;U> for T where U: TryFrom&lt;T>, { type Error = U::Error; fn try_into(self) -> Result&lt;U, U::Error> { U::try_from(self) } } Let&rsquo;s say that in the context of our program it doesn&rsquo;t make sense for Points to have x and y values that are less than -1000 or greater than 1000. This is how we&rsquo;d rewrite our earlier From impls using TryFrom to signal to the users of our type that this conversion can now fail:
use std::convert::TryFrom; use std::error; use std::fmt; struct Point { x: i32, y: i32, } #[derive(Debug)] struct OutOfBounds; impl fmt::Display for OutOfBounds { fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_>) -> fmt::Result { write!(f, "out of bounds") } } impl error::Error for OutOfBounds {} // now fallible impl TryFrom&lt;(i32, i32)> for Point { type Error = OutOfBounds; fn try_from((x, y): (i32, i32)) -> Result&lt;Point, OutOfBounds> { if x.abs() > 1000 || y.abs() > 1000 { return Err(OutOfBounds); } Ok(Point { x, y }) } } // still infallible impl From&lt;Point> for (i32, i32) { fn from(Point { x, y }: Point) -> Self { (x, y) } } And here&rsquo;s the refactored TryFrom&lt;[TryInto&lt;Point>; 3]> impl for Triangle:
use std::convert::{TryFrom, TryInto}; use std::error; use std::fmt; struct Point { x: i32, y: i32, } #[derive(Debug)] struct OutOfBounds; impl fmt::Display for OutOfBounds { fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_>) -> fmt::Result { write!(f, "out of bounds") } } impl error::Error for OutOfBounds {} impl TryFrom&lt;(i32, i32)> for Point { type Error = OutOfBounds; fn try_from((x, y): (i32, i32)) -> Result&lt;Self, Self::Error> { if x.abs() > 1000 || y.abs() > 1000 { return Err(OutOfBounds); } Ok(Point { x, y }) } } struct Triangle { p1: Point, p2: Point, p3: Point, } impl&lt;P> TryFrom&lt;[P; 3]> for Triangle where P: TryInto&lt;Point>, { type Error = P::Error; fn try_from([p1, p2, p3]: [P; 3]) -> Result&lt;Self, Self::Error> { Ok(Triangle { p1: p1.try_into()?, p2: p2.try_into()?, p3: p3.try_into()?, }) } } fn example() -> Result&lt;Triangle, OutOfBounds> { let t: Triangle = [(0, 0), (1, 1), (2, 2)].try_into()?; Ok(t) } FromStr Prerequisites
Self Functions Associated Types Error TryFrom &amp; TryInto trait FromStr { type Err; fn from_str(s: &amp;str) -> Result&lt;Self, Self::Err>; } FromStr types allow performing a fallible conversion from &amp;str into Self. The idiomatic way to use FromStr is to call the .parse() method on &amp;strs:
use std::str::FromStr; fn example&lt;T: FromStr>(s: &amp;'static str) { // these are all equivalent let t: Result&lt;T, _> = FromStr::from_str(s); let t = T::from_str(s); let t: Result&lt;T, _> = s.parse(); let t = s.parse::&lt;T>(); // most idiomatic } Example impl for Point:
use std::error; use std::fmt; use std::iter::Enumerate; use std::num::ParseIntError; use std::str::{Chars, FromStr}; #[derive(Debug, Eq, PartialEq)] struct Point { x: i32, y: i32, } impl Point { fn new(x: i32, y: i32) -> Self { Point { x, y } } } #[derive(Debug, PartialEq)] struct ParsePointError; impl fmt::Display for ParsePointError { fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_>) -> fmt::Result { write!(f, "failed to parse point") } } impl From&lt;ParseIntError> for ParsePointError { fn from(_e: ParseIntError) -> Self { ParsePointError } } impl error::Error for ParsePointError {} impl FromStr for Point { type Err = ParsePointError; fn from_str(s: &amp;str) -> Result&lt;Self, Self::Err> { let is_num = |(_, c): &amp;(usize, char)| matches!(c, '0'..='9' | '-'); let isnt_num = |t: &amp;(_, _)| !is_num(t); let get_num = |char_idxs: &amp;mut Enumerate&lt;Chars&lt;'_>>| -> Result&lt;(usize, usize), ParsePointError> { let (start, _) = char_idxs .skip_while(isnt_num) .next() .ok_or(ParsePointError)?; let (end, _) = char_idxs .skip_while(is_num) .next() .ok_or(ParsePointError)?; Ok((start, end)) }; let mut char_idxs = s.chars().enumerate(); let (x_start, x_end) = get_num(&amp;mut char_idxs)?; let (y_start, y_end) = get_num(&amp;mut char_idxs)?; let x = s[x_start..x_end].parse::&lt;i32>()?; let y = s[y_start..y_end].parse::&lt;i32>()?; Ok(Point { x, y }) } } #[test] // âœ… fn pos_x_y() { let p = "(4, 5)".parse::&lt;Point>(); assert_eq!(p, Ok(Point::new(4, 5))); } #[test] // âœ… fn neg_x_y() { let p = "(-6, -2)".parse::&lt;Point>(); assert_eq!(p, Ok(Point::new(-6, -2))); } #[test] // âœ… fn not_a_point() { let p = "not a point".parse::&lt;Point>(); assert_eq!(p, Err(ParsePointError)); } FromStr has the same signature as TryFrom&lt;&amp;str>. It doesn&rsquo;t matter which one we impl for a type first as long as we forward the impl to the other one. Here&rsquo;s a TryFrom&lt;&amp;str> impl for Point assuming it already has a FromStr impl:
impl TryFrom&lt;&amp;str> for Point { type Error = &lt;Point as FromStr>::Err; fn try_from(s: &amp;str) -> Result&lt;Point, Self::Error> { &lt;Point as FromStr>::from_str(s) } } AsRef &amp; AsMut Prerequisites
Self Methods Sized Generic Parameters Sized Deref &amp; DerefMut trait AsRef&lt;T: ?Sized> { fn as_ref(&amp;self) -> &amp;T; } trait AsMut&lt;T: ?Sized> { fn as_mut(&amp;mut self) -> &amp;mut T; } AsRef is for cheap reference to reference conversions. However, one of the most common ways it&rsquo;s used is to make functions generic over whether they take ownership or not:
// accepts: // - &amp;str // - &amp;String fn takes_str(s: &amp;str) { // use &amp;str } // accepts: // - &amp;str // - &amp;String // - String fn takes_asref_str&lt;S: AsRef&lt;str>>(s: S) { let s: &amp;str = s.as_ref(); // use &amp;str } fn example(slice: &amp;str, borrow: &amp;String, owned: String) { takes_str(slice); takes_str(borrow); takes_str(owned); // âŒ takes_asref_str(slice); takes_asref_str(borrow); takes_asref_str(owned); // âœ… } The other most common use-case is returning a reference to inner private data wrapped by a type which protects some invariant. A good example from the standard library is String which is just a wrapper around Vec&lt;u8>:
struct String { vec: Vec&lt;u8>, } This inner Vec cannot be made public because if it was people could mutate any byte and break the String&rsquo;s valid UTF-8 encoding. However, it&rsquo;s safe to expose an immutable read-only reference to the inner byte array, hence this impl:
impl AsRef&lt;[u8]> for String; Generally, it often only makes sense to impl AsRef for a type if it wraps some other type to either provide additional functionality around the inner type or protect some invariant on the inner type.
Let&rsquo;s examine a example of bad AsRef impls:
struct User { name: String, age: u32, } impl AsRef&lt;String> for User { fn as_ref(&amp;self) -> &amp;String { &amp;self.name } } impl AsRef&lt;u32> for User { fn as_ref(&amp;self) -> &amp;u32 { &amp;self.age } } This works and kinda makes sense at first, but quickly falls apart if we add more members to User:
struct User { name: String, email: String, age: u32, height: u32, } impl AsRef&lt;String> for User { fn as_ref(&amp;self) -> &amp;String { // uh, do we return name or email here? } } impl AsRef&lt;u32> for User { fn as_ref(&amp;self) -> &amp;u32 { // uh, do we return age or height here? } } A User is composed of Strings and u32s but it&rsquo;s not really the same thing as a String or a u32. Even if we had much more specific types:
struct User { name: Name, email: Email, age: Age, height: Height, } It wouldn&rsquo;t make much sense to impl AsRef for any of those because AsRef is for cheap reference to reference conversions between semantically equivalent things, and Name, Email, Age, and Height by themselves are not the same thing as a User.
A good example where we would impl AsRef would be if we introduced a new type Moderator that just wrapped a User and added some moderation specific privileges:
struct User { name: String, age: u32, } // unfortunately the standard library cannot provide // a generic blanket impl to save us from this boilerplate impl AsRef&lt;User> for User { fn as_ref(&amp;self) -> &amp;User { self } } enum Privilege { BanUsers, EditPosts, DeletePosts, } // although Moderators have some special // privileges they are still regular Users // and should be able to do all the same stuff struct Moderator { user: User, privileges: Vec&lt;Privilege> } impl AsRef&lt;Moderator> for Moderator { fn as_ref(&amp;self) -> &amp;Moderator { self } } impl AsRef&lt;User> for Moderator { fn as_ref(&amp;self) -> &amp;User { &amp;self.user } } // this should be callable with Users // and Moderators (who are also Users) fn create_post&lt;U: AsRef&lt;User>>(u: U) { let user = u.as_ref(); // etc } fn example(user: User, moderator: Moderator) { create_post(&amp;user); create_post(&amp;moderator); // âœ… } This works because Moderators are just Users. Here&rsquo;s the example from the Deref section except using AsRef instead:
use std::convert::AsRef; struct Human { health_points: u32, } impl AsRef&lt;Human> for Human { fn as_ref(&amp;self) -> &amp;Human { self } } enum Weapon { Spear, Axe, Sword, } // a Soldier is just a Human with a Weapon struct Soldier { human: Human, weapon: Weapon, } impl AsRef&lt;Soldier> for Soldier { fn as_ref(&amp;self) -> &amp;Soldier { self } } impl AsRef&lt;Human> for Soldier { fn as_ref(&amp;self) -> &amp;Human { &amp;self.human } } enum Mount { Horse, Donkey, Cow, } // a Knight is just a Soldier with a Mount struct Knight { soldier: Soldier, mount: Mount, } impl AsRef&lt;Knight> for Knight { fn as_ref(&amp;self) -> &amp;Knight { self } } impl AsRef&lt;Soldier> for Knight { fn as_ref(&amp;self) -> &amp;Soldier { &amp;self.soldier } } impl AsRef&lt;Human> for Knight { fn as_ref(&amp;self) -> &amp;Human { &amp;self.soldier.human } } enum Spell { MagicMissile, FireBolt, ThornWhip, } // a Mage is just a Human who can cast Spells struct Mage { human: Human, spells: Vec&lt;Spell>, } impl AsRef&lt;Mage> for Mage { fn as_ref(&amp;self) -> &amp;Mage { self } } impl AsRef&lt;Human> for Mage { fn as_ref(&amp;self) -> &amp;Human { &amp;self.human } } enum Staff { Wooden, Metallic, Plastic, } // a Wizard is just a Mage with a Staff struct Wizard { mage: Mage, staff: Staff, } impl AsRef&lt;Wizard> for Wizard { fn as_ref(&amp;self) -> &amp;Wizard { self } } impl AsRef&lt;Mage> for Wizard { fn as_ref(&amp;self) -> &amp;Mage { &amp;self.mage } } impl AsRef&lt;Human> for Wizard { fn as_ref(&amp;self) -> &amp;Human { &amp;self.mage.human } } fn borrows_human&lt;H: AsRef&lt;Human>>(human: H) {} fn borrows_soldier&lt;S: AsRef&lt;Soldier>>(soldier: S) {} fn borrows_knight&lt;K: AsRef&lt;Knight>>(knight: K) {} fn borrows_mage&lt;M: AsRef&lt;Mage>>(mage: M) {} fn borrows_wizard&lt;W: AsRef&lt;Wizard>>(wizard: W) {} fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) { // all types can be used as Humans borrows_human(&amp;human); borrows_human(&amp;soldier); borrows_human(&amp;knight); borrows_human(&amp;mage); borrows_human(&amp;wizard); // Knights can be used as Soldiers borrows_soldier(&amp;soldier); borrows_soldier(&amp;knight); // Wizards can be used as Mages borrows_mage(&amp;mage); borrows_mage(&amp;wizard); // Knights &amp; Wizards passed as themselves borrows_knight(&amp;knight); borrows_wizard(&amp;wizard); } Deref didn&rsquo;t work in the prior version of the example above because deref coercion is an implicit conversion between types which leaves room for people to mistakenly formulate the wrong ideas and expectations for how it will behave. AsRef works above because it makes the conversion between types explicit and there&rsquo;s no room leftover to develop any wrong ideas or expectations.
Borrow &amp; BorrowMut Prerequisites
Self Methods Generic Parameters Subtraits &amp; Supertraits Sized AsRef &amp; AsMut PartialEq &amp; Eq Hash PartialOrd &amp; Ord trait Borrow&lt;Borrowed> where Borrowed: ?Sized, { fn borrow(&amp;self) -> &amp;Borrowed; } trait BorrowMut&lt;Borrowed>: Borrow&lt;Borrowed> where Borrowed: ?Sized, { fn borrow_mut(&amp;mut self) -> &amp;mut Borrowed; } These traits were invented to solve the very specific problem of looking up String keys in HashSets, HashMaps, BTreeSets, and BTreeMaps using &amp;str values.
We can view Borrow&lt;T> and BorrowMut&lt;T> as stricter versions of AsRef&lt;T> and AsMut&lt;T>, where the returned reference &amp;T has equivalent Eq, Hash, and Ord impls to Self. This is more easily explained with a commented example:
use std::borrow::Borrow; use std:#ï¸âƒ£:Hasher; use std::collections::hash_map::DefaultHasher; use std:#ï¸âƒ£:Hash; fn get_hash&lt;T: Hash>(t: T) -> u64 { let mut hasher = DefaultHasher::new(); t.hash(&amp;mut hasher); hasher.finish() } fn asref_example&lt;Owned, Ref>(owned1: Owned, owned2: Owned) where Owned: Eq + Ord + Hash + AsRef&lt;Ref>, Ref: Eq + Ord + Hash { let ref1: &amp;Ref = owned1.as_ref(); let ref2: &amp;Ref = owned2.as_ref(); // refs aren't required to be equal if owned types are equal assert_eq!(owned1 == owned2, ref1 == ref2); // âŒ let owned1_hash = get_hash(&amp;owned1); let owned2_hash = get_hash(&amp;owned2); let ref1_hash = get_hash(&amp;ref1); let ref2_hash = get_hash(&amp;ref2); // ref hashes aren't required to be equal if owned type hashes are equal assert_eq!(owned1_hash == owned2_hash, ref1_hash == ref2_hash); // âŒ // ref comparisons aren't required to match owned type comparisons assert_eq!(owned1.cmp(&amp;owned2), ref1.cmp(&amp;ref2)); // âŒ } fn borrow_example&lt;Owned, Borrowed>(owned1: Owned, owned2: Owned) where Owned: Eq + Ord + Hash + Borrow&lt;Borrowed>, Borrowed: Eq + Ord + Hash { let borrow1: &amp;Borrowed = owned1.borrow(); let borrow2: &amp;Borrowed = owned2.borrow(); // borrows are required to be equal if owned types are equal assert_eq!(owned1 == owned2, borrow1 == borrow2); // âœ… let owned1_hash = get_hash(&amp;owned1); let owned2_hash = get_hash(&amp;owned2); let borrow1_hash = get_hash(&amp;borrow1); let borrow2_hash = get_hash(&amp;borrow2); // borrow hashes are required to be equal if owned type hashes are equal assert_eq!(owned1_hash == owned2_hash, borrow1_hash == borrow2_hash); // âœ… // borrow comparisons are required to match owned type comparisons assert_eq!(owned1.cmp(&amp;owned2), borrow1.cmp(&amp;borrow2)); // âœ… } It&rsquo;s good to be aware of these traits and understand why they exist since it helps demystify some of the methods on HashSet, HashMap, BTreeSet, and BTreeMap but it&rsquo;s very rare that we would ever need to impl these traits for any of our types because it&rsquo;s very rare that we would ever need create a pair of types where one is the &ldquo;borrowed&rdquo; version of the other in the first place. If we have some T then &amp;T will get the job done 99.99% of the time, and T: Borrow&lt;T> is already implemented for all T because of a generic blanket impl, so we don&rsquo;t need to manually impl it and we don&rsquo;t need to create some U such that T: Borrow&lt;U>.
ToOwned Prerequisites
Self Methods Default Impls Clone Borrow &amp; BorrowMut trait ToOwned { type Owned: Borrow&lt;Self>; fn to_owned(&amp;self) -> Self::Owned; // provided default impls fn clone_into(&amp;self, target: &amp;mut Self::Owned); } ToOwned is a more generic version of Clone. Clone allows us to take a &amp;T and turn it into an T but ToOwned allows us to take a &amp;Borrowed and turn it into a Owned where Owned: Borrow&lt;Borrowed>.
In other words, we can&rsquo;t &ldquo;clone&rdquo; a &amp;str into a String, or a &amp;Path into a PathBuf, or an &amp;OsStr into an OsString, since the clone method signature doesn&rsquo;t support this kind of cross-type cloning, and that&rsquo;s what ToOwned was made for.
For similar reasons as Borrow and BorrowMut, it&rsquo;s good to be aware of this trait and understand why it exists but it&rsquo;s very rare we&rsquo;ll ever need to impl it for any of our types.
Iteration Traits Iterator Prerequisites
Self Methods Associated Types Default Impls trait Iterator { type Item; fn next(&amp;mut self) -> Option&lt;Self::Item>; // provided default impls fn size_hint(&amp;self) -> (usize, Option&lt;usize>); fn count(self) -> usize; fn last(self) -> Option&lt;Self::Item>; fn advance_by(&amp;mut self, n: usize) -> Result&lt;(), usize>; fn nth(&amp;mut self, n: usize) -> Option&lt;Self::Item>; fn step_by(self, step: usize) -> StepBy&lt;Self>; fn chain&lt;U>( self, other: U ) -> Chain&lt;Self, &lt;U as IntoIterator>::IntoIter> where U: IntoIterator&lt;Item = Self::Item>; fn zip&lt;U>(self, other: U) -> Zip&lt;Self, &lt;U as IntoIterator>::IntoIter> where U: IntoIterator; fn map&lt;B, F>(self, f: F) -> Map&lt;Self, F> where F: FnMut(Self::Item) -> B; fn for_each&lt;F>(self, f: F) where F: FnMut(Self::Item); fn filter&lt;P>(self, predicate: P) -> Filter&lt;Self, P> where P: FnMut(&amp;Self::Item) -> bool; fn filter_map&lt;B, F>(self, f: F) -> FilterMap&lt;Self, F> where F: FnMut(Self::Item) -> Option&lt;B>; fn enumerate(self) -> Enumerate&lt;Self>; fn peekable(self) -> Peekable&lt;Self>; fn skip_while&lt;P>(self, predicate: P) -> SkipWhile&lt;Self, P> where P: FnMut(&amp;Self::Item) -> bool; fn take_while&lt;P>(self, predicate: P) -> TakeWhile&lt;Self, P> where P: FnMut(&amp;Self::Item) -> bool; fn map_while&lt;B, P>(self, predicate: P) -> MapWhile&lt;Self, P> where P: FnMut(Self::Item) -> Option&lt;B>; fn skip(self, n: usize) -> Skip&lt;Self>; fn take(self, n: usize) -> Take&lt;Self>; fn scan&lt;St, B, F>(self, initial_state: St, f: F) -> Scan&lt;Self, St, F> where F: FnMut(&amp;mut St, Self::Item) -> Option&lt;B>; fn flat_map&lt;U, F>(self, f: F) -> FlatMap&lt;Self, U, F> where F: FnMut(Self::Item) -> U, U: IntoIterator; fn flatten(self) -> Flatten&lt;Self> where Self::Item: IntoIterator; fn fuse(self) -> Fuse&lt;Self>; fn inspect&lt;F>(self, f: F) -> Inspect&lt;Self, F> where F: FnMut(&amp;Self::Item); fn by_ref(&amp;mut self) -> &amp;mut Self; fn collect&lt;B>(self) -> B where B: FromIterator&lt;Self::Item>; fn partition&lt;B, F>(self, f: F) -> (B, B) where F: FnMut(&amp;Self::Item) -> bool, B: Default + Extend&lt;Self::Item>; fn partition_in_place&lt;'a, T, P>(self, predicate: P) -> usize where Self: DoubleEndedIterator&lt;Item = &amp;'a mut T>, T: 'a, P: FnMut(&amp;T) -> bool; fn is_partitioned&lt;P>(self, predicate: P) -> bool where P: FnMut(Self::Item) -> bool; fn try_fold&lt;B, F, R>(&amp;mut self, init: B, f: F) -> R where F: FnMut(B, Self::Item) -> R, R: Try&lt;Ok = B>; fn try_for_each&lt;F, R>(&amp;mut self, f: F) -> R where F: FnMut(Self::Item) -> R, R: Try&lt;Ok = ()>; fn fold&lt;B, F>(self, init: B, f: F) -> B where F: FnMut(B, Self::Item) -> B; fn fold_first&lt;F>(self, f: F) -> Option&lt;Self::Item> where F: FnMut(Self::Item, Self::Item) -> Self::Item; fn all&lt;F>(&amp;mut self, f: F) -> bool where F: FnMut(Self::Item) -> bool; fn any&lt;F>(&amp;mut self, f: F) -> bool where F: FnMut(Self::Item) -> bool; fn find&lt;P>(&amp;mut self, predicate: P) -> Option&lt;Self::Item> where P: FnMut(&amp;Self::Item) -> bool; fn find_map&lt;B, F>(&amp;mut self, f: F) -> Option&lt;B> where F: FnMut(Self::Item) -> Option&lt;B>; fn try_find&lt;F, R>( &amp;mut self, f: F ) -> Result&lt;Option&lt;Self::Item>, &lt;R as Try>::Error> where F: FnMut(&amp;Self::Item) -> R, R: Try&lt;Ok = bool>; fn position&lt;P>(&amp;mut self, predicate: P) -> Option&lt;usize> where P: FnMut(Self::Item) -> bool; fn rposition&lt;P>(&amp;mut self, predicate: P) -> Option&lt;usize> where Self: ExactSizeIterator + DoubleEndedIterator, P: FnMut(Self::Item) -> bool; fn max(self) -> Option&lt;Self::Item> where Self::Item: Ord; fn min(self) -> Option&lt;Self::Item> where Self::Item: Ord; fn max_by_key&lt;B, F>(self, f: F) -> Option&lt;Self::Item> where F: FnMut(&amp;Self::Item) -> B, B: Ord; fn max_by&lt;F>(self, compare: F) -> Option&lt;Self::Item> where F: FnMut(&amp;Self::Item, &amp;Self::Item) -> Ordering; fn min_by_key&lt;B, F>(self, f: F) -> Option&lt;Self::Item> where F: FnMut(&amp;Self::Item) -> B, B: Ord; fn min_by&lt;F>(self, compare: F) -> Option&lt;Self::Item> where F: FnMut(&amp;Self::Item, &amp;Self::Item) -> Ordering; fn rev(self) -> Rev&lt;Self> where Self: DoubleEndedIterator; fn unzip&lt;A, B, FromA, FromB>(self) -> (FromA, FromB) where Self: Iterator&lt;Item = (A, B)>, FromA: Default + Extend&lt;A>, FromB: Default + Extend&lt;B>; fn copied&lt;'a, T>(self) -> Copied&lt;Self> where Self: Iterator&lt;Item = &amp;'a T>, T: 'a + Copy; fn cloned&lt;'a, T>(self) -> Cloned&lt;Self> where Self: Iterator&lt;Item = &amp;'a T>, T: 'a + Clone; fn cycle(self) -> Cycle&lt;Self> where Self: Clone; fn sum&lt;S>(self) -> S where S: Sum&lt;Self::Item>; fn product&lt;P>(self) -> P where P: Product&lt;Self::Item>; fn cmp&lt;I>(self, other: I) -> Ordering where I: IntoIterator&lt;Item = Self::Item>, Self::Item: Ord; fn cmp_by&lt;I, F>(self, other: I, cmp: F) -> Ordering where F: FnMut(Self::Item, &lt;I as IntoIterator>::Item) -> Ordering, I: IntoIterator; fn partial_cmp&lt;I>(self, other: I) -> Option&lt;Ordering> where I: IntoIterator, Self::Item: PartialOrd&lt;&lt;I as IntoIterator>::Item>; fn partial_cmp_by&lt;I, F>( self, other: I, partial_cmp: F ) -> Option&lt;Ordering> where F: FnMut(Self::Item, &lt;I as IntoIterator>::Item) -> Option&lt;Ordering>, I: IntoIterator; fn eq&lt;I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialEq&lt;&lt;I as IntoIterator>::Item>; fn eq_by&lt;I, F>(self, other: I, eq: F) -> bool where F: FnMut(Self::Item, &lt;I as IntoIterator>::Item) -> bool, I: IntoIterator; fn ne&lt;I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialEq&lt;&lt;I as IntoIterator>::Item>; fn lt&lt;I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialOrd&lt;&lt;I as IntoIterator>::Item>; fn le&lt;I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialOrd&lt;&lt;I as IntoIterator>::Item>; fn gt&lt;I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialOrd&lt;&lt;I as IntoIterator>::Item>; fn ge&lt;I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialOrd&lt;&lt;I as IntoIterator>::Item>; fn is_sorted(self) -> bool where Self::Item: PartialOrd&lt;Self::Item>; fn is_sorted_by&lt;F>(self, compare: F) -> bool where F: FnMut(&amp;Self::Item, &amp;Self::Item) -> Option&lt;Ordering>; fn is_sorted_by_key&lt;F, K>(self, f: F) -> bool where F: FnMut(Self::Item) -> K, K: PartialOrd&lt;K>; } Iterator&lt;Item = T> types can be iterated and will produce T types. There&rsquo;s no IteratorMut trait. Each Iterator impl can specify whether it returns immutable references, mutable references, or owned values via the Item associated type.
Vec&lt;T> method Returns .iter() Iterator&lt;Item = &amp;T> .iter_mut() Iterator&lt;Item = &amp;mut T> .into_iter() Iterator&lt;Item = T> Something that is not immediately obvious to beginner Rustaceans but that intermediate Rustaceans take for granted is that most types are not their own iterators. If a type is iterable we almost always impl some custom iterator type which iterates over it rather than trying to make it iterate over itself:
struct MyType { items: Vec&lt;String> } impl MyType { fn iter(&amp;self) -> impl Iterator&lt;Item = &amp;String> { MyTypeIterator { index: 0, items: &amp;self.items } } } struct MyTypeIterator&lt;'a> { index: usize, items: &amp;'a Vec&lt;String> } impl&lt;'a> Iterator for MyTypeIterator&lt;'a> { type Item = &amp;'a String; fn next(&amp;mut self) -> Option&lt;Self::Item> { if self.index >= self.items.len() { None } else { let item = &amp;self.items[self.index]; self.index += 1; Some(item) } } } For the sake of teaching the above example shows how to impl an Iterator from scratch but the idiomatic solution in this situation would be to just defer to Vec&rsquo;s iter method:
struct MyType { items: Vec&lt;String> } impl MyType { fn iter(&amp;self) -> impl Iterator&lt;Item = &amp;String> { self.items.iter() } } Also this is a good generic blanket impl to be aware of:
impl&lt;I: Iterator + ?Sized> Iterator for &amp;mut I; It says that any mutable reference to an iterator is also an iterator. This is useful to know because it allows us to use iterator methods with self receivers as if they had &amp;mut self receivers.
As an example, imagine we have a function which processes an iterator of more than three items, but the first step of the function is to take out the first three items of the iterator and process them separately before iterating over the remaining items, here&rsquo;s how a beginner may attempt to write this function:
fn example&lt;I: Iterator&lt;Item = i32>>(mut iter: I) { let first3: Vec&lt;i32> = iter.take(3).collect(); for item in iter { // âŒ iter consumed in line above // process remaining items } } Well that&rsquo;s annoying. The take method has a self receiver so it seems like we cannot call it without consuming the whole iterator! Here&rsquo;s what a naive refactor of the above code might look like:
fn example&lt;I: Iterator&lt;Item = i32>>(mut iter: I) { let first3: Vec&lt;i32> = vec![ iter.next().unwrap(), iter.next().unwrap(), iter.next().unwrap(), ]; for item in iter { // âœ… // process remaining items } } Which is okay. However, the idiomatic refactor is actually:
fn example&lt;I: Iterator&lt;Item = i32>>(mut iter: I) { let first3: Vec&lt;i32> = iter.by_ref().take(3).collect(); for item in iter { // âœ… // process remaining items } } Not very easy to discover. But anyway, now we know.
Also, there are no rules or conventions on what can or cannot be an iterator. If the type impls Iterator then it&rsquo;s an iterator. Some creative examples from the standard library:
use std::sync::mpsc::channel; use std::thread; fn paths_can_be_iterated(path: &amp;Path) { for part in path { // iterate over parts of a path } } fn receivers_can_be_iterated() { let (send, recv) = channel(); thread::spawn(move || { send.send(1).unwrap(); send.send(2).unwrap(); send.send(3).unwrap(); }); for received in recv { // iterate over received values } } IntoIterator Prerequisites
Self Methods Associated Types Iterator trait IntoIterator where &lt;Self::IntoIter as Iterator>::Item == Self::Item, { type Item; type IntoIter: Iterator; fn into_iter(self) -> Self::IntoIter; } IntoIterator types can be converted into iterators, hence the name. The into_iter method is called on a type when it&rsquo;s used within a for-in loop:
// vec = Vec&lt;T> for v in vec {} // v = T // above line desugared for v in vec.into_iter() {} Not only does Vec impl IntoIterator but so does &amp;Vec and &amp;mut Vec if we&rsquo;d like to iterate over immutable or mutable references instead of owned values, respectively.
// vec = Vec&lt;T> for v in &amp;vec {} // v = &amp;T // above example desugared for v in (&amp;vec).into_iter() {} // vec = Vec&lt;T> for v in &amp;mut vec {} // v = &amp;mut T // above example desugared for v in (&amp;mut vec).into_iter() {} FromIterator Prerequisites
Self Functions Generic Parameters Iterator IntoIterator trait FromIterator&lt;A> { fn from_iter&lt;T>(iter: T) -> Self where T: IntoIterator&lt;Item = A>; } FromIterator types can be created from an iterator, hence the name. FromIterator is most commonly and idiomatically used by calling the collect method on Iterator:
fn collect&lt;B>(self) -> B where B: FromIterator&lt;Self::Item>; Example of collecting an Iterator&lt;Item = char> into a String:
fn filter_letters(string: &amp;str) -> String { string.chars().filter(|c| c.is_alphabetic()).collect() } All the collections in the standard library impl IntoIterator and FromIterator so that makes it easier to convert between them:
use std::collections::{BTreeSet, HashMap, HashSet, LinkedList}; // String -> HashSet&lt;char> fn unique_chars(string: &amp;str) -> HashSet&lt;char> { string.chars().collect() } // Vec&lt;T> -> BTreeSet&lt;T> fn ordered_unique_items&lt;T: Ord>(vec: Vec&lt;T>) -> BTreeSet&lt;T> { vec.into_iter().collect() } // HashMap&lt;K, V> -> LinkedList&lt;(K, V)> fn entry_list&lt;K, V>(map: HashMap&lt;K, V>) -> LinkedList&lt;(K, V)> { map.into_iter().collect() } // and countless more possible examples I/O Traits Read &amp; Write Prerequisites
Self Methods Scope Generic Blanket Impls trait Read { fn read(&amp;mut self, buf: &amp;mut [u8]) -> Result&lt;usize>; // provided default impls fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_>]) -> Result&lt;usize>; fn is_read_vectored(&amp;self) -> bool; unsafe fn initializer(&amp;self) -> Initializer; fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8>) -> Result&lt;usize>; fn read_to_string(&amp;mut self, buf: &amp;mut String) -> Result&lt;usize>; fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -> Result&lt;()>; fn by_ref(&amp;mut self) -> &amp;mut Self where Self: Sized; fn bytes(self) -> Bytes&lt;Self> where Self: Sized; fn chain&lt;R: Read>(self, next: R) -> Chain&lt;Self, R> where Self: Sized; fn take(self, limit: u64) -> Take&lt;Self> where Self: Sized; } trait Write { fn write(&amp;mut self, buf: &amp;[u8]) -> Result&lt;usize>; fn flush(&amp;mut self) -> Result&lt;()>; // provided default impls fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_>]) -> Result&lt;usize>; fn is_write_vectored(&amp;self) -> bool; fn write_all(&amp;mut self, buf: &amp;[u8]) -> Result&lt;()>; fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_>]) -> Result&lt;()>; fn write_fmt(&amp;mut self, fmt: Arguments&lt;'_>) -> Result&lt;()>; fn by_ref(&amp;mut self) -> &amp;mut Self where Self: Sized; } Generic blanket impls worth knowing:
impl&lt;R: Read + ?Sized> Read for &amp;mut R; impl&lt;W: Write + ?Sized> Write for &amp;mut W; These say that any mutable reference to a Read type is also Read, and same with Write. This is useful to know because it allows us to use any method with a self receiver as if it had a &amp;mut self receiver. We already went over how to do this and why it&rsquo;s useful in the Iterator trait section so I&rsquo;m not going to repeat it again here.
I&rsquo;d like to point out that &amp;[u8] impls Read and that Vec&lt;u8> impls Write so we can easily unit test our file handling functions using Strings which are trivial to convert to &amp;[u8] and from Vec&lt;u8>:
use std::path::Path; use std::fs::File; use std::io::Read; use std::io::Write; use std::io; // function we want to test fn uppercase&lt;R: Read, W: Write>(mut read: R, mut write: W) -> Result&lt;(), io::Error> { let mut buffer = String::new(); read.read_to_string(&amp;mut buffer)?; let uppercase = buffer.to_uppercase(); write.write_all(uppercase.as_bytes())?; write.flush()?; Ok(()) } // in actual program we'd pass Files fn example(in_path: &amp;Path, out_path: &amp;Path) -> Result&lt;(), io::Error> { let in_file = File::open(in_path)?; let out_file = File::open(out_path)?; uppercase(in_file, out_file) } // however in unit tests we can use Strings! #[test] // âœ… fn example_test() { let in_file: String = "i am screaming".into(); let mut out_file: Vec&lt;u8> = Vec::new(); uppercase(in_file.as_bytes(), &amp;mut out_file).unwrap(); let out_result = String::from_utf8(out_file).unwrap(); assert_eq!(out_result, "I AM SCREAMING"); } Conclusion We learned a lot together! Too much in fact. This is us now:
Artist credit: The Jenkins Comic
Discuss Discuss this article on
Github learnrust subreddit official Rust users forum Twitter lobste.rs rust subreddit Notifications Get notified when the next blog post get published by
Following pretzelhammer on Twitter or Watching this repo&rsquo;s releases (click Watch -> click Custom -> select Releases -> click Apply) Further Reading Sizedness in Rust Common Rust Lifetime Misconceptions Learning Rust in 2020 Learn Assembly with Entirely Too Many Brainfuck Compilers source:Tour of Rust&rsquo;s Standard Library Traits</content></entry><entry><title>å¦‚ä½•å®ç°ä¸€ä¸ªæ‹¼å†™æ£€æŸ¥å™¨[ç¿»è¯‘]</title><url>https://zhimoe.github.io/post/spell-correct/</url><categories><category>ç¿»è¯‘</category></categories><tags><tag>code</tag><tag>python</tag></tags><content type="html"> è°·æ­ŒAIè´Ÿè´£äººnorvigåœ¨07å¹´å†™çš„å¦‚ä½•å®ç°ä¸€ä¸ªæ‹¼å†™çº æ­£å™¨çš„ç»å…¸åšæ–‡How to Write a Spelling Corrector.
ä¸Šé¢çš„é“¾æ¥å·²ç»æ˜¯16å¹´æ›´æ–°è¿‡äº†,ç¨‹åºä¹Ÿæ›´æ–°åˆ°äº†python3.
ä¸­æ–‡ç‰ˆçš„ç¿»è¯‘ å¦‚ä½•å®ç°ä¸€ä¸ªæ‹¼å†™çº æ­£å™¨ è¿˜æ˜¯åŸºäº07å¹´ç‰ˆæœ¬çš„.
åšæ–‡æœ€æœ‰æ„æ€çš„åœ°æ–¹æ˜¯å¤§ç‰›è®°å½•äº†å¦‚ä½•åœ¨é£æœºä¸Šé¢æ²¡æœ‰ç½‘ç»œçš„æ¡ä»¶ä¸‹å¾’æ‰‹å†™ä¸€ä¸ªå‡†ç¡®ç‡è¶…è¿‡70%çš„æ‹¼å†™çº æ­£å™¨.</content></entry><entry><title>Associated Type in Rust</title><url>https://zhimoe.github.io/post/type-in-rust/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>rust</tag></tags><content type="html"> Associated Type and generic diff in rust
type outside impl a type Foo = Bar outside is just type alias. most used in generic type.
like: type Thunk = Box&lt;dyn Fn() + Send + 'static>;
type inside impl type in an impl defines an associated type. associated typeå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªç±»å‹å ä½ç¬¦,åœ¨traitçš„æ–¹æ³•å£°æ˜ä¸­ä½¿ç”¨.
pub trait Iterator { type Item; // or type T: Display; fn next(&amp;mut self) -> Option&lt;Self::Item>; } è¿™é‡ŒIteratorçš„Implementorså°†ä¼šæŒ‡å®šItemçš„å…·ä½“ç±»å‹.ä¾‹å¦‚ï¼š
impl Iterator for Counter { type Item = u32; fn next(&amp;mut self) -> Option&lt;Self::Item> { // --snip-- } } diff in associated type and generic ç›´æ¥å°†ä¸Šé¢çš„Iteratorå£°æ˜ä¸ºå¦‚ä¸‹æ³›å‹ä¸æ˜¯æ›´ç®€å•ä¹ˆï¼Ÿ
pub trait Iterator&lt;T> { fn next(&amp;mut self) -> Option&lt;T>; } // with generice, you can set default type: /// trait Iterator&lt;T = String> /// where T: Display, ä¸»è¦çš„åŒºåˆ«å°±æ˜¯genericå¯æ˜¯æœ‰ä»»æ„å¤šä¸ªå®ç°,å› ä¸ºIterator&lt;Foo>å’ŒIterator&lt;Bar>æ˜¯ä¸¤ä¸ªä¸åŒçš„ç±»å‹.
è€Œassociated typeåªèƒ½æœ‰ä¸€ä¸ªå®ç°,å› ä¸ºIteratoråªæœ‰ä¸€ä¸ªç±»å‹,æ‰€ä»¥associated typeå¯ä»¥ç”¨äºé™åˆ¶ç±»å‹.
when use The quick and dirty answer to when to use generics and when to use associated types is:
Use generics if it makes sense to have multiple implementations of a trait for a specific type (such as the From&lt;T> trait).
Otherwise, use associated types (like Iterator and Deref).
å‡è®¾æˆ‘ä»¬å®ç°ä¸€ä¸ªredis å®¢æˆ·ç«¯,é‚£ä¹ˆæ¯”è¾ƒé€‚åˆä½¿ç”¨associated types:
trait RedisCommand{ type Response; fn receive(&amp;self, message: String) -> Result&lt;Self::Response>; } impl RedisCommand for PingCommand { type Response = String fn receive(&amp;self, message: String) -> Result&lt;Self::Response>{ // -- snip -- } }</content></entry><entry><title>æœ€ä½³ç¼–ç¨‹å­—ä½“</title><url>https://zhimoe.github.io/post/programming-fonts/</url><categories><category>éšæƒ³</category></categories><tags><tag>font</tag><tag>aurulent</tag><tag>firacode</tag></tags><content type="html"> ä¸ªäººå¯¹äºç¼–ç¨‹å­—ä½“æœ‰ä¸€ç‚¹ç‚¹æ´ç™–ï¼Œåœ¨å°è¯•åå‡ ä¸ªå­—ä½“åï¼Œç»ˆäºä½¿ç”¨FontForgeå’Œfontline.pyåŠ¨æ‰‹ä¿®æ”¹åˆ¶ä½œè‡ªå·±çš„ç¼–ç¨‹å­—ä½“:Aurulentå’Œ Fira Codeã€‚
Aurulent å­—ä½“ä¸‹è½½
å°å†™å­—æ¯æ¥è‡ªAurulent Sans Monoï¼Œå…¶ä»–åŸºäºFira Code.Aurulent Sans Monoé£æ ¼å’ŒSourceCodeProéå¸¸åƒï¼Œèƒ–å®½å‹ï¼Œå¤§å¼€å¤§åˆï¼Œç®€å•å´æœ‰å…·æœ‰è®¾è®¡ï¼Œç‰¹åˆ«æ˜¯å­—ç¬¦gï¼Œaï¼Œpï¼Œyï¼Œsã€‚ å­—æ¯rçš„æ€è·¯æ¥è‡ªgintronic. ä¼˜ç‚¹æ˜¯åœ¨ä½åˆ†è¾¨ç‡å±ï¼Œrçš„æœ«å°¾ä¸ä¼šè¢«hintåªå‰©ä¸‹å°–å°–ã€‚ é—®å·ï¼Ÿä¹Ÿæ¥è‡ªgintronicå­—ä½“ï¼Œéå¸¸æ¼‚äº®ã€‚ Aurulentæ•ˆæœ
Fira Code Fira Codeæ˜¯å…¨ç½‘æœ€å—æ¬¢è¿çš„å­—ä½“ï¼Œä½†æ˜¯è¿™ä¸ªrå®åœ¨è¿‡äºfancyï¼Œæ‰€ä»¥é‡æ–°æ„å»ºäº†ä¸€ä¸ªç‰ˆæœ¬ï¼Œåªæä¾›regularå’Œboldä¸¤ä¸ªå­—é‡
MonoLisa ç›®å‰åœ¨ç”¨ä¹Ÿæ˜¯æœ€å–œæ¬¢çš„æ”¶è´¹å­—ä½“ï¼Œ MonoLisaå®Œç¾ä½“ç°äº†å®˜ç½‘ä¸Šé¢çš„"font follows function"å®£è¨€ï¼Œæ•´ä¸ªå­—ä½“åœ¨ä»£ç é˜…è¯»ä¸­æœ‰ä¸€ç§ä»å·¦åˆ°å³çš„æµåŠ¨æ„Ÿã€‚ä¹Ÿæ˜¯è‡ªå·±ç¬¬äºŒæ¬¡ä»˜è´¹å­—ä½“(ç¬¬ä¸€æ¬¡æ˜¯æ–¹æ­£)
å”¯ä¸€ä¸è¶³çš„æ˜¯å’Œfira codeç›¸æ¯”ï¼Œå¼€å‘è€…åœ¨hintæ–¹é¢ä¸å¤ªè¡Œï¼Œæ¯ä¸ªç‰ˆæœ¬æ€»æ˜¯ä¼šæœ‰ä¸€äº›hinté—®é¢˜ï¼Œåœ¨é4Kæ˜¾ç¤ºå™¨ä¸Šé¢æ•ˆæœä¼šå¾ˆç³Ÿç³•ï¼Œä¾‹å¦‚"=>&ldquo;çš„ç­‰å·ä¼šæ˜æ˜¾ä¸Šä¸‹ç²—ç»†ä¸ä¸€è‡´ã€‚å› ä¸ºè‡ªå·±éƒ½æ˜¯4Kæ˜¾ç¤ºå™¨ï¼Œå¹²è„†å°±ä½¿ç”¨fontforgeè¿›è¡Œdehintå¤„ç†ã€‚
å…¶ä»–ç¼–ç¨‹å­—ä½“ ä¸ªäººæ¯”è¾ƒå–œæ¬¢çš„å­—ä½“æœ‰
SourceCodeProï¼Œ åªæ˜¯è¿™ä¸ªråœ¨ä½åˆ†è¾¨ç‡ä¸‹ä¸€å¡Œç³Šæ¶‚ï¼Œ ç»“åˆoffice code proåšäº†ä¸€ä¸ªæ›´é€‚åˆæ­£æ–‡çš„SourceCodeProç‰ˆæœ¬ Adobe LetterGothicï¼š è¿™æ˜¯ä¸€ä¸ªç»å…¸çš„IBMæ‰“å­—æœºå­—ä½“ã€‚è¿™ä¸ªå­—ä½“ç»å…¸åœ¨äºå­—ç¬¦ræ˜¯æˆ‘è®¤ä¸ºæ‰€æœ‰å­—ä½“é‡Œé¢è®¾è®¡çš„æœ€æ¼‚äº®çš„ï¼Œ åœ¨å­—ä½“è®¾è®¡ä¸­ï¼Œæ„Ÿè§‰ræ˜¯æœ€éš¾è®¾è®¡çš„ï¼Œåƒfira codeè¿™ç§rï¼Œ æœ‰ç‚¹è¿‡äºfancyï¼Œå¾ˆå®¹æ˜“å¸å¼•ä½ çš„ç›®å…‰; åƒsource code proé‚£ç§è¶…çº§ç®€æ´ï¼Œ åœ¨winä¸‹é¢æ¸²æŸ“é™¤éæ˜¯é«˜åˆ†å±ï¼Œå¦åˆ™ä¸€å¡Œç³Šæ¶‚.é™¤äº†å­—ç¬¦rï¼Œ letter gothicä½œä¸º1960æ—¶ä»£æ‰“å­—æœºé»˜è®¤å­—ä½“ä¹‹ä¸€ï¼Œåœ¨å­—ç¬¦nï¼Œuçš„è§’ä¸Šï¼Œéƒ½ä¿ç•™äº†éå¸¸æ¼‚äº®è€Œå«è“„çš„ç»†èŠ‚ï¼Œè¿™ä¸€ç‚¹ï¼Œæˆ‘éå¸¸åæ§½jetbrains monoå­—ä½“ï¼Œå±…ç„¶æŠŠå°å†™uçš„å°¾å·´å»æ‰ï¼Œå£°ç§°å¯ä»¥åŠ å¿«é˜…è¯»ï¼Œ æˆ–è®¸èƒ½æé€Ÿï¼Œä½†æ˜¯ä¸¢äº†ç¾æ„Ÿ. LetterGothicå…·ä½“çš„æ•ˆæœçœ‹æˆ‘ä¹‹å‰çš„æ¨æ–‡Thread. TheSansMono: ç»å…¸ç­‰å®½å­—ä½“ã€‚ä½ å¯ä»¥åœ¨å¾ˆå¤šä¹¦ä¸Šé¢çœ‹åˆ°è¿™ä¸ªå­—ä½“.æ–œä½“æ˜¯æ‰€æœ‰å­—ä½“æœ€å¥½çœ‹çš„ï¼Œæ”¶è´¹ï¼Œä½œè€…ä¹Ÿæ˜¯windowsç»å…¸çš„ä»£ç å­—ä½“Consolasä½œè€…ã€‚ Letter Gothicæ•ˆæœ
éç¼–ç¨‹è‹±æ–‡å­—ä½“æ¨è Sansç±» ä¸€èˆ¬é»‘ä½“ä¸­æ–‡é€‚åˆæ­é…Sansè‹±æ–‡å­—ä½“ï¼Œæ¨èç»å…¸çš„Open Sansï¼ŒInterï¼ŒLatoï¼ŒFira Sansã€‚Interé£å¤´æ­£ç››ï¼Œå¾ˆå¤šç½‘ç«™åŒ…æ‹¬2023çš„jetbrains IDE UIå­—ä½“éƒ½æ¢æˆè¿™ä¸ªäº†ï¼Œç‰¹ç‚¹å°±æ˜¯æ²¡æœ‰ä»»ä½•ç‰¹è‰²ã€‚ä¸ªäººè®¤ä¸ºLatoè®¾è®¡ç»†èŠ‚æœ€ä½³ï¼Œä½†ç¡®å®ä¸é€‚åˆç”¨äºUIï¼Œä½†æ˜¯åœ¨ç½‘ç«™æ­£æ–‡ä¸­ä½¿ç”¨éå¸¸ä¸é”™ã€‚
æ”¶è´¹å­—ä½“ä¸­Sana Sansåœ¨æ­£æ–‡ä¸­æ•ˆæœä¹Ÿä¸é”™ï¼Œæ’­å®¢ç½‘ç«™changelogç”¨çš„å°±æ˜¯è¿™ä¸ªå­—ä½“ã€‚
Serifç±» ä¸€èˆ¬å®‹ä½“ä¸­æ–‡é€‚åˆæ­é…è¡¬çº¿è‹±æ–‡å­—ä½“ï¼Œæ¨èPalatinoå’ŒMerriweatherï¼Œåè€…æ˜¯google fontä¸Šé¢æ’åç¬¬ä¸€çš„serifå­—ä½“ï¼Œç¼ºç‚¹æ˜¯å­—ä½“åç²—ã€‚
æ‰‹å†™ä½“ å¤§éƒ¨åˆ†æ‰‹å†™ä½“éƒ½ä¸é€‚åˆé˜…è¯»ï¼Œä½†æ˜¯Alegreya Sansæ–œä½“æ¯”è¾ƒåˆé€‚ï¼Œåœ¨æ‰‹å†™é£æ ¼å’Œå¯è¯»æ€§è¾¾åˆ°è¾ƒå¥½å¹³è¡¡ã€‚</content></entry><entry><title>å¦‚ä½•æ­£ç¡®åœ°ç³»é‹å¸¦</title><url>https://zhimoe.github.io/post/how-to-tie-shoelace/</url><categories><category>ç”Ÿæ´»</category></categories><tags><tag>é‹å¸¦</tag></tags><content type="html"> Ianå®‰å…¨ç»“æ˜¯ç™»å±±ç³»é‹å¸¦çš„é¦–é€‰,å®ƒè¶Šç©¿è¶Šç´§,ä¸ä¼šæ¾å¼€.è§£é‹å¸¦è½»è½»ä¸€æ‹‰å³å¼€. è€Œä¸”å¯¹ç§°ç¾è§‚,ä¸Šæ‰‹ç®€å•.å€¼å¾—æ¯ä¸ªäººèŠ±ååˆ†é’Ÿå­¦ä¹ .
æœ¬ç¯‡ä¸ä»…ç»™å‡ºIanå®‰å…¨ç»“ç¤ºæ„å›¾,è¿˜å‘Šè¯‰å¤§å®¶å¦‚ä½•è®©å®‰å…¨ç»“å’Œè´è¶ç»“æ°´å¹³å¯¹ç§°,å°½å¯èƒ½ç¾è§‚çš„ç§˜è¯€.
ä»¥ä¸Šæ˜¯Ianç»“çš„æ­¥éª¤.ä¸‹é¢æ˜¯é‡ç‚¹ï¼š
æ— è®ºæ˜¯è´è¶ç»“è¿˜æ˜¯Ianå®‰å…¨ç»“,å¦‚æœä½ å‘ç°è‡ªå·±çš„é‹å¸¦ç³»å®Œæ˜¯æ–œçš„è€Œéæ°´å¹³,åŸå› æ˜¯ç¬¬ä¸€ä¸ªè¾…åŠ©ç»“å’Œç¬¬äºŒä¸ªç»“ä¸Šä¸‹å…³ç³»åäº†. å³å›¾1çš„é‚£ä¸ªç»“æ˜¯è¾…åŠ©ç»“,é»„è‰²åœ¨ä¸Š,è“è‰²åœ¨ä¸‹,é‚£ä¹ˆç¬¬äºŒä¸ªç»“å¿…é¡»å’Œå›¾2ä¸­ä¸€æ ·,é»„è‰²åœ¨ä¸Š,è“è‰²åœ¨ä¸‹, å¦‚æœä½ åœ¨ç¬¬äºŒæ­¥é»„è“åäº†,æœ€åæˆç»“å°±æ˜¯æ–œçš„!!! è¿™æ˜¯æˆ‘æ¯•ç”Ÿç»å­¦äº†.
Ianå®‰å…¨ç»“æƒ³è¦å¥½çœ‹çš„è¯€çªåœ¨äº,åœ¨å¿«è¦æ‹‰ç´§ç»³ç»“ä¹‹å‰,å…ˆæ‹‰ä½é‹å¸¦ä¸¤ç«¯æ¾ä¸€ä¸‹ç»“,å‡è£…è¦æ‰¯å¼€é‹å¸¦,è¿™æ ·å®‰å…¨ç»“å†…éƒ¨ä¼šå˜æ•´é½,ç„¶åæŠ“ä½8å­—ç¯ä¸¤ç«¯æ‹‰ç´§é‹å¸¦.æ³¨æ„,æ˜¯å¿«è¦æ‹‰ç´§ä¹‹å‰æ‰¯æ¾ä¸€ä¸‹,æ‰¯çš„æ—¶å€™ç»³ç»“åº”è¯¥å·²ç»æœ‰ç‚¹æ‘©æ“¦äº†,å¤ªæ¾äº†å¤–æ‰¯æ•´ç†ä¸åˆ°ç»“çš„å†…éƒ¨,å¤ªç´§äº†å¤–æ‰¯ç»“ä¹Ÿä¸ä¼šæ”¹å˜å½¢çŠ¶äº†,å°±æ˜¯æ‹‰ç´§ä¹‹å‰åå¤æ•´ç†ä¸€ä¸‹,æ³¨æ„,å¦‚æœè¿™é‡Œä½ è¾…åŠ©ç»“ä¸Šä¸‹å…³ç³»é”™äº†,æœ€åå¾ˆéš¾æ•´ç†å‡ºæ¥æ»¡æ„çš„æ•ˆæœ.æœ€åçš„æ•ˆæœåº”è¯¥æ˜¯æœ€åä¸€å¹…å›¾çš„æ•ˆæœ,è€Œä¸æ˜¯ç¬¬ä¸€å¹…çš„å›¾6é‚£ä¹ˆä¸‘çš„.
ä½œè€…ï¼šzhimoe
é“¾æ¥ï¼šhttps://www.zhihu.com/question/19728687/answer/501699533</content></entry><entry><title>Java 8 Lambdaç¬”è®°</title><url>https://zhimoe.github.io/post/java-lambda/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>java</tag><tag>lambda</tag></tags><content type="html"> é—®é¢˜ Javaæ˜¯OOPè¯­è¨€,ä½¿ç”¨å¯¹è±¡å°è£….ç”±äºå‡½æ•°ä¸æ˜¯ä¸€ç­‰å…¬æ°‘,æ— æ³•åœ¨æ–¹æ³•ä¸­ä¼ é€’å‡½æ•°/æ–¹æ³•. åœ¨Java 8ä¹‹å‰,ä½¿ç”¨åŒ¿åç±»è¡¨ç¤ºè¡Œä¸ºï¼š
// ç›‘å¬å™¨æ¥å£ public interface ActionListener { void actionPerformed(ActionEvent e); } // ä½¿ç”¨åŒ¿åç±»ä¼ é€’ä¸€ä¸ªè¡Œä¸º button.addActionListener(new ActionListener(){ public void actionPerformed(Event e){ System.out.println("button clicked"); } }); ä¸Šé¢çš„ä»£ç ä¸»è¦çš„é—®é¢˜åœ¨äºaddActionListeneræ–¹æ³•æœŸæœ›çš„æ˜¯ä¸€ä¸ªè¡Œä¸º,ä¸ºäº†æè¿°è¿™ä¸ªè¡Œä¸ºï¼ˆä»£ç å³æ•°æ®çš„æ¦‚å¿µï¼‰,åœ¨Javaä¸­ä¸å¾—ä¸ä¼ å…¥ä¸€ä¸ªå¯¹è±¡. é™¤äº†ä»£ç å†—ä½™,è¿˜å­˜åœ¨ä¸‹é¢é—®é¢˜
ä¸šåŠ¡é€»è¾‘æ·¹æ²¡åœ¨åŒ¿åç±»è¯­æ³•ä¸­,å°±åƒGoè¯­è¨€çš„if err != nilä¸€æ · åŒ¿åç±»ä¸­çš„ this å’Œå˜é‡åå®¹æ˜“ä½¿äººäº§ç”Ÿè¯¯è§£ ç±»å‹è½½å…¥å’Œå®ä¾‹åˆ›å»ºè¯­ä¹‰ä¸å¤Ÿçµæ´» æ— æ³•æ•è·é final çš„å±€éƒ¨å˜é‡ lambdaè¡¨è¾¾å¼ ä¸ºäº†è§£å†³ä¸Šé¢çš„é—®é¢˜,Java8æ¨å‡ºäº†lambdaè¡¨è¾¾å¼â€”â€”å½“æ¥å£åªæœ‰ä¸€ä¸ªæŠ½è±¡æ–¹æ³•æ—¶,ç§°ä¸ºå‡½æ•°å¼æ¥å£ï¼ˆä¹Ÿå«å•æŠ½è±¡æ–¹æ³•ç±»å‹,SAMç±»å‹ï¼‰,å¯ä»¥ä½¿ç”¨lambdaè¡¨è¾¾å¼è¡¨ç¤ºè¿™ä¸ªæ¥å£çš„å®ç°æ–¹æ³•.
button.addActionListener(e -> System.out.println("button clicked")); å…¶ä¸­çš„eæ˜¯actionPerformed(Event e)æ–¹æ³•çš„å‚æ•°,-> åé¢çš„æ˜¯æ–¹æ³•ä½“. æ³¨æ„è¿™é‡Œæˆ‘ä»¬å¹¶æ²¡æœ‰æä¾›eçš„ç±»å‹,è¿™æ˜¯ç”±ç±»å‹æ¨å¯¼æŠ€æœ¯å®ç°çš„â€”â€”javacæ ¹æ®addActionListeneræ–¹æ³•ç­¾åå’ŒactionPerformedæ–¹æ³•ç­¾åæ¨å¯¼å‡ºå‚æ•°ç±»å‹åªèƒ½æ˜¯Event.
ä¸æ˜¯æ‰€æœ‰æƒ…å†µéƒ½å¯ä»¥çœç•¥ç±»å‹,ä½†æ˜¯è¯·ç»™IDEè¡¨ç°æœºä¼š,åªæœ‰åœ¨IDEæé†’ä½ æœ‰é”™è¯¯æ—¶å†è¡¥å……ä¸Šç±»å‹ä¿¡æ¯.
ä¸‹é¢éƒ½æ˜¯åˆæ³•çš„lambdaè¡¨è¾¾å¼ï¼š
Runnable tsk = () -> println(""); Runnable tsk = name -> { println(name);} BinaryOperator&lt;Long> add = (Long x, Long y) -> x + y; BinaryOperator&lt;Long> add = (x, y) -> {return x + y;} //ç±»å‹æ¨æ–­, returnå’Œ{}æ˜¯å†—ä½™çš„ // &lt;!-- å‚æ•°æ‹¬å·å’Œå¤§æ‹¬å·çœç•¥è§„åˆ™ --> // 1. å‚æ•°()ï¼šæ— å‚æ•°ä½¿ç”¨(),1ä¸ªå‚æ•°å¯ä»¥çœç•¥æ‹¬å·,å…¶ä»–ä½¿ç”¨(). // 2. å‡½æ•°ä½“{}ï¼šå•è¯­å¥çš„å¯ä»¥çœç•¥{},å¤šæ¡è¯­å¥å¿…é¡»æœ‰{} åœ¨Javaä¸­,å·²ç»æœ‰å¤§é‡çš„å‡½æ•°å¼æ¥å£ï¼š
java.lang.Runnable java.util.concurrent.Callable java.security.PrivilegedAction java.util.Comparator java.io.FileFilter java.beans.PropertyChangeListener thisæŒ‡å‘è°ƒç”¨è€…,ä¹Ÿå³æ˜¯button lambdaçš„ç±»å‹æ˜¯æ ¹æ®ä¸Šä¸‹æ–‡æ¥å†³å®šçš„, æ‰€ä»¥ç›¸åŒå…¥å‚å’Œè¿”å›å€¼æƒ…å†µä¸‹,ç›®æ ‡ç±»å‹å¯èƒ½ä¸åŒ,åœ¨æ— æ³•åˆ¤æ–­æ—¶,éœ€è¦è¡¥å……ç›®æ ‡ç±»å‹ä¿¡æ¯: Callable&lt;String> c = () -> "done"; PrivilegedAction&lt;String> a = () -> "done"; // error var add = (Long x, Long y) -> x + y; // è¿™é‡Œaddä¼šæŠ¥é”™ï¼š // java: cannot infer type for local variable add // (lambda expression needs an explicit target-type) // å› ä¸ºæ»¡è¶³ (Long, Long) -> Longçš„å‡½æ•°å¼æ¥å£å¾ˆå¤š,ç¼–è¯‘å™¨æ— æ³•çŸ¥é“addç›®æ ‡ç±»å‹åº”è¯¥æ˜¯ä»€ä¹ˆ. å½“æ¶‰åŠåˆ°æ³›å‹æ—¶,ç±»å‹æ¨å¯¼æ€»æ˜¯æœ‰ç‚¹åŠ›ä¸ä»å¿ƒ,éœ€è¦æ·»åŠ å¿…è¦çš„ç±»å‹ä¿¡æ¯ï¼š å‡½æ•°å¼æ¥å£ä¸@FunctionalInterface æœ‰äº†lambdaå’Œå‡½æ•°å¼æ¥å£,æ¡†æ¶æ–¹æ³•åœ¨å½¢å‚ç±»å‹ä¸Šé¢å¯ä»¥æ›´åŠ æ³›åŒ–äº†.ä¾‹å¦‚ä½ å¸Œæœ›ä½ çš„æ¡†æ¶æ–¹æ³•æ”¯æŒä¸€ä¸ªT->Rçš„æ“ä½œ,ä½ å¯èƒ½ä¼šå®šä¹‰ä¸€ä¸ª
@FunctionalInterface public interface Transfer&lt;T, R> { R apply(T t); } è¿™é‡ŒT,Ræ˜¯æ³›å‹,è¿™æ˜¯ä¸€ä¸ªéå¸¸æ³›åŒ–çš„å‡½æ•°å¼æ¥å£.æ‰€ä»¥Java8åœ¨util.functionåŒ…ä¸­æ–°å¢äº†43ä¸ªå‡½æ•°å¼æ¥å£,ç›®çš„å°±æ˜¯æ–¹ä¾¿æ¡†æ¶å¼€å‘è€…èƒ½å¤Ÿå‡å°‘æ–°å»ºè‡ªå·±çš„FunctionalInterface.
åŸºç¡€çš„æ¥å£åªæœ‰6ä¸ª:
æ¥å£ å‡½æ•°ç­¾å ä¸¾ä¾‹ UnaryOperator R apply(T t); String::toLocaerCase BinaryOperator R apply(T t, U u); BigInterger::add Predicate boolean test(T t); Collection::isEmpty Function R apply(T t); Arrays::asList Supplier T get(); Instant::now Consumer void accept(T t); System.out::println ä¸Šé¢çš„æ˜¯åŸºç¡€æ¥å£,æ­¤å¤–è¿˜æœ‰ï¼š
Consumer, Function, Predicateå„è‡ªæœ‰ä¸€ä¸ª2ä¸ªå…¥å‚çš„ç‰ˆæœ¬,å…±3ä¸ª:BiConsumer,BiFunction,BiPredicate. 6ä¸ªåŸºç¡€æ¥å£å¯¹åº”å…¥å‚ä¸ºåŸºæœ¬ç±»å‹int,long,doubleçš„æ¥å£,å…±18ä¸ª:IntSupplier,LongFunction&hellip; 6ä¸ªåŸºç¡€æ¥å£å¯¹åº”è¿”å›å€¼ä¸ºåŸºæœ¬ç±»å‹int,long,doubleçš„Functionå’ŒBiFunction,å…±6ä¸ª: ToIntBiFunction,ToIntFunction&hellip; int,long,doubleåŸºæœ¬ç±»å‹äº’è½¬çš„Functionå…±6ä¸ªï¼šDoubleToIntFunction,DoubleToLongFunction,IntToDoubleFunction,IntToLongFuncion,LongToDoubleFunction,LongToIntFunction. Consumeræœ‰åŒæ—¶æ¥å—ä¸€ä¸ªObjectå’Œä¸€ä¸ªåŸºæœ¬ç±»å‹çš„ç‰ˆæœ¬,å…±3ä¸ª: ObjDoubleConsumer{void accept(T t, int value);} æœ€åè¿˜æœ‰ä¸€ä¸ªBooleanSupplier{boolean getAsBoolean();} ç¬¬ä¸€æ¬¡è§åˆ°BooleanSupplierå¯èƒ½å®Œå…¨ä¸çŸ¥é“ä½¿ç”¨åœºæ™¯,æ¯•ç«Ÿæœ‰Supplierä¸å°±å¯ä»¥äº†ä¹ˆï¼Ÿ
ä¸Šé¢çš„åŸºç¡€æ¥å£è™½ç„¶éå¸¸é€šç”¨,ä½†æ˜¯å¦‚æœæœ‰æ›´å¥½çš„æ¥å£åç§°æ—¶,åº”è¯¥ä½¿ç”¨æ›´åˆé€‚çš„é‚£ä¸ª.ä¾‹å¦‚Comparator{int compare(T o1, T o2);}å’ŒToIntBiFunction&lt;T, U> {int applyAsInt(T t, U u);}ç­¾åå®Œå…¨ä¸€è‡´,ä½†æ˜¯è¿˜æ˜¯åœ¨æ¯”è¾ƒçš„æ—¶å€™ä½¿ç”¨Comparator.
åœ¨æ„å»ºè‡ªå·±çš„å‡½æ•°å¼æ¥å£æ—¶,åŠ¡å¿…ä½¿ç”¨æ³¨è§£@FunctionalInterfaceæ ‡æ³¨ä½ çš„æ¥å£,è¿™æ ·å¯ä»¥ç»™IDE lintå’Œä½¿ç”¨è€…æä¾›æ›´åŠ å……åˆ†ä¿¡æ¯.
æ–¹æ³•å¼•ç”¨ å¦‚æœlambdaè¡¨è¾¾å¼çš„æ–¹æ³•ä½“è¿‡é•¿,é‚£ä¹ˆéœ€è¦æŠ½å–æ–¹æ³•,Java8æä¾›äº†æ›´è¿‘ä¸€æ­¥çš„è¯­æ³•â€”â€”æ–¹æ³•å¼•ç”¨. æ–¹æ³•å¼•ç”¨è¡¨ç¤ºä¸€ä¸ªlambdaè¡¨è¾¾å¼.åªéœ€è¦å¼•ç”¨çš„æ–¹æ³•ç­¾åå’Œlambdaç›®æ ‡ç±»å‹çš„æŠ½è±¡æ–¹æ³•ç­¾åä¸€è‡´å³å¯.
æ–¹æ³•å¼•ç”¨ä¸€å…±æœ‰5ç§ç±»å‹,å…¶ä¸­,é™æ€æ–¹æ³•æ˜¯æœ€å¸¸ç”¨çš„ç±»å‹.
æ–¹æ³•å¼•ç”¨ç±»å‹ æ–¹æ³•å¼•ç”¨ å¯¹åº”lambdaè¡¨è¾¾å¼ é™æ€æ–¹æ³• Integer::parseInt str-> Integer.parseInt(str) æœ‰é™åˆ¶(Bound receiver)å®ä¾‹å¼•ç”¨ Instant.now()::isAfter Instant then = Instant.now(); then.isAfter(t) æ— é™åˆ¶(Unbound receiver)å®ä¾‹å¼•ç”¨ String::toLowerCase str -> str.toLowerCase ç±»æ„é€ å™¨ TreeMap&lt;K,V>::new ()-> new TreeMap&lt;K,V>() æ•°ç»„æ„é€ å™¨ int[]::new len->new int[len] Bound receiverå…¶å®å¾ˆå¥½ç†è§£,æ–¹æ³•çš„receiver(ä¸Šé¢çš„then = Instant.now())æ˜¯å›ºå®šçš„. Unbound receiverçš„å«ä¹‰æ˜¯æ–¹æ³•çš„æ¥æ”¶è€…(ä¸Šé¢çš„str)æ˜¯ä¸ç¡®å®šçš„, é€šè¿‡å…¥å‚çš„å½¢å¼ä¼ å…¥. è€Œåœ¨æ–¹æ³•å¼•ç”¨çš„å½¢å¼ä¸Šé¢åè€Œåƒé™æ€æ–¹æ³•å¼•ç”¨(String::toLowerCase, toLowerCaseä¸æ˜¯é™æ€æ–¹æ³•,æ‰€ä»¥ä¸æ˜¯é™æ€æ–¹æ³•å¼•ç”¨). æ›´ç²—æš´çš„ç†è§£å°±æ˜¯å…¥å‚æ˜¯æ–¹æ³•çš„å¼•ç”¨å¯¹è±¡,æ‰€ä»¥æ–¹æ³•å¼•ç”¨å¯¹è±¡å–å†³äºå…¥å‚ï¼ˆä¸ç¡®å®šï¼‰. æ•°ç»„æ„é€ å™¨çš„æ¯”è¾ƒéš¾ä»¥ç†è§£,å¯ä»¥çœ‹æˆå¦‚ä¸‹ä»£ç ï¼š IntFunction&lt;int[]> arrayMaker = int[]::new; int[] array = arrayMaker.apply(len) // åˆ›å»ºæ•°ç»„ int[len]</content></entry><entry><title>åŸºäºMDXçš„webè¯å…¸</title><url>https://zhimoe.github.io/post/mdict-web/</url><categories><category>éšæƒ³</category></categories><tags><tag>python</tag><tag>rust</tag></tags><content type="html"> Mdicté¡¹ç›®æ˜¯ä¸€ä¸ªç³…åˆäº†MDXè¯å…¸ã€ESä¾‹å¥æœç´¢å’ŒAIæ¨¡å‹ç¿»è¯‘çš„å¤šæºæœç´¢åŠŸèƒ½Webè¯å…¸.ç‰¹åˆ«é€‚åˆéƒ¨ç½²åœ¨å†…ç½‘ä¸­å­¦ä¹ ä½¿ç”¨æˆ–è€…ç»™å­©å­å­¦ä¹ ä½¿ç”¨.
pythonç‰ˆæœ¬å¢åŠ äº†ä¸€ä¸ªæœºå™¨å­¦ä¹ æ¨¡å‹ç¿»è¯‘.rustç‰ˆæœ¬ä¹Ÿæœ‰æ¨¡å‹,ä½†æ˜¯è¿˜æ²¡æ¥å¾—åŠåŠ .
mdict-py mdict-pyæºç 
Mdicté¡¹ç›®æ˜¯ä¸€ä¸ªç³…åˆäº†MDXè¯å…¸ã€ESä¾‹å¥æœç´¢å’ŒAIæ¨¡å‹ç¿»è¯‘çš„å¤šæºæœç´¢åŠŸèƒ½Webè¯å…¸.ç‰¹åˆ«é€‚åˆéƒ¨ç½²åœ¨å†…ç½‘ä¸­å­¦ä¹ ä½¿ç”¨æˆ–è€…ç»™å­©å­å­¦ä¹ ä½¿ç”¨.
ç‰¹ç‚¹ï¼š
è‡ªåŠ¨è¯†åˆ«ä¸­è‹±æ–‡é€‰æ‹©å¯¹åº”mdxè¯å…¸,ç›®å‰è‹±æ–‡è¯å…¸åŒ…å«ç‰›æ´¥8å’Œæœ—æ–‡4,ä¸­æ–‡è¯å…¸åŒ…å«æ±‰è¯­è¯å…¸3 è‹±æ–‡å°è¯•æ‹¼å†™çº é”™åŠŸèƒ½,åŠ¨è¯æ—¶æ€çº é”™ å¦‚æœé…ç½®äº†ä¸­æ–‡ä¼šå°è¯•æœç´¢æœ—æ–‡çš„ä¾‹å¥,æ¨¡ç³Šæœç´¢,å¯¹äºæœ‰è‹±è¯­åŸºç¡€çš„åŒå­¦å¾ˆæœ‰ç”¨ å¦‚æœé…ç½®äº†AIæ¨¡å‹,ä¼šä½¿ç”¨æœºå™¨å­¦ä¹ æ¨¡å‹ç¿»è¯‘,ç¿»è¯‘ç»“æœæ¯”è¾ƒç²—ç³™,ä½†æ˜¯å¯ä»¥å‚è€ƒ mdict-rs mdict-rsæºç 
å’Œpythonç‰ˆæœ¬ç›¸æ¯”ç›®å‰åªæœ‰åŸºæœ¬åŠŸèƒ½ï¼š mdxæ–‡ä»¶è§£æ,æŸ¥è¯¢.</content></entry><entry><title>Python 4é“ç¬”è¯•é¢˜</title><url>https://zhimoe.github.io/post/python-interview-questions/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>python</tag></tags><content type="html"> 4é“å¸¸è§çš„pythoné¢è¯•é¢˜å’Œè§£ç­”,ä»¥åŠä¸€äº›pythoné™·é˜±çš„é“¾æ¥.
é—®é¢˜ é¢˜ç›®1 def change(v): v[1] = 4 return v a = [1, 2, 3] print(change(a)) print(a) é¢˜ç›®2 def append1(x=[]): x.append(1) return x def now(n=time.time()): time.sleep(1) return n print(append1(), append1()) #? print(now(), now()) #? é¢˜ç›®3 def arr_multi(): x = [[0] * 3] * 3 x[0][0] = 42 return x print(arr_multi()) é¢˜ç›®4 def fn_for(): f = [lambda x: x * i for i in range(3)] print(f[0](1), f[1](1), f[2](1)) print(fn_for()) è§£ç­” [1, 4, 3] [1, 4, 3] # å°±æ˜¯ç®€å•çš„å¼•ç”¨ä¼ é€’,ä½†æ˜¯å¾ˆå¤šäººä¸è‡ªä¿¡,åœ¨é€‰æ‹©é¢˜é‡Œé¢é¢‘é¢‘å‡ºé”™. # pythonä¸­æ‰€æœ‰çš„éƒ½æ˜¯å¯¹è±¡, id(obj)ä¼šè¿”å›åœ°å€. # ä½†æ˜¯å¦‚æœæ–°å»ºå¯¹è±¡æ˜¯short string,int [-5,256],ä¸å¯å˜çš„ç©ºé›†åˆ(empty tuples) ç­‰æƒ…å†µä¸ä¼šçœŸçš„åˆ›å»ºæ–°å¯¹è±¡. from copy import copy, deepcopy arr1 = [1,2,3,[4,5,6]] arr2 = copy(arr1) # shallow copy, new id, but elements in array is same id id(arr1[0]) == id(arr2[0]) #deepcopy arr3 = deepcopy(arr1) # elements id is new # ç»“æœ: [1, 1] [1, 1] 1590544209.9695618 1590544209.9695618 # ä¸å°‘äººè®¤ä¸ºæ˜¯: [1] [1, 1].å…¶å®è¿˜æ˜¯æ²¡æœ‰æ·±å…¥ç†è§£å¼•ç”¨çš„åŸç†, # ç¿»è¯‘ä¸€ä¸‹å°±å¾ˆå¥½ç†è§£äº†: y = append1() # id(y) == id(x), y=[1] y = append1() # id(y) == id(x), y=[1,1] print(y,y) # æœ€å¥½ä¸è¦ä½¿ç”¨[]ä½œä¸ºé»˜è®¤å‚æ•°,ä½¿ç”¨ä¸‹é¢çš„å½¢å¼: def my_func(working_list=None): if working_list is None: working_list = [] working_list.append("a") print(working_list) # æˆ–è€… def fun(count=[]): count.append(2) #è¿™é‡Œcountä¸¤æ¬¡è°ƒç”¨å¦‚æœéƒ½ä½¿ç”¨é»˜è®¤å‚æ•°çš„è¯,åˆ™æ˜¯åŒä¸€ä¸ªæ•°ç»„,éå¸¸å±é™©! return count fun() #[2] fun() #[2,2] [[42, 0, 0], [42, 0, 0], [42, 0, 0]] # list æ˜¯mutable, []*3è¡¨ç¤ºæ˜¯å¼•ç”¨å¤åˆ¶ä¸‰æ¬¡. # èµ‹å€¼åä¸ºä»€ä¹ˆåªæ”¹å˜åˆ—çš„å€¼ï¼Ÿ 2 2 2 None æœ¬æ„å…¶å®æ˜¯æƒ³å¾—åˆ°ä¸€ä¸ªå‡½æ•°åˆ—è¡¨[0x,1x,2*x],
ä½†æ˜¯ Pythonâ€™s closures are late binding. This means that the values of variables used in closures are looked up at the time the inner function is called.
è§£å†³æ–¹æ¡ˆæ˜¯åå‡½æ•°partial
from functools import partial def fix_fn_for(): f = [partial(lambda y, x: y * x, x=i) for i in range(3)] print(f[0](1), f[1](1), f[2](1)) æˆ–ï¼š
fl=[lambda x, i=i: x*i for i in range(3)] å¸¸è§pythoné™·é˜±
The 10 Most Common Mistakes in Python
Some Common Gotchas in Python</content></entry><entry><title>Scala Python æ–‡ä»¶è¯»å–è·³è¿‡è½¬ä¹‰å­—ç¬¦</title><url>https://zhimoe.github.io/post/scala-python-file-encoding-escape/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>scala</tag><tag>python</tag></tags><content type="html"> åœ¨æ–‡ä»¶è¯»å–çš„æ—¶å€™,ä¼šé‡åˆ°éæ³•è½¬ä¹‰å­—ç¬¦,å¯¼è‡´æ–‡ä»¶æŒ‰è¡Œè¯»å–å¤±è´¥.æ­¤æ—¶å¯ä»¥é€šè¿‡å¿½ç•¥è½¬ä¹‰å­—ç¬¦æ¥è§£å†³.æœ¬æ–‡è®°å½•äº†scalaå’Œpythonçš„æ–¹æ³•.
èƒŒæ™¯ æœ‰50Gçš„æœåŠ¡å™¨æ—¥å¿—,æ‹†åˆ†ä¸ºå‡ åƒä¸ªtxtæ–‡ä»¶,ç¼–ç æ˜¯utf8,ä½¿ç”¨scalaå’ŒpythonæŒ‰è¡Œå¤„ç†ï¼š
scala def main(args: Array[String]): Unit = { for (line &lt;- Source.fromFile("./txt1.log","UTF8").getLines()) { if (line.contains("ABC")) { //do something } } } python with open('./txt1.log','r',encoding='utf-8') as f: for line in f: pass #do something ä½†æ˜¯æ–‡æœ¬ä¸­æœ‰ä¸€äº›è¡ŒåŒ…å«éæ³•çš„è½¬ä¹‰å­—ç¬¦,ä¾‹å¦‚ï¼š
http://bbc.com/search.html \xa3\xa9 404 \r\n ææ™“æ˜ å¯¼è‡´ç¨‹åºå¼‚å¸¸:
#scala java.nio.charset.MalformedInputException: Input length = 1 #python 'utf-8' codec can't decode byte 0xa3 in position 168: invalid start byte æ–¹æ¡ˆ ä¸€èˆ¬é‡åˆ°è¿™ç§éæ³•è½¬ä¹‰å­—ç¬¦,å¯ä»¥è·³è¿‡è¿™ä¸ªé”™è¯¯,çœ‹æˆraw stringæ¥å¤„ç†.
scala import java.nio.charset.CodingErrorAction import scala.io.{Codec, Source} implicit val codec = Codec("UTF-8") codec.onMalformedInput(CodingErrorAction.REPLACE) codec.onUnmappableCharacter(CodingErrorAction.REPLACE) // æ³¨æ„,fromFileæ–¹æ³•æ²¡æœ‰æä¾›"UTF8"å‚æ•° def main(args: Array[String]): Unit = { for (line &lt;- Source.fromFile("./test.file").getLines()) { if (line.contains("ABC")) { //do something } } } python with open('./txt1.log','r',encoding='utf-8',errors='ignore') as f: for line in f: pass #do something å¦‚æœç¡®è®¤æ–‡æœ¬ä¸­æ²¡æœ‰ä¸­æ–‡çš„è¯,ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸‹é¢çš„æ–¹å¼ç›´æ¥å°†å…¶è½¬ä¹‰æ‰
with open('./txt1.log','r',encoding='unicode_escape') as f:</content></entry><entry><title>Matplotlibå›¾ä¾‹ä¸­æ–‡ä¹±ç è§£å†³æ–¹æ¡ˆ</title><url>https://zhimoe.github.io/post/matplotlib-chinese-garbled-solution/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>python</tag></tags><content type="html"> å¾ˆä¹…ä»¥å‰å†™çš„ä¸€ä¸ªç­”æ¡ˆ,å››å¹´æ¥ä¸€ç›´æœ‰äººè¯„è®ºæ„Ÿè°¢,è¯´åªæœ‰æˆ‘çš„æ–¹æ³•æ˜¯æœ‰æ•ˆçš„.éå¸¸æ„å¤–ä¹Ÿå¾ˆé«˜å…´. ä¹Ÿæ”¾åˆ°åšå®¢ä¸­é‡Œå¤‡ä»½å§.
zhihu.com
# https://www.zhihu.com/question/25404709/answer/67672003 import matplotlib.font_manager as fm # å¾®è½¯é›…é»‘,å¦‚æœéœ€è¦å®‹ä½“,å¯ä»¥ç”¨simsun.ttc myfont = fm.FontProperties(fname='C:/Windows/Fonts/msyh.ttc') # Linuxå­—ä½“åœ¨"/usr/share/fonts/opentype/noto/NotoSansCJK-Regular.ttc", # éœ€è¦å…ˆå®‰è£…å­—ä½“">sudo apt install fonts-noto-cjk -y" # MacOSä¸­æ–‡å­—ä½“æ–‡ä»¶åœ¨"/System/Library/Fonts/PingFang.ttc" # Win10,Linuxå·²æµ‹è¯•,MacOSæœªéªŒè¯ import matplotlib.pyplot as plt plt.clf() # æ¸…ç©ºç”»å¸ƒ plt.plot([1, 2, 3], [4, 5, 6]) plt.xlabel("æ¨ªè½´",fontproperties=myfont) plt.ylabel("çºµè½´",fontproperties=myfont) plt.title("pythoner.com",fontproperties=myfont) plt.legend(['å›¾ä¾‹'],prop=myfont) plt.show()</content></entry><entry><title>Rust Ownerships Lifetimesæ•™ç¨‹</title><url>https://zhimoe.github.io/post/rust-ownership-lifetimes/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>rust</tag></tags><content type="html"> some notes on rust ownership,reference,string and &amp;str, and lifetimes
rust ownership //heap and stack: stack is store data that known,fixed size. //memory manager keeping track of what parts of code are using what data on the heap, //minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap //so you donâ€™t run out of space are all problems that ownership addresses. //ownership rules: // Each value in Rust has a variable thatâ€™s called its owner. // There can only be one owner at a time. // When the owner goes out of scope, the value will be dropped. // stack only data(æ ˆå†…æ•°æ®) assignment will make a copy operation, since it is fixed size, the copy is fast // rust use h.clone() make a heap data deeply copy. // impl the Copy trait can make the original variable still usable after assignment. // Copy trait can not use with Drop trait, Dropå¯ä»¥ç†è§£ä¸ºdestructor,å½“æ•°æ®è¶…è¿‡è‡ªå·±çš„scopeæ—¶, drop()æ–¹æ³•è¢«è°ƒç”¨; fn copy() { let x = 5; let y = x; //copy the value(5) in the stack,since it is fixed-size, the copy operation is fast let s1 = String::from("hello"); //String å’Œ &amp;stråŒºåˆ«è§åæ–‡ let s2 = s1; //now s1 is invalid // println!("{}, world!", s1); //error, the "hello" ownership move to s2 let s3 = s2.clone(); //copy the heap value("hello"), String impl the Clone trait println!("{}, world!", s2); //s2 still usable } // passing function arguments or return value by function is same as // assigning a value to a variable, you need take care the ownership of heap value, fn ownership() { let x = 5; let x10 = plus10(x);//x still usable since the x is stack data println!("{}", x); println!("{}", x10); let s = String::from("hello"); takes_ownership(s); //s's value moves into the function and so is no longer valid here //println!(s) ;//error! } fn plus10(i: i32) -> i32 { // since the i is primitive in stack, so the function return a new value i + 10 } fn takes_ownership(some_string: String) { // some_string comes into scope println!("{}", some_string); } // Here, some_string goes out of scope and `drop()` is called. The backing memory is freed. æ¨èé˜…è¯»A closer look at Ownership in Rust
References and Borrowing: // since the ownership is too hard to track by coder's eye, rust introduce the ref and borrowing // a function that accept a ref will not takeover a value's ownership when the function is called // also will not drop the value's backend memory when function is return. // a variable can only have one mut ref or many immutable ref in a same scope; //dangling reference fn dangle() -> &amp;String { let s = String::from("dangle ref"); &amp;s //error }// the s is dropped, but the function try to return s reference ### String vs str vs &amp;String vs &amp;str //1. String is heap string buffer //2. &amp;String is a ref of String //3. str is unknown immutable sequence of utf8 bytes stored somewhere in memory. the memory may be: // 3a. in binary: a string literal "foo" is a &amp;'static str. The data is hardcoded into the executable and loaded into memory when the program runs. // 3b. in heap: String implement Deref&lt;Target=str>, and so inherit all of str's methods. // 3c. in stack: when use str::from_utf8(x).unwrap(); x is stack-value ref //> the &amp;str param can accept a &amp;String since the String implement Deref&lt;Target=str>. // å³æ¥å—&amp;strçš„åœ°æ–¹éƒ½å¯ä»¥ä½¿ç”¨&amp;String //!!! since the str is unknown size, one can only use it by &amp;str, called slice. slice is a view of some data. fn str_demo() { let s = "hello str";//The type of s here is &amp;str: itâ€™s a slice pointing to that specific point of the binary. // This is also why string literals are immutable; &amp;str is an immutable reference. let mut string = s.to_string(); //&amp;str to String string.push_str(" append"); println!("{}", string); } //a slice has static lifetime let s = "hello"; //means let s: &amp;â€™static str = "hello"; lifetimes are only about reference a ref must die before its referent
in rust:
A resource can only have one owner at a time. When it goes out of the scope, Rust removes it from the Memory.
When we want to reuse the same resource, we are referencing it/ borrowing its content.
When dealing with references, we have to specify lifetime annotations to provide instructions for the compiler to set
how long those referenced resources should be alive.
â­ But because of lifetime annotations make the code more verbose, in order to make common patterns more ergonomic,
Rust allows lifetimes to be elided/omitted in fn definitions. In this case, the compiler assigns lifetime annotations
implicitly.
// No inputs, return a reference fn function1&lt;'a>() -> &amp;'a str {} // Single input fn function2&lt;'a>(x: &amp;'a str) {} // Single input and output, both have the same lifetime // The output should live at least as long as input exists fn function3&lt;'a>(x: &amp;'a str) -> &amp;'a str {} // no need the lifetime annotation,lifetime elision // Multiple inputs, only one input and the output share same lifetime // The output should live at least as long as y exists fn function4&lt;'a>(x: i32, y: &amp;'a str) -> &amp;'a str {} // Multiple inputs, both inputs and the output share same lifetime // The output should live at least as long as x and y exist fn function5&lt;'a>(x: &amp;'a str, y: &amp;'a str) -> &amp;'a str {} // Multiple inputs, inputs can have different lifetimes ğŸ” // The output should live at least as long as x exists fn function6&lt;'a, 'b>(x: &amp;'a str, y: &amp;'b str) -> &amp;'a str {} lifetimes in struct/enum // Single element // Data of x should live at least as long as Struct exists struct Struct1&lt;'a> { x: &amp;'a str } // Multiple elements // Data of x and y should live at least as long as Struct exists struct Struct2&lt;'a> { x: &amp;'a str, y: &amp;'a str } // Variant with a single element // Data of the variant should live at least as long as Enum exists enum Enum&lt;'a> { Variant(&amp;'a Type) }</content></entry><entry><title>SpringBootåº”ç”¨å’ŒRuståº”ç”¨çš„Dockerfileæœ€ä½³å®è·µ</title><url>https://zhimoe.github.io/post/dockerfile-best-practices/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>docker</tag><tag>spring</tag><tag>rust</tag></tags><content type="html"> è®°å½•spring bootå’Œrusté¡¹ç›®çš„Dockerfileçš„æœ€ä½³å®è·µ.
spring bootåº”ç”¨Dockerfile spring.ioæä¾›äº†ä¸€ä¸ªbootåº”ç”¨çš„DockerfileæŒ‡å¯¼.
ä¸è¿‡æœ‰ä¸ªé—®é¢˜,è¿™ä¸ªDockerfileä½¿ç”¨çš„mavenæ˜¯é¡¹ç›®æºç é‡Œé¢copyè¿‡å»çš„.åœ¨ä¸€èˆ¬ä¼ä¸šé¡¹ç›®ä¸­è¿™ä¹ˆåšæ˜¾ç„¶ä¸è§„èŒƒ,ç›´æ¥ä½¿ç”¨mavenåŸºç¡€é•œåƒæ›´åˆç†.
Dockerfileçš„æœ€ç»ˆç‰ˆ:
# syntax=docker/Dockerfile:experimental FROM maven:3-jdk-8-alpine as build WORKDIR /workspace/app COPY pom.xml . COPY src src RUN --mount=type=cache,target=/root/.m2 mvn package -DskipTests # app base image FROM openjdk:8-jdk-alpine VOLUME /tmp ARG BUILD=/workspace/app/target WORKDIR /app COPY --from=build ${BUILD}/*.jar . RUN jar -xf ./*.jar RUN rm ./*.jar ENTRYPOINT ["java","-cp","/app","org.springframework.boot.loader.JarLauncher"] è¦ç‚¹:
# syntax=docker/Dockerfile:experimentalè¡¨ç¤ºå¯ç”¨dockerå®éªŒç‰¹æ€§BuildKitçš„mount cacheåŠŸèƒ½,è¿™æ ·å¯ä»¥åˆ©ç”¨maven libçš„cacheæé«˜é•œåƒæ„å»ºé€Ÿåº¦. å¯ä»¥æœç´¢docker BuildKitäº†è§£.
å¦‚æœæ²¡æœ‰è¿™ä¸€è¡Œ,é‚£ä¹ˆä¸‹é¢çš„--mount=type=cache,target=/root/.m2å°±æ˜¯éæ³•çš„. ç”±äºæ˜¯å®éªŒç‰¹æ€§,æ„å»ºé•œåƒçš„æ—¶å€™éœ€è¦è®¾ç½®ä¸€ä¸ªç¯å¢ƒå˜é‡DOCKER_BUILDKIT=1æ‰èƒ½è¿è¡Œ: DOCKER_BUILDKIT=1 docker build -t zhimoe/boot-app . spring.ioçš„æ•™ç¨‹é‡Œé¢ä½¿ç”¨çš„buildé•œåƒæ˜¯openjdk:8-jdk-alpine,è¿™ä¸ªé•œåƒæ˜¯æ²¡æœ‰mavençš„,å› ä¸ºæ•™ç¨‹ä¸­çš„Dockerfileä»æºç å¤åˆ¶äº†mvnw,.mvn/åˆ°é•œåƒå».æ‰€ä»¥è¿™é‡Œæ›¿æ¢ä¸ºmaven:3-jdk-8-alpine ä½¿ç”¨äº†dockerçš„multi-stage buildåŠŸèƒ½,openjdk:8-jdk-alpineç”±äºæ²¡æœ‰maven,æ‰€ä»¥ä¼šæ¯”mavené•œåƒå°‘20M. spring.ioçš„æ•™ç¨‹é‡Œé¢åœ¨ENTRYPOINTé‡Œé¢æ˜¯ç›´æ¥è®¾ç½®main classå¯åŠ¨åº”ç”¨çš„. è¿™ç§ç¡¬ç¼–ç æ–¹å¼ä¸é€šç”¨ä¹Ÿä¸åˆ©äºç»´æŠ¤(ä¿®æ”¹main class nameåDockerfileä¹Ÿè¦ä¿®æ”¹).åªè¦å°†åº”ç”¨çš„jaråŒ…è§£å‹å‡ºæ¥çš„orgç›®å½•(å³org.springframework.boot.loader.jarè§£å‹å†…å®¹,ä¸åˆ°1M)ä¿ç•™,å³å¯é€šè¿‡org.springframework.boot.loader.JarLauncherå¯åŠ¨åº”ç”¨. æ³¨æ„java -cp /appä¸­çš„classpath:/app ä¸€å®šæ˜¯ç»å¯¹è·¯å¾„,å¦åˆ™javaæ‰¾ä¸åˆ°main class,æŠ¥é”™:Error: Could not find or load main class org.springframework.boot.loader.JarLauncher ruståº”ç”¨Dockerfile # pull the latest version of Rust FROM rust:latest AS builder # create a new empty shell project RUN USER=root cargo new --bin prj WORKDIR /prj # copy over your manifests COPY ./Cargo.lock ./Cargo.toml ./ # change the crate.io source COPY ./config $CARGO_HOME/ # this build step will cache your dependencies RUN cargo build --release RUN rm -r src/* # copy your source files to WORKDIR/src COPY ./src ./src COPY ./static ./static # build for release, note! the Cargo.toml package name in deps is _, not - RUN rm ./target/release/deps/rs_notes* RUN cargo build --release RUN mv ./target/release/rs-notes . ## 2 stage build # our final base FROM debian:stretch-slim AS app # for connecting to postgres and TLS hosts # RUN apt update -y &amp;&amp; apt install -y libpq-dev openssl libssl1.0-dev ca-certificates # copy the build artifact and static resources from the build stage COPY --from=builder /prj/rs-notes ./ COPY --from=builder /prj/static ./static # set the startup command to run your binary CMD ["./rs-notes"] è¦ç‚¹:
å¦‚æœä½¿ç”¨scratchæˆ–è€…alpineé•œåƒ,é‚£ä¹ˆéœ€è¦å°†ç¼–è¯‘ç›®æ ‡è®¾ç½®ä¸ºMUSL,ç½‘ç»œä¸Šæœ‰æ•™ç¨‹,ä¸ªäººæ„Ÿè§‰ä¸éœ€è¦.ruståº”ç”¨ä½¿ç”¨debian-slimåŸºæœ¬åœ¨60Må·¦å³,åªæœ‰spring bootåº”ç”¨é•œåƒçš„ä¸€åŠå¤§å°. åœ¨å›½å†…ç”±äºç½‘ç»œé—®é¢˜,æ‰€ä»¥ä¿®æ”¹äº†cargoçš„crate.io mirroråœ°å€:COPY ./config $CARGO_HOME/. configå†…å®¹å¦‚ä¸‹: [source.crates-io] registry = "https://github.com/rust-lang/crates.io-index" replace-with = 'ustc' [source.ustc] registry = "git://mirrors.ustc.edu.cn/crates.io-index" buildä¸­ä½¿ç”¨äº†cargoç¼“å­˜,å³å…ˆå°†é¡¹ç›®Cargo.tomlå’ŒCargo.lockå¤åˆ¶åˆ°ä¸€ä¸ªç©ºé¡¹ç›®ä¸­ç¼–è¯‘,ç„¶åå†å°†æºç å¤åˆ¶è¿›å»ç¼–è¯‘. RUN rm ./target/release/deps/rs_notes*,æ³¨æ„è¿™é‡Œçš„rs_notesæ˜¯ä¸‹åˆ’çº¿.cargoä¸­package nameè½¬æ¢ä¸ºcrate nameçš„é»˜è®¤è§„åˆ™.</content></entry><entry><title>Docker CMD ENTRYPOINTåŒºåˆ«</title><url>https://zhimoe.github.io/post/docker-cmd-entrypoint-diff/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>docker</tag></tags><content type="html"> è®°å½•dockerä¸­exec formå’Œshell formçš„åŒºåˆ«,CMDå’ŒENTRYPOINTåŒºåˆ«,ä»¥åŠæœ€ä½³å®è·µ.
exec form VS shell form # exec form &lt;instruction> ["executable", "param1", "param2", ...] # shell form &lt;instruction> &lt;command> exec form ä»¥JSONæ ¼å¼è§£æ,æ‰€ä»¥å‘½ä»¤å‚æ•°å¿…é¡»ä½¿ç”¨""åŒå¼•å·åŒ…è£¹; exec form ä¸ä¼šinvoke shell. æ‰€ä»¥CMD [ "echo", "$HOME" ]ä¸­$HOMEå˜é‡ä¸ä¼šè¢«æ›¿æ¢; shell formå®é™…æ˜¯æ‰§è¡Œ/bin/sh -c "&lt;command>"; ä¼˜å…ˆä½¿ç”¨ exec form,å› ä¸ºåœ¨shell formä¸­spawns your application in a new process and you wonâ€™t receive signals from Docker,åœ¨k8sä¸­ä¼šé‡åˆ°é—®é¢˜; åœ¨shell formä¹Ÿå¯ä»¥ä½¿ç”¨exec &lt;cmd>å½¢å¼; CMD VS ENTRYPOINT ç›´æ¥ç¿»è¯‘SOä¸Šé¢çš„å›ç­”,æ¯”è¾ƒæ¸…æ¥š
ENTRYPOINTæ˜¯å®¹å™¨æ‰§è¡Œå…¥å£,CMDæ˜¯å‚æ•°è®¾ç½®.
Dockeræœ‰é»˜è®¤çš„ ENTRYPOINT:/bin/sh -c,ä½†æ˜¯æ²¡æœ‰é»˜è®¤çš„CMD.ä½†æ˜¯ä¸€èˆ¬é•œåƒéƒ½ä¼šè®¾ç½®ä¸€ä¸ªé»˜è®¤çš„CMD.(æ³¨æ„æ˜¯dockerçš„é»˜è®¤ ENTRYPOINT,å’Œé•œåƒçš„é»˜è®¤CMD,åŸºç¡€é•œåƒä¸€èˆ¬ä¸è®¾ç½® ENTRYPOINT)
docker run -i -t ubuntu bash the ENTRYPOINT is the default /bin/sh -c, the image is ubuntu and the command is bash.
æ‰€ä»¥ä¸Šé¢çš„å‘½ä»¤å®é™…ä¸Šåœ¨å¯åŠ¨å®¹å™¨ä¸­æ‰§è¡Œäº†/bin/sh -c bash. ä¸æ˜¯æ‰€æœ‰åœºæ™¯éƒ½éœ€è¦"/bin/sh"çš„,æ‰€ä»¥å¼•å…¥äº† ENTRYPOINT and --entrypoint.
docker run -i -t ubuntuä¸­ ubuntu(é•œåƒå)åé¢è·Ÿçš„æ‰€æœ‰å†…å®¹éƒ½ä½œä¸ºå‚æ•°ä¼ é€’ç»™entrypoint. è¿™å’Œä½¿ç”¨CMDæŒ‡ä»¤æ˜¯å®Œå…¨ä¸€æ ·çš„,ä¹Ÿå³æ˜¯CMDæŒ‡ä»¤å¯ä»¥åœ¨docker runä¸­è¦†ç›–.
ç”±äºubuntué•œåƒè®¾ç½®äº†é»˜è®¤CMD: CMD ["bash"],æ‰€ä»¥docker run -i -t ubuntuå’Œdocker run -i -t ubuntu bashæ˜¯å®Œå…¨ä¸€æ ·çš„æ•ˆæœ.
æ‰€ä»¥åˆ°æ­¤,å¯ä»¥æ€»ç»“: ENTRYPOINT æ˜¯å®¹å™¨çš„æ‰§è¡Œå…¥å£,CMDæ˜¯å‚æ•°è®¾ç½®,ä¸è¿‡å‚æ•°ä¹Ÿå¯ä»¥æ˜¯bashä¸­çš„å¯æ‰§è¡Œå‘½ä»¤(ä¾‹å¦‚,CMD ["echo","hello"],å®é™…æ‰§è¡Œ /bin/sh -c "echo hello").
ENTRYPOINTå’ŒCMDçš„æ­é…å¯ä»¥å®ç°å°†å®¹å™¨ä½œä¸ºä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶å¯åŠ¨,è¿™ä¸ªç‰¹æ€§ä¹Ÿæ˜¯æˆ‘ä»¬æ—¥å¸¸ä½¿ç”¨dockerçš„ä¸»è¦ç›®çš„.ä¾‹å¦‚åœ¨Dockerfileä¸­è®¾ç½®:
ENTRYPOINT ["/bin/cat"] è¿è¡Œdocker run cat-img /etc/passwd,/etc/passwd æ˜¯cmd, å®é™…æ‰§è¡Œçš„æ˜¯/bin/cat /etc/passwd. æ­å–œä½ ,å¾—åˆ°ä¸€ä¸ªcatç¨‹åº,å‡è®¾ä½ å®‰è£…äº†ä¸€ä¸ªlinuxç³»ç»Ÿ,é‡Œé¢æ²¡æœ‰catå‘½ä»¤,cat-imgé•œåƒå°±å¯ä»¥å®ç°ä½ æƒ³è¦çš„åŠŸèƒ½.
å†ä¾‹å¦‚ä½ æœ‰ä¸ªredisé•œåƒ,ä¸å…¶è¿è¡Œ docker run redis-img redis -H srv-host -u toto get key,
ä¸å¦‚è®¾ç½®ENTRYPOINT ["redis", "-H", "srv-host", "-u", "toto"] ç„¶åè¿è¡Œdocker run redis-img get key.
Dockerfileåªæœ‰æœ€åä¸€ä¸ªCMDä¼šç”Ÿæ•ˆ; å¯ä»¥ä½¿ç”¨docker inspect &lt;img-id>æŸ¥çœ‹é»˜è®¤çš„CMDå‚æ•°; å–æ¶ˆé»˜è®¤ENTRYPOINT,å¯ä»¥åœ¨Dockerfileä¸­è®¾ç½®: ENTRYPOINT []</content></entry><entry><title>scala uniform access principle</title><url>https://zhimoe.github.io/post/scala-uniform-access-principle/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>scala</tag></tags><content type="html"> è™½ç„¶ä»£ç å†™çš„å¾ˆæ°´,ä½†æ˜¯æˆ‘å¯¹å„ç§ç¼–ç¨‹è¯­è¨€ä¸€ç›´æ¯”è¾ƒæ„Ÿå…´è¶£. é™¤äº†å·¥ä½œä¸­ä½¿ç”¨çš„Javaä¹‹å¤–,è‡ªå·±ä¹Ÿäº†è§£Python,Groovy,Scala,Kotlin,Clojure,Go,Rust.å…¶ä¸­Pythonå’ŒScalaåœ¨å·¥ä½œä¸­ä¹Ÿå¶å°”ä½¿ç”¨. äº†è§£ä¸åŒçš„ç¼–ç¨‹è¯­è¨€è¯­æ³•å¯¹äºç¼–ç¨‹æ€ç»´çš„å½±å“è¿˜æ˜¯è›®æœ‰æ„æ€çš„.
ä¾‹å¦‚, åªä¼šJavaçš„å¼€å‘è€…å¯èƒ½æ²¡æœ‰å¬è¿‡æ¨¡å¼åŒ¹é…(pattern match).åœ¨æˆ‘å­¦ä¹ äº†Scalaä¹‹å,æˆ‘å¯¹æ¨¡å¼åŒ¹é…çš„ç†è§£å°±æ˜¯æ›´å¼ºæ›´ä¼˜é›…çš„switch+if. è€Œåœ¨æˆ‘çœ‹è¿‡rustå’Œelixirè¯­è¨€ä¸­å…³äºæ¨¡å¼åŒ¹é…ä¹‹å,æˆ‘å¯¹æ¨¡å¼åŒ¹é…çš„ç†è§£å°±å®Œå…¨ä¸ä¸€æ ·äº†.
è¿™äº›è¯­è¨€ä¸­,è®ºè¯´å¯¹ç¼–ç¨‹æ€ç»´æ”¹å˜æœ€å¤§çš„å½“å±Clojureè«å±. Lispè¯­è¨€æ˜¯ä¸€ç§éå¸¸ä¼˜é›…çš„è¯­è¨€. è¿™ç§ä¼˜é›…çš„æœ€å¤§ç‰¹ç‚¹å°±æ˜¯Lisp(Clojure)ä»è¯­æ³•ä¸Šé¢åšåˆ°äº†ä»£ç å³æ•°æ®.å³Clojureçš„ä»£ç å½¢å¼å’Œå…¶æ•°æ®ç»“æ„listçš„å½¢å¼æ˜¯ä¸€æ ·çš„(è¿™ä¹Ÿæ˜¯lispåå­—ç”±æ¥,LISt Processor).
è¿™ä¸ªç‰¹ç‚¹çš„å¥½å¤„å°±æ˜¯Clojureèµ‹äºˆäº†listè¿™ç§æ•°æ®ç»“æ„å¼ºå¤§çš„è¡¨è¾¾èƒ½åŠ›,å¯ä»¥åœ¨ä½¿ç”¨æå…¶ç®€ç»ƒçš„è¯­æ³•åœ¨listæ•°æ®ç»“æ„å®ç°å¤æ‚çš„é€»è¾‘.
&ldquo;It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.&rdquo; â€”Alan Perlis
å°½å¯èƒ½çš„å‡å°‘è¯­æ³•çš„è§„åˆ™,è¿™ç§è¯­æ³•ç‰¹ç‚¹åœ¨Scalaä¸Šé¢ä¹Ÿæœ‰ä½“ç°.
uniform access principle scala ä¸­ç»Ÿä¸€è®¿é—®åŸåˆ™å°†classçš„æ–¹æ³•å’Œå±æ€§è®¿é—®ç»Ÿä¸€,éƒ½æ˜¯é€šè¿‡obj.mbrè®¿é—®.
è¿™ä¹ˆåšçš„å¥½å¤„æ˜¯ä»£ç æ›´åŠ ç»Ÿä¸€,è€Œä¸”é‡æ„æ›´åŠ æ–¹ä¾¿.
A function that takes no parameters, which is defined without any empty parentheses.
Invocations of parameter less functions may not supply parentheses.
This supports the uniform access principle, which enables the def to be changed into a val without
requiring a change to client code.
class Person { private var privateName = "" def name = privateName def name_=(value: String) = privateName = value } val john = new Person john.name = "John Doe" println(john.name) ç»Ÿä¸€ä¹Ÿä½“ç°åœ¨é›†åˆè®¿é—®å½¢å¼ä¸Š,åœ¨Scalaä¸­,Map,List,Arrayçš„å…ƒç´ è®¿é—®éƒ½æ˜¯é€šè¿‡coll(ki)å½¢å¼. kiè¡¨ç¤ºkeyæˆ–è€…index.ä¸ªäººéå¸¸å–œæ¬¢è¿™ç§ç»Ÿä¸€.</content></entry><entry><title>Highlights in Scala for Impatient 2nd</title><url>https://zhimoe.github.io/post/highlights-in-scala-for-impatient-2nd/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>scala</tag><tag>scala-for-impatient</tag></tags><content type="html"> key points in scala-for-impatient 2nd book, best book for java developer to use scala in a rush.
scala-for-impatientç« èŠ‚æ‘˜è¦, è¿™æœ¬ä¹¦å¯¹äºJavaå¼€å‘è€…å¿«é€Ÿä¸Šæ‰‹Scalaå¸®åŠ©å¾ˆå¤§.
Functions â€¢ if expression has a value. â€¢ A block has a value â€” the value of its last expression. â€¢ The Scala for loop is like an â€œenhancedâ€ Java for loop. â€¢ Semicolons are (mostly) optional. â€¢ The void type is Unit. â€¢ Avoid using `return` in a function. â€¢ Beware of missing = in a function definition. â€¢ Exceptions work just like in Java or C++, but you use a â€œpattern matchingâ€ syntax for catch. â€¢ Scala has no checked exceptions. Arrays â€¢ Use an Array if the length is fixed, and an ArrayBuffer if the length can vary. â€¢ Donâ€™t use new when supplying initial values. â€¢ Use () to access elements. â€¢ Use for (elem &lt;- arr) to traverse the elements. â€¢ Use for (elem &lt;- arr if . . . ) . . . yield . . . to transform into a new array. â€¢ Scala and Java arrays are interoperable; with ArrayBuffer, use scala.collection.JavaConverters._ don't use scala.collection.JavaConversions. import scala.collection.mutable.ArrayBuffer val b = ArrayBuffer[Int]() // Or new ArrayBuffer[Int] // An empty array buffer, ready to hold integers b += 1 // ArrayBuffer(1) // Add an element at the end with += b += (1, 2, 3, 5) // ArrayBuffer(1, 1, 2, 3, 5) // Add multiple elements at the end by enclosing them in parentheses b ++= Array(8, 13, 21) // ArrayBuffer(1, 1, 2, 3, 5, 8, 13, 21) // You can append any collection with the ++= operator b.trimEnd(5) // ArrayBuffer(1, 1, 2) // Removes the last five elements b.insert(2, 6) // ArrayBuffer(1, 1, 6, 2) // Insert before index 2 // iterate array with index // use view or use index(it's faster) for (i&lt;-b.indices){val v = b(i)} Maps &amp; Tuples var scores = Map("Alice" -> 10, "Bob" -> 3, "Cindy" -> 8) val scores2 = Map(("Alice", 10), ("Bob", 3), ("Cindy", 8)) val bobsScore = scores("Bob") // Like scores.get("Bob") in Java val scores1 = scala.collection.mutable.Map("Alice" -> 10, "Bob" -> 3, "Cindy" -> 8) val scores3 = scala.collection.mutable.Map[String, Int]() scores1("Bob") = 10 val v = scores1("Bob") // NPE if key is not exists scores1.get("Bob") // None if key is not exists scores1.getOrElse("Bob",10)// 10 if key is not exists scores1 += ("Bob" -> 10, "Fred" -> 7) scores1 -= "Alice" // for immutable val newScores = scores + ("Bob" -> 10, "Fred" -> 7) // New map with update val scores4 = scores - "Alice" scores -= "Alice" for ((k, v) &lt;- scores){} for ((k, v) &lt;- scores) yield (v, k) // sorted map val sortedScores = scala.collection.mutable.SortedMap("Alice" -> 10,"Fred" -> 7, "Bob" -> 3, "Cindy" -> 8) // insert order val months = scala.collection.mutable.LinkedHashMap("January" -> 1,"February" -> 2, "March" -> 3, "April" -> 4, "May" -> 5) import scala.collection.JavaConverters._ // tuple val t = (1, 3.14, "Fred") val second = t._2 // Sets second to 3.14 val keys = Array() val values = Array() val kv = keys.zip(values).toMap() Object â€¢ Use objects for singletons and utility methods. â€¢ A class can have a companion object with the same name. â€¢ Objects can extend classes or traits. â€¢ The apply method of an object is usually used for constructing new instances of the companion class. â€¢ To avoid the main method, use an object that extends the App trait. â€¢ You can implement enumerations by extending the Enumeration object. Package The key points of this chapter are: â€¢ Packages nest just like inner classes. â€¢ Package paths are not absolute. â€¢ A chain x.y.z in a package clause leaves the intermediate packages x and x.y invisible. â€¢ Package statements without braces at the top of the file extend to the entire file. â€¢ A package object can hold functions and variables. â€¢ Import statements can import packages, classes, and objects. â€¢ Import statements can be anywhere. â€¢ Import statements can rename and hide members. â€¢ java.lang, scala, and Predef are always imported Inheritance â€¢ The `extends` and `final` keywords are as in Java. â€¢ You must use `override` when you override a method. â€¢ Only the primary constructor can call the primary superclass constructor. â€¢ You can `override` fields. Files â€¢ Source.fromFile(...).getLines.toArray yields all lines of a file. â€¢ Source.fromFile(...).mkString yields the file contents as a string. â€¢ To convert a string into a number, use the toInt or toDouble method. â€¢ Use the Java PrintWriter to write text files. â€¢ "regex".r is a Regex object. â€¢ Use """...""" if your regular expression contains backslashes or quotes. â€¢ If a regex pattern has groups, you can extract their contents using the syntax for (regex(var1, ...,varn) &lt;- string). Traits Key points of this chapter: â€¢ A class can implement any number of traits. â€¢ Traits can require implementing classes to have certain fields, methods, or superclasses. â€¢ Unlike Java interfaces, a Scala trait can provide implementations of methods and fields. â€¢ When you layer multiple traits, the order mattersâ€”the trait whose methods execute first goes to the back. Operators val a = 10 //a: Int = 10 -a // res0: Int = -10 //means the same as a.unary_-. a.unary_- //res1: Int = -10 High Order Functions Array(3.14, 1.42, 2.0).map{ (x: Double) => 3 * x } //== Array(3.14, 1.42, 2.0) map { (x: Double) => 3 * x } // diff method and function Collections The key points of this chapter are: â€¢ All collections extend the Iterable trait. â€¢ The three major categories of collections are sequences, sets, and maps. â€¢ Scala has mutable and immutable versions of most collections. â€¢ A Scala list is either empty, or it has a head and a tail which is again a list. â€¢ Sets are unordered collections. â€¢ Use a LinkedHashSet to retain the insertion order or a SortedSet to iterate in sorted order. â€¢ + adds an element to an unordered collection; +: and :+ prepend or append to a sequence; ++ concatenates two collections; - and -- remove elements. â€¢ The Iterable and Seq traits have dozens of useful methods for common operations. Check them out before writing tedious loops. â€¢ Mapping, folding, and zipping are useful techniques for applying a function or operation to the elements of a collection Iterable trait methods: head, last, headOption, lastOption tail, init length, isEmpty map(f), flatMap(f), foreach(f), transform(f), collect(pf) reduceLeft(op), reduceRight(op),foldLeft(init)(op), foldRight(init)(op) reduce(op), fold(init)(op),aggregate(init)(op, combineOp) sum, product, max, min count(pred), forall(pred), exists(pred) filter(pred), filterNot(pred), partition(pred) takeWhile(pred), dropWhile(pred), span(pred) take(n), drop(n), splitAt(n) takeRight(n), dropRight(n) slice(from, to), view(from, to) zip(coll2), zipAll(coll2, fill, fill2), zipWithIndex(cation! the 2nd value in tuple is index) grouped(n), sliding(n) groupBy(k) // mkString(before, between, after), addString(sb, before, between, after) toIterable, toSeq, toIndexedSeq, toArray, toBuffer, toList, toStream, toSet, toVector, toMap, to[C] Important Methods of the Seq Trait: contains(elem), containsSlice(seq), startsWith(seq), endsWith(seq) indexOf(elem), lastIndexOf(elem), indexOfSlice(seq), lastIndexOfSlice(seq), indexWhere(pred) prefixLength(pred), segmentLength(pred, n) padTo(n, fill) intersect(seq), diff(seq) reverse sorted, sortWith(less), sortBy(f) permutations, combinations(n) //The map and flatMap methods are important because they are used //for translating for expressions. For example, the expression: for (i &lt;- 1 to 10) yield i * i //is translated to (1 to 10).map(i => i * i) //and for (i &lt;- 1 to 10; j &lt;- 1 to i) yield i * j //becomes (1 to 10).flatMap(i => (1 to i).map(j => i * j)) val coll = List() coll.par.sum coll.par.count(_ % 2 == 0) for (i &lt;- (0 until 100000).par) print(s" $i") (for (i &lt;- (0 until 100000).par) yield i) == (0 until 100000) Pattern Matching The key points of this chapter are: â€¢ The match expression is a better switch, without fall-through. â€¢ If no pattern matches, a MatchError is thrown. Use the case _ pattern to avoid that. â€¢ A pattern can include an arbitrary condition, called a guard. â€¢ You can match on the type of an expression; prefer this over isInstanceOf/asInstanceOf. â€¢ You can match patterns of arrays, tuples, and case classes, and bind parts of the pattern to variables. â€¢ In a for expression, nonmatches are silently skipped. â€¢ A case class is a class for which the compiler automatically produces the methods that are needed for pattern matching. â€¢ The common superclass in a case class hierarchy should be sealed. â€¢ Use the Option type for values that may or may not be presentâ€”it is safer than using null. Annotations The key points of this chapter are: â€¢ You can annotate classes, methods, fields, local variables, parameters,expressions, type parameters, and types. â€¢ With expressions and types, the annotation follows the annotated item. â€¢ Annotations have the form @Annotation, @Annotation(value), or @Annotation(name1 =value1, ...). â€¢ @volatile, @transient, @strictfp, and @native generate the equivalent Java modifiers. â€¢ Use @throws to generate Java-compatible throws specifications. â€¢ The @tailrec annotation lets you verify that a recursive function uses tail call optimization. â€¢ The assert function takes advantage of the @elidable annotation. You can optionally remove assertions from your Scala programs. â€¢ Use the @deprecated annotation to mark deprecated features. Future The key points of this chapter are: â€¢ A block of code wrapped in a Future { ... } executes concurrently. â€¢ A future succeeds with a result or fails with an exception. â€¢ You can wait for a future to complete, but you donâ€™t usually want to. â€¢ You can use callbacks to get notified when a future completes, but that gets tedious when chaining callbacks. â€¢ Use methods such as map/flatMap, or the equivalent for expressions, to compose futures. â€¢ A promise has a future whose value can be set (once), which gives added flexibility for implementing tasks that produce results. â€¢ Pick an execution context that is suitable for the concurrent workload of your computation. Implicits The key points of this chapter are: â€¢ Implicit conversions are used to convert between types. â€¢ You must import implicit conversions so that they are in scope. â€¢ An implicit parameter list requests objects of a given type. They can be obtained from implicit objects that are in scope, or from the companion object of the desired type. â€¢ If an implicit parameter is a single-argument function, it is also used as an implicit conversion. â€¢ A context bound of a type parameter requires the existence of an implicit object of the given type. â€¢ If it is possible to locate an implicit object, this can serve as evidence that a type conversion is valid. Type Class CanBuildFrom</content></entry><entry><title>Rust Packages Crates Mod Notes</title><url>https://zhimoe.github.io/post/rust-packages-crates-mod/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>rust</tag></tags><content type="html"> åˆå­¦rustå¯¹äºé¡¹ç›®çš„packageå’Œcrateçš„å…³ç³»,moduleå’Œæ–‡ä»¶çš„å…³ç³»æœ‰ç‚¹ç†ä¸æ¸….åšäº†ä¸€ç‚¹ç¬”è®°.
packages, crates and modules A Cargo.toml is a package. and must have a package name, like
[package] name = "actix-web" A package(project) contains one or more crates;
A package CAN contain as many binary crates as youâ€™d like, but it must contain at least one crate (either library or binary);
use src/main.rs, will build to package-name binary, or use src/bin/b1.rs,src/bin/b2.rs, wil get 2 binaries: b1,b2.
A package must contain zero or one(0æˆ–è€…1ä¸ª) library crates, and no more.
by convention, package-name is use - (dash,can be _), but lib_name must use _ (underscores, can not be -);
cargo will auto replace the - with _ in package-name to name the default library crate(lib.rs in src root). Also you can name it in [lib]:
[lib] name = "actix_web" path = "src/lib.rs" # also you can rename the binary: # it use [[]], array in toml [[bin]] name = "my-cool-binary" path = "src/my-cool-binary.rs" one package(project) can only have one library crate, when the lib continues to get bigger, you want to split up the lib into multiple packages.
cargo introduce you with workspace.
A workspace is a set of packages that share the same Cargo.lock and output directory.
here is the actix-web package Cargo.toml file:
[workspace] members = [ ".", "awc", "actix-http", "actix-cors", "actix-files", "actix-framed", "actix-session", "actix-identity", "actix-multipart", "actix-web-actors", "actix-web-codegen", "test-server", ] # awc,actix-http... all are packages that contains their own Cargo.toml and src/lib.rs; A crate is a compilation unit in Rust.
Whenever rustc some_file.rs is called, some_file.rs is treated as the crate file.
If some_file.rs has mod declarations in it, then the contents of the module files would be inserted
in places where mod declarations in the crate file are found, before running the compiler it.
In other words, modules do not get compiled individually, only crates get compiled.
mod mod_name {} defines a mod.
mod mod_name; cargo will look for mod_name.rs or mod_name/mod.rs and insert the content to current file.
by default the mod is private; but nested mod is allowed to use any code in super mod;
self and super is to ref the current mod and super mod;
fn main(){ // absolute path crate::music::popular::play(); // relative path music::popular::play(); } the Structs members is all private by default even struct name is pub;
the Enums members is all public by default if the name is pub;
use keyword the use keyword brings path(crate mod path) into scope;
//bring a module into scope with `use` and a relative path need start `self`: use self::music::popular; //!!!the self:: is no needed in rust 2018+ //use the absolute path use crate::music::popular; //make the path to public pub use crate::music::popular; //use use std::{cmp::Ordering,io}; use std::{self,Write}; split up mod into files the mod can be defined in mod_name.rs or mod_name/mod.rs. and nested mod can be in mod_name/nested_mod.rs. you can ref the nested_mod by use mod nested_mod; in mod_name.rs; summary ç®€å•ç²—æš´çš„ç†è§£,ä¸€ä¸ªé¡¹ç›® == ä¸€ä¸ªpackage, ä¸€ä¸ªpackageå¯ä»¥åŒ…å«å¤šä¸ªcrate.
crateæ˜¯Cargoçš„ç¼–è¯‘å•å…ƒ,ä¹Ÿæ˜¯Cargo.tomlä¸­[dependencies]çš„ä¾èµ–å•å…ƒ.
ä¸€ä¸ªpackageåªèƒ½åŒ…å«ä¸€ä¸ªlib crate(src/lib.rs),ä½†æ˜¯å¯ä»¥åœ¨src/main.rsæˆ–è€…src/bin/*.rsä¸‹é¢åŒ…å«ä»»æ„å¤šä¸ªbin crate;
å¯¹äºå¤æ‚é¡¹ç›®,å¯ä»¥é€šè¿‡cargoçš„[workspace]ç®¡ç†å¤šä¸ªcrate,è¿™æ ·å¯ä»¥å®ç°ä¸€ä¸ªCargo.tomlç®¡ç†/æ„å»ºå¤šä¸ªlib crate.
modæ˜¯rustä¸­ä»£ç çš„ç»„ç»‡æœ€å°å•å…ƒ. mod mod_name {} æ˜¯å®šä¹‰ä¸€ä¸ªmod;mod mod_name; è¡¨ç¤ºå°†mod_name.rsæˆ–è€…mod_name/mod.rsä¸­çš„å†…å®¹æ’å…¥åˆ°å½“å‰æ–‡ä»¶å½“å‰ä½ç½®,å¹¶ä¸”æ’å…¥å†…å®¹è¢«åŒ…å«åœ¨mod mod_nameä¸­.
crateå†…éƒ¨çš„modå¼•ç”¨ä½¿ç”¨self::å¼€å¤´,å¼•ç”¨å¤–éƒ¨crateåˆ™ä½¿ç”¨crate::å¼€å¤´.</content></entry><entry><title>git å¸¸ç”¨å‘½ä»¤å¤‡å¿˜å½•</title><url>https://zhimoe.github.io/post/git-useful-tips/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>git</tag><tag>code</tag></tags><content type="html"> è®°å½•æ—¥å¸¸å¼€å‘ä¸­å¶å°”ä¼šé‡åˆ°çš„ä½†æ˜¯æ€»æ˜¯è®°ä¸ä½çš„gitå‘½ä»¤.
ä»¥ä¸‹æŠ€å·§éƒ½æ¥è‡ªäºoh shit git å’Œ stackoverflow. ç‰ˆæƒå½’ä½œè€…æ‰€æœ‰.
delete all history commit and commit current content git checkout --orphan tmp_branch &amp;&amp; git add -A &amp;&amp; git commit -am "first commit" &amp;&amp; git branch -D master &amp;&amp; git branch -m master &amp;&amp; git push -f origin master store password in local git config credential.helper store git reflog git reflog # you will see a list of every thing you've # done in git, across all branches! # each one has an index HEAD@{index} # find the one before you broke everything git reset HEAD@{index} # magic time machine git commit &ndash;amend # make your change git add . # or add individual files git commit --amend --no-edit # now your last commit contains that change! # WARNING: never amend public(remote) commits!!! # I need to change the message on my last commit! git commit --amend # follow prompts to change the commit message undo a commit # Oh shit, I need to undo a commit from like 5 commits ago! # find the commit you need to undo git log # use the arrow keys to scroll up and down in history # once you've found your commit, save the hash git revert [saved hash] # git will create a new commit that undoes that commit # follow prompts to edit the commit message # or just save and commit undo a file&rsquo;s changes # find a hash for a commit before the file was changed git log # use the arrow keys to scroll up and down in history # once you've found your commit, save the hash git checkout [saved hash] -- path/to/file # the old version of the file will be in your index git commit -m "Wow, you don't have to copy-paste to undo" git stash # å¦‚æœä¸´æ—¶æƒ³è¦å°†ä»£ç æ¢å¤åˆ°æœ€è¿‘ä¸€æ¬¡commit,å¸®åŠ©åŒäº‹å¤ç°ä»–çš„é—®é¢˜ # ä½¿ç”¨git stash æš‚å­˜å½“å‰ä¿®æ”¹,è¿™ä¸ªä¸æ˜¯stage,ä¹Ÿä¸æ˜¯commit git stash # æ˜¾ç¤ºå½“å‰æš‚å­˜å†å² git stash list # æ‰¾å›æš‚å­˜ git stash apply # or spec which the stash git stash apply stash@{1} git rebase git pull request git cherry-pick commit change in submodule # submodule is a independent repo, # so you need commit/push change in submodule first and then # update(commit) the main project to refer a new submodule commit hash # step 1 cd path/to/submodule git add &lt;stuff> git commit -m "comment" git push # step 2 cd /main/project git add path/to/submodule git commit -m "updated my submodule" git push</content></entry><entry><title>DevOpsèƒ½åŠ›æˆç†Ÿåº¦æ¨¡å‹</title><url>https://zhimoe.github.io/post/devops-maturity-model-checklist/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>devops</tag></tags><content type="html"> ä¹‹å‰å¬è¯´è¿‡AWSçš„è½¯ä»¶å·¥ç¨‹å¸ˆæ˜¯éœ€è¦è‡ªå·±å†™éœ€æ±‚è¯´æ˜ä¹¦,å‰åç«¯ä»£ç ,æµ‹è¯•å’Œä¸Šçº¿.è¿˜æœ‰instagramçš„å·¥ç¨‹å¸ˆå¯ä»¥åšåˆ°pythonçš„ä»£ç æäº¤å¦‚æœåˆå¹¶åˆ°ä¸»åˆ†æ”¯åå¯ä»¥åœ¨ä¸€ä¸ªå°æ—¶å†…è‡ªåŠ¨éƒ¨ç½²åˆ°ç”Ÿäº§è¢«ç”¨æˆ·ä½¿ç”¨åˆ°,æ„Ÿè§‰è¿™ä¸ªéå¸¸ç¥å¥‡.å¦‚æœéœ€è¦åšåˆ°è¿™ä¸ª,å¯¹ç»„ç»‡çº§ä¸ä¸ªäººéƒ½æœ‰æé«˜çš„devopsèƒ½åŠ›æˆç†Ÿåº¦è¦æ±‚.
ä¸Šå‘¨ä»£è¡¨CRMé¡¹ç›®é€šè¿‡äº†ä¿¡é€šé™¢çš„DevOpsä¸‰çº§è®¤è¯.æ„Ÿè§‰æå‡çš„ç©ºé—´å¾ˆå¤§. ä¸“é—¨çœ‹äº†ä¸€ä¸‹æˆç†Ÿåº¦æ¨¡å‹çš„æ ‡å‡†.
æ ¸å¿ƒè¦ç‚¹æ˜¯è¦æœ‰ç»Ÿä¸€çš„ç®¡ç†ç³»ç»Ÿ,ç³»ç»Ÿä¹‹é—´éœ€è¦è”åŠ¨,
ä¾‹å¦‚è®°å½•æ•…äº‹çš„ç³»ç»Ÿ,å¦‚ä½•å’Œä½ æäº¤è®°å½•å…³è”?
æµ‹è¯•çš„ç¼ºé™·é—®é¢˜å¦‚ä½•å’Œä½ çš„æ•…äº‹å…³è”?
ç”Ÿäº§æ­£åœ¨è¿è¡Œçš„ä»£ç ,å¦‚ä½•å’Œä»£ç åº“çš„æŸä¸ªåŸºçº¿å¯¹åº”ä¸Š?
æµ‹è¯•æŠ¥å‘Š/éœ€æ±‚è¯´æ˜ä¹¦æ˜¯å¦ç»Ÿä¸€ç®¡ç†å¹¶å’Œä½ çš„è¿­ä»£æœ‰å…³è”?
æ˜¯å¦å¯ä»¥åšåˆ°äº‹æ•…åå®šä¼šä¹‹åå›æ»šéƒ¨ç½²?
ç ”å‘è¿è¥ä¸€ä½“åŒ–ï¼ˆDevOpsï¼‰èƒ½åŠ›æˆç†Ÿåº¦æ¨¡å‹ ç¬¬1éƒ¨åˆ†ï¼šæ€»ä½“æ¶æ„</content></entry><entry><title>Scala Collection Tips</title><url>https://zhimoe.github.io/post/scala-collection-tips/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>scala</tag></tags><content type="html"> scala collection æä¾›äº†ä¸€æ•´å¥—ç‹¬ç«‹äºJavaçš„é«˜æ€§èƒ½é›†åˆ,ä½¿ç”¨ä¸Šéå¸¸çµæ´»,æ‰€ä»¥éœ€è¦æ¸…æ¥šä¸€äº›å¸¸ç”¨çš„æ–¹æ³•:
reduce fold scan é›†åˆçš„ç¬¦å·æ–¹æ³• æ•°ç»„,tuple 2.13çš„é›†åˆæ¶æ„ reduce fold scan //reduceæ˜¯ä¸€ä¸ªäºŒå…ƒå‡½æ•°,éå†æ•´ä¸ªé›†åˆ List(1, 3, 5).reduceLeft(_ + _) // == ((1+3)+5) //reduceRight start from end of the collection //also you can given initial argument List(1, 3, 5).foldLeft("")(_ + _) // == 135 //foldLeft ç­‰ä»·äº \: æ“ä½œç¬¦ (0 /: List(1, 3, 5)) (_ - _) //folding å¸¸ç”¨äºæ›¿ä»£for-loop val wf1 = scala.collection.mutable.Map[Char, Int]() for (c &lt;- "Mississippi") wf1(c) = wf1.getOrElse(c, 0) + 1 // Now freq is Map('i' -> 4, 'M' -> 1, 's' -> 4, 'p' -> 2) //æ³¨æ„ä½¿ç”¨äº†ä¸å¯å˜map val wf = (Map[Char, Int]() /: "Mississippi") { (m, c) => m + (c -> (m.getOrElse(c, 0) + 1)) } //scan æ–¹æ³•å¯ä»¥è·å¾—æ¯ä¸€æ­¥ä¸­é—´ç»“æœé›† (1 to 10).scanLeft(0)(_ + _) //Vector(0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55) é›†åˆçš„ç¬¦å·æ–¹æ³• //+ è¡¨ç¤ºæ·»åŠ ä¸€ä¸ªå…ƒç´ åˆ°æ— åºé›†åˆ // :+ +:è¡¨ç¤ºæ·»åŠ åˆ°æœ‰åºé›†åˆçš„é¦–/å°¾ //elem append or prepend to coll (Seq) coll :+ elem elem +: coll //add elem to set/map coll + elem coll + (e1,e2,...) coll ++ coll2 coll2 ++: coll // prepend to lst elem :: lst lst2 ::: lst // ç­‰ä»·list ++: list2 list ::: list2 // å«æœ‰=çš„è¡¨ç¤ºä¿®æ”¹,å¿…é¡»æ˜¯mutableçš„é›†åˆ // TIP: As you can see, Scala provides many operators for adding and removing // elements. Here is a summary: // 1. Append (:+) or prepend (+:) to a sequence. // 2. Add (+) to an unordered collection. // 3. Remove with the - operator. // 4. Use ++ and -- for bulk add and remove. // 5. Mutations are += ++= -= --=. // 6. For lists, many Scala programmers prefer the :: and ::: operators. // 7. Stay away from ++: +=: ++=:. NOTE: For lists, you can use +: instead of :: for consistency, with one
exception: Pattern matching (case h::t) does not work with the +: operator.
å…¶ä»– //æ•°ç»„çš„ç¬”è®° val ints = new Array[Int](30) // empty array val ints2 = Array[Int](1, 2, 3, 4) // array with init values val matrix4x9 = Array.ofDim[Double](4, 9) //update ints2(3) = 1000 // or ints2.update(3, 1000) //æ±‚å’Œ val ints2Sum = ints2.sum val days = Array("Monday", "Tuesday", "Wednesday", "Thrusday", "Friday", "Saturday", "Sunday") //éå† for (i &lt;- 0 until days.length) println(days(i)) for (day &lt;- days) println(day) days foreach println //éå†ä¸­ä½¿ç”¨index days.zipWithIndex.map { case (e, i) => (i, e) } //faster for (i &lt;- days.indices) yield (i, days(i)) //Possibly fastest Array.tabulate(days.length) { i => (i, days(i)) } //è‚¯å®šæœ€å¿« val b = new Array[(Int, String)](days.length) var i = 0 while (i &lt; days.length) { b(i) = (i, days(i)) i += 1 } //filter days.filter(day => day.length > 4) //map Array(1, 2, 3, 4, 5).map(x => x * x) //sort Array(3, 6, 2, 0, 8, 5).sortWith((e1, e2) => e1 &lt; e2) //å°çš„åœ¨å‰ //reduce,ä¸‹é¢çš„ä¼šæç¤ºä½¿ç”¨sum, Array(1, 2, 3, 4, 5).reduce((e1, e2) => e1 + e2) //ä¸å®šé•¿æ•°ç»„ import scala.collection.mutable.ArrayBuffer val arr = ArrayBuffer[Int]() //tuple val oneAndTwo = (1, 2) val oneAndTwo1 = Tuple2(1, 2) //Pair is alias of Tuple2 val oneAndTwo2 = Pair(1, "two") val oneAndTwo3 = 1 -> 2 //è®¿é—®å…ƒç´ ä¸‹æ ‡æ˜¯ä»1å¼€å§‹,è¿™æ˜¯å› ä¸ºtupleé‡Œé¢æ¯ä¸ªå…ƒç´ ç±»å‹ä¸ä¸€æ ·,ä¸ºäº†èƒ½å¤Ÿå’Œlistç­‰åŒºåˆ†å¼€ //ä½¿ç”¨äº†ç±»ä¼¼Haskell/MLçš„ä¹ æƒ¯ val two = oneAndTwo._2 //option val emptyOpt: Option[Int] = None val fullOpt: Option[Int] = Some(42) emptyOpt match { case Some(value) => println(value) case None => println("Empty") } fullOpt.get //42 emptyOpt.isEmpty //true //either def divide(a: Double, b: Double): Either[String, Double] = { if (b == 0.0) Left("Division by zero") else Right(a / b) } divide(4, 0) def either(flag: Boolean): Either[String, List[Int]] = { if (flag) Right(List(1, 2, 3)) else Left("Wrong") } val content = either(true).right.map(_.filter(_ > 0)) //cast Seq(1).toArray Seq(1).toBuffer Seq(1).toList Seq((1, 2)).toMap Seq(1).toStream Seq(1).toString Seq(1).toVector Seq(1).toTraversable Seq(1).toIndexedSeq Seq(1).toIterable Set(1).toSeq Seq(1).toSet //zip, zipAll, zipWithIndex, unzip "abcde" zip 1.to(5) //zipAll:ç¬¬äºŒä¸ªå‚æ•°æ˜¯è°ƒç”¨è€…å…ƒç´ ç¼ºå¤±ä½¿ç”¨çš„é»˜è®¤å€¼,ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯ç¬¬ä¸€ä¸ªå®å‚ä¸å¤Ÿé•¿çš„é»˜è®¤å€¼ "abcde".zipAll(1.to(2), "caller", "arg") //å°è¯•è‡ªå·±å®ç°ä¸€ä¸ªzipAll? // "abcde" zipWithIndex Seq((1, 2), (3, 4), (5, 6)) unzip // val s = Seq("a", "b") scala 2.13 collection åŸºæœ¬é‡å†™äº†.å‚è€ƒè¿™ä¸¤ä¸ªæ–‡æ¡£:
collections migration 2.13
the architecture of scala 2.13â€™s collections</content></entry><entry><title>å‰ç«¯é™æ€èµ„æºå›¾ç‰‡ä¼˜åŒ–[ç¿»è¯‘]</title><url>https://zhimoe.github.io/post/%E5%89%8D%E7%AB%AF%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/</url><categories><category>ç¿»è¯‘</category></categories><tags><tag>code</tag></tags><content type="html"> GTmetrixæ˜¯ä¸€ä¸ªå‰ç«¯é¡µé¢æµ‹è¯•çš„ç½‘ç«™,å¯ä»¥å‘ç°ä½ çš„ç«™ç‚¹å“ªäº›å›¾ç‰‡åŠ è½½é€Ÿåº¦è¾ƒæ…¢,å¹¶é’ˆå¯¹æ€§çš„ä¼˜åŒ–.
source:How to Optimize Images: A Practical Guide</content></entry><entry><title>Spring FactoryBean and ContextAware</title><url>https://zhimoe.github.io/post/spring-factorybean-contextaware/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>spring</tag></tags><content type="html"> ç†è§£Springçš„FactoryBean å’Œ ContextAwareæ¥å£.
FactoryBean ä¸€å¥è¯å°±æ˜¯FactoryBeanç”¨äºè¿”å›å…¶ä»–å¯¹è±¡å®ä¾‹çš„,è€Œä¸æ˜¯è‡ªèº«ç±»å‹çš„å®ä¾‹.
public class Tool { private int id; // standard constructors, getters and setters } public class ToolFactory implements FactoryBean&lt;Tool> { private int factoryId; private int toolId; @Override public Tool getObject() throws Exception { return new Tool(toolId); } @Override public Class&lt;?> getObjectType() { return Tool.class; } @Override public boolean isSingleton() { return false; } // standard setters and getters } æ³¨å†ŒTool:
&lt;!-- factorybean-spring-ctx.xml --> &lt;beans> &lt;bean id="tool" class="com.baeldung.factorybean.ToolFactory"> &lt;property name="factoryId" value="9090"/> &lt;property name="toolId" value="1"/> &lt;/bean> &lt;/beans> ä½¿ç”¨æ³¨è§£æ³¨å†Œ:
@Bean(name = "tool") ToolFactory toolFactory() { ToolFactory factory = new ToolFactory(); factory.setFactoryId(7070); factory.setToolId(2); return factory; } ä½¿ç”¨Tool:
@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = { "classpath:factorybean-spring-ctx.xml" }) public class FactoryBeanXmlConfigTest { @Autowired private Tool tool; @Test public void testConstructWorkerByXml() { assertThat(tool.getId(), equalTo(1)); } } è®¿é—®ToolFactory,åœ¨bean idå‰é¢æ·»åŠ  &amp;:
@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = { "classpath:factorybean-spring-ctx.xml" }) public class FactoryBeanXmlConfigTest { @Resource(name = "&amp;tool") private ToolFactory toolFactory; @Test public void testConstructWorkerByXml() { assertThat(toolFactory.getFactoryId(), equalTo(9090)); } } å’ŒBeanFactoryçš„åŒºåˆ« é™¤äº†FactoryBean,è¿˜æœ‰ä¸€ä¸ªBeanFactoryçš„æ¥å£åŠå…¶å®ç°.</content></entry><entry><title>é€šè¿‡ä¾‹å­å­¦ä¹ Clojure</title><url>https://zhimoe.github.io/post/learn-clojure-by-example/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>clojure</tag></tags><content type="html"> è¿™ä»½ç¬”è®°è¯•å›¾æ‰“é€ æœ€å¼ºçš„clojureå°æŠ„,keep refactoring it&hellip;
clojure å…¥é—¨ (ns clj-notes.core (:gen-class)) ;:gen-class generate java class file ;Parameter is variable in the declaration of function. ;Argument is the actual value of this variable that gets passed to function. ; ;install leiningen: ;put lein.bat in your PATH ;open cmder,run: lein repl ;start repl,use exit,(exit),(quit) or ctrl+d to quit repl (println "hello clojure") ;Symbols are used to bind names to values ;' will prevent a form from being evaluated ;'() same as (quote ()) ;def global variable ;let local variable binding (def object "light") (println object) (let [x 10 y 20 z 30] (+ x y z)) ;=> 60 ;data collection ;seq is abstract for list vector array ;map (def dict {:k1 "v1" :k2 "v2"}) ;keyword as function (:k1 dict) ;return v1 ;map as function (dict :k1) ;return v1 (let [v (dict :k1)] (println v)) ;also you can use get on seq or map (get {:a 1 :b 2} :b) ;=> 2 ;clojure.core/seq is a function that produces a sequence over the given argument. ;Data types that clojure.core/seq can produce a sequence over are called seqable: ; ;Clojure collections ;Java maps ;All iterable types (types that implement java.util.Iterable) ;Java collections (java.util.Set, java.util.List, etc) ;Java arrays ;All types that implement java.lang.CharSequence interface, including Java strings ;All types that implement clojure.lang.Seqable interface ;nil ;function for seq or collection ;= ;count ;conj ;empty ;seq ;first ;rest ;next ;count ;counted? ;conj ;get ;assoc ;defn å®šä¹‰å‡½æ•° ;defn- å®šä¹‰nså†…ç§æœ‰å‡½æ•° (defn f "the second line is doc-string" {:added "1.2" ;this is attr-map :static true} [param] (print "hello " param)) (meta (var f)) ;#' is the reader macro for var and works the exactly same (meta #'f) ;fn create a function (def f (fn [] (println "this is from fn function"))) ;#() is the shortcut for fn (def plus-one #(+ 1 %)) ;% will be replaced with arguments passed to the function ;%1 is for the first argument, %2 is for the second and so on (defn des [{k1 :k1}] ;get :k1 value from argument (map) and binding it to k1(parameter) (println "destructing in map" k1)) (des dict) ;destructing in map v1 ;key don't have to be keyword (defn currency-of [{currency "currency"}] currency) (defn currency-of [{currency 'currency}] currency) ;if want to destructing multi key,use :keys, in this case,parameter name(currency amount) ;must same as arguments's keys(:currency :amount),can not use string as key (defn currency-of [{:keys [currency amount]}] (* currency amount)) (currency-of {:currency "RMB" :amount 100000}) ;ok (currency-of {"currency" "RMB" "amount" 100000}) ;currency will be nil,you will need use :strs or syms (defn currency-strs [{:strs [currency amount]}] currency) (currency-strs {"currency" "RMB" "amount" 100000}) ;ok (defn currency-syms [{:syms [currency amount]}] currency) (currency-syms {'currency "CNY" 'amount 100000}) ;ok ;use :or to give a default value for parameter (defn currency-or [{:keys [currency amount] :or {currency "USD"}}] currency) (currency-or {:amount 100000}) ;=> "USD" ;use &amp; for Variadic Functions parameters (defn log [message &amp; args] (println "args: " args)) ;named params , achieved by Variadic Functions destructing (defn job-info [&amp; {:keys [name job income] :or {job "unemployed" income "$0.00"}}] (if name [name job income] (println "No name specified"))) ;cation! arguments to job-info is not a map (job-info :name "Robert" :job "Engineer") ;["Robert" "Engineer" "$0.00"] ;Without the use of a variadic argument list, ;you would have to call the function with a single map argument such as (job-info {:name "Robert" :job "Engineer"}) ;destructuring example ;https://gist.github.com/john2x/e1dca953548bfdfb9844 (def my-vec [1 2 3]) (let [[a b c d] my-vec] (println a b c d)) ;1 2 3 nil (let [[a b &amp; the-rest] my-vec] (println "a=" a "b=" b "the-rest=" the-rest)) ;a= 1 b= 2 the-rest= (3) (let [[:as all] my-vec] (println all)) ;[1 2 3] (let [[a :as all] my-vec] (println a all)) ;1 [1 2 3] (let [[a b &amp; the-rest :as all] my-vec] (println a b the-rest all)) ;1 2 (3) [1 2 3] ;note: &amp; the-rest convert vector to list, ;but :as preserves them (as a list, or as a vector) (def my-vec ["first" "second"]) (let [{a 0 b 1} my-vec] (println a b)) ;=> "first second" ;optional arguments to functions (defn foo [a b &amp; more-args] (println a b more-args)) (foo :a :b) ;; => :a :b nil (foo :a :b :x) ;; => :a :b (:x) (foo :a :b :x :y :z) ;; => :a :b (:x :y :z) ;map destructuring (def my-hashmap {:a "A" :b "B" :c "C" :d "D"}) (def my-nested-hashmap {:a "A" :b "B" :c "C" :d "D" :q {:x "X" :y "Y" :z "Z"}}) (let [{a :a d :d} my-hashmap] (println a d)) ;; => A D (let [{a :a, b :b, {x :x, y :y} :q} my-nested-hashmap] (println a b x y)) ;; => A B X Y (let [{a :a, b :b, not-found :not-found, :or {not-found ":)"}, :as all} my-hashmap] (println a b not-found all)) ;; => A B :) {:a A :b B :c C :d D} ;!!! There is no &amp; rest for maps. ;everything but false and nil evaluates to true in Clojure. ;:as bind entire map to param ;See https://github.com/ring-clojure/ring/wiki/File-Uploads for explanation (defn file-handler ;è¡¨ç¤ºå…¥å‚æ˜¯ä¸€ä¸ªmap,é‡Œé¢æœ‰:paramsè¿™ä¸ªkey,å°†:params ;[{{{tempfile :tempfile filename :filename} "file"} :params :as request}] [{{{tempfile :tempfile filename :filename} "file"} :params :as request}] (println request) (let [n (num-lines tempfile)] (response (str "File " filename " has " n " lines ")))) ;a simple example (defn first-first [[[i _] _]] i) (first-first [[1 2] [3 4]]) ;return 1 ;(defn name doc-string? attr-map? [params*] prepost-map? body) ;(defn name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?) ;function can have params type hint (defn round "^double here is type hint" [^double d ^long precision] (let [factor (Math/pow 10 precision)] (/ (Math/floor (* d factor)) factor))) ;ä¸å®šé•¿å‚æ•° ;é‡è½½å‡½æ•° (defn bar ([a b] (bar a b 100)) ([a b c] (* a b c))) (bar 5 6) (bar 5 6 3) (defn keyworded-map [&amp; {:keys [function sequence]}] (map function sequence)) (keyworded-map :sequence [1 2 3] :function #(+ % 2)) ;trampoline ;trampoline ;namespace ;create-ns create a namespace (create-ns 'zhi.moe.clj) ;in-ns move to a namespace ;require loads a namespace and ;refer refers the namespace. ;To do these at once, you can use use (require 'clojure.by.example) (clojure.by.example/favorite-language) (use 'clojure.by.example) ;you can rename namespace (require '[clojure.by.example :as temp-ns]) ;ns macro creates a new namespace and gives you an opportunity to load other namespaces at the creation time ;import java class (import java.util.Date) (println (str (new Date))) ;Wed Jul 24 22:55:24 CST 2019 ;boolean ;In Clojure, everything except false and nil are true. (if 1 (println "it is true") (println "will never print")) ;if (if true (println "executed when true") (println "executed when false")) ;use do to execute multi expressions (if true (do (println "one") (println "two"))) ;if-let: (defn positive-number [numbers] (if-let [pos-nums (not-empty (filter pos? numbers))] pos-nums "no positive numbers")) ;when when-let case cond condp ; (defn cond-test [n] (cond (= n 1) "n is 1" (and (> n 3) (&lt; n 10)) "n is over 3 and under 10" :else "n is other")) (cond-test 1000) ;string (let [first "Hirokuni" last "Kim"] (str "My name is " first " " last)) ;format (format "My name is %s %s" "Hirokuni" "Kim") ;power function (defn power [x n] (reduce * (repeat n x))) ;bigint,N is a literal for bigint (+ 9223372036854775807 10N) ;list conj nth count '(1 2 3) ;vector conj nth count .indexOf [1 2 3] (.indexOf [1 2 3] 4) (count [1 2]) ;set conj nth count disj sort contains? subset? superset? #{1 2 3} ;map assoc merge keys vals (let [os {:Apple "Mac" :Microsoft "Windows"}] (get os :Apple)) (assoc {:Apple "Mac" :Microsoft "Windows"} :Commodore "Amiga") ;Sequences are data types that abstract all more concrete data types with unified functions. ;These functions are called the Seq library in Clojure. ;seq first rest cons concat map reduce into ;To add an element to the head of sequence, use cons. (cons 4 [1 2 3]) (into [] `(1 2 3)) (reverse [1 2 3]) ;get a sequence of infinite integers with iterate. Be careful, ;though. Running this example will freeze your terminal since the evaluation of this expression never returns. (doc iterate) (doc range) (repeatedly 5 (fn [] (println "hi!"))) ;for each (doseq [animal ["cat" "dog" "horse"]] (println animal)) (take 5 (range 0 100)) (take-while neg? [-3 -2 -1 0 1 2 3]) ;drop will remove the first n elements (drop 5 (range 0 10)) (drop-while neg? [-3 -2 -1 0 1 2 3]) ;(0 1 2 3) (remove pos? [-1 -2 3 4]) ;(-1 -2) (filter pos? [-1 2 3]) (partition-by #(&lt; 3 %) [1 2 3 4 5 6]) (group-by #(&lt; 3 %) [1 2 3 4 5 6 1 2 3]) (println (take 5 (iterate inc 0))) ;for compression (for [x '(1 2 3)] (+ 10 x)) (doc for) ;åŒé‡for å¾ªç¯ (for [x (range 10) y (range 20) :while (&lt; y x)] [x y]) ;&lt;==> {x | x >0} (for [x '(-1 1 2) :when (> x 0)] x) (for [x [0 1 2 3 4 5] :let [y (* x 3)] :when (even? y)] y) ;meta data for function parameters (defn round [^double d ^long precision] (let [factor (Math/pow 10 precision)] (/ (Math/floor (* d factor)) factor))) ;# is Dispatch character that tells the Clojure reader how to interpret the next character using a read table ;set #{1 2 3} ;discard {:a 1, #_#_:b 2, :c 3} ;regular expression (re-matches #"^test$" "test") ;anonymous function #(println %) ;var quote (read-string "#'foo") ;symbolic values (/ 1.0 0.0) ;##Inf ;tagged literals (type #inst "2014-05-19T19:12:37.925-00:00") ;java.util.Date ;meta (meta #'fn-name) ;reader conditionals #?(:clj (Clojure expression) :cljs (ClojureScript expression) :cljr (Clojure CLR expression) :default (fallthrough expression)) ;#?@ splicing reader conditional (defn build-list [] (list #?@(:clj [5 6 7 8] :cljs [1 2 3 4]))) ;return [5 6 7 8] when run on clojure ;#= allows the reader to evaluate an arbitrary form during read time (read-string "#=(+ 3 4)") ;7 ;Recursion ;simple recursion (defn fibo "this is recursion function" [n] (if (or (= n 0) (= n 1)) n (+ (fibo (- n 1)) (fibo (- n 2))))) ;do not do this!!! take a long time to finish (fibo 1000) ;use recur (defn fibo-recur [iteration] (let [fibo (fn [one two n] (if (= iteration n) one (recur two (+ one two) (inc n))))] ;recur re-binds it's arguments to new values and call the function with the new values ;fibo is an inner function (fibo 0N 1N 0))) (fibo-recur 1000) ;it is really fast ;notes ;with simple recursion, each recursive call creates a stack frame which is ;a data to store the information of the called function on memory. ;Doing deep recursion requires large memory for stack frames, but since it cannot, ;we get StackOverflowError ;å°¾é€’å½’ ;A function is tail recursive when the recursion is happening at the end of it's definition ;In other words, a tail recursive function must return itself as it's returned value. ;When you use recur, it makes sure you are doing tail recursion (doc loop) ;loop/recur is merely a friendly way to write recursion code. ;All imperative loops can be converted to recursions and all recursions can be converted to loops, ;so Clojure chose recursions. ;Although you can write code that looks like an imperative loop with loop/recur, ;Clojure is doing recursion under the hood. ; (defmacro unless [test then] "Evaluates then when test evaluates to be falsey" (list 'if (list 'not test) then)) (macroexpand '(unless false (println "hi"))) ;' quoting ;` syntax-quoting returns the fully qualified namespace. ;Using fully qualified namespace is very important in order to avoid name conflicts when defining macro. ;~ unquote `(+ ~(list 1 2 3)) ;(clojure.core/+ (1 2 3)) `(+ ~@(list 1 2 3)) ;(clojure.core/+ 1 2 3) ;The ~@ unquote splice works just like ~ unquote, ;except it expands a sequence and splice the contents of ;the sequence into the enclosing syntax-quoted data structure ;thread first macro (-> [] (conj 1) (conj 2) (conj 3)) ;[1 2 3] (first (.split (.replace (.toUpperCase "a b c d") "A" "X") " ")) ;"X" ;;Perhaps easier to read: ;-> åé¢æ˜¯åˆå§‹å‚æ•°,ç¬¬2è¡Œå¼€å§‹æ¯ä¸€è¡Œæ˜¯ä¸€ä¸ªå‡½æ•°è°ƒç”¨, ;ä¸”ä¸Šä¸€è¡Œçš„è¿”å›å€¼ä¼šä½œä¸ºè¿™ä¸€è¡Œç¬¬ä¸€ä¸ªå‚æ•°(è¿™å°±æ˜¯thread first)çš„firstå«ä¹‰ ;è¿™é‡Œçš„threadæ˜¯ç®¡é“çš„æ„æ€,è€Œä¸æ˜¯å¹¶å‘ç¼–ç¨‹çš„çº¿ç¨‹ ;å¦‚æœçœç•¥(),é‚£ä¹ˆé‡ç”Ÿç¬¦å·(bare symbol)å’Œkeywordéƒ½ä¼šå½“ä½œä¸€ä¸ªå‡½æ•°è°ƒç”¨, ;ä¾‹å¦‚,è¿™é‡Œçš„.toUpperCaseæ˜¯bare symbol,ç­‰æ•ˆäº(.toUpperCase ,,,) ;clojureä¸­ é€—å·ç­‰äºç©ºç™½ç¬¦,æ‰€ä»¥ä¸Šé¢ç”¨,,,è¡¨ç¤ºå°†ä¼šæ’å…¥çš„å‚æ•°(å³"a b c d") (-> "a b c d" .toUpperCase (.replace "A" "X") (.split " ") first) ;same as follow, ,,, is equals whitespace (-> "a b c d" (.toUpperCase,,,) (.replace "A" "X") (.split " ") first) ;suppose a function (defn calculate [] (reduce + (map #(* % %) (filter odd? (range 10))))) ;same as ;ä¸Šä¸€è¡Œçš„ç»“æœä½œä¸ºæœ€åä¸€ä¸ªå‚æ•°æ’å…¥,è¿™å«thread last (defn calculate* [] (->> (range 10) (filter odd?,,,) (map #(* % %),,,) (reduce +,,,))) ;å¦‚æœæƒ³è¦æŒ‡å®šæ¯æ¬¡æ’å…¥çš„ä½ç½®é‚£ä¹ˆéœ€è¦ç”¨ as-> ;væ˜¯æ¯ä¸€è¡Œçš„è¿”å›å€¼çš„åç§°,è¿™æ ·ä½ å¯ä»¥åœ¨ä¸‹ä¸€è¡Œä»»æ„å‚æ•°ä½ç½®æŒ‡å®š (as-> [:foo :bar] v (map name v) (first v) (.substring v 1)) ; ;destructing ({:keys [firstname lastname] :as person} {:firstname "John" :lastname "Smith"}) ;future and deref (let [future-val (future (inc 1))] (println (deref future-val))) ;deref == @ (let [future-val (future (inc 1))] (println @future-val)) (def my-future (future (Thread/sleep 5000))) (repeatedly 6 (fn [] (println (realized? my-future)) (Thread/sleep 1000))) (doc future) ;promise (def my-promise (promise)) ;you define a promise (def listen-and-callback (fn [] (println "Start listening...") (future (println "Callback fired: " @my-promise)))) (defn do-time-consuming-job [] (Thread/sleep 5000) (deliver my-promise "delivered value")) (listen-and-callback) (do-time-consuming-job) ;atom is like mutable var in other languages but atom is thread safe ;ref dosync ref-set alter (def my-ref (ref 0)) (dosync (alter my-ref (fn [current_ref] (inc current_ref)))) (print @my-ref) (def user (ref {})) (dosync (alter user merge {:name "Kim"}) (throw (Exception. "something wrong happens!")) (alter user merge {:age 32})) (def user-record (atom {})) (do (swap! user-record merge {:name "Kim"}) (throw (Exception. "something wrong happens!")) (swap! user-record merge {:age 32})) ;Java (new java.util.Date "2016/2/19") (java.util.Date.) (java.util.Date. "2016/2/19") (Math/pow 2 3) ;static method (def rnd (new java.util.Random)) (. rnd nextInt 10) (let [date1 (new java.util.Date) date2 (new java.util.Date)] (.equals date1 date2)) ;(.instanceMember instance args*) ;(.instanceMember Classname args*) ;(.-instanceField instance) ;(Classname/staticMethod args*) ;Classname/staticField ;;; (defn geohash [lat lng] (println "geohash:" lat lng) ;;this function take two separate values as params. ;;and it return a geohash for that position ) (let [{:strs [lat lng] :as coord} {"lat" 51.503331, "lng" -0.119500}] (println "calculating geohash for coordinates: " coord) (geohash lat lng)) ;assoc-in associateä½¿åŠ å…¥</content></entry><entry><title>ç†è§£Elasticsearch Query DSLä¸­çš„JSONç»“æ„</title><url>https://zhimoe.github.io/post/elasticsearch-query-dsl/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>elasticsearch</tag></tags><content type="html"> ç†è§£ESæœç´¢ä¸­JSON DSLæœ‰åŠ©äºè‡ªå·±å†™JSONæŸ¥è¯¢,ç‰¹åˆ«æ˜¯æ‰‹å†™å¤æ‚åµŒå¥—json.
diffs in es 2.x and es 5.x query dsl aggr query diffs in es 2.x and es 5.x æ²¡æœ‰stringç±»å‹,æ”¹ä¸ºtextå’Œkeyword 2ä¸ªç±»å‹äº†.textå­—æ®µå¯ä»¥æŒ‡å®šfieldsæ¥ä¸åˆ†è¯.å¦‚ä¸‹ï¼š cityå­—æ®µè¢«ingestä¸ºcityå’Œcity.raw2ä¸ªå­—æ®µ. { "mappings": { "_doc": { "properties": { "city": { "type": "text", "fields": { "raw": { "type": "keyword", "ignore_above": 256 } } } } } } } default double -> float geo_point //2.x "location": { "type": "geo_point", "lat_lon": true, "geohash": true, "geohash_prefix": true, "geohash_precision": "1m" } //5.x "location": { "type": "geo_point" } query dsl basic query å°±åƒç Œæˆ¿å­çš„ç –å¤´,åŸºæœ¬æŸ¥è¯¢å°±æ˜¯ESæŸ¥è¯¢çš„ç –å¤´.åŸºæœ¬æŸ¥è¯¢æ˜¯ç»„åˆæŸ¥è¯¢(boolæŸ¥è¯¢ç­‰)çš„å•å…ƒ.åŸºæœ¬æŸ¥è¯¢æœ‰ï¼š
//basic query element match, multi_match, common, geoshape, ids, match_all, query_string, simple_query_string, range, prefix, regexp, span_term, term, terms, wildcard å…¶ä¸­common, ids, prefix, span_term, term, terms, wildcard æ˜¯ä¸åˆ†æ(å³ä¸èƒ½ç”¨äºtextå­—æ®µ)æœç´¢,match, multi_match, query_string, simple_query_stringæ˜¯å…¨æ–‡æ£€ç´¢,å‡ ä¹å¯ä»¥ç¡®ä¿å¯ä»¥è¿”å›ç»“æœ.è€Œprefix,regexp,wildcardæ˜¯æ¨¡å¼æ£€ç´¢.è¿™é‡Œåˆ†åˆ«ç»™ä¸€äº›ä¾‹å­:
multi_match multi_match æŸ¥è¯¢ä¸ºèƒ½åœ¨å¤šä¸ªå­—æ®µä¸Šåå¤æ‰§è¡Œç›¸åŒæŸ¥è¯¢æä¾›äº†ä¸€ç§ä¾¿æ·æ–¹å¼
æ—¢ç„¶æ—¶å¤šå­—æ®µæŸ¥è¯¢,åˆ™æœ‰3ä¸­åœºæ™¯:best_fields ã€ most_fields å’Œ cross_fields ï¼ˆæœ€ä½³å­—æ®µã€å¤šæ•°å­—æ®µã€è·¨å­—æ®µï¼‰
{ "multi_match": { "query": "Quick brown fox", "type": "best_fields", //é»˜è®¤çš„,å¯ä¸å¡« "fields": [ "title", "body" ], "tie_breaker": 0.3, "minimum_should_match": "30%" } } ç­‰ä»·äºä¸‹é¢çš„å½¢å¼:
{ "dis_max": { "queries": [ { "match": { "title": { "query": "Quick brown fox", "minimum_should_match": "30%" } } }, { "match": { "body": { "query": "Quick brown fox", "minimum_should_match": "30%" } } }, ], "tie_breaker": 0.3 } } è¿˜å¯ä»¥ä½¿ç”¨é€šé…ç¬¦æŒ‡å®šå­—æ®µ,ä»¥åŠç»™æŸäº›å­—æ®µæ·»åŠ æƒé‡.
{ "multi_match": { "query": "Quick brown fox", "fields": [ "*_title", "chapter_title^2" ] } } query_string å’Œ simple_query_string éå¸¸çµæ´»çš„ä¸€ä¸ªæŸ¥è¯¢æ–¹å¼:
// GET index_name/_search { "query": { "query_string" : { "default_field" : "content", "query" : "(new york city) OR (big apple)" } } } ä¸Šé¢çš„queryå­—æ®µè¯­æ³•å¯ä»¥å‚è€ƒ: query_string_syntax
simple_query_stringä¸ä¼šæŠ›å‡ºå¼‚å¸¸,ç›´æ¥å¿½ç•¥æ— æ•ˆè¯­å¥.
term terms // ä¸è¦ç”¨äºtextå­—æ®µ // GET /_search { "query": { "term": { "user": { "value": "Kimchy", "boost": 1.0 } } } } //termså’Œtermä¸€æ ·,ä¸è¿‡å¯ä»¥æŒ‡å®šå¤šä¸ªå€¼, "user" : ["kimchy", "elasticsearch"]// è¿”å›userä¸ºkimchyæˆ–elasticsearchçš„æ–‡æ¡£ prefix // userå­—æ®µ(ä¸åˆ†è¯å­—æ®µ)ä¸­ä»¥"ki"å¼€å¤´çš„æ–‡æ¡£ { "query": { "prefix" : { "user" : "ki" } } } ç»„åˆæŸ¥è¯¢ bool, boosting, constant_score, dis_max, function_score, has_child, has_parent, indices, nested, span_first, span_multi,span_first, span_multi, span_near, span_not, span_or, span_term, top_children, filtered(åºŸå¼ƒ,ä½¿ç”¨boolåŒ…å«ä¸€ä¸ªmustå’Œä¸€ä¸ªfilteræ›¿ä»£) bool boolæŸ¥è¯¢çš„å¤–æ¡†æ¶ç»“æ„ä¸ºï¼š
{ "query": { "bool": { "must": [ {} ], "should": [ {} ], "must_not": [ {} ], "filter": [ {} ] } } } //some other parameter for bool: //boost,minimum_should_match,disable_coord</content></entry><entry><title>Useful Scala Code Snippets</title><url>https://zhimoe.github.io/post/useful-scala-code-snippets/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>scala</tag></tags><content type="html"> merge two map and sum its values å¤šä¸ªmapåˆå¹¶,keyç›¸åŒæ—¶åˆ™valueç›¸åŠ 
val map1 = Map(1 -> 1, 2 -> 2) val map2 = Map(1 -> 11, 3 -> 3) val map3 = Map(1 -> 111, 3 -> 3) val mapList = List(map1, map2, map3) val merged = mapList.reduce((m1, m2) => m1 ++ m2.map { case (k, v) => k -> (v + m1.getOrElse(k, 0)) } ) æ–‡ä»¶è¯» // """"""å¯ä»¥é¿å…\\ç¬¦å· val file = """d:\data\file.txt""" for (line &lt;- Source.fromFile(file, encoding).getLines()) { print(line) } æ–‡ä»¶å†™ //èµ„æºç®¡ç† def using[A &lt;: {def close() : Unit}, R](resource: A)(fun: A => R): R = { import scala.language.reflectiveCalls try { fun(resource) } finally { resource.close() } } using(new OutputStreamWriter(new FileOutputStream(outputFile), StandardCharsets.UTF_8)) { writer => writer.write(s"""${line}\n""") } ç»Ÿè®¡è¯é¢‘ val nanoUnit = 1000000 //åˆ†è¯å¹¶ç»Ÿè®¡è¯é¢‘ def main(args: Array[String]): Unit = { val path = """D:\code\ideaProjects\scala-notes\data\src\out""" val files: List[File] = new File(path).listFiles.filter(_.isFile).toList val start = System.nanoTime() val wfList = ListBuffer[mutable.Map[String, Long]]() val futures = for (file &lt;- files) yield Future { countWrodsInFile(file, "UTF-8") } for (f &lt;- futures) { val words: mutable.Map[String, Long] = Await.result(f, Duration.Inf) wfList += words } //merge the word frequency map val finalWf = wfList.reduce((m1, m2) => m1 ++ m2.map { case (k, v) => k -> (v + m1.getOrElse(k, 0L)) } ) val end = System.nanoTime() println(s"container size=${finalWf.size}") // sort map val wordsFreq = finalWf.toList.sortWith(_._2 > _._2) write2file(wordsFreq, Paths.get(path, "final.txt").toFile) println(s"total used time = ${(end - start) / nanoUnit} ms") println(s"cups = ${Runtime.getRuntime.availableProcessors()}") } def countWrodsInFile(file: File, encoding: String): mutable.Map[String, Long] = { val wf = mutable.Map[String, Long]().withDefaultValue(0) for (line &lt;- Source.fromFile(file, encoding).getLines()) { val l = line.trim wf.update(l, wf(l) + 1) } println(s"${file.getName} has words:${wf.size}") wf } def write2file(wf: Seq[(String, Long)], out: File): Unit = { using(new OutputStreamWriter(new FileOutputStream(out), StandardCharsets.UTF_8)) { writer => for (it &lt;- wf) { writer.write(s"""${it._1} ${it._2}\n""") } } }</content></entry><entry><title>Scala Future</title><url>https://zhimoe.github.io/post/scala-future/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>scala</tag></tags><content type="html"> some notes on scala future, includes:
future executor context await future result callback recover future import java.time._ import scala.concurrent._ import ExecutionContext.Implicits.global Future { Thread.sleep(10000) println(s"This is the future at ${LocalTime.now}") } println(s"This is the present at ${LocalTime.now}") executor context future need a new thread to execute it task. import ExecutionContext.Implicits.global is a implicit threadpool.
await for future result // for 10.seconds conversion import scala.concurrent.duration._ val f = Future { Thread.sleep(10000); 42 } val result = Await.result(f, Duration.Inf) // if f throw exception, it will rethrow to Await.result // use ready() solve this val f = Future { ... } Await.ready(f, 10.seconds) val Some(t) = f.value // The f.value method returns an Option[Try[T]], // which is None when the future is not completed // and Some(t) when it is is // t is Try type instance // A Try[T] instance is either a Success(v), where v is a value of type T or a Failure(ex) val t = Some(t).get t match { case Success(v) => println(s"The answer is $v") case Failure(ex) => println(ex.getMessage) } // or if (t.isSuccess) println(s"The answer is ${t.get}") callback val f = Future { Thread.sleep(10000) if (random() &lt; 0.5) throw new Exception 42 } f.onComplete { case Success(v) => println(s"The answer is $v") case Failure(ex) => println(ex.getMessage) } callback hell val future1 = Future { getData1() } val future2 = Future { getData2() } future1 onComplete { case Success(n1) => future2 onComplete { case Success(n2) => { val n = n1 + n2 println(s"Result: $n") } case Failure(ex) => ... } case Failure(ex) => ... } // improve val future1 = Future { getData1() } val combined = future1.map(n1 => n1 + getData2()) // val future1 = Future { getData1() } val future2 = Future { getData2() } val combined = future1.map(n1 => future2.map(n2 => n1 + n2)) // use for-yield for ( n1 &lt;- future1 n2 &lt;- future2 ) yield n1+n2</content></entry><entry><title>Spring Boot Notes</title><url>https://zhimoe.github.io/post/spring-boot-notes/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>spring</tag></tags><content type="html"> ä¸€äº›å®¹æ˜“å¿˜è®°çš„spring bootçŸ¥è¯†è¦ç‚¹.
æ³¨æ„,.yamlå’Œ.ymlæ–‡ä»¶æ²¡ä»»ä½•åŒºåˆ«.
é…ç½® SpringBootApplicationæ³¨è§£ @SpringBootApplication // &lt;=ç­‰ä»·=> @Configuration @ComponentScan @EnableAutoConfiguration è‡ªåŠ¨é…ç½® springçš„è‡ªåŠ¨é…ç½®ä¾èµ–ä»¥ä¸‹æ³¨è§£:
é…ç½®æ–‡ä»¶ ä»»ä½•æ—¶å€™ç¡¬ç¼–ç çš„é…ç½®æ€»æ˜¯ä¸å¥½çš„,springæ”¯æŒä»å¾ˆå¤šç¯å¢ƒä¸­è¯»å–é…ç½®: é…ç½®æ–‡ä»¶,yamlæ–‡ä»¶,ç¯å¢ƒå˜é‡,å‘½ä»¤å‚æ•°.
é…ç½®å¯ä»¥åœ¨@Valueæ³¨è§£ä¸­ä½¿ç”¨,ä¹Ÿå¯Environmentè®¿é—®,æˆ–è€…é€šè¿‡@ConfigurationPropertieså°†é…ç½®å±æ€§ç»‘å®šåˆ°ç‰¹å®šçš„bean(ä¾‹å­).
spring bootçš„é…ç½®å±æ€§è¯»å–é¡ºåºä¸º:
Devtools global settings properties on your home directory (~/.spring-boot-devtools.properties when devtools is active). @TestPropertySource annotations on your tests. @SpringBootTest#properties annotation attribute on your tests. Command line arguments. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property) ServletConfig init parameters. ServletContext init parameters. JNDI attributes from java:comp/env. Java System properties (System.getProperties()). OS environment variables. A RandomValuePropertySource that only has properties in random.*. Profile-specific application properties outside of your packaged jar (application-{profile}.properties and YAML variants) Profile-specific application properties packaged inside your jar (application-{profile}.properties and YAML variants) Application properties outside of your packaged jar (application.properties and YAML variants). Application properties packaged inside your jar (application.properties and YAML variants). @PropertySource annotations on your @Configuration classes. Default properties (specified using SpringApplication.setDefaultProperties). å› ä¸ºspring-bootä¸»è¦ä½¿ç”¨çš„application.properties/yamlæ–‡ä»¶,æ‰€ä»¥åé¢ä¸»è¦å…³æ³¨è¿™ä¸ªæ–‡ä»¶.
æ­¤å¤–,springä»£ç ä¸­ä½¿ç”¨äº†å¤§çº¦è¿‘åƒä¸ª(300å¤šç±»)é»˜è®¤å€¼,è¿™äº›é»˜è®¤å€¼éƒ½æ˜¯å¯ä»¥è¦†ç›–çš„.åªéœ€ä½ åœ¨ä½ çš„propeties/yamlæ–‡ä»¶ä¸­ç”¨ç›¸åŒçš„keyå³å¯.
æ‰€æœ‰çš„å‚è€ƒå€¼è§: example application.properties
application.properties SpringApplication loads properties from application.properties files in the following locations and adds them to the Spring Environment:
A /config subdirectory of the current directory The current directory A classpath /config package The classpath root application.yml yamlæ˜¯jsonçš„è¶…é›†,ç›¸æ¯”propertiesæ–‡ä»¶,æœ‰ç€ç®€æ´çµæ´»çš„ä¼˜åŠ¿ ä¾‹å¦‚å¯ä»¥è®¾ç½®æ•°ç»„,è®¾ç½®groupæ¦‚å¿µç­‰.
yamlæ–‡ä»¶å¯ä»¥é…ç½®æ•°ç»„:
# æ•°ç»„åŠŸèƒ½,ç­‰ä»· # my.servers[0]=dev.bar.com # my.servers[1]=foo.bar.com my: servers: - dev.bar.com - foo.bar.com #ä¸Šé¢çš„é…ç½®å¯ä»¥é€šè¿‡æ³¨è§£ç»‘å®šåˆ°ä»¥ä¸‹beanä¸­,éå¸¸å¼ºå¤§. @ConfigurationProperties(prefix="my") public class Config { private List&lt;String> servers = new ArrayList&lt;String>(); } # åœ¨ä¸€ä¸ªyamlæ–‡ä»¶è®¾ç½®ä¸åŒçš„profileé…ç½®,propertiesæ–‡ä»¶åªèƒ½é€šè¿‡æ‹†åˆ†æ–‡ä»¶`application-profiles.properties`å®ç°. server: address: 192.168.1.100 --- spring: profiles: DEV server: address: 127.0.0.1 --- spring: profiles: PRD server: address: 192.168.1.120 yamlç¼ºç‚¹: YAML files cannot be loaded by using the @PropertySource annotation. So, in the case that you need to load values that way, you need to use a properties file.
å½“ç„¶ä½¿ç”¨propertiesæ–‡ä»¶ç¼ºç‚¹ä¹Ÿæ˜æ˜¾,ä¸èƒ½åˆ†ç»„(yamlçš„&mdash;åŠŸèƒ½);åŒæ—¶ä¸­æ–‡æ˜¾ç¤ºå®¹æ˜“unicodeç .
è¯»å–é…ç½®æ–‡ä»¶ é™¤äº†application.propertiesæ–‡ä»¶,å…¶ä»–çš„é…ç½®å±æ€§æ–‡ä»¶éœ€è¦æˆ‘ä»¬è‡ªå·±åŠ è½½è¯»å–.æ³¨æ„,ä¸‹é¢çš„PropertySourceæ— æ³•åŠ è½½yamlæ–‡ä»¶.
ä½¿ç”¨PropertySource cron=0/3 * * * * ? @Configuration @PropertySource("classpath:foo.properties") public class PropertiesWithJavaConfig { @Value(${cron}) private String cron; } //or @PropertySource({ "classpath:persistence-${envTarget:mysql}.properties" }) //multi files //java 8+ @PropertySource("classpath:foo.properties") @PropertySource("classpath:bar.properties") public class PropertiesWithJavaConfig { //... } //java 6+ @PropertySources({ @PropertySource("classpath:foo.properties"), @PropertySource("classpath:bar.properties") }) public class PropertiesWithJavaConfig { //... } //é€šè¿‡xmlåŠ è½½ //register file in xml &lt;context:property-placeholder location="classpath:foo.properties" /> //foo.properties in src/main/resources &lt;context:property-placeholder location="classpath:foo.properties, classpath:bar.properties"/> å¦‚ä½•åŠ è½½è‡ªå®šä¹‰çš„yamlæ–‡ä»¶ ä¸Šé¢æåˆ°springä¼šé»˜è®¤åŠ è½½application.ymlæ–‡ä»¶çš„é…ç½®.ä½†æ˜¯å…¶ä»–æ–‡ä»¶åçš„ymlæ–‡ä»¶æ— æ³•é€šè¿‡@PropertySourceåŠ è½½.å¯ä»¥æœ‰ä»¥ä¸‹æ–¹æ³•.
ä½¿ç”¨xml,ç„¶ååœ¨Java Configç±»åŠ è½½xml. ä¸ªäººä¸æ¨èä½¿ç”¨xmlæ–‡ä»¶,è„±ç¦»spring bootçš„åˆè¡·äº†. ä½¿ç”¨ymlåŠ è½½å™¨: The YamlPropertiesFactoryBean will load YAML as Properties and the YamlMapFactoryBean will load YAML as a Map. é¿å…ä½¿ç”¨,å°½é‡å°†ä½ çš„æ‰€ä»¥é…ç½®æ”¾åœ¨application.ymlé‡Œé¢,å› ä¸ºymlå¯ä»¥æœ‰åˆ†ç»„åŠŸèƒ½. å°†ä½ æ–‡ä»¶å‘½åä¸ºapplication-redis.yml,ç„¶ååœ¨application.ymlä½¿ç”¨spring.profiles.include: 'redis' åŠ è½½. ä½¿ç”¨yamlæ–‡ä»¶çš„åŠ è½½å¯ä»¥é€šè¿‡ConfigurationPropertiesç»‘å®šåˆ°é…ç½®beanä¸­.è¿˜è¦æ·»åŠ 2ä¸ªæ³¨è§£æ³¨å†Œåˆ°spring:
@Configuration @EnableConfigurationProperties @ConfigurationProperties public class YAMLConfig { private String name; private String environment; private List&lt;String> servers = new ArrayList&lt;>(); // standard getters and setters } spring: profiles: prod name: prod-YAML environment: production servers: - www.abc.com - www.xyz.com profiles å¾ˆå¤šé…ç½®å¸Œæœ›åŸºäºç¯å¢ƒ,spring bootæ”¯æŒapplication-profile.propertiesæ ¼å¼çš„é…ç½®,profileå¯ä»¥æ˜¯DEV,ST,UAT,PRD,TESTç­‰.
ä¾‹å¦‚æŸä¸ªclasså¸Œæœ›åªæœ‰åœ¨PRDç¯å¢ƒæ‰æœ‰:
@Profile("PRD") @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter {} ç„¶ååœ¨application.yml/propertiesè®¾ç½®profile:
spring: profiles: active: PRD propertiesæ–‡ä»¶è®¾ç½®profile application.propertiesæ–‡ä»¶åªèƒ½ä½¿ç”¨application-DEV.properties,application-ST.propertiesè®¾ç½®profile.
ymlæ–‡ä»¶è®¾ç½®profile application.ymlæ—¢å¯ä»¥åƒpropertiesæ–‡ä»¶ä½¿ç”¨application-DEV.ymlæ¥è®¾ç½®profile,ä¹Ÿå¯ä»¥ä½¿ç”¨---åˆ†ç»„.å¦‚ä¸‹ç¤ºä¾‹,logging.level=INFOåœ¨æ‰€æœ‰profileä¸­ç”Ÿæ•ˆ,è€Œåœ¨ç”Ÿäº§ç¯å¢ƒä¸­å¢åŠ æ—¥å¿—æ–‡ä»¶è®¾ç½®,DEVç¯å¢ƒåˆ™ä½¿ç”¨DEBUGçº§åˆ«æ—¥å¿—.
# application.yml logging: level: root: INFO --- spring: profiles: DEV logging: level: root: DEBUG --- spring: profiles: PRD logging: path: /tmp/ file: BookWorm.log level: root: WARN æ¿€æ´»profiles åœ¨application.yml/propertiesæ–‡ä»¶ä¸­æ¿€æ´»æŸä¸ªprofile:
spring: profiles: active: DEV å¦‚æœä½ è®¾ç½®äº†SPRING_PROFILES_ACTIVEç¯å¢ƒå˜é‡,é‚£ä¹ˆä¼šè¦†ç›–ä¸Šé¢çš„profileè®¾ç½®.å½“ç„¶ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨è‡ªå®šä¹‰ç¯å¢ƒå˜é‡å’Œé»˜è®¤å€¼:
spring: profiles: active: ${ENV_TYP:PRD} # è¯»å–ENV_TYPç¯å¢ƒå˜é‡çš„å€¼ä½œä¸ºæ¿€æ´»profile,å¦‚æœæ²¡ç”¨è¿™ä¸ªç¯å¢ƒå˜é‡,é‚£ä¹ˆè®¾ç½®ä¸ºPRD. æµ‹è¯•</content></entry><entry><title>Pattern Matching Anonymous Function</title><url>https://zhimoe.github.io/post/pattern-matching-anonymous-function/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>scala</tag></tags><content type="html"> Scalaä¸­å¾ˆå¤šä½¿ç”¨ifçš„åœ°æ–¹éƒ½å¯ä»¥ç”¨match caseæ¥æ›¿æ¢.å¸¸è§çš„å°±æ˜¯ä¸‹é¢çš„è¿™ç§å†™æ³•:
val res = msg match { case it if it.contains("H") => "Hello" case _ => "Other" } //æ›´å¸¸è§çš„ç”¨æ³•æ˜¯å»åŒ¹é…å‚æ•°çš„æ¨¡å¼: case class Player(name: String, score: Int) def message(player: Player) = player match { case Player(_, score) if score > 100000 => "Get a job, dude!" case Player(name, _) => "Hey, $name, nice to see you again!" } def printMessage(player: Player) = println(message(player)) å…¶å®caseè¿˜æœ‰ä¸€ç§åœ¨åŒ¿åå‡½æ•°ä¸­çš„ç”¨æ³•,çœ‹å¦‚ä¸‹çš„ä»£ç ,åœ¨è¯é¢‘ç»Ÿè®¡æˆ–è€…è¿‡æ»¤ä¸­å¾ˆå¸¸è§:
val wordFrequencies = ("habitual", 6) :: ("and", 56) :: ("consuetudinary", 2) :: Nil def wordsWithoutOutliers(wordFrequencies: Seq[(String, Int)]): Seq[String] = wordFrequencies.filter(wf => wf._2 > 3 &amp;&amp; wf._2 &lt; 25).map(_._1) ä¸Šé¢çš„ä»£ç æœ‰æ¯”è¾ƒå¤§çš„é—®é¢˜æ˜¯è®¿é—®tupleå…ƒç´ çš„æ–¹å¼æ¯”è¾ƒéš¾çœ‹,Scalaæä¾›äº†ä¸€ç§pattern matching anonymous functionè§£å†³è¿™ä¸ªé—®é¢˜:
def wordsWithoutOutliers(wordFrequencies: Seq[(String, Int)]): Seq[String] = wordFrequencies.filter { case (_, f) => f > 3 &amp;&amp; f &lt; 25 } map { case (w, _) => w } æ³¨æ„åˆ°çœç•¥äº†æœ€æ—©ç‰ˆæœ¬çš„ wf =>,IDEAå…¶å®ä¼šæç¤ºä½ çœç•¥è¿™ä¸ªå†—ä½™éƒ¨åˆ†.
å¦ä¸€ä¸ªé—®é¢˜å°±æ˜¯ä¸Šé¢çš„æ“ä½œä¸­æˆ‘ä»¬å…ˆè¿‡æ»¤æƒ³è¦çš„åºåˆ—,ç„¶åå¯¹åºåˆ—è¿›è¡Œäº†mapæ˜ å°„æ“ä½œ.Scala é›†åˆçš„ API æœ‰ä¸€ä¸ªå«åš collect çš„æ–¹æ³•,å¯¹äº Seq[A] ,å®ƒæœ‰å¦‚ä¸‹æ–¹æ³•ç­¾åï¼š
def collect[B](pf: PartialFunction[A, B]): Seq[B] è¿™ä¸ªæ–¹æ³•å°†ç»™å®šçš„_åå‡½æ•°(partial function)_ åº”ç”¨åˆ°åºåˆ—çš„æ¯ä¸€ä¸ªå…ƒç´ ä¸Š, æœ€åè¿”å›ä¸€ä¸ªæ»¡è¶³æ¡ä»¶å¹¶å¤„ç†åæ–°çš„åºåˆ— ,è¿™é‡Œåå‡½æ•°åšäº† filter å’Œ map è¦åšçš„äº‹æƒ….
ç°åœ¨,æˆ‘ä»¬æ¥é‡æ„ wordsWithoutOutliers ,é¦–å…ˆå®šä¹‰éœ€è¦çš„åå‡½æ•°ï¼š
val pf: PartialFunction[(String, Int), String] = { case (word, freq) if freq > 3 &amp;&amp; freq &lt; 25 => word } wordFrequencies.collect(pf) æˆ‘ä»¬ä¸ºè¿™ä¸ªæ¡ˆä¾‹åŠ å…¥äº† å®ˆå«è¯­å¥,ä¸åœ¨åŒºé—´é‡Œçš„å…ƒç´ å°±æ²¡æœ‰å®šä¹‰.
ä»¥ä¸Šæ¥è‡ªScalaåˆå­¦è€…æŒ‡å—
å½“ç„¶æœ‰ä¸­æ–‡ç‰ˆ:Scalaåˆå­¦è€…æŒ‡å—-gitbook</content></entry><entry><title>Scala Type Class</title><url>https://zhimoe.github.io/post/scala-type-class/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>scala</tag></tags><content type="html"> scala type class notes:
å…³äºscala type classéå¸¸å¥½çš„æ–‡ç« 
æ ¸å¿ƒçŸ¥è¯†ç‚¹ //scalaæ²¡æœ‰ä¸“é—¨çš„type classè¯­æ³•,è€Œæ˜¯å€ŸåŠ©trait + implicit + context boundæ¥å®ç°çš„, //æ‰€ä»¥å¾ˆå¤šæ—¶å€™è¯†åˆ«type classæ¯”è¾ƒå›°éš¾. //type class ç”±ä¸‰éƒ¨åˆ†æ„æˆ //1. type class: å³ä¸‹é¢çš„Show,å®šä¹‰ä¸€ä¸ªè¡Œä¸ºtoHtml. //2. type class instancesï¼šå¸Œæœ›å®ç°toHtmlæ–¹æ³•çš„ç±»å‹å®ä¾‹ //3. user interface: type classä¸­ä¼´ç”Ÿå¯¹è±¡çš„åŒåæ–¹æ³•æˆ–è€…éšå¼è½¬æ¢æ–¹æ³•. // type class trait Show[A] { def toHtml(a: A): String } // å®šä¹‰åœ¨ä¼´ç”Ÿå¯¹è±¡çš„å¥½å¤„å°±æ˜¯implicitå˜é‡è‡ªåŠ¨å¤„äºscopeå†… object Show { //åˆ©ç”¨ä¼´ç”Ÿå¯¹è±¡applyç‰¹ç‚¹å®ç°ä¸‹é¢Show[A].toHtmlè°ƒç”¨æ–¹å¼,å³éšè—implicit sh def apply[A](implicit sh: Show[A]): Show[A] = sh //å¦‚æœæ²¡æœ‰apply,é‚£ä¹ˆä¸‹é¢çš„toHtmléœ€è¦ä¸€ä¸ªéšå¼å‚æ•°ï¼š //def toHtml[A](a: A)(implicit sh: Show[A]): String = sh.toHtml(a) //æˆ–è€…ï¼š //def toHtml[A: Show](a: A): String = implicitly[Show[A]].toHtml(a) //å¯¹å¤–æ¥å£,æä¾›toHtml("type")çš„è°ƒç”¨å½¢å¼ def toHtml[A: Show](a: A) = Show[A].toHtml(a) //å¯¹å¤–æ¥å£,é€šè¿‡éšå¼è½¬æ¢æä¾›10 toHtmlçš„è°ƒç”¨å½¢å¼ implicit class ShowOps[A: Show](a: A) { // æƒ¯ä¾‹ä½¿ç”¨TypeCls+Ops def toHtml = Show[A].toHtml(a) } //ä¸ºäº†é¿å…è¿è¡Œå¼€é”€,å¯ä»¥å°†Opsç±»å®šä¹‰ä¸ºvalue classï¼š // implicit class ShowOps[A](val a: A) extends AnyVal { // def toHtml(implicit sh: Show[A]) = sh.toHtml(a) // } //ä¸Šé¢ä¸¤ä¸ªå¯¹å¤–æ¥å£éƒ½åˆ©ç”¨äº†ä¼´ç”Ÿå¯¹è±¡çš„applyæ–¹æ³•å’Œcontext bound //type class instance int implicit val intCanShow: Show[Int] = int => s"&lt;int>$int&lt;/int>" //type class instance string implicit val stringCanShow: Show[String] = str => s"&lt;string>$str&lt;/string>" } //use type class import Show._ print(10 toHtml) print(toHtml("type")) è‹¥ä½¿ç”¨import Show._ å¯¼å…¥å…¨éƒ¨å†…å®¹,åˆ™ç”¨æˆ·æ— æ³•è‡ªå·±å®ç°ä¸€äº› type class instanceåˆ™ä¼šè¦†ç›–é»˜è®¤å®ä¾‹å¯¼è‡´æ­§ä¹‰.
å¯ä»¥å°†å¯¹å¤–æ¥å£ç§»åŠ¨åˆ°å•ç‹¬çš„opså¯¹è±¡ä¸­ï¼š
trait Show[A] { def toHtml(a: A): String } object Show { def apply[A](implicit sh: Show[A]): Show[A] = sh object ops { def toHtml[A: Show](a: A) = Show[A].toHtml(a) implicit class ShowOps[A: Show](a: A) { // æƒ¯ä¾‹ä½¿ç”¨TypeCls+Ops def toHtml = Show[A].toHtml(a) } } implicit val intCanShow: Show[Int] = int => s"&lt;int>$int&lt;/int>" implicit val stringCanShow: Show[String] = str => s"&lt;string>$str&lt;/string>" } ä½¿ç”¨ï¼š
import xxx.Show //å¦‚æœéœ€è¦å®ç°è‡ªå®šä¹‰çš„type class instanceåˆ™éœ€è¦ import xxx.Show.ops._ è‡ªå®šä¹‰ case class Person(name: String, age: Int) implicit val personOps: Show[Person] = p => s"&lt;person>name=${p.name},age=${p.age}&lt;/person>" print(Person("lee", 19) toHtml)//&lt;person>name=lee,age=19&lt;/person> Simulacrum Simulacrumé€šè¿‡å®ä¸º type class æ·»åŠ ä¾¿æ·è¯­æ³•,æ˜¯å¦ä½¿ç”¨å–å†³äºä¸ªäººåˆ¤æ–­.
è‹¥ä½¿ç”¨ Simulacrum,åˆ™å¯ä»¥ä¸€çœ¼æ‰¾å‡ºä»£ç ä¸­æ‰€æœ‰çš„ type class,å¹¶ä¸”å¯çœå»å¾ˆå¤šæ ·æ¿ä»£ç .
å¦ä¸€æ–¹é¢,ä½¿ç”¨ @typeclassï¼ˆSimulacrum ä¸»è¦æ³¨è§£ï¼‰åˆ™æ„å‘³ç€éœ€è¦ä¾èµ– macro paradise ç¼–è¯‘å™¨æ’ä»¶.
ä½¿ç”¨ Simulacrum é‡å†™æˆ‘ä»¬çš„ Show type classï¼š
import simulacrum._ @typeclass trait Show[A] { def toHtml(a: A): String } æœ‰äº† Simulacrum,type class å®šä¹‰å˜å¾—éå¸¸ç®€æ´,æˆ‘ä»¬åœ¨å…¶ä¼´ç”Ÿå¯¹è±¡ä¸­æ·»åŠ  Show[String] å®ä¾‹ï¼š
//Simulacrum ä¼šä¸º Show è‡ªåŠ¨ç”Ÿæˆ ops å¯¹è±¡,ä¸å‰é¢è‡ªå®šä¹‰çš„åŸºæœ¬ä¸€è‡´. object Show { implicit val stringShow: Show[String] = s â‡’ s"String: $s" }</content></entry><entry><title>Scala å­¦ä¹ ç¬”è®°</title><url>https://zhimoe.github.io/post/scala-notes/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag></tags><content type="html"> some notes on scala, includes:
setup with maven import == and eq case class for&hellip;yield companion object and class method and function(def val) _ in scala => in scala () {} in scala implicit string setup with maven ç›®å‰ç”¨sbtçš„é¡¹ç›®æ¯”è¾ƒå°‘,mavençš„æ›´å¤š. è€Œä¸”sbtçƒ§cpu. mavené¡¹ç›®ä½¿ç”¨scalaå‚è€ƒæˆ‘çš„gist:scala_maven_pom.xml
å­¦ä¹ scalaå¯ä»¥ä½¿ç”¨scalaæ’ä»¶çš„worksheet,è¿™æ˜¯ä¸€ä¸ªåŸºäºè„šæœ¬äº’åŠ¨çš„REPL. æœ¬æ–‡åé¢çš„ä»£ç å…¨éƒ¨åœ¨worksheetä¸­æµ‹è¯•.
import scalaçš„importè¯­å¥å¾ˆçµæ´»,å¯ä»¥åœ¨ä»»ä½•åœ°æ–¹å¯¼å…¥classå†…éƒ¨å¤–éƒ¨,æ–¹æ³•å†…éƒ¨,ä»£ç å—å†…éƒ¨,è¿™æ ·åšæœ‰ä¸€ä¸ªå¥½å¤„,é™åˆ¶å¯¼å…¥æ–¹æ³•å’Œå¯¹è±¡çš„scope,é˜²æ­¢æ±¡æŸ“å˜é‡.åœ¨åé¢å­¦äº†implicitéšå¼è½¬æ¢å,å°±çŸ¥é“import scopeæœ‰å¤šé‡è¦äº†.
import scala.math._ // import everything in math package import java.util.{ ArrayList => _, _} //ç¬¬ä¸€ä¸ªä¸‹åˆ’çº¿è¡¨ç¤ºéšè—ArrayList,ç¬¬äºŒä¸ªè¡¨ç¤ºé€šé…ç¬¦,å¯¼å…¥æ‰€æœ‰ //é»˜è®¤,scalaå¯¼å…¥: java.lang._ scala._ scala.Predef._ //æ¨èçœ‹ä¸€ä¸‹Predefçš„æºä»£ç åŒ…æ‹¬ï¼š //Predefä¸­å®šä¹‰çš„æ–¹æ³•å’Œå±æ€§ //å¸¸ç”¨æ–¹æ³•å’Œç±» //æ‰“å°æ–¹æ³• printlnç­‰ //ä¸€äº›è°ƒè¯•å’Œé”™è¯¯æ–¹æ³• //ä¸€ä¸ªç‰¹æ®Šçš„æ–¹æ³•è¡¨ç¤ºæ–¹æ³•æœªå®ç° def ??? : Nothing = throw new NotImplementedError //Predefè¿˜æœ‰å¤§é‡çš„éšå¼è½¬æ¢å’Œéšå¼å‚æ•° == and eq scalaé‡Œé¢==ç­‰ä»·äºjavaçš„equalsæ–¹æ³•å³å†…å®¹æ¯”è¾ƒ,å¹¶ä¸”å¯ä»¥æ­£ç¡®å¤„ç†null(è¿˜è®°å¾—javaè§„èŒƒé‡Œé¢çƒ¦äººçš„ "A".equals(m)è§„èŒƒä¹ˆ?). è€Œåœ°å€(å¼•ç”¨)æ¯”è¾ƒä½¿ç”¨eq æ–¹æ³•,è¿™ä¸ªæ–¹æ³•å…¶å®å¾ˆå°‘ç”¨åˆ°,åº”ç”¨ä»£ç ä¸€èˆ¬æ— éœ€æ¯”è¾ƒ2ä¸ªå˜é‡çš„åœ°å€.
case class case classç±»ä¼¼data class,å³javaçš„pojo bean,ä½†æ˜¯æä¾›äº†æ›´å¤šçš„æ–¹æ³•.
// 5ä¸ªç‰¹æ€§ // 1.æ·»åŠ companion object,applyæ–¹æ³•,unapplyæ–¹æ³• // 2.toString, hashCode and equals and copy methods case class Student(name: String, marks: Int) val s1 = Student("Rams", 550) val s2 = s1.copy() val s3 = s1.copy(marks = 590) s2 == s1 //true s3 == s1 //false // 3. æ„é€ å‡½æ•°å‚æ•°è‡ªåŠ¨æˆä¸ºæˆå‘˜å˜é‡,å³è‡ªåŠ¨ç»™æ„é€ å‚æ•°æ·»åŠ valå‰ç¼€ // 4. å¯ä»¥ç”¨äºæ¨¡å¼åŒ¹é… // 5. é»˜è®¤çš„,case classå’Œcase objectæ˜¯å¯åºåˆ—åŒ–çš„(å®ç°Serializable),ä¹Ÿå³æ˜¯å¯ä»¥ç½‘ç»œä¼ è¾“çš„ for&hellip;yield Scalaâ€™s â€œfor comprehensionsâ€ are syntactic sugar for composition of multiple operations with foreach, map, flatMap, filter or withFilter
scalaçš„foræ¨å¯¼å…¶å®å°±æ˜¯ç»„åˆå¤šä¸ªforeach, map, flatMap, filter or withFilterçš„è¯­æ³•ç³–.
ä»¥ä¸‹ä»£ç ç»“æœr1,r2å®Œå…¨ä¸€è‡´:
val c1 = List(1, 2, 3) val c2 = List("a", "b", "c") val c3 = List("!", "@", "#") val r1 = for (x &lt;- c1; y &lt;- c2; z &lt;- c3) yield { x + y + z } //&lt;==> val r2 = c1.flatMap(x => c2.flatMap(y => c3.map(z => { x + y + z }))) assert(r1 == r2)//true companion object Scalaä¸­,é™¤äº†æ–¹æ³•,ä¸€åˆ‡éƒ½æ˜¯å¯¹è±¡ï¼å‡½æ•°ä¹Ÿæ˜¯å¯¹è±¡,æ ¹æ®å‚æ•°çš„ä¸ªæ•°,å‡½æ•°çš„ç±»å‹ä¸ºFunctionN.Nä¸ºå‡½æ•°å‚æ•°ä¸ªæ•°.
ä¼´ç”Ÿå¯¹è±¡ç”¨äºå®šä¹‰ä¸€äº›é™æ€æ–¹æ³•(å·¥å‚æ–¹æ³•),å…¶ä¸­applyå’Œunapplyæ–¹æ³•å¸¸ç”¨. applyæ–¹æ³•ç”¨äºä»£æ›¿newçš„å·¥å‚æ–¹æ³•.
åŒæ—¶,companion objects can access private fields and methods of their companion trait/class.
class Person(name: String, age: Int) { private var skill: String = "no skill" def introduce() = println(s"my name is $name, I am $age years old") } // companion object name should be identical to the class name. object Person { def apply(name: String, age: Int): Person = { new Person(name, age) } //apply method override def apply(name: String, age: Int, skill: String): Person = { val p = new Person(name, age) p.skill = skill p } } val dahu = Person("dahu", 30) dahu.introduce ä¼´ç”Ÿå¯¹è±¡åœ¨æ¨¡å¼åŒ¹é…å’ŒæŠ½å–å™¨çš„åº”ç”¨
//å…³äºæŠ½å–å™¨å’Œunapplyæ–¹æ³•çš„è¿›ä¸€æ­¥ç¤ºä¾‹: trait User class FreeUser( val name: String, val score: Int, val upgradeProbability: Double) extends User class PremiumUser( val name: String, val score: Int) extends User object FreeUser { def unapply(user: FreeUser): Option[(String, Int, Double)] = Some((user.name, user.score, user.upgradeProbability)) } object PremiumUser { def unapply(user: PremiumUser): Option[(String, Int)] = Some((user.name, user.score)) } val freeUsr = new FreeUser("john", 70, 0.5) freeUsr match { case FreeUser(name, _, p) => if (p > 0.75) println(s"what can I do for you,$name") else println(s"hello,$name") case _ => println("who are you") } //boolæŠ½å–å™¨ object premiumCandidate { def unapply(user: FreeUser): Boolean = user.upgradeProbability > 0.4 } // boolæŠ½å–å™¨çš„ç”¨æ³• freeUsr match { case freeUser@premiumCandidate() => println(s"æ­å–œæˆä¸ºé»„é‡‘ä¼šå‘˜å€™é€‰äºº") case _ => println("æ¬¢è¿å›æ¥") } //æ¥æº: [Scalaåˆå­¦è€…æŒ‡å—](http://danielwestheide.com/scala/neophytes.html) method and function(def val) å…ˆçœ‹å‡½æ•°å®šä¹‰
A function can be invoked with a list of arguments to produce a result.
A function has a parameter list, a body, and a result type. Functions that are
members of a class, trait, or singleton object are called methods.
Functions defined inside other functions are called local functions. Functions
with the result type of Unit are called procedures. Anonymous functions in
source code are called function literals. At run time, function literals are
instantiated into objects called function values.
quote fromï¼š
Martin Odersky - Lex Spoon - Bill Venners
å‡½æ•°ç”±ä¸€ä¸ªå‚æ•°åˆ—è¡¨,ä¸€ä¸ªå‡½æ•°ä½“,ä¸€ä¸ªç»“æœç±»å‹æ„æˆ.å‡½æ•°å¦‚æœä½œä¸ºclass,traitæˆ–è€…objectï¼ˆæ³¨æ„,è¿™é‡Œçš„objectæ˜¯scalaç‰¹æœ‰çš„å•ä¾‹å¯¹è±¡,ä¸æ˜¯Javaä¸­çš„instanceï¼‰çš„æˆå‘˜,é‚£ä¹ˆè¿™ä¸ªå‡½æ•°å«æ–¹æ³•.å‡½æ•°å’Œæ–¹æ³•çš„åŒºåˆ«å°±æ˜¯å‡½æ•°æ—¶FunctionNçš„ä¸€ä¸ªå®ä¾‹,ç¼–è¯‘åæ˜¯ä¸€ä¸ªå•ç‹¬çš„classæ–‡ä»¶,è€Œæ–¹æ³•æ˜¯ä¾é™„å¯¹è±¡çš„,è°ƒç”¨æ–¹æ³•çš„æ ¼å¼æ˜¯obj.method(param),è€Œè°ƒç”¨å‡½æ•°çš„æ ¼å¼æœ¬è´¨æ˜¯å°†è°ƒç”¨å‡½æ•°å¯¹è±¡çš„applyæ–¹æ³•.
å‡½æ•°å®šä¹‰åœ¨åˆ«çš„å‡½æ•°å†…éƒ¨å«å±€éƒ¨å‡½æ•°.å‡½æ•°è¿”å›å€¼æ˜¯Unitç§°ä¸ºè¿‡ç¨‹ï¼ˆproceduresï¼‰.
åŒ¿åå‡½æ•°æ˜¯é€šè¿‡å‡½æ•°å­—é¢é‡ï¼ˆ ()=>{å‡½æ•°ä½“} ï¼‰å®šä¹‰çš„å‡½æ•°.åœ¨è¿è¡Œæ—¶,å‡½æ•°å­—é¢é‡è¢«å®ä¾‹åŒ–å¯¹è±¡,å«å‡½æ•°å€¼.
å‡½æ•°å’Œæ–¹æ³•çš„åŒºåˆ«,å¤§éƒ¨åˆ†æƒ…å†µä¸‹ä¸ç”¨åœ¨æ„åŒºåˆ«ï¼š
å‡½æ•°æ˜¯æœ‰ç±»å‹çš„ï¼š (T1, &hellip;, Tn) => U,æ˜¯trait FunctionNçš„ä¸€ä¸ªå®ä¾‹å¯¹è±¡,å‡½æ•°æœ‰ä¸€ä¸ªapplyæ–¹æ³•,ç”¨æ¥å®é™…æ‰§è¡Œfunctionçš„å‡½æ•°ä½“.å‡½æ•°è¿˜æœ‰toString, andThen ,conposeç­‰æ–¹æ³•.
val fn: Int => String = i => i+"123" //å£°æ˜ä¸€ä¸ªå‡½æ•° fn(3) //å®é™…èƒŒåæ˜¯fn.apply(3); scalaä¸­é™¤äº†method,ä¸€åˆ‡éƒ½æ˜¯instance
methodåªèƒ½ç”¨def å£°æ˜,functionå¯ä»¥æ˜¯valå’Œdefå£°æ˜
methodå¯ä»¥æœ‰ç±»å‹å‚æ•°[] ,functionä¸èƒ½æœ‰,å‡½æ•°åœ¨å£°æ˜æ—¶å°±éœ€è¦çŸ¥é“å…·ä½“ç±»å‹.
def fn(p: List[String]): Map[T] = {...} //is function def m[T](t: List[T]): Map[T] = {...} //is method,å¯ä»¥æœ‰æ³›å‹å‚æ•°. å°†methodè½¬æ¢æˆfunctionæœ‰ä¸¤ç§æ–¹æ³•ï¼š val f1 = m1 _ //ä¸‹åˆ’çº¿è¡¨ç¤ºå‚æ•°åˆ—è¡¨ eta-expansion val f2: (Int) => Int = m1 //m1 çš„å…¥å‚å’Œè¿”å›å€¼è¦å’Œf2çš„ä¸€æ · //scalaå¯ä»¥è‡ªåŠ¨å°†methodè½¬æ¢ä¸ºfunction,å¦‚æœä¸€ä¸ªæ–¹æ³•éœ€è¦ä¸€ä¸ªå‡½æ•°ä½œä¸ºå‚æ•°, //é‚£ä¹ˆå¯ä»¥ç›´æ¥å°†m1ä¼ é€’ç»™ä»–,ä¸éœ€è¦ ä¸‹åˆ’çº¿. //æ¯ä¸€æ¬¡å°†æ–¹æ³•è½¬æ¢æˆfunctionéƒ½æ˜¯å¾—åˆ°ä¸€ä¸ªæ–°çš„function object. //functionæ—¢ç„¶æ˜¯ä¸€ä¸ªinstance,é‚£ä¹ˆç¼–è¯‘æˆclassæ–‡ä»¶ä¼šæœ‰ä¸€ä¸ªclassæ–‡ä»¶. _ in scala /** * class Reference[T] { * private var contents: T = _ * //ä½¿ç”¨ç±»å‹é»˜è®¤å€¼åˆå§‹åŒ–å˜é‡,å¦‚æœTæ˜¯Int,åˆ™contentsæ˜¯0,Tæ˜¯boolean,åˆ™æ˜¯falseï¼›Unitåˆ™æ˜¯() * } * * * List(1, 2, 3) foreach (print _ ) //output 123,è¡¨ç¤ºå®å‚ * * //åœ¨åŒ¿åå‡½æ•°ä¸­ä½œä¸ºå‚æ•°å ä½ç¬¦ï¼š * List(1, 2, 3) map ( _ + 2 ) * // _ + 2æ˜¯ä¸€ä¸ªåŒ¿åå‡½æ•° * * //æ¨¡å¼åŒ¹é…ä¸­çš„æœ€åä¸€è¡Œä½œä¸ºé€šé…ç¬¦ * case _ => "this is match anything other than before cases " * * expr match { * * case List(1,_,_) => " a list with three element and the first element is 1" * case List(_*) => " a list with zero or more elements " * case Map[_,_] => " matches a map with any key type and any value type " * case _ => * } * * * //importä¸­ä½œä¸ºé€šé…ç¬¦å’Œéšè—ç¬¦ * import java.util.{ ArrayList => _, _} * //ç¬¬ä¸€ä¸ªä¸‹åˆ’çº¿è¡¨ç¤ºéšè—ArrayList,ç¬¬äºŒä¸ªè¡¨ç¤ºé€šé…ç¬¦,å¯¼å…¥æ‰€æœ‰ * * //å°†æ–¹æ³•å˜ä¸ºvalue * method _ // Eta expansion of method into method value * * //tuple çš„è®¿é—® * tpl._2 //è¿”å›tplç¬¬äºŒä¸ªå…ƒç´ ,æ³¨æ„,tupleæ˜¯ä»1å¼€å§‹çš„ * * * //è¿˜æœ‰å¾ˆå¤šé«˜çº§çš„æ¦‚å¿µ,ç›®å‰è¿˜ä¸ç†è§£,soä¸Šç»™å‡ºçš„ç­”æ¡ˆ * def f[M[_]] // Higher kinded type parameter * def f(m: M[_]) // Existential type * _ + _ // Anonymous function placeholder parameter * m _ // Eta expansion of method into method value * m(_) // Partial function application * _ => 5 // Discarded parameter * case _ => // Wild card pattern -- matches anything * val (a, _) = (1, 2) // same thing * for (_ &lt;- 1 to 10) // same thing * f(xs: _*) // Sequence xs is passed as multiple parameters to f(ys: T*) * case Seq(xs @ _*) // Identifier xs is bound to the whole matched sequence * var i: Int = _ // Initialization to the default value * def abc_&lt;>! // An underscore must separate alphanumerics from symbols on identifiers * t._2 */ => in scala å‡½æ•°å­—é¢é‡åˆ†éš”å‚æ•°å’Œå‡½æ•°ä½“ åœ¨å‡½æ•°å­—é¢é‡ä¸­ =>åˆ†éš”å‚æ•°å’Œå‡½æ•°ä½“. ä¹Ÿå¯ä»¥è¡¨ç¤ºä¸€ä¸ªå‡½æ•°ç±»å‹.
(x: Int) => x * 2è¡¨ç¤ºä¸€ä¸ªåŒ¿åå‡½æ•°,æ¥æ”¶ä¸€ä¸ªæ•´æ•°,è¿”å›å‚æ•°ä¹˜ä»¥2çš„ç»“æœ. scala> val f: Function1[Int,String] = argInt => "my int: "+argInt.toString f: Int => String = &lt;function1> // Int => String ç­‰ä»· Function1[Int,String] scala> val f2: Int => String = myInt => "my int v2: "+myInt.toString f2: Int => String = &lt;function1> //æ³¨æ„,åŒ¿åå‡½æ•°æ²¡æœ‰å‚æ•°ä¹Ÿè¦æ‹¬å· ()=>{}ï¼› //() => Unitè¡¨ç¤ºæ²¡æœ‰è¿”å›å€¼çš„å‡½æ•° call-by-name parameter åœ¨å‡½æ•°çš„å‚æ•°å£°æ˜ä¸­ä½¿ç”¨=>(e.g. def f(arg: => T))è¡¨ç¤ºè¿™ä¸ªå‚æ•°æ˜¯"by-name parameter",è¡¨ç¤ºè¿™ä¸ªå‚æ•°åªæœ‰åœ¨å‡½æ•°ä½“ä¸­åŒ…å«è¿™ä¸ªå‚æ•°çš„è¯­å¥è¢«æ‰§è¡Œæ‰ä¼šè¢«evaluate.
è¿™ä¸ªç‰¹ç‚¹å«call-by-name,argå¯ä»¥æ˜¯ä¸€ä¸ªä»£ç å—,ç”šè‡³å‡½æ•°,åœ¨ä¼ é€’ç»™fæ—¶ä¸ä¼ševaluate,åªæœ‰få‡½æ•°ä½“å†…éƒ¨è°ƒç”¨argæ—¶,argæ‰ä¼šè¢«æ‰§è¡Œ.
scala> def now()={println("nano time:");System.nanoTime} scala> def callByName(p: => Long):Long = {println("call-by-name:"+p);p;} callByName: (p: => Long)Long scala> def justCall(p : Long) :Long = {println("just-call:"+p);p;} justCall: (p: Long)Long scala> callByName(now()) nano time: call-by-name:5664511571389 nano time: res2: Long = 5664511727048 //now()åœ¨callByNameçš„å‡½æ•°ä½“çš„æ¯ä¸ªå‡ºç°çš„åœ°æ–¹éƒ½æ‰§è¡Œäº† scala> justCall(now()) nano time: just-call:5667489483159 res3: Long = 5667489483159 //now()åªåœ¨ä¼ é€’å‚æ•°çš„æ—¶å€™è¢«æ‰§è¡Œäº†. æ¨¡å¼åŒ¹é…ä¸­åˆ†éš”caseæ¨¡å¼å’Œè¿”å›å€¼ åœ¨caseè¯­å¥ä¸­,=> åˆ†éš”æ¨¡å¼å’Œè¿”å›è¡¨è¾¾å¼.
var a = 1 a match{ case 1 => println("One") case 2 => println("Two") case _ => println("No") } () {} in method call // è§„åˆ™1:{}è¡¨ç¤ºcode block,ä½ å¯ä»¥åœ¨é‡Œé¢æ”¾å‡ ä¹ä»»ä½•è¯­å¥,blockçš„è¿”å›å€¼æ˜¯ç”±æœ€åä¸€å¥å†³å®š // è§„åˆ™2:blockå†…å®¹å¦‚æœåªæœ‰ä¸€å¥å¯ä»¥çœç•¥{},ä½†æ˜¯case clauseé™¤å¤–:{case ...} // è§„åˆ™3: å•å‚æ•°æ–¹æ³•å¦‚æœå®å‚æ˜¯code block,é‚£ä¹ˆå¯ä»¥çœç•¥() { import util.Try println{"hello"} 5 } val tupleList = List[(String, String)]() //è§„åˆ™2 tupleList takeWhile( { case(t1,t2) => t1==t2 } ) // è§„åˆ™2 List(1, 2, 3).reduceLeft(_+_) // ä¸€ç§ç‰¹æ®Šæƒ…å†µ,æç¤º:éšå¼è½¬æ¢ val r = List(1, 2, 3).foldLeft(0) {_+_} //val l = r{"hello"} //ä¸è¦è°ƒç”¨è¿™ä¸ªæ–¹æ³• def loopf(x: Int): Int = loopf {x} //ä½¿ç”¨{}çš„ç‰¹æ®Šæƒ…å†µ:foræ¨å¯¼å¯ä»¥å’Œ()äº’æ¢,ä¸€èˆ¬å»ºè®®æ˜¯é™¤äº†yieldçš„å…¶ä»–æƒ…å†µéƒ½ç”¨() for{tpl &lt;-tupleList} yield tpl._2 //ä¸å»ºè®® for{tpl &lt;-tupleList} { println(tpl) } //æ¨è for(tpl &lt;-tupleList) { println(tpl) } //è¡¥å……, æ–¹æ³•å®šä¹‰æ—¶å¦‚æœæ²¡æœ‰è¿”å›å€¼å¯ä»¥çœç•¥=,ç§°ä¸ºprocedure,scala 2.13å·²ç»åºŸå¼ƒ,ä¸è¦è¿™ä¹ˆå†™ //don't def p(in:String ){ println(s"hello $in") } implicit implicitåˆ†ä¸ºéšå¼å‚æ•°å’Œéšå¼è½¬æ¢æ–¹æ³•.
éšå¼å‚æ•° //1.éšå¼å‚æ•° class Prefixer(val prefix: String) def addPrefix(s: String)(implicit p: Prefixer) = p.prefix + s // addPrefixéœ€è¦æä¾›ä¸€ä¸ªéšå¼å®é™…å‚æ•°,å¦åˆ™æŠ¥é”™.å½“ç„¶å¯ä»¥åœ¨è°ƒç”¨æ—¶æ˜¾å¼ä¼ é€’ä¸€ä¸ªå‚æ•° implicit val myImplicitPrefixer = new Prefixer("***") addPrefix("abc") // returns "***abc" éšå¼è½¬æ¢ //1. å®šä¹‰ä¸€ä¸ªå«æœ‰ç›®æ ‡æ–¹æ³•çš„class class BlingString(s:String) { def bling = "*"+s+"*" } //2. å®šä¹‰éšå¼è½¬æ¢æ–¹æ³• implicit def str2BlingString(s:String) = new BlingString(s) //3. ä½¿ç”¨ç›®æ ‡æ–¹æ³• val s = "hello" s.bling // *hello* //åœ¨scala.Predefä¸­å®šä¹‰äº†å¤§é‡çš„éšå¼è½¬æ¢,ä¾‹å¦‚RichInt,StringOpsè¿™äº›,æä¾›ç±»ä¼¼mkStringè¿™äº›æ–¹æ³• //å¤ªé˜³åº•ä¸‹æ— æ–°äº‹,scalaå¸¸ç”¨å¯¹è±¡çš„çµæ´»ä¸°å¯Œçš„è¯­æ³•éƒ½æ˜¯é€šè¿‡éšå¼è½¬æ¢æ·»åŠ çš„. implicit class å¯ä»¥çœ‹åˆ°ä¸Šé¢çš„ç¬¬1,2æ­¥éå¸¸çš„ç¹ç,äºæ˜¯SIP-13æå‡ºä¸€ä¸ªimplicit class,å°†ä¸Šé¢çš„2æ­¥åˆå¹¶:
implicit class BlingString(s:String) { def bling = "*"+s+"*" } //implicit def str2BlingString(s:String) = new BlingString(s) val hi = "hello" hi.bling // *hello* æ³¨æ„,è¿™ä¸ªåªæ˜¯ä¸€ä¸ªè¯­æ³•ç³–.å»ç³–åå°±æ˜¯ä¸Šé¢çš„é‚£ä¸ªå½¢å¼. implicit classæœ‰3ä¸ªçº¦æŸå’Œä¸€ä¸ªæ³¨è§£é—®é¢˜ï¼š
å¿…é¡»è¦æœ‰ä¸»ä¸€ä¸ªæ„é€ å‡½æ•°ä¸”åªèƒ½ä¸€ä¸ªæ„é€ å‚æ•°ï¼ˆimplicitå‚æ•°é™¤å¤–ï¼‰.æ„é€ å‚æ•°å°±æ˜¯æºç±»å‹. è¿™ä¸ªæ„é€ å‡½æ•°å³ç­‰ä»·ä¸Šé¢ç¬¬2æ­¥çš„éšå¼è½¬æ¢æ–¹æ³•ï¼š
implicit class RichDate(date: java.util.Date) // OK! implicit class Indexer[T](collecton: Seq[T], index: Int) // BAD! implicit class Indexer[T](collecton: Seq[T])(implicit index: Index) // OK! åªèƒ½å®šä¹‰åœ¨å…¶ä»–trait/class/objectä¸­ï¼š
object Helpers { implicit class RichInt(x: Int) // OK! } implicit class RichDouble(x: Double) // BAD! åœ¨å½“å‰scopeå†…,ä¸å…è®¸æœ‰å’Œimplicit classåŒåçš„æ–¹æ³•,å¯¹è±¡,å˜é‡.å› ä¸ºcase classä¼šè‡ªåŠ¨ç”ŸæˆåŒåobjectå¯¹è±¡,æ‰€ä»¥implicit classä¸èƒ½æ˜¯case class.
object Bar implicit class Bar(x: Int) // BAD! val x = 5 implicit class x(y: Int) // BAD! //cuz case class has companion object by default implicit case class Baz(x: Int) // BAD! conflict with the companion object è¿˜æœ‰å°±æ˜¯implicit classçš„æ³¨è§£åœ¨å»è¯­æ³•ç³–åä¼šè‡ªåŠ¨æ·»åŠ åˆ°ç±»å’Œæ–¹æ³•,é™¤éåœ¨æ³¨è§£ä¸­æŒ‡æ˜èŒƒå›´ï¼š
@bar implicit class Foo(n: Int) //desugar @bar implicit def Foo(n: Int): Foo = new Foo(n) @bar class Foo(n:Int) //é™¤éåœ¨æ³¨è§£ä¸­æŒ‡æ˜ï¼šgenClass / method @(bar @genClass) implicit class Foo(n: Int) //desugarå¾—åˆ° @bar class Foo(n: Int) implicit def Foo(n: Int): Foo = new Foo(n) value class scala è¿˜æœ‰ä¸€ä¸ªæ¦‚å¿µï¼švalue class
class Wrapper(val underlying: Int) extends AnyVal //1. ä¸€ä¸ªpublic valå‚æ•°è¡¨ç¤ºruntimeç±»å‹,è¿™é‡Œæ˜¯Int. ç¼–è¯‘æ—¶æ˜¯Wrapperç±»å‹,æ‰€ä»¥value classç›®çš„æ˜¯é™ä½åˆ†é…å¼€é”€. //2. value class éœ€è¦ extends AnyVal //3. value class åªèƒ½æœ‰ defs, ä¸èƒ½æœ‰vals, vars, or nested traits, classes or objects, // å› ä¸ºdefæ˜¯é€šè¿‡é™æ€æ–¹æ³•å®ç°çš„,è€Œval,varè¿™äº›åˆ™å¿…é¡»åˆ›å»ºç›¸åº”ç±»å‹äº†. //4. value class åªèƒ½æ‰©å±•é€šç”¨traitï¼ˆuniversal traitsï¼‰, // universal traitsæ˜¯A universal trait is a trait that extends Any, only has defs as members, and does no initialization. // extension method å½“implicit classç±»å‹å‚æ•°æ˜¯AnyValå­ç±»æ—¶,value classå’Œä¸Šé¢çš„implicit classå½¢å¼ç›¸è¿‘,æ‰€ä»¥å¯ä»¥é€šè¿‡value classé™ä½implicit classçš„åˆ†é…å¼€é”€.ä¾‹å¦‚RichtInt
implicit class RichInt(val self: Int) extends AnyVal { def toHexString: String = java.lang.Integer.toHexString(self) } å› ä¸ºRichIntæ˜¯value class,åœ¨è¿è¡Œæ—¶ï¼ˆruntimeï¼‰ä¸ä¼šæœ‰RichIntè¿™ä¸ªç±»,è€Œæ˜¯Int,è€Œ3.toHexStringå®é™…æ˜¯é€šè¿‡é™æ€æ–¹æ³•å®ç°çš„ï¼š RichInt$.MODULE$.extension$toHexString(3),è¿™ä¹ˆåšå¥½å¤„æ˜¯å‡å°‘å¯¹è±¡åˆ†é…å¼€é”€(avoid the overhead of allocation).å¦‚æœimplicit classçš„ç±»å‹å‚æ•°ä¸æ˜¯AnyValå­ç±»,é‚£ä¹ˆåœ¨runtimeæ—¶ä¼šæœ‰ç›¸åº”ç±»å‹å¯¹è±¡è¢«åˆ›å»º,ç”¨æˆ·å¯Ÿè§‰ä¸åˆ°åŒºåˆ«.
value classè¿˜æœ‰å…¶ä»–ä½œç”¨å’Œå±€é™æ€§,å¯ä»¥å‚è€ƒä¸Šé¢é“¾æ¥.å¦‚æœå‘ç°é”™è¯¯,è¯·æŒ‡å‡º,å…ˆè°¢è¿‡.
Implicit Design Patterns in Scalaâ€‹www.lihaoyi.com
The Neophyte&rsquo;s Guide to Scalaâ€‹
é›†åˆç±»çš„implicitè½¬æ¢ //scalaé›†åˆå’Œjavaé›†åˆçš„è½¬æ¢æ˜¯scalaç¼–ç¨‹æœ€å¸¸ç”¨çš„,æ¯•ç«Ÿjavaæœ‰å¤§é‡ç¬¬ä¸‰æ–¹åº“. //scalaæä¾›äº†ä¸¤ç§æ–¹æ³•,ç¬¬ä¸€ç§æ–¹æ³•å°±æ˜¯éšå¼è½¬æ¢collection.JavaConversions(scala 2.8) //å¾ˆå¿«æ„è¯†åˆ°éšå¼è½¬æ¢å¯¹äºä½¿ç”¨è€…çš„ä»£ç é˜…è¯»æ¯”è¾ƒå¤æ‚,åœ¨2.8.1æä¾›äº†æ˜¾ç¤ºè½¬æ¢collection.JavaConverters, //å…ˆçœ‹JavaConversionséšå¼è½¬æ¢: object JavaConversions extends WrapAsScala with WrapAsJava //åœ¨WrapAsJava implicit def mapAsJavaMap[A, B](m: Map[A, B]): ju.Map[A, B] = m match { case null => null case JMapWrapper(wrapped) => wrapped.asInstanceOf[ju.Map[A, B]] case _ => new MapWrapper(m) } //ç„¶åçœ‹ä¸‹collection.JavaConverters._,ç¨å¾®å¤æ‚ä¸€äº›,ä½†æ˜¯æ¢æ±¤ä¸æ¢è¯,åº•å±‚è¿˜æ˜¯éšå¼è½¬æ¢, object JavaConverters extends DecorateAsJava with DecorateAsScala //åœ¨DecorateAsJavaä¸­æœ‰å¾ˆå¤šéšå¼è½¬æ¢æ–¹æ³•,è¿™äº›æ–¹æ³•å°†scalaé›†åˆè½¬æ¢ä¸ºAsJavaå¯¹è±¡ //(æ³¨æ„ä¸‹é¢çš„ju,æ˜¯java.utilç¼©å†™,è¯¦æƒ…è§[å¾æœscala_1](https://zhuanlan.zhihu.com/p/22670426)) implicit def seqAsJavaListConverter[A](b : Seq[A]): AsJava[ju.List[A]] = new AsJava(seqAsJavaList(b)) // è€ŒAsJavaä¸­å®šä¹‰äº†asJavaæ–¹æ³•,è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åœ¨scalaé›†åˆä¸Šé¢è°ƒç”¨asJava class AsJava[A](op: => A) { /** Converts a Scala collection to the corresponding Java collection */ def asJava: A = op } //å¹¶ä¸”asJavaæ–¹æ³•çš„å®ç°æ˜¯ä½œä¸ºæ„é€ å‚æ•°ä¼ å…¥AsJavaçš„ //ä¸Šé¢çš„seqAsJavaListå°±æ˜¯å°†scala.Seqè½¬æ¢ä¸ºju.Listçš„å…·ä½“å®ç° def seqAsJavaList[A](s: Seq[A]): ju.List[A] = s match { case null => null case JListWrapper(wrapped) => wrapped.asInstanceOf[ju.List[A]] case _ => new SeqWrapper(s) } //ç»¼ä¸Š,JavaConvertersç”¨çš„è¿˜æ˜¯éšå¼è½¬æ¢,åªä¸è¿‡å¢åŠ äº†ä¸€ä¸ªä¸­é—´ç±»AsJava/AsScala. éšå¼è½¬æ¢çš„scope //æ— è®ºæ˜¯éšå¼å‚æ•°è¿˜æ˜¯éšå¼è½¬æ¢,ç¼–è¯‘å™¨éƒ½è¦çŸ¥é“å»å“ªé‡ŒæŸ¥æ‰¾è¿™äº›implicitå‚æ•°æˆ–è€…æ–¹æ³•, //ä¾‹å¦‚import collection.JavaConverters._ //ç”±äºscala importå¯ä»¥å‡ºç°åœ¨ä»»ä½•åœ°æ–¹,è¿™ä¸ºæ§åˆ¶implicitçš„scopeæä¾›äº†çµæ´»æ€§ //è¿™ä¸€å—æˆ‘ä¸æ˜¯å®Œå…¨æ¸…æ¥š,åªæä¾›ä¸€ä¸ªè‡ªå·±çš„ç†è§£ // 1.é¦–å…ˆæ˜¯å½“å‰scopeçš„Implicitså®šä¹‰,ä¾‹å¦‚,å½“å‰æ–¹æ³•å†…,classå†… // 2.æ˜¾å¼å¯¼å…¥ import collection.JavaConversions.asScalaIterator // 3.é€šé…ç¬¦å¯¼å…¥ import collection.JavaConverters._ // 4.ç±»å‹çš„ä¼´ç”Ÿå¯¹è±¡å†…(è¿™ä¸ªå¸¸ç”¨) // 5.å‚æ•°ç±»å‹çš„éšå¼scope (2.9.1æ·»åŠ ):classæ„é€ å‚æ•°çš„éšå¼è½¬æ¢æœç´¢è¿”å›ä¼šè¢«åº”ç”¨åˆ° class A(val n: Int) { def +(other: A) = new A(n + other.n) } object A { implicit def fromInt(n: Int) = new A(n) } new A(1) + 2 // new A(1) + A.fromInt(2) //6.ç±»å‹å‚æ•°çš„éšå¼è½¬æ¢,ä¸‹é¢çš„sortedæ–¹æ³•æœŸæœ›æœ‰ä¸€ä¸ªOrdering[A], //åœ¨ä¼´ç”Ÿå¯¹è±¡ä¸­æä¾›äº†ä¸€ä¸ª A -> Ordering[A] , class A(val n: Int) object A { implicit val ord = new Ordering[A] { def compare(x: A, y: A) = implicitly[Ordering[Int]].compare(x.n, y.n) } } List(new A(5), new A(2)).sorted // æ³¨æ„implicitly[Ordering[Int]] è¡¨ç¤ºåœ¨å½“å‰scopeå†…æœç´¢ä¸€ä¸ªéšå¼å‚æ•°å€¼ def implicitly[T](implicit e: T): T = e string // The s String Interpolator: val name = "James" println(s"Hello, $name") // Hello, James // The f Interpolator val height = 1.9d val name = "James" println(f"$name%s is $height%2.2f meters tall") // James is 1.90 meters tall // The raw Interpolator // The raw interpolator is similar to the s interpolator except that // it performs no escaping of literals within the string. // Hereâ€™s an example processed string // å³ä¸ç¿»è¯‘è½¬ä¹‰å­—ç¬¦ scala>raw"a\nb" res1: String = a\nb // """ triple quotes string // triple quotes """ to escape characters val donutJson4: String = """ |{ |"donut_name":"Glazed Donut", |"taste_level":"Very Tasty", |"price":2.50 |} """ .stripMargin // |ä¼šè¢«å¿½ç•¥ // """è¿˜æœ‰ä¸ªå¾ˆå¥½çš„ç”¨å¤„,æ­£åˆ™è¡¨è¾¾å¼: // åœ¨javaä¸­è¡¨ç¤ºä¸€ä¸ªæˆ–å¤šä¸ªç©ºæ ¼,"\\s+" // åœ¨scalaä¸­åªè¦ """\s+""",å¯¹äºå¤æ‚æ­£åˆ™è¡¨è¾¾å¼éå¸¸æœ‰ç”¨. links https://www.btbytes.com/scala.html
https://booksites.artima.com/programming_in_scala_2ed/examples/index.html
http://blog.higher-order.com/assets/fpiscompanion.pdf
https://courses.cs.washington.edu/courses/cse341/09au/notes/scala.html
https://github.com/dnvriend/my-scala-notes
https://gist.github.com/jamesyang124/d65b067327452792287a</content></entry><entry><title>ä½¿ç”¨redisçš„hashä¼˜åŒ–å†…å­˜ä½¿ç”¨[ç¿»è¯‘]</title><url>https://zhimoe.github.io/post/%E4%BD%BF%E7%94%A8redis%E7%9A%84hash%E4%BC%98%E5%8C%96%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8/</url><categories><category>ç¿»è¯‘</category></categories><tags><tag>code</tag><tag>redis</tag></tags><content type="html"> ä½¿ç”¨redisçš„hashä¼˜åŒ–å†…å­˜ä½¿ç”¨
é—®é¢˜å’Œæ–¹æ¡ˆ åœºæ™¯: æœ‰3äº¿å¼ å›¾ç‰‡æ”¾åœ¨å¯¹è±¡å­˜å‚¨(DELL ECS/AMAZON EC2)ä¸Šé¢,ç°åœ¨éœ€è¦ä¿å­˜å›¾ç‰‡çš„id->ç”¨æˆ·idçš„æ˜ å°„.æœ€ç›´æ¥çš„æ€è·¯æ˜¯:
set "media:1155220" "user1" set "media:1155221" "user2" è¿™æ ·è®¾è®¡keyä¹‹å3äº¿å¼ å›¾ç‰‡éœ€è¦21GBçš„å†…å­˜,å› ä¸ºredisçš„stringæ˜¯çº¿æ€§å¢é•¿çš„.
æ­¤æ—¶å¯ä»¥ä½¿ç”¨hashä¼˜åŒ–å†…å­˜ä½¿ç”¨.hashæ˜¯ç±»ä¼¼java hashmapçš„æ•°æ®ç»“æ„: key field1 value1 field2 value2 &hellip;
hashçš„å¼ºå¤§åœ¨äºå®ƒå¯ä»¥åªè·å–ä¸€ä¸ªfieldçš„value,è€Œæ— éœ€è¿”å›æ•´ä¸ªkey.
å†ä»”ç»†æƒ³æƒ³,hashçš„keyå¯ä»¥ç±»æ¯”äºåˆ†åº“åˆ†è¡¨çš„bucketæ¦‚å¿µ.
å›åˆ°ä¸Šé¢çš„é—®é¢˜,Mike Krieger,Instagramçš„åˆ›å§‹äººæå‡ºå°†å›¾ç‰‡çš„idé™¤ä»¥1000åˆ†ç‰‡(sharding)åˆ°1000ä¸ªhash keyä¸Š:
HSET "mda-bkt:1155" "1155220" "user1" "1155221" "user2" # mda-bkt:1155 æ˜¯1155220/1000ä¹‹åå¾—åˆ°çš„bucket. HGET "mda-bkt:1155" "1155220" # è¿™é‡Œkeyçš„å‰ç¼€*mda-bkt:)åªé‡å¤äº†1000æ¬¡,è€Œä¸Šé¢çš„stringæ–¹å¼é‡å¤äº†3äº¿æ¬¡. å› ä¸ºredisé’ˆå¯¹hash list zsetä¸‰ç§ç»“æ„ä½¿ç”¨äº†ziplisté«˜æ•ˆå­˜å‚¨æ–¹æ¡ˆ.
æ–°çš„é—®é¢˜åˆæ¥äº†,rediså¯¹äºziplistç»“æ„çš„keyæ•°é‡æœ‰é™åˆ¶çš„,å³hash-max-ziplist-entriesçš„å«ä¹‰æ˜¯: å¯ä½¿ç”¨å†…éƒ¨ç©ºé—´ä¼˜åŒ–å­˜å‚¨çš„æœ€å¤šhash key
ä½¿ç”¨ziplistçš„æ•°æ®ç»“æ„æœ‰ä¸‰ä¸ªlist hash zset:
list-max-ziplist-entries 512 list-max-ziplist-value 64 #Limits for ziplist use with LISTs. hash-max-ziplist-entries 512 hash-max-ziplist-value 64 #Limits for ziplist use with HASHes (previous versions of Redis used a different name and encoding for this) #hash-max-zipmap-entries 512 (for Redis &lt; 2.6). zset-max-ziplist-entries 128 zset-max-ziplist-value 64 #Limits for ziplist use with ZSETs. ä½ å¯ä»¥ä½¿ç”¨debug_object(key)æŸ¥çœ‹ä½ çš„keyæ˜¯å¦ä½¿ç”¨äº†ziplistç»“æ„.
å»ºè®®hash-max-ziplist-entriesæœ€å¤§è®¾ç½®ä¸º1000,è¿‡å¤§ä¼šå½±å“redisæ€§èƒ½.
å‚è€ƒèµ„æ–™ redis moemory optimize
9.1.1 The ziplist representation-EBOOK â€“ REDIS IN ACTION
source:Understanding Redis hash-max-ziplist-entries</content></entry><entry><title>Scala 2 Implicit</title><url>https://zhimoe.github.io/post/scala-implicit/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>scala</tag></tags><content type="html"> éšå¼å‚æ•° //éšå¼å‚æ•°æ˜¯åœ¨è°ƒç”¨æ—¶å¯ä»¥è‡ªåŠ¨å¡«å……çš„å‚æ•°, éœ€è¦åœ¨è°ƒç”¨èŒƒå›´å†…ï¼ˆscope)æœ‰ä¸€ä¸ªéšå¼å˜é‡å¯ä¾›å¡«å……. def addInt(i:Int)(implicit n: Int) = i + n //éœ€è¦æä¾›ä¸€ä¸ªéšå¼å˜é‡n implicit val sn = 1 addInt(2) // 3 //å¦‚æœæœ‰ä¸¤ä¸ªæ»¡è¶³ç±»å‹çš„éšå¼å˜é‡,åˆ™åœ¨ç¼–è¯‘addInt(2)æ—¶æŠ¥é”™ //scalaçš„æ–¹æ³•ä¸­ExecutionContextä¸€èˆ¬ä½œä¸ºimplicitå‚æ•°. éšå¼è½¬æ¢æ–¹æ³• å¦‚æœæƒ³è¦ç»™Stringå®ç°ä¸€ä¸ªmkStræ–¹æ³•,ç®€å•çš„ç»™Stringæ·»åŠ ä¸€ä¸ªOps!å‰ç¼€å†è¿”å›.
//1. é¦–å…ˆå®ç°ä¸€ä¸ªåŒ…å«ç›®æ ‡æ–¹æ³•çš„ç±»å‹,å®ç°è¯¥æ–¹æ³• class StrOps(s:String) { def mkStr(): String = { return "Ops! " + s } } //2. å‘Šè¯‰scalaç¼–è¯‘å™¨Stringå¯ä»¥é€šè¿‡ç±»å‹è½¬æ¢è·å¾—mkStrè¿™ä¸ªæ–¹æ³•ï¼š implicit final def string2StrOps(s: String) = new StrOps(s) //3. ç°åœ¨ç”¨æˆ·å¯ä»¥ç›´æ¥è®¤ä¸ºStringæœ‰mkStræ–¹æ³• val s = "who changed my string" s.mkStr() //res2: String = Ops! who changed my string //åœ¨scala.Predefä¸­å®šä¹‰äº†å¤§é‡çš„éšå¼è½¬æ¢,ä¾‹å¦‚RichInt,RichDouble,StringOpsè¿™äº› implicit class å¯ä»¥çœ‹åˆ°ç¬¬2æ­¥éå¸¸çš„å†—ä½™,äºæ˜¯SIP-13æå‡ºä¸€ä¸ªimplicit class,å°†ä¸Šé¢çš„1,2æ­¥åˆå¹¶:
implicit class StrOps(s:String) { def mkStr(): String = { return "Ops! " + s } } æ³¨æ„,è¿™ä¸ªåªæ˜¯ä¸€ä¸ªè¯­æ³•ç³–.å»ç³–åå°±æ˜¯ä¸Šé¢çš„é‚£ä¸ªå½¢å¼. implicit classæœ‰3ä¸ªçº¦æŸå’Œä¸€ä¸ªæ³¨è§£é—®é¢˜ï¼š
å¿…é¡»è¦æœ‰ä¸»ä¸€ä¸ªæ„é€ å‡½æ•°ä¸”åªèƒ½ä¸€ä¸ªæ„é€ å‚æ•°ï¼ˆimplicitå‚æ•°é™¤å¤–ï¼‰.æ„é€ å‚æ•°å°±æ˜¯æºç±»å‹. è¿™ä¸ªæ„é€ å‡½æ•°å³ç­‰ä»·ä¸Šé¢ç¬¬2æ­¥çš„éšå¼è½¬æ¢æ–¹æ³•ï¼š
implicit class RichDate(date: java.util.Date) // OK! implicit class Indexer[T](collecton: Seq[T], index: Int) // BAD! implicit class Indexer[T](collecton: Seq[T])(implicit index: Index) // OK! åªèƒ½å®šä¹‰åœ¨å…¶ä»–trait/class/objectä¸­ï¼š
object Helpers { implicit class RichInt(x: Int) // OK! } implicit class RichDouble(x: Double) // BAD! åœ¨å½“å‰scopeå†…,ä¸å…è®¸æœ‰å’Œimplicit classåŒåçš„æ–¹æ³•,å¯¹è±¡,å˜é‡.å› ä¸ºcase classä¼šè‡ªåŠ¨ç”ŸæˆåŒåobjectå¯¹è±¡,æ‰€ä»¥implicit classä¸èƒ½æ˜¯case class.
object Bar implicit class Bar(x: Int) // BAD! val x = 5 implicit class x(y: Int) // BAD! //cuz case class has companion object by default implicit case class Baz(x: Int) // BAD! conflict with the companion object è¿˜æœ‰å°±æ˜¯implicit classçš„æ³¨è§£åœ¨å»è¯­æ³•ç³–åä¼šè‡ªåŠ¨æ·»åŠ åˆ°ç±»å’Œæ–¹æ³•,é™¤éåœ¨æ³¨è§£ä¸­æŒ‡æ˜èŒƒå›´ï¼š
@bar implicit class Foo(n: Int) //desugar @bar implicit def Foo(n: Int): Foo = new Foo(n) @bar class Foo(n:Int) //é™¤éåœ¨æ³¨è§£ä¸­æŒ‡æ˜ï¼šgenClass / method @(bar @genClass) implicit class Foo(n: Int) //desugarå¾—åˆ° @bar class Foo(n: Int) implicit def Foo(n: Int): Foo = new Foo(n) implicitlyæ–¹æ³• scalaçš„PreDefä¸­æœ‰æœ‰ä¸€ä¸ªimplicitlyæ–¹æ³•,è¡¨ç¤ºåœ¨å½“å‰scopeå¾å¬ä¸€ä¸ªéšå¼å˜é‡å¹¶è¿”å›è¯¥å˜é‡.
//PreDef @inline def implicitly[T](implicit e: T) = e implitly[T] means return implicit value of type T in the context
implicit class Foo(val i: Int) { def addValue(v: Int): Int = i + v } implicit val foo:Foo = Foo(1) val fooImplicitly = implicitly[Foo] // Foo(1) value class scala è¿˜æœ‰ä¸€ä¸ªæ¦‚å¿µï¼švalue class
class Wrapper(val underlying: Int) extends AnyVal //1. ä¸€ä¸ªpublic valå‚æ•°è¡¨ç¤ºruntimeç±»å‹,è¿™é‡Œæ˜¯Int. ç¼–è¯‘æ—¶æ˜¯Wrapperç±»å‹,æ‰€ä»¥value classç›®çš„æ˜¯é™ä½åˆ†é…å¼€é”€. //2. value class éœ€è¦ extends AnyVal //3. value class åªèƒ½æœ‰ defs, ä¸èƒ½æœ‰vals, vars, or nested traits, classes or objects, // å› ä¸ºdefæ˜¯é€šè¿‡é™æ€æ–¹æ³•å®ç°çš„,è€Œval,varè¿™äº›åˆ™å¿…é¡»åˆ›å»ºç›¸åº”ç±»å‹äº†. //4. value class åªèƒ½æ‰©å±• é€šç”¨traitï¼ˆuniversal traitsï¼‰, // universal traitsæ˜¯A universal trait is a trait that extends Any, only has defs as members, and does no initialization. extension method å½“implicit classç±»å‹å‚æ•°æ˜¯AnyValå­ç±»æ—¶,value classå’Œä¸Šé¢çš„implicit classå½¢å¼ç›¸è¿‘,æ‰€ä»¥å¯ä»¥é€šè¿‡value classé™ä½implicit classçš„åˆ†é…å¼€é”€.ä¾‹å¦‚RichtInt
implicit class RichInt(val self: Int) extends AnyVal { def toHexString: String = java.lang.Integer.toHexString(self) } å› ä¸ºRichIntæ˜¯value class,åœ¨è¿è¡Œæ—¶ï¼ˆruntimeï¼‰ä¸ä¼šæœ‰RichIntè¿™ä¸ªç±»,è€Œæ˜¯Int,è€Œ3.toHexStringå®é™…æ˜¯é€šè¿‡é™æ€æ–¹æ³•å®ç°çš„ï¼š RichInt$.MODULE$.extension$toHexString(3),è¿™ä¹ˆåšå¥½å¤„æ˜¯å‡å°‘å¯¹è±¡åˆ†é…å¼€é”€ï¼ˆavoid the overhead of allocationï¼‰.å¦‚æœimplicit classçš„ç±»å‹å‚æ•°ä¸æ˜¯AnyValå­ç±»,é‚£ä¹ˆåœ¨runtimeæ—¶ä¼šæœ‰ç›¸åº”ç±»å‹å¯¹è±¡è¢«åˆ›å»º,ç”¨æˆ·å¯Ÿè§‰ä¸åˆ°åŒºåˆ«.
value classè¿˜æœ‰å…¶ä»–ä½œç”¨å’Œå±€é™æ€§,å¯ä»¥å‚è€ƒä¸Šé¢é“¾æ¥.</content></entry><entry><title>ä½¿ç”¨travisè‡ªåŠ¨å‘å¸ƒmarkdownåˆ°åšå®¢</title><url>https://zhimoe.github.io/post/%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83markdown%E5%88%B0%E5%8D%9A%E5%AE%A2/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>github</tag></tags><content type="html"> å¦‚ä½•ä½¿ç”¨github pageså’Œgithub actionsæ„å»ºé™æ€ä¸ªäººåšå®¢ç«™ç‚¹
update at 2021 æ›´æ–°ï¼šgithubå¼€æ”¾actionåŠŸèƒ½å,travis-ciå·²ç»æ²¡æœ‰å¿…è¦äº†,ç›®å‰åšå®¢ä½¿ç”¨zhimoeä»“åº“ç®¡ç†æºç ,ä½¿ç”¨actionç¼–è¯‘åå°†publicç›®å½•åŒæ­¥åˆ°zhimoe.github.ioä»“åº“çš„gh-pagesåˆ†æ”¯.
æ³¨æ„,ç”±äºä½¿ç”¨äº†jsdelivrçš„cdnåŠŸèƒ½,åˆ‡æ¢åˆ†æ”¯åthemeçš„ç›¸å…³é™æ€æ–‡ä»¶çš„pathä¹Ÿè¦ä¿®æ”¹.
githubç»™ä¸ªäººå’Œç»„ç»‡å…è´¹æä¾›github pagesåŠŸèƒ½. å°±æ˜¯è¯´å¦‚æœæœ‰ä¸ªrepoçš„åå­—ä¸º zhimoe.github.io (zhimoe ä¸ºä½ çš„github username), é‚£ä¹ˆè¿™ä¸ªrepoé‡Œé¢çš„masteræˆ–è€…gh-pagesåˆ†æ”¯çš„å†…å®¹å¦‚æœå­˜åœ¨index.html, é‚£ä¹ˆå…¶ä»–äººå¯ä»¥é€šè¿‡ https://zhimoe.github.io è®¿é—®è¿™ä¸ªç«™ç‚¹.
å€ŸåŠ©äºä¸€äº›static genå·¥å…·,ä½ å¯ä»¥å°†ä½ çš„markdownè½¬æ¢ä¸ºä¸€ä¸ªé™æ€ç½‘ç«™(html,js,css). ç„¶åæŠŠé™æ€ç½‘ç«™çš„å†…å®¹ä¸Šä¼ åˆ°åˆšè¯´çš„repoä¸­, å°±æœ‰ä¸€ä¸ªè‡ªå·±çš„åšå®¢ç«™ç‚¹äº†. static genå·¥å…·éå¸¸å¤š, githubæ¨èçš„æ˜¯Jekyll(ruby), ä¸»æµçš„è¿˜æœ‰hexo(js)å’Œhugo(go), hexoå› ä¸ºæ˜¯åŸºäºjsçš„,æ‰€ä»¥é«˜è´¨é‡çš„ä¸»é¢˜å¤š(å› ä¸ºåšä¸»é¢˜æ˜¯éœ€è¦js,cssæŠ€èƒ½), hugoçš„ç¼–è¯‘å¿«äº›, ä½†æ˜¯å¥½çœ‹çš„ä¸»é¢˜ä¸å¤š. é«˜è´¨é‡çš„ä¸»é¢˜é™¤äº†ç¾è§‚å¯èƒ½è¿˜éœ€è¦è€ƒè™‘ç§»åŠ¨ç«¯(responsive),è¯„è®º, è®¿é—®ç»Ÿè®¡ç­‰å„ç§åŠŸèƒ½. æ¯ä¸ªgenå·¥å…·éƒ½æœ‰è‡ªå·±çš„ä¸»é¢˜ç«™ç‚¹. hugoçš„ä¸»é¢˜åœ¨è¿™é‡Œæ‰¾: hugo themes.
åˆ¶ä½œgithub pagesç«™ç‚¹çš„ä¸€èˆ¬åšæ³•æ˜¯æŠŠä»£ç (æ”¾å›¾ç‰‡å’Œmarkdown)æ”¾åœ¨masteråˆ†æ”¯,static genç¼–è¯‘åçš„(html,js,css,image)å†…å®¹æ”¾åœ¨gh-pagesåˆ†æ”¯.ç„¶ååœ¨settingsé‡Œé¢è®¾ç½®. è¿™æ ·å°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªç«™ç‚¹äº†. è¿™ä¹ˆåšæœ‰ä¸ªç¼ºç‚¹,å°±æ˜¯markdownæ–‡ä»¶ä¼šè¢«åˆ«äººæ•´ä¸ªä¸‹è½½è¿‡å»,ä¹‹å‰å°±é‡åˆ°è¿‡ä¸€æ¬¡. æ­£å¥½githubç°åœ¨æœ‰3ä¸ªå…è´¹ç§æœ‰ä»“åº“. æ‰€ä»¥æˆ‘æŠŠæºç æ”¾åœ¨ç§æœ‰ä»“åº“zhimoe.github.io.srcé‡Œé¢,è€Œç¼–è¯‘åçš„å†…å®¹å‘å¸ƒçš„ https://zhimoe.github.ioä¸Šé¢å».
è‡ªåŠ¨ç¼–è¯‘å‘å¸ƒè¿™ä¸ªè¿‡ç¨‹å°±æ˜¯æŒç»­é›†æˆ(continue integration,CI)äº†, å³æˆ‘æäº¤ä¸€ä¸ªmarkdownæ–‡ä»¶,æˆ‘çš„ä¸»é¡µä¼šè‡ªåŠ¨çœ‹åˆ°è¿™ç¯‡æ–‡ç« , ä¸éœ€è¦æˆ‘åœ¨æœ¬åœ°ç¼–è¯‘å†æäº¤ç¼–è¯‘ç»“æœæ–‡ä»¶.travis-ci æä¾›äº†å…è´¹çš„github CIæœåŠ¡. ä½¿ç”¨githubè´¦å·ç™»å½•å°±ä¼šæœ‰æç¤ºæ“ä½œ. è¿™é‡Œå‹¾é€‰ç§æœ‰ä»“åº“zhimoe.github.io.src, ç„¶ååœ¨é¡¹ç›®é‡Œé¢æ·»åŠ .travis.ymlæ–‡ä»¶å‘Šè¯‰traviså¦‚ä½•ç¼–è¯‘å’Œå‘å¸ƒå†…å®¹åˆ°ä¸ªäººç«™ç‚¹.
markdownæ¸²æŸ“è®¾ç½® hugoä½¿ç”¨BlackFridayæ¸²æŸ“markdownæ–‡ä»¶,é»˜è®¤çš„è®¾ç½®æœ‰å‡ ä¸ªè¿‡äºä¸¥æ ¼:
æ²¡æœ‰ç¡¬æ¢è¡Œ,éœ€è¦ä½¿ç”¨\æ¥è¡¨ç¤ºæ¢è¡Œ æ ‡é¢˜å’Œ#ä¹‹é—´å¿…é¡»æœ‰ç©ºæ ¼ ä»£ç å—å‰é¢å¿…é¡»æœ‰ç©ºè¡Œ åœ¨config.tomlå¯ä»¥ä¿®æ”¹è¿™äº›é…ç½®:
# markdownè§£æå¼•æ“blackfridayé…ç½®, # extensions : noEmptyLineBeforeBlock-ä»£ç å—å‰é¢æ— éœ€ç©ºè¡Œ,hardLineBreak-æ¢è¡Œæ— éœ€ä½¿ç”¨backslash # extensionsmask spaceHeaders-æ ‡é¢˜ä¹‹é—´æ— éœ€ç©ºæ ¼ [blackfriday] angledQuotes = true extensions = ["hardLineBreak","noEmptyLineBeforeBlock"] extensionsmask = ["spaceHeaders"] fractions = false plainIDAnchors = true travis-cié…ç½® å°±æ˜¯ä»ä¸€ä¸ªç§æœ‰çš„æºç ä»“åº“ç¼–è¯‘,ç„¶åå°†ç¼–è¯‘åçš„æ–‡ä»¶å¼ºåˆ¶è¦†ç›–åˆ°ä¸ªäººä¸»é¡µ(å³username.github.ioè¿™ä¸ªä»“åº“)çš„ä»“åº“ä¸­.å…·ä½“çš„é…ç½®å°±ä¸è¯´äº†,æ³¨æ„æ˜¯éœ€è¦ä¸€ä¸ªgithubçš„personal-access-key. ä¸‹é¢æ˜¯.travis.ymlå†…å®¹:
dist: xenial language: python python: 3.7 # Handle git submodules yourself git: submodules: false # Use sed to replace the SSH URL with the public URL, then initialize submodules before_install: - sudo apt update -qq - sudo apt -yq install apt-transport-https - echo -e "Host github.com\n\tStrictHostKeyChecking no\n" >> ~/.ssh/config - git config --global user.email ${GITHUB_EMAIL} - git config --global user.name ${GITHUB_USERNAME} - sed -i 's/git@github.com:/https:\/\/github.com\//' .gitmodules - git submodule update --init --recursive install: # install latest hugo release version # - wget -qO- https://api.github.com/repos/gohugoio/hugo/releases/latest | sed -r -n '/browser_download_url/{/Linux-64bit.deb/{s@[^:]*:[[:space:]]*"([^"]*)".*@\1@g;p;q}}' | xargs wget # use local hugo pkg for speed - sudo dpkg -i hugo*.deb - rm -rf public 2> /dev/null # compile src to dist script: - hugo -d ./dist/ after_success: - git clone https://zhimoe:${GITHUB_TOKEN}@github.com/zhimoe/zhimoe.github.io.git - cd zhimoe.github.io - git rm -rf . &amp;&amp; git clean -fxd - mv -v ../dist/* . - git add . - git commit -m "update site" - git remote set-url origin https://zhimoe:${GITHUB_TOKEN}@github.com/zhimoe/zhimoe.github.io.git - git remote -v - git push -q -f è¦ç‚¹:
åœ¨é¡¹ç›®çš„æºç ä¸­æ”¾äº†hugoçš„debå®‰è£…åŒ…,çœå»ä¸‹è½½çš„è¿‡ç¨‹ ä¸»é¢˜ä»¥submodulesæ”¾åœ¨themesç›®å½•ä¸­,æ‰€ä»¥ç¼–è¯‘å‰ä¸€å®šè¦git submodule update --init --recursiveæ›´æ–°ä¸»é¢˜åˆ°æœ¬åœ°. ç›®æ ‡repoçš„è¿œç¨‹ä»“åº“ä¸€å®šè¦åœ¨pushå‰é‡æ–°è®¾ç½®:git remote set-url origin xxx</content></entry><entry><title>wsl-docker-environment</title><url>https://zhimoe.github.io/post/wsl-docker-environment/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>wsl</tag><tag>code</tag></tags><content type="html"> ä½¿ç”¨wsl,MobaXterm,cmder,dockeræ‰“é€ å¯è§†åŒ–çš„linuxå¼€å‘ç¯å¢ƒ
ç¦»ä¸å¼€Windowsçš„ç†ç”±å¾ˆå¤š,ä½œä¸ºåç«¯å¼€å‘éœ€è¦ä½¿ç”¨linuxçš„æƒ…å†µä¹Ÿå¾ˆå¤š,åŒç³»ç»Ÿæ€»å½’æ˜¯ä¸æ–¹ä¾¿,è€Œä¸”linuxä¸‹çš„GUIä½“éªŒä¹Ÿæ²¡ç”¨Win 10å¥½.
å¦‚æœä½¿ç”¨è™šæ‹Ÿæœº,é‚£ä¹ˆæ–‡ä»¶äº¤æ¢å’Œç½‘ç»œç­‰å„ç§é—®é¢˜ä¹Ÿéœ€è¦è§£å†³,å¯¹ç³»ç»Ÿçš„å†…å­˜è¦æ±‚ä¹Ÿæ›´é«˜ä¸€äº›.å¾®è½¯ä¸ºäº†è®©æ›´å¤šçš„å¼€å‘äººå‘˜ç•™åœ¨Win10ä¸Šé¢,å¼€å‘äº†WSL,ç›®å‰çš„å®é™…ä½“éªŒå·²ç»å¾ˆæ£’,
ä»Šå¤©ä»‹ç»ä¸€ä¸‹å¦‚ä½•æ‰“é€ ä¸€ä¸ªå¯è§†åŒ–çš„linuxå¼€å‘ç¯å¢ƒ&ndash;å³åœ¨Win10å¯åŠ¨linuxçš„GUIè½¯ä»¶,ä¾‹å¦‚vs codeç­‰.åœ¨wslå¯åŠ¨vs codeå†™ä»£ç å¯ä»¥æœ‰æ•ˆé¿å…ä¸€äº›Windowså’Œlinuxçš„ç¼–ç å’Œæ¢è¡Œé—®é¢˜.
æœ¬æ•™ç¨‹åˆ†ä¸º2éƒ¨åˆ†:
é…ç½®wslå¯è§†åŒ– åœ¨wslä½¿ç”¨docker ä»¥ä¸‹å†…å®¹ä¸­ wslå’Œubuntuå«ä¹‰ç›¸åŒ,consoleå’Œå‘½ä»¤è¡Œå«ä¹‰ç›¸åŒ.
é…ç½®wslå¯è§†åŒ– ç³»ç»Ÿè¦æ±‚æ˜¯Win 10 1803+ç‰ˆæœ¬(ä½äº1803çš„wslåŠŸèƒ½æœ‰é—®é¢˜),å¿…é¡»æ˜¯ä¸“ä¸šç‰ˆæˆ–æ•™è‚²ç‰ˆæ‰æœ‰wslåŠŸèƒ½.ä»¥ä¸‹å†…å®¹çš„å‘½ä»¤è¡Œå¦‚æœå¼€å¤´æœ‰>å­—ç¬¦è¯·å¿½ç•¥.
windowså¼€å¯wslåŠŸèƒ½ æ§åˆ¶é¢æ¿\ç¨‹åº\ç¨‹åºå’ŒåŠŸèƒ½\å¼€å‘æˆ–å…³é—­WindowsåŠŸèƒ½ > å‹¾é€‰ &lsquo;é€‚ç”¨äºlinuxçš„Windowså­ç³»ç»Ÿ&rsquo;å’Œ &lsquo;hyper-V&rsquo;(docker for Windowséœ€è¦è¿™ä¸ªåŠŸèƒ½,ä¹Ÿå¯ä»¥ä½¿ç”¨virtualboxä»£æ›¿), é‡å¯ç”µè„‘.
windowsä¸‹è½½wsl Windows storeæœç´¢"wsl"æˆ–è€…"ubuntu"ä¸‹è½½ubuntuç‰ˆæœ¬. ubuntuå’Œubuntu1804æ˜¯ä¸€ä¸ªç‰ˆæœ¬,ubuntu1604æ˜¯æ—§çš„ç‰ˆæœ¬.å®‰è£…å®Œæˆä½ çš„Windowsåº”ç”¨åˆ—è¡¨ä¼šæœ‰ä¸€ä¸ªubuntuåº”ç”¨,ç‚¹å‡»å›¾æ ‡å³å¯æ‰“å¼€ubuntuå‘½ä»¤è¡Œ.ç¬¬ä¸€æ¬¡å¯åŠ¨éœ€è¦ç­‰å¾…åˆå§‹åŒ–,ç„¶åè®¾ç½®ç”¨æˆ·åå’Œå¯†ç .ç”±äºå­—ä½“éš¾çœ‹,æ‰€ä»¥ä¸ç”¨è¿™ä¸ªè‡ªå¸¦çš„å‘½ä»¤è¡Œè€Œä½¿ç”¨ä¸‹é¢çš„cmder.
windwsä¸‹è½½cmderè½¯ä»¶ cmderæ˜¯Windowsä¸‹æœ€å¼ºçš„å‘½ä»¤è¡ŒåŠŸèƒ½. ä¸è¦ä¸‹è½½minié‚£ä¸ª,é‡Œé¢æ²¡ç”¨vimå’Œgit.ç¬¬ä¸€æ¬¡å¯åŠ¨cmderè®°å¾—ä¿®æ”¹cmderå¯åŠ¨ç›®å½•(é»˜è®¤æ˜¯cç›˜)å’Œæ˜¾ç¤ºä¸­æ–‡è®¾ç½®,å…·ä½“æ–¹æ³•è¯·google.
wslä¿®æ”¹è½¯ä»¶æº,ä½¿ç”¨é˜¿é‡Œäº‘çš„æº. > sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak > sudo sed -i 's/archive.ubuntu.com/mirrors.aliyun.com/g' /etc/apt/sources.list > sudo apt update > sudo apt upgrade -y wslå®‰è£…å¿…è¦è½¯ä»¶ # å®‰è£…ä½ éœ€è¦çš„è½¯ä»¶,gitå’Œvimæ˜¯å¿…é¡»çš„,åé¢çš„ç¼–è¾‘å‘½ä»¤æ˜¯ä½¿ç”¨vim >sudo apt install openjdk-8-jdk-headless openjdk-8-jre-headless maven git unzip vim -y ä¿®æ”¹wslä¸‹Windowsç£ç›˜æŒ‚è½½ç‚¹ é»˜è®¤çš„Windowsç£ç›˜åœ¨wslçš„è®¿é—®æ–¹å¼æ˜¯/mnt/d/å¼€å¤´,dè¡¨ç¤ºdç›˜.ä½†æ˜¯docker on linuxçš„è®¿é—®è·¯å¾„æ˜¯ /d,æ‰€ä»¥è¿™é‡Œéœ€è¦ä¿®æ”¹æŒ‚è½½ç‚¹è·¯å¾„.
sudo vim /etc/wsl.conf ##æ·»åŠ 3è¡Œå†…å®¹ [automount] root = / options = "metadata" é€€å‡ºwslé‡å¯,å‘ç°/mntå·²ç»æ²¡äº†,å½“å‰ç›®å½•åº”è¯¥æ˜¯/c/xxxæˆ–è€…/d/xxx.
wslå®‰è£…vs codeå’Œä¸­æ–‡å­—ä½“ å› ä¸ºwslæ²¡ç”¨ä¸­æ–‡å­—ä½“å°†æ˜¾ç¤ºè±†è…å—.
# install chinese fonts for wsl,font name: 'Noto Sans Mono CJK SC' sudo apt install -y fonts-noto-cjk fonts-noto-cjk-extra # Win10ä¸‹è½½vs codeçš„debåŒ…,cdåˆ°è¯¥ç›®å½•,ä½¿ç”¨ä¸‹é¢å‘½ä»¤å®‰è£… sudo apt install ./code_1.31.1-1549938243_amd64.deb # åœ¨wslè¦å¯åŠ¨codeå¿…è¦ä¾èµ– sudo apt install libgtk2.0-0 libxss1 libasound2 wslè®¾ç½®SSHåŠŸèƒ½ è¿™æ ·å¯ä»¥å€ŸåŠ©VcXsrvçš„X11è½¬å‘åŠŸèƒ½æ‰“å¼€GUIè½¯ä»¶
>sudo vim /etc/ssh/sshd_config #å–æ¶ˆPortçš„æ³¨é‡Š,å¹¶å°†ç«¯å£æ”¹ä¸º2222 (ç«¯å£éœ€è¦å¤§äº1000) #å°†PasswordAuthenticationçš„å€¼æ”¹ä¸ºyes. #é‡å¯ ssh server: sudo service ssh --full-restart #å°†ssh serverè®¾ç½®ä¸ºæœåŠ¡: sudo service ssh start windowså®‰è£…VcXsrv ç”¨å®ƒçš„X11è½¬å‘åŠŸèƒ½.å®‰è£…åé»˜è®¤é€‰é¡¹å³å¯,å¯ä»¥è®¾ç½®ä¸ºå¼€æœºå¯åŠ¨.
å¯åŠ¨wslçš„vs code åœ¨wslè¾“å…¥code .,ç­‰å¾…2ç§’,ä½ ä¼šå‘ç°Windowsä»»åŠ¡æ å¯åŠ¨äº†ä¸€ä¸ªvs code,å¦‚æœæ²¡ç”¨å¯åŠ¨æˆåŠŸ,è¯´æ˜ä½ çš„VcXsrvçš„X11è½¬å‘åŠŸèƒ½æœ‰é—®é¢˜.
é…ç½®vs code. ä¸Šé¢æ‰“å¼€çš„vs codeæœ‰2ä¸ªé—®é¢˜:ä¸­æ–‡æ˜¾ç¤ºè±†è…å—,å’Œä¸èƒ½å…¨å±. æ‰“å¼€vs codeçš„è®¾ç½®
#åœ¨å­—ä½“é‡Œé¢å…ˆè®¾ç½®ä½ æƒ³è¦è‹±æ–‡å­—ä½“,é€—å·è·Ÿä¸Š'Noto Sans Mono CJK SC' #æœç´¢titleBarStyle,å°†'Window: title Bar Style'è®¾ç½®ä¸º native #ä¸Šé¢2ä¸ªè®¾ç½®ä¹Ÿå¯é€šè¿‡ç›´æ¥ç¼–è¾‘æ–‡ä»¶è®¾ç½®,ä¾‹å¦‚æˆ‘çš„vs codeæ–‡ä»¶è®¾ç½®æ˜¯ > cat ~/.config/Code/User/settings.json { "Window.titleBarStyle": "native", "editor.fontFamily": "monospace,'Noto Sans Mono CJK SC'" } è‡³æ­¤,å·²ç»å¯ä»¥åœ¨linuxä¸‹é¢å¼€å‘äº†.å½“ç„¶,å…¶ä»–GUIè½¯ä»¶æ²¡ç”¨æµ‹è¯•ä¸ç¡®å®šæ˜¯ä¸æ˜¯ä¼šæœ‰å°é—®é¢˜.ä½†æ˜¯vs codeå·²ç»å¯ä»¥åº”ä»˜å¾ˆå¤šå¼€å‘å·¥ä½œäº†.
åœ¨wslä½¿ç”¨docker ç›®å‰çš„wslæ˜¯ä¸æ”¯æŒè¿è¡Œdockerçš„,ä½†æ˜¯å¯ä»¥åœ¨wslä½¿ç”¨Windowsçš„docker,åœ¨ä½¿ç”¨ä¸Šé¢æ˜¯æ— æ„Ÿçš„.
å®‰è£…docker for Windows. è¿™ä¸ªå°±ä¸ç»†è¯´äº†,æ³¨æ„dockerç¤¾åŒºç‰ˆä¹Ÿæ˜¯éœ€è¦æ³¨å†Œæ‰èƒ½ä¸‹è½½çš„.
å¯åŠ¨docker for Windows,å³é”®ä»»åŠ¡æ çš„dockerå›¾æ ‡,&ldquo;settings&rdquo;,å‹¾ä¸Š &ldquo;expose the daemon on tcp:/localhost:2375 without TLS&rdquo;,è¿™æ ·åœ¨wslå¯ä»¥è®¿é—®è¿™ä¸ªdockeræœåŠ¡.
wslå®‰è£…docker,è¯¦ç»†å†…å®¹å¯ä»¥å‚è€ƒå®˜æ–¹æ–‡æ¡£,ä¸‹é¢ä»…åˆ—å‡ºå¿…è¦bashå‘½ä»¤.
#å®‰è£…å¿…è¦ç»„ä»¶ sudo apt install -y apt-transport-https ca-certificates curl software-properties-common #gpgç­¾å curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo apt-key fingerprint 0EBFCD88 #æ·»åŠ dockerå®‰è£…æº sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable" sudo apt update sudo apt install -y docker-ce #é€šè¿‡pipå®‰è£…docker-compose sudo apt install -y python python-pip sudo usermod -aG docker $USER pip install --user docker-compose #éªŒè¯dockerå®‰è£…æ˜¯å¦æˆåŠŸ docker info docker-compose --version #ä¿®æ”¹dockeræœåŠ¡ä¸ºWindowsçš„docker echo "export DOCKER_HOST=tcp://localhost:2375" >> ~/.bashrc &amp;&amp; source ~/.bashrc #éªŒè¯æ˜¯å¦å¯ä»¥è®¿é—®Windowsçš„dockeræœåŠ¡,çœ‹image listå‘½ä»¤è¾“å‡ºå’ŒWindowsçš„å‘½ä»¤è¡Œä¸‹é¢çš„image listè¾“å‡ºæ˜¯ä¸æ˜¯å®Œå…¨ä¸€æ ·. å¯ä»¥å…ˆåœ¨Windowsä¸‹ç”¨dockeræ‹‰å‡ ä¸ªé•œåƒ.ç„¶ååœ¨wsléªŒè¯ docker image list è‡³æ­¤,wslçš„dockeræœåŠ¡ä¹Ÿé…ç½®å®Œæˆ.</content></entry><entry><title>Neo4jå…¥é—¨</title><url>https://zhimoe.github.io/post/neo4j-intro/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>neo4j</tag><tag>code</tag><tag>database</tag></tags><content type="html"> neo4jå›¾æ•°æ®åº“ä»‹ç» neo4jæ˜¯ç›®å‰æ’åæœ€é«˜çš„å›¾æ•°æ®åº“,åˆ†ä¸ºå•†ä¸šå’Œç¤¾åŒºç‰ˆæœ¬,ç¤¾åŒºç‰ˆåªæ”¯æŒå•æœº,è€Œä¸”æŸ¥è¯¢çš„è¿è¡Œæ—¶(runtime)ä¸åŒ(cypher runtime:interpreted(ç¤¾åŒºç‰ˆ),slotted(ä¼ä¸šç‰ˆ)). æ•°æ®åº“æ’åå¯ä»¥åœ¨ https://db-engines.com/en/ranking/graph+dbms æŸ¥çœ‹,ä¸‹ä¸€ä»£æœ€æœ‰å‰æ™¯çš„å¼€æºå›¾æ•°æ®åº“æ˜¯dgraph,ç›®å‰è¿˜ç§¯æå¼€å‘ä¸­,ç”Ÿäº§æœªå°±ç»ª,ç­‰ä»–çš„Javaå®¢æˆ·ç«¯å†æˆç†Ÿä¸€ç‚¹å¯ä»¥è¯•ç”¨.
neo4jæ•°æ®åº“ä¸­åªæœ‰3ä¸ªæ¦‚å¿µ: Node, Relationship, Properties. Nodeè¡¨ç¤ºå®ä½“ç±»åˆ«,ä½¿ç”¨LabelåŒºåˆ†,ä¾‹å¦‚ä¸€ä¸ªèŠ‚ç‚¹å¯ä»¥æœ‰Person/Fatherç­‰å¤šä¸ªæ ‡ç­¾,Relationshipå³å…³ç³»,é›‡ä½£å…³ç³»,çˆ¶å­å…³ç³»,æŠ•èµ„å…³ç³»,äº¤æ˜“å…³ç³»ç­‰. Nodeå’ŒRelationshipéƒ½å¯ä»¥æœ‰Proerties,å±æ€§è‡ªèº«ä¸åˆ†æ˜¯å±äºèŠ‚ç‚¹è¿˜æ˜¯å±äºå…³ç³»,ä¾‹å¦‚Personå¯ä»¥æœ‰å±æ€§name,å…³ç³»ä¹Ÿå¯ä»¥ç”¨å±æ€§name.ä½ å¯ä»¥åœ¨neo4j browserå·¦ä¾§çœ‹åˆ°å½“å‰æ•°æ®åº“çš„æ‰€æœ‰Node Label,Relationship Type,Properties.
æœ¬åœ°å®‰è£…å’Œåœ¨çº¿æ²™ç®± neo4jèƒŒåçš„å…¬å¸ä¸ºäº†å¸å¼•ç”¨æˆ·,æä¾›äº†ä¸€äº›å¥½ç©çš„æ•°æ®åº“æ²™ç®±,è¿™äº›æ²™ç®±æ•°æ®åº“å·²ç»æå‰æ”¾äº†ä¸€äº›ä¸»é¢˜æ•°æ®,ä¾‹å¦‚è´­ç‰©æ•°æ®,å›½ä¼šå…³ç³»æ•°æ®.ä½ å¯ä»¥é€šè¿‡æ³¨å†Œç™»å½• https://neo4j.com/sandbox-v2/, é€‰æ‹©ä¸€ä¸ªæ•°æ®æ²™ç®±å®ä¾‹è¿›è¡Œå­¦ä¹ è¯•ç©.å½“ç„¶ä½ ä¹Ÿå¯ä»¥ä¸‹è½½ç¤¾åŒºç‰ˆ,å‘½ä»¤è¡Œ neo4j.bat consoleå¯åŠ¨,æ‰“å¼€127.0.0.1:7474å¼€å§‹å­¦ä¹ .
ä¸€ä¸ªneo4jæ”¯æŒå¤šä¸ªæ•°æ®åº“ä½†æ˜¯ä¸€æ¬¡åªèƒ½æ¿€æ´»ä¸€ä¸ªæ•°æ®åº“,ä¸€ä¸ªæ•°æ®åº“æ‰€æœ‰æ–‡ä»¶éƒ½åœ¨$neo4j_home\data\databasesç›®å½•çš„ç‹¬ç«‹æ–‡ä»¶å¤¹,åœ¨conf/neo4j.confçš„dbms.active_database=graph.dbæŒ‡å®šæ¿€æ´»é‚£ä¸ªæ•°æ®åº“.
cypheræŸ¥è¯¢è¯­è¨€ neo4jä½¿ç”¨cypherè¯­è¨€ä½œä¸ºæŸ¥è¯¢è¯­è¨€.è¿™æ˜¯ä¸€ç§æ¨¡å¼åŒ¹é…çš„å£°æ˜å¼è¯­è¨€.åŸºæœ¬è¯­æ³•å’ŒSQLç›¸ä¼¼.
cypherä¸­å¸¸ç”¨çš„å­å¥(clause)æœ‰: MATCH,RETURN,WITH,WHERE,UNWIND,LIMIT,UNION,SKIP,SET. RETURN,LIMIT WHEREå’ŒSQLä¸­æ˜¯ä¸€æ ·çš„,UNWINDè¿™äº›éœ€è¦ç”¨åˆ°å†æŸ¥çœ‹æ–‡æ¡£,è¿™é‡Œä»‹ç»MATCHå’ŒWITH.
MTACHç”¨äºæŒ‡å®šæœç´¢çš„æ¨¡å¼.ä¾‹å¦‚å¸Œæœ›æ‰¾åˆ°&rsquo;Tom Hanks&rsquo;åœ¨2018æ¼”è¿‡çš„æ‰€æœ‰ç”µå½±:MATCH (p:ACTOR {name:'Tom Hanks' }) -[r: ACT_IN]->(m:MOVIE {time: '2018'}),è¿™æ˜¯ä¸€ä¸ªæ¨¡å¼,å¯ä»¥ç›´æ¥REURENè¿”å›p,r,mç­‰å˜é‡.å¯ä»¥çœ‹åˆ°æ¨¡å¼ä¸­çš„èŠ‚ç‚¹(Node Label)ä½¿ç”¨();å…³ç³»ç±»å‹(Relationship Type)ä½¿ç”¨[]æŒ‡å®š,å¦‚æœä¸å…³å¿ƒtype,é‚£ä¹ˆ[]å¯ä»¥çœç•¥.ä½¿ç”¨&ndash;; å±æ€§(Properties) ä½¿ç”¨{pname: pvalue}æŒ‡å®š.
WITHçš„ä½œç”¨å’Œpythonçš„withéå¸¸ç›¸ä¼¼(å®é™…ä¸Šcypherè¯­è¨€å€Ÿé‰´äº†pythonçš„listå¤„ç†è¯­æ³•),ç”¨äºä¿®æ”¹ä¸€äº›å˜é‡,å˜é‡ä¸€èˆ¬éƒ½æ˜¯ä¸Šä¸€ä¸ªå­å¥çš„æŸ¥è¯¢ç»“æœ,ä¿®æ”¹ä¹‹åä¼ ç»™ä¸‹ä¸€ä¸ªå­å¥.ä¾‹å¦‚ä¸‹é¢çš„è¯­å¥æ‰¾åˆ°å’ŒAndersæœ‰å…³ç³»çš„äººçš„å¹´é¾„æœ€å¤§çš„é‚£ä¸ªäºº,è¿”å›é‚£ä¸ªäººçš„æ‰€æœ‰è®¤è¯†çš„äººçš„åå­—.
MATCH (n { name: 'Anders' })--(m) WITH m ORDER BY m.age DESC LIMIT 1 MATCH (m)--(o) RETURN o.name cypheræ‰‹å†Œ: https://neo4j.com/docs/cypher-manual/3.5/clauses/
cypherçš„æ“ä½œç¬¦ å¦‚æœéœ€è¦è¿›è¡Œcypherè°ƒä¼˜,æœ‰å¿…è¦äº†è§£ä¸€ä¸‹cypherçš„æ“ä½œç¬¦. ä¸€èˆ¬ç¼–ç¨‹è¯­è¨€çš„ä»£ç åœ¨è¢«æ‰§è¡Œå‰éƒ½ä¼šè¢«ç¼–è¯‘å¾—åˆ°æŠ½è±¡è¯­æ³•æ ‘(AST). ä¾‹å¦‚Javaä»£ç ,ä¸€ä¸ªJavaæ–‡ä»¶ä¼šè¢«æŠ½è±¡ä¸ºä¸€ä¸ªpackage,class, method,variable declareç­‰ä¸åŒéƒ¨åˆ†å¾—åˆ°ä¸€ä¸ªClasså¯¹è±¡. cypherè¯­å¥ä¸€æ ·ä¼šè¢«ç¼–è¯‘å¾—åˆ°ä¸€æ£µè¯­æ³•æ ‘(AST),æ¯ä¸ªæ ‘èŠ‚ç‚¹æ˜¯ä¸€ä¸ªæ“ä½œç¬¦. ä»å¶èŠ‚ç‚¹çš„æ“ä½œç¬¦å¼€å§‹æ‰§è¡Œ,å¾—åˆ°çš„ç»“æœä¾æ¬¡è¿”å›ç»™çˆ¶èŠ‚ç‚¹è¿›ä¸€æ­¥å¤„ç†.å¸¸è§çš„æ“ä½œç¬¦æœ‰:AllNodesScan(å…¨å±€æ‰«æ,åªèƒ½ä½œä¸ºå¶èŠ‚ç‚¹),NodeByLabelScan,Applyç­‰.ä¾‹å¦‚MATCH (n) return nä¼šå¾—åˆ°ä¸€ä¸ªAllNodesScanå’ŒProduceResultsæ“ä½œç¬¦æ„æˆçš„AST, ä½ å¯ä»¥é€šè¿‡PROFILEæŸ¥çœ‹ä½ è¯­å¥ç¼–è¯‘åå¾—åˆ°çš„æ“ä½œç¬¦æ„æˆçš„æ‰§è¡Œè®¡åˆ’.
# æ‰§è¡Œè¯­å¥å¾—åˆ°ä¸‹é¢çš„è¡¨æ ¼ PROFILE MATCH (p:Person { name: 'Tom Hanks' }) RETURN p # çœç•¥äº†éƒ¨åˆ†åˆ— +-----------------+----------------+------+---------+-----------------+ | Operator | Estimated Rows | Rows | DB Hits | Page Cache Hits | +-----------------+----------------+------+---------+-----------------+ | +ProduceResults | 1 | 1 | 0 | 0 | | | +----------------+------+---------+-----------------+ | +NodeIndexSeek | 1 | 1 | 2 | 0 | +-----------------+----------------+------+---------+-----------------+ cypher runtime pass
neo4j browserä»‹ç» å’Œå¤§å¤šæ•°æ•°æ®åº“ä¸€æ ·,neo4jæ˜¯server-clientçš„æ•°æ®åº“,æ”¯æŒhttpå’Œbolt2ä¸­åè®®.neo4jè‡ªå¸¦ä¸€ä¸ªåŸºäºæµè§ˆå™¨çš„å®¢æˆ·ç«¯,åªéœ€åœ¨æµè§ˆå™¨è¾“å…¥serverIp:7474å³å¯ä½¿ç”¨.
neo4j browserè‡ªå¸¦ä¸€ä¸ªæ•™ç¨‹å’Œç”µå½±å…³ç³»çš„æ•°æ®åº“åˆå§‹åŒ–è„šæœ¬.æ–¹ä¾¿ä½ å¯ä»¥å­¦ä¹ .ä¸‹é¢ä»‹ç»å‡ ä¸ªå¸¸ç”¨çš„å‘½ä»¤.
:help helpå‘½ä»¤æ˜¾ç¤ºå„ç§å¸®åŠ©æç¤º. å¸¸è§çš„topicæœ‰ :help cypher :help commands :help keys :help param :play äº¤äº’å¼å­¦ä¹ å‘½ä»¤. ä¾‹å¦‚,:play movie graph è¿›å…¥åŸºäºç”µå½±æ•°æ®åº“çš„æ•™ç¨‹. :param å‘½ä»¤,è®¾ç½®å˜é‡. :param usrname => &ldquo;zhimoe&rdquo;,æ³¨æ„,å˜é‡åå’Œ=>ä¹‹é—´æœ‰ç©ºæ ¼.è®¾ç½®å˜é‡ä¹‹åå¯ä»¥ä½¿ç”¨å˜é‡MATCH (n:Person) WHERE n.name = $usrname :params æ˜¾ç¤ºå½“å‰å·²ç»è®¾ç½®çš„æ‰€æœ‰å˜é‡. ä¹Ÿå¯ä»¥ä½¿ç”¨:params {name: &lsquo;Stella&rsquo;, age: 24} è¦†ç›–ç›®å‰çš„å˜é‡. ä½†æ˜¯è¿™ä¸ªå‘½ä»¤æ²¡ç”¨ç±»å‹å®‰å…¨. spring-neo4jé…ç½® pass
cypherè°ƒä¼˜ cypheræ˜¯ä¸€ç§å£°æ˜å¼çš„,æ¨¡å¼åŒ¹é…çš„æŸ¥è¯¢è¯­è¨€.æ¨¡å¼åœ¨cypherè¯­è¨€ä¸­éå¸¸é‡è¦.å¦‚ä½•åˆç†åœ°è®¾è®¡æŸ¥è¯¢ä¸­çš„æ¨¡å¼æ˜¯cypheræ€§èƒ½å¯è°ƒä¼˜ç©ºé—´æœ€å¤§çš„åœ°æ–¹.ä¸‹é¢ç»™å‡ºå¸¸è§çš„ä¼˜åŒ–å»ºè®®.
éœ€è¦è¯´æ˜çš„æ˜¯,åé¢çš„è¿™äº›å»ºè®®å…¶å®å¤§éƒ½å¯ä»¥åœ¨cypheræ‰‹å†Œæ‰¾åˆ°,å¦‚æœæ„Ÿå…´è¶£,å»ºè®®é€šè¯»è¿™ä»½é•¿æ–‡æ¡£&hellip;
é¿å…å…¨å±€scan cypher æ˜¯ä¸€ç§æ¨¡å¼åŒ¹é…çš„è¯­è¨€,é»˜è®¤ä¼šè¿›è¡Œå…¨å±€æ‰«æ,é™¤éä½ å‘Šè¯‰å®ƒä¸è¦.æ‰€ä»¥èµ·å§‹èŠ‚ç‚¹çš„labeléå¸¸é‡è¦.èµ·å§‹çš„æ¨¡å¼åŒ¹é…åŸºæ•°å¤§å°ä¹Ÿéå¸¸é‡è¦.
ç¼“å­˜å’Œç¡¬ç›˜IO neo4jæ•°æ®åº“å°†æ•°æ®æ–‡ä»¶å’ŒPage Cacheä½œäº†æ˜ å°„,å¦‚æœåœ¨ç¼“å­˜ä¸­æ²¡æœ‰æŸ¥è¯¢åˆ°,neo4jä¼šä»ç¡¬ç›˜åŠ è½½æ•°æ®æ–‡ä»¶.ç¬¬äºŒæ¬¡æŸ¥è¯¢å°±å¯ä»¥èµ°ç¼“å­˜.æ‰€ä»¥éœ€è¦å……åˆ†åˆ©ç”¨Page Cache.è®°ä½ç¬¬ä¸€æ¬¡æŸ¥è¯¢æ€»æ˜¯ä¼šæ¯”è¾ƒæ…¢,å› ä¸ºæ²¡ç”¨ç¼“å­˜.neo4j æœ‰2çº§ç¼“å­˜:string cacheå’ŒAST cache
string cache
é»˜è®¤neo4jåœ¨cacheä¸­ä¿ç•™1000ä¸ªæŸ¥è¯¢è®¡åˆ’,å¯åœ¨conf/neo4j.confä¸­å‚æ•° dbms.query_cache_sizeä¿®æ”¹è¿™ä¸ªè®¾ç½®. éœ€è¦æ³¨æ„çš„æ˜¯cacheæ˜¯æ ¹æ®è¯­å¥çš„string hashå€¼åˆ¤æ–­çš„,æ‰€ä»¥ä¸€æ ·çš„è¯­å¥ä»…ä»…æ˜¯å¤§å°å†™ä¸ä¸€æ ·æˆ–è€…ç©ºç™½ç¬¦ä¸ä¸€æ ·å¯¹ç¼“å­˜æ¥è¯´ä¹Ÿæ˜¯2ä¸ªè¯­å¥.
PROFILE/EXPLAINè¯­å¥åªä¼šcacheå…¶å»æ‰PROFILE/EXPLAINä¹‹åçš„éƒ¨åˆ†.ä¾‹å¦‚:MATCH (n) return COUNT(n);å’ŒPROFILE MATCH (n) return COUNT(n);çš„cacheæ˜¯ä¸€è‡´çš„.
AST cache
ç¼–ç¨‹è¯­è¨€éƒ½æœ‰è¯­æ³•æ ‘.å¦‚æœåœ¨string cacheä¸­æ²¡æœ‰æ‰¾åˆ°ç¼“å­˜.é‚£ä¹ˆä¼šå°†æŸ¥è¯¢æ­£è§„åŒ–,å¾—åˆ°è¯­æ³•æ ‘å¹¶å°†å…¶ç¼“å­˜.æ­£è§„åŒ–çš„åŒæ—¶ä¹Ÿä¼šåšä¸€äº›ä¼˜åŒ–,ä¾‹å¦‚
match (n:Person {id:101}) return n;åœ¨æ­£è§„åŒ–ä¹‹åå¾—åˆ°match (n:Person) where n.id={param1} return n; {param1: 101},AST cacheä¸åŒºåˆ†å¤§å°å†™,ç©ºæ ¼ç­‰,æ‰€ä»¥ä»¥ä¸‹æŸ¥è¯¢æ˜¯ä¸€è‡´çš„: match (n:Person) where n.id=101 return n; match (n:Person {id:101}) return n; MATCH ( n:Person { id : 101 } ) RETURN n; execution plan å½“cypherå¼•æ“æ”¶åˆ°æŸ¥è¯¢è¯­å¥åå¦‚æœæ²¡ç”¨æ‰¾åˆ°å¯¹åº”çš„ç¼“å­˜,é‚£ä¹ˆCypher query plannerä¼šå°†è¯­å¥è§„èŒƒåŒ–,ä¼˜åŒ–åç¼–è¯‘å¾—åˆ°ä¸€ä¸ªæ‰§è¡Œè®¡åˆ’(execution plan).è¿™ä¸ªæ‰§è¡Œè®¡åˆ’ä¼šç¼“å­˜ä¸€åˆ‡ä¸”å¯ä»¥å¤ç”¨. å½“æŸ¥è¯¢ç¼“å­˜è¿‡å¤š,æˆ–è€…æ•°æ®åº“çš„æ•°æ®å˜åŒ–å¤§æ—¶(è®¾ç½®å‚æ•°æ˜¯)è¿™ä¸ªæ‰§è¡Œè®¡åˆ’åˆ™å¤±æ•ˆè¢«ç§»é™¤.åœ¨æŸ¥è¯¢ä¸­ä½¿ç”¨å‚æ•°è€Œä¸æ˜¯å­—é¢é‡å€¼,å¯ä»¥æé«˜ä¸€ä¸ªæ‰§è¡Œè®¡åˆ’çš„å¤ç”¨ç‡.
æ›´å¤šä¿¡æ¯å‚è€ƒæ–‡æ¡£:https://neo4j.com/docs/cypher-manual/3.5/execution-plans/#execution-plan-introduction
æŸ¥çœ‹æŸ¥è¯¢è®¡åˆ’ å¦‚æœæƒ³è¦æŸ¥çœ‹æŸ¥è¯¢è¯­å¥çš„æ‰§è¡Œè®¡åˆ’,å¯ä»¥åœ¨æŸ¥è¯¢è¯­å¥å‰åŠ ä¸Š EXPLANIN OR PROFILE å…³é”®å­—, ä½ å¯ä»¥åœ¨neo4j browseræŸ¥çœ‹query planæ‰¾åˆ°æ€§èƒ½ç“¶é¢ˆ.ç»“æœå·¦ä¾§è¾¹é‡Œé¢ç¬¬3ä¸ªtabä¼šç»™å‡ºè¯¦ç»†çš„æ€§èƒ½è­¦å‘Š(warn).
EXPLAINåªä¼šç»™å‡ºè¯­å¥çš„åˆ†æç»“æœ;è€ŒPROFILEåˆ™ä¼šæ‰§è¡Œä½ çš„æŸ¥è¯¢è¯­å¥æŠŠç»™å‡ºè€—æ—¶æœ€å¤šçš„æŠ¥å‘Š,ä»¥åŠæ¯ä¸ªæ“ä½œç¬¦è¿”å›äº†å¤šå°‘è¡Œè®°å½•. æ³¨æ„,profilingä¼šæ¶ˆè€—å¾ˆå¤šèµ„æº,æ‰€ä»¥ä¸è¦åœ¨ç”Ÿäº§ç¯å¢ƒä¸­é¢‘ç¹ä½¿ç”¨.è°ƒä¼˜çš„åŸºç¡€æ˜¯åŸºäºcypherçš„æ“ä½œç¬¦,æ‰€ä»¥éœ€è¦ä½ å¯¹æ“ä½œç¬¦æœ‰åŸºæœ¬çš„äº†è§£.
ç´¢å¼• æ•°æ®åº“ç¦»ä¸å¼€ç´¢å¼•.è¿™é‡Œæœ‰ä¸ªå°é™·é˜±,æœ€æ—©è°±ç³»çš„èŠ‚ç‚¹æ˜¯ä¼ä¸šå®¢æˆ·(label: COR_CUSTOMER)+å’Œå‡ åä¸ªé›¶å”®å®¢æˆ·èŠ‚ç‚¹(label:RTL_CUSTOMER),æˆ‘åœ¨æŸ¥è¯¢è¯­å¥èµ·å§‹èŠ‚ç‚¹æ²¡æœ‰æŒ‡å®šlabel,æ²¡ç”¨é‡åˆ°æ€§èƒ½é—®é¢˜,åæ¥åŠ å…¥äº†3ç™¾ä¸‡çš„ä¸ªäººèŠ‚ç‚¹æ•°æ®å,åŸæ¥1sçš„æŸ¥è¯¢å˜æˆäº†1åˆ†åŠé’Ÿ. æ‰€ä»¥åœ¨å¹²æ‰°çš„labelæ¯”è¾ƒå°‘æ—¶,ä½ ä¸ä¼šå¯Ÿè§‰åˆ°æ€§èƒ½é—®é¢˜.åŠ¡å¿…åœ¨èµ·å§‹èŠ‚ç‚¹æŒ‡å®šlabel,å³ä½¿ç›®å‰åªæœ‰ä¸€ä¸ªlabel,æœ€å¥½ä¹Ÿæå‰åŠ ä¸Š.
ç„¶è€Œ,cypherè¯­å¥ç›®å‰ä¸å…è®¸åœ¨ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å®šå¤šä¸ªlabel,ä¾‹å¦‚ä½ å¸Œæœ›èµ·ç‚¹labelæ˜¯COR_CUSTOMER|RTL_CUSTOMER,è¿™ä¸ªæ˜¯ä¸å…è®¸çš„. åªèƒ½åœ¨whereè¯­å¥æŒ‡å®š.
MATCH n WHERE n:COR_CUSTOMER OR n:RTL_CUSTOMER RETURN n åœ¨3.0ä¹‹å‰çš„neo4jä¸­ä½¿ç”¨ä¸Šé¢çš„è¯­å¥,ä¼šå¯¼è‡´ä¸€ä¸ªAllNodesScan,åœ¨3.0ä¹‹å,è¯¥è¯­å¥åˆ™æ˜¯å°†2ä¸ªNodeByLabelScanåŒ¹é…ç»“æœUNIONç„¶åDISTINCTçš„ç»“æœ. æ‰€ä»¥æ˜¯æœç´¢2æ¬¡å†åˆå¹¶ç»“æœ.ä½ å¯ä»¥åœ¨ä¸Šé¢çš„cypherè¯­å¥å‰é¢æ·»åŠ EXPLAINæŸ¥çœ‹æ‰§è¡Œè®¡åˆ’,å·²ç¡®å®šä½ çš„è¯­å¥æ˜¯å¦ä¼šå¯¼è‡´å…¨å±€æ‰«æ.
SOä¸Šå…³äºå¤šä¸ªlabelåŒ¹é…çš„è®¨è®º
å¤§ç»“æœé›† å¦‚æœä½ çš„æŸ¥è¯¢è¿”å›ç»“æœé›†å¤ªå¤§,ä¾‹å¦‚å‡ Må¤§å°,é‚£ä¹ˆä½ å¯èƒ½éœ€è¦è€ƒè™‘ä½ çš„è®¾è®¡äº†. è¿‡å¤§çš„ç»“æœé›†ä¼šå¯¼è‡´æŸ¥è¯¢è¿”å›å˜æ…¢,è¦æ³¨æ„,è¿™äº›ç»“æœä¼šå ç”¨ä½ çš„ç¼“å­˜ç©ºé—´,è€Œå¦‚æœåœ¨ç½‘ç»œæƒ…å†µä¸å¥½æ—¶,æƒ…å†µæ›´åŠ ç³Ÿç³•äº†.
ç›®å‰è°±ç³»å¯¹è¿™ä¸€å—å¹¶æ²¡æœ‰ä¼˜åŒ–,æœ€å¤§çš„è°±ç³»çš„è¿”å›æ¥å£å¯èƒ½è¾¾åˆ°1Må¤š,åŠ ä¸ŠESçš„æ•°æ®,å‰ç«¯æ¥æ”¶æ•°æ®ä¼šæœ‰4Må¤š.
é” å½“ä½ ä¿®æ”¹èŠ‚ç‚¹çš„ä¿¡æ¯æ—¶,èŠ‚ç‚¹ä¼šè¢«é”å®š;å¦‚æœä¿®æ”¹å…³ç³»,å…³ç³»ä¼šè¢«é”å®š;å¦‚æœå¢åŠ /åˆ é™¤å…³ç³»,é‚£ä¹ˆ2ä¸ªèŠ‚ç‚¹å’Œè¿™ä¸ªå…³ç³»éƒ½ä¼šè¢«é”å®š.è€Œå¦‚æœæ­¤æ—¶æœ‰èŠ‚ç‚¹/å…³ç³»çš„ç›¸å…³æŸ¥è¯¢è¯·æ±‚,è¿™äº›è¯·æ±‚ä¼šç­‰å¾….æ‰€ä»¥,å¦‚æœä½ éœ€è¦å°†50ä¸ªèŠ‚ç‚¹åŠ å…¥ä¸€ä¸ªç»„(group)&ndash;å³æ·»åŠ 50ä¸ªå…³ç³»,å¦‚æœä½ è°ƒç”¨50æ¬¡æ–¹æ³•,é‚£ä¹ˆè¿™ä¸ªgroupèŠ‚ç‚¹è¢«lockçš„æ—¶é—´è¾ƒé•¿,æ­¤æ—¶å¯ä»¥é€šè¿‡UNWINDå’Œåˆ—è¡¨(list)å‚æ•°å¤„ç†è¿™ä¸ªé—®é¢˜.
MATCH (g:Group { uuid: $groupUuid }) UNWIND $personUuidList as personUuid MATCH (p:Person { uuid : personUuid }) MERGE (p)-[:IS_MEMBER]->(g) å¸¸è§æŸ¥è¯¢é”™è¯¯ å˜é‡å labelå¿˜è®°æ·»åŠ å†’å·,ä¾‹å¦‚MATCH (Person) å’Œ MATCH (:Person) æ˜¯å®Œå…¨ä¸ä¸€æ ·çš„,å‰è€…Personæ˜¯å˜é‡,ä¸èµ°ç´¢å¼•. æœ‰è¿‡å¤§çš„ä¸­é—´ç»“æœé›†,ä¼˜åŒ–ä½ çš„è¯­å¥æ—¶æ€è€ƒ:å°½æ—©distinct,å°½æ—©limit,ä½¿ç”¨collectå‡å°‘ç»“æœçš„è¡Œæ•°,åœ¨æ­£ç¡®åœ°æ–¹ä½¿ç”¨order by; å¤šä¸ªUNWINDè¯­å¥å¯¼è‡´ç¬›å¡å°”ç§¯ å¤šä¸ªUNWINDä¼šå¯¼è‡´ä¸€ä¸ªç¬›å¡å°”ç§¯çš„ç»“æœ,è¿™ä¸ªç»“æœå¯èƒ½ä¼šå¾ˆå¤§.ä¾‹å¦‚ä¸‹é¢çš„ç»“æœä¼šå¾—åˆ°3*3=9è¡Œ,æ‰€ä»¥å°½é‡é¿å…ç¬›å¡å°”ç§¯.
with ['a','b','c'] as lts, [1,2,3] as nrs unwind lts as char unwind nrs as nr return char,nr åœ¨MATCHä¸­ä½¿ç”¨å¤šä¸ªæ¨¡å¼ç¬›å¡å°”ç§¯ åœ¨MATCHä¸­ä½¿ç”¨å¤šä¸ªæ¨¡å¼ä¹Ÿä¼šå¯¼è‡´ç¬›å¡å°”ç§¯,æ¯”è¾ƒä¸‹é¢çš„2ä¸ªç»“æœç›¸åŒçš„è¯­å¥,ç¬¬ä¸€ä¸ªè€—æ—¶80s,ç¬¬äºŒä¸ªåªéœ€8ms.
# 1. ç¬›å¡å°”ç§¯ 80000 ms w/ ~900 players, ~40 teams, ~1200 games MATCH (pl:Player),(t:Team),(g:Game) RETURN COUNT(DISTINCT pl), COUNT(DISTINCT t), COUNT(DISTINCT g) # 2. 8ms w/~900 players, ~40 teams, ~1200 games MATCH (pl:Player) WITH COUNT(pl) as players MATCH (t:Team) WITH COUNT(t) as teams, players MATCH (g:Game) RETURN COUNT(g) as games, teams, players æ¨¡å¼ä¸­çš„æ–¹å‘ ä¸‹é¢çš„æŸ¥è¯¢ä¸­,å¦‚æœç»™å…³ç³»ACTED_INæ·»åŠ ä¸Šæ–¹å‘,å¯ä»¥æé«˜æŸ¥è¯¢é€Ÿåº¦.
MATCH (p:Person)-[:ACTED_IN]-(m) WHERE p.name = "Tom Hanks" RETURN m</content></entry><entry><title>Jupyter Notebook Install New Package[ç¿»è¯‘]</title><url>https://zhimoe.github.io/post/jupyter-notebook-install-new-package/</url><categories><category>ç¿»è¯‘</category></categories><tags><tag>code</tag><tag>python</tag></tags><content type="html"> notes åœ¨pycharmå†™ä»£ç ä¸­å¦‚æœä½¿ç”¨åˆ°æ–°çš„package,ä¾‹å¦‚numpy,åªéœ€è¦è¾“å…¥import numpy ç„¶åALT+ENTERåœ¨æç¤ºä¸­é€‰æ‹©install new packageå³å¯.
åœ¨notebookä¸­,ç½‘ä¸Šçš„æ•™ç¨‹éƒ½è¯´æ˜¯!pip install numpy. ä½†æ˜¯è¿™ä¸ªå¯èƒ½æœ‰å‘.ç©¶å…¶åŸå› æ˜¯å› ä¸º:
é€šè¿‡bashå¯åŠ¨çš„notebookçš„python pip condaè¿™å‡ ä¸ªå‘½ä»¤çš„ç¯å¢ƒå’Œå®é™…æ‰§è¡Œnotebookä»£ç çš„pythonç¯å¢ƒå¯èƒ½ä¸æ˜¯åŒä¸€ä¸ª. è¿™ç§æƒ…å†µä¸€èˆ¬å‘ç”Ÿåœ¨ç³»ç»Ÿæœ‰å¥½å‡ ä¸ªpythonçš„æƒ…å†µ,ä¾‹å¦‚ç³»ç»Ÿè‡ªå¸¦pythonå’Œç”¨æˆ·å®‰è£…çš„anaconda python. å¯ä»¥é€šè¿‡å¯¹æ¯”ä»¥ä¸‹ä¸¤ä¸ªnotebookå‘½ä»¤çš„è¾“å‡ºåˆ¤æ–­pipæ‰§è¡Œç¯å¢ƒå’Œnotebookä»£ç æ‰§è¡Œç¯å¢ƒæ˜¯å¦ä¸€è‡´ï¼š # pipæ‰§è¡Œç¯å¢ƒpython !type python # notebook ä»£ç æ‰§è¡Œç¯å¢ƒçš„python import sys sys.executable å¦‚æœä¸ä¸€æ ·,é‚£ä¹ˆéœ€è¦ä½¿ç”¨ä¸‹é¢å‘½ä»¤å®‰è£…æ‰èƒ½åœ¨notebookä¸­ç”Ÿæ•ˆï¼š import sys !{sys.executable} -m pip install numpy syså’ŒosåŒºåˆ« os: æ“ä½œç³»ç»Ÿçš„æŠ½è±¡. sys: ä»£ç å’Œpythonè§£é‡Šå™¨äº¤äº’çš„æ¥å£.æä¾›ä¸€ç³»åˆ—å‡½æ•°æ¥è®¿é—®ä¿®æ”¹pythonè§£é‡Šå™¨ç¯å¢ƒè®¾ç½®. source:installing new python package from jupyter notebook</content></entry><entry><title>Javaå¹¶å‘4-çº¿ç¨‹æ± ä¸æ‰§è¡Œå™¨</title><url>https://zhimoe.github.io/post/java-concurrency-4-threadpool-hierachy/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>å¹¶å‘</tag><tag>java</tag><tag>thread-pool</tag></tags><content type="html"> thread pool classes hierarchy java thread pool class hierarchy Executor (java.util.concurrent) |---ExecutorService (java.util.concurrent) |---AbstractExecutorService (java.util.concurrent) | |---AbstractEventExecutor (io.netty.util.concurrent) | |---ForkJoinPool (java.util.concurrent) | |---ThreadPoolExecutor (java.util.concurrent) | | |---ScheduledThreadPoolExecutor (java.util.concurrent) |---DelegatedExecutorService in Executors (java.util.concurrent) |---ScheduledExecutorService (java.util.concurrent) three thread pool interfaces Executor, a simple interface that supports launching new tasks.
ExecutorService, a sub-interface of Executor, which adds features that help manage the life cycle, both of the
individual tasks and of the executor itself.
ScheduledExecutorService, a sub-interface of ExecutorService, supports future and/or periodic execution of tasks.
common thread pool implements ThreadPoolExecutoræ˜¯thread pool æœ€å¸¸ç”¨çš„å®ç°. ä¸€èˆ¬é€šè¿‡Executorsé™æ€å·¥å‚æ–¹æ³•æ¥åˆ›å»º.
//Executors.newFixedThreadPool //Executors.newCachedThreadPool //Executors.newSingleThreadExecutor //åŒæ ·çš„,Executorsè¿˜æä¾›äº†ScheduledExecutorServiceçš„å·¥å…·æ–¹æ³• // Executors.newSingleThreadScheduledExecutor /** * corePoolSize - ä¿ç•™å­˜æ´»çš„çº¿ç¨‹ä¸ªæ•° * maximumPoolSize - æœ€å¤§çº¿ç¨‹ä¸ªæ•° * keepAliveTime - çº¿ç¨‹æ•°è¶…è¿‡corePoolSizeæ—¶,ç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´ * unit - keepAliveTimeçš„å•ä½,æ¯«ç§’ç§’åˆ†ç­‰ * workQueue â€“ ä»»åŠ¡é˜Ÿåˆ—,åªä¿å­˜é€šè¿‡ execute()æ–¹æ³•æäº¤çš„ Runnableä»»åŠ¡ * threadFactory â€“ ç»™è‡ªå·±åˆ›å»ºä¸€ä¸ªçº¿ç¨‹çš„å·¥å‚æ–¹æ³• * handler â€“ å½“çº¿ç¨‹æ± è¾¾åˆ°æ•°é‡é™åˆ¶æˆ–è€…ä»»åŠ¡é˜Ÿåˆ—æ»¡äº†,å¯¹æ–°ä»»åŠ¡æäº¤çš„å¤„ç†ç­–ç•¥ */ class ThreadPoolExecutor { public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {} } JDKé»˜è®¤çš„æ‹’ç»ç­–ç•¥RejectedExecutionHandleræœ‰ï¼š
/** * ThreadPoolExecutor.AbortPolicy - é»˜è®¤çš„handler,æŠ›å‡ºä¸€ä¸ªRejectedExecutionException * ThreadPoolExecutor.CallerRunsPolicy - æäº¤ä»»åŠ¡çš„çº¿ç¨‹è‡ªå·±æ‰§è¡Œè¿™ä¸ªä»»åŠ¡ * ThreadPoolExecutor.DiscardPolicy - æŠ›å¼ƒè¿™ä¸ªä»»åŠ¡ * ThreadPoolExecutor.DiscardOldestPolicy - æŠ›å¼ƒä»»åŠ¡é˜Ÿåˆ—ä¸­æœ€æ—©æäº¤ä¸Šæ¥çš„ä»»åŠ¡,ç„¶åå°è¯•é‡æ–°æäº¤å½“å‰è¿™ä¸ªä»»åŠ¡ */ ä»»åŠ¡æäº¤æ‰§è¡Œæµç¨‹ fork/join æ¡†æ¶ fork/joinå’Œä¸Šé¢ThreadPoolExecutorçš„åŒºåˆ«åœ¨äºä½¿ç”¨äº†ä»»åŠ¡çªƒå–ç®—æ³•,å·¥ä½œçº¿ç¨‹å®Œæˆè‡ªå·±çš„ä»»åŠ¡åå¯ä»¥ä»å…¶ä»–çº¿ç¨‹å·å–ä»»åŠ¡,æé«˜æ•´ä½“çš„ä»»åŠ¡æ•ˆç‡.
æ ¸å¿ƒæ˜¯ä¸€ä¸ªForkJoinPool classå’Œä¸€ä¸ªæ‰©å±•çš„AbstractExecutorService. æ‰§è¡ŒForkJoinTask ä»»åŠ¡.
åœ¨JDK8ä¸­æœ‰ä¸ªjava.util.Arrays.parallelSort()ä½¿ç”¨çš„å°±æ˜¯ fork/join.
å½“ç„¶,ä¸æ˜¯æ‰€æœ‰äººéƒ½æ»¡æ„JDK7å¼•å…¥çš„Fork/Joinæ¡†æ¶.</content></entry><entry><title>Spark Basic</title><url>https://zhimoe.github.io/post/spark-basic/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>spark</tag></tags><content type="html"> å¼•è¨€ å¤§æ•°æ®è®¡ç®—å’Œæ™®é€šçš„ç¨‹åºå¹¶æ— æœ¬è´¨åŒºåˆ«ï¼šæ•°æ®è¾“å…¥=>è®¡ç®—=>è¾“å‡ºå’Œç»“æœçš„æŒä¹…åŒ–.è¿™é‡Œçš„æŒ‘æˆ˜åœ¨äºè®¡ç®—çš„æ•ˆç‡å’Œå®¹é”™æ€§.ç”±äºæ•°æ®è¾“å…¥å·¨å¤§,è®¡ç®—çš„æ•ˆç‡æ˜¯åŸºæœ¬çš„è¦æ±‚.ä¸ºäº†åœ¨é€šç”¨ç¡¬ä»¶ä¸Šé«˜æ•ˆå®Œæˆå¤§é‡è®¡ç®—,å”¯ä¸€çš„é€”å¾„å°±æ˜¯å°†è®¡ç®—ä»»åŠ¡æ‹†åˆ†åˆ†å¸ƒå¼è®¡ç®—.è¿™å°±å¼•å‡ºäº†æ–°çš„é—®é¢˜ï¼šåˆ†å¸ƒå¼è®¡ç®—èµ„æºçš„ç®¡ç†ï¼ˆMesos,YARNï¼‰,åˆ†å¸ƒå¼è®¡ç®—å¤±è´¥åçš„æ¢å¤ï¼ˆå®¹é”™æ€§ï¼‰ï¼ˆSpark RDDï¼‰,ä»¥åŠåˆ†å¸ƒå¼çš„æ•°æ®è¾“å…¥å’Œä¿å­˜ï¼ˆåˆ†å¸ƒå¼æ–‡ä»¶HDFSï¼‰.hadoopç”Ÿæ€åœˆå°±æ˜¯ä¸ºäº†è§£å†³å‡ ä¸ªé—®é¢˜è®¾è®¡çš„(YARN,MapR,HDFS).åªä¸è¿‡åœ¨è®¡ç®—è¿™ä¸€ç¯èŠ‚Sparkåšçš„æ›´åŠ é«˜æ•ˆå–ä»£äº†MapR.æ‰€ä»¥å…ˆçœ‹ä¸‹hadoopçš„æ ¸å¿ƒä¸¤ä¸ªç»„ä»¶.
HDFS HDFSæ˜¯hadoopçš„è™šæ‹Ÿåˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿ.æ»¡è¶³å¤§æ•°æ®é—®é¢˜ä¸‹è¦æ±‚çš„ï¼šå¯æ‰©å±•çš„,å®¹é”™çš„,ç¡¬ä»¶é€šç”¨çš„å’Œé«˜å¹¶å‘çš„ç‰¹æ€§.HDFSæœ€é‡è¦çš„ç‰¹æ€§æ˜¯ä¸å¯å˜æ€§&ndash;æ•°æ®æäº¤åˆ°HDFSåå³ä¸å¯æ›´æ–°äº†,ä¹Ÿå°±æ˜¯æ‰€è°“çš„WORM(write once read many). æ–‡ä»¶åœ¨HDFSä¸­æ˜¯ä»¥blockæ„æˆ,é»˜è®¤ä¸€ä¸ªblockæ˜¯128M.blockæ˜¯æ˜¯åˆ†å¸ƒå¼çš„,å³å¦‚æœé›†ç¾¤ä¸­å¦‚æœæœ‰å¤šäº1ä¸ªèŠ‚ç‚¹,é‚£ä¹ˆæœ‰æ–‡ä»¶å¯èƒ½ä¼šè¢«åˆ†å¸ƒåœ¨å¤šä¸ªèŠ‚ç‚¹ä¸Š.blockæ˜¯è¢«å¤åˆ¶çš„,è¿™ä¸»è¦æ˜¯ä¸¤ä¸ªç›®çš„ï¼š1.å®¹é”™,2.å¢åŠ æ•°æ®å±€éƒ¨æ€§çš„æ¦‚ç‡,æœ‰åˆ©äºè®¿é—®.blockå¤åˆ¶åœ¨æ•°æ®èŠ‚ç‚¹æ¥æ”¶ï¼ˆingestï¼šæ¶ˆåŒ–ï¼‰blockæ—¶åŒæ—¶å‘ç”Ÿ.å¦‚å›¾æ‰€ç¤ºï¼š NameNodeï¼šä¸çŸ¥é“æ€ä¹ˆç¿»è¯‘,NameNodeä¸»è¦è´Ÿè´£ç®¡ç†HDFSçš„å…ƒæ•°æ®,åŒ…æ‹¬directory,æ–‡ä»¶å¯¹è±¡å’Œç›¸å…³å±æ€§ï¼ˆe.g. ACL),å…ƒæ•°æ®æ˜¯å¸¸é©»å†…å­˜ä¸­çš„,ç¡¬ç›˜ä¸Šä¹Ÿæœ‰å¤‡ä»½ä»¥åŠæ—¥å¿—ä¿è¯æŒä¹…æ€§å’Œå´©æºƒåçš„ä¸€è‡´æ€§ï¼ˆå’Œæ•°æ®åº“ç›¸ä¼¼ï¼‰.è¿˜åŒ…æ‹¬blockçš„ä½ç½®ä¿¡æ¯&ndash;blockä¹‹é—´çš„å…³ç³».æ³¨æ„,æ•°æ®ï¼ˆæ–‡ä»¶ï¼‰å¹¶ä¸ç»è¿‡NameNode,å¦åˆ™å¾ˆå®¹æ˜“æˆä¸ºæ€§èƒ½ç“¶é¢ˆ,æ•°æ®æ˜¯ç›´æ¥åˆ°è¾¾DataNode,å¹¶ä¸ŠæŠ¥ç»™NameNodeç®¡ç†. æ•°æ®èŠ‚ç‚¹ï¼ˆDataNodeï¼‰è´Ÿè´£ï¼šblockå¤åˆ¶ï¼›ç®¡ç†æœ¬èŠ‚ç‚¹çš„å­˜å‚¨ï¼›å‘NameNodeä¸ŠæŠ¥blockä¿¡æ¯.æ³¨æ„,æ•°æ®èŠ‚ç‚¹ä¸ä¼šæ„è¯†åˆ°HDFSçš„ç›®å½•ï¼ˆdirectoryï¼‰å’Œæ–‡ä»¶ï¼ˆFilesï¼‰çš„æ¦‚å¿µ,è¿™äº›ä¿¡æ¯æ˜¯NameNodeç®¡ç†ä¿å­˜çš„,å®¢æˆ·ç«¯åªä¼šå’ŒNameNodeäº¤é“. hdfså®¢æˆ·ç«¯åˆ†ä¸ºï¼šfs shell;hdfs java api;rest proxyæ¥å£ï¼ˆHttpFSç­‰ï¼‰. å¸¸è§å‘½ä»¤ï¼š # ä¸Šä¼ ä¸€ä¸ªæ–‡ä»¶ -fè¡¨ç¤ºè¦†ç›– hadoop fs -put -f jour.txt /user/dahu/jour/ # ä¸‹è½½ hadoop fs -get /user/dahu/jour/jour.txt # ls hadoop fs -ls /user/dahu/ # åˆ é™¤ -rè¡¨ç¤ºé€’å½’,åˆ é™¤ç›®å½• hadoop fs -rm /user/dahu/jour/jour.txt hadoop fs -rm -r /user/dahu/jour YARN YARN:Yet Another Resource Negotiatoræ˜¯hadoopçš„èµ„æºç®¡ç†å™¨.YARNæœ‰ä¸ªå®ˆæŠ¤è¿›ç¨‹&ndash;ResourceManager,è´Ÿè´£å…¨å±€çš„èµ„æºç®¡ç†å’Œä»»åŠ¡è°ƒåº¦,æŠŠæ•´ä¸ªé›†ç¾¤å½“ä½œè®¡ç®—èµ„æºæ± ,åªå…³æ³¨åˆ†é…,ä¸ç®¡åº”ç”¨,ä¸”ä¸è´Ÿè´£å®¹é”™.YARNå°†applicationï¼ˆæˆ–è€…å«jobï¼‰åˆ†å‘ç»™å„ä¸ªNodeManager,NodeManageræ˜¯å®é™…çš„workeræˆ–è€…workerçš„ä»£ç†.ResourceManagerä¸»è¦æœ‰ä¸¤ä¸ªç»„ä»¶ï¼šScheduler å’Œ ApplicationsManager. ä¸‹å›¾æ˜¯YARNçš„ç»“æ„ç¤ºæ„å›¾ï¼š ä¸Šå›¾ä¸­ResourceManagerè´Ÿè´£ç®¡ç†å’Œåˆ†é…å…¨å±€çš„è®¡ç®—èµ„æº.è€ŒNodeManagerçœ‹ç€æ›´å¤æ‚ä¸€äº›ï¼š1.ç”¨æˆ·æäº¤ä¸€ä¸ªappç»™RMï¼ˆResourceManagerï¼‰ï¼›2.RMåœ¨èµ„æºå……è¶³çš„NodeManagerä¸Šå¯åŠ¨ä¸€ä¸ªApplicationMasterï¼ˆä¹Ÿå°±æ˜¯è¿™ä¸ªappå¯¹åº”çš„ç¬¬ä¸€ä¸ªcontainerï¼‰.3.ApplicationMasterè´Ÿè´£åœ¨æ‰€æœ‰NodeManagersä¸­åè°ƒåˆ›å»ºå‡ ä¸ªtask container,ä¹ŸåŒ…æ‹¬ApplicationMasterè‡ªå·±æ‰€åœ¨çš„NodeManagerï¼ˆä¸Šå›¾ä¸­ç´«è‰²2ä¸ªå’Œçº¢è‰²çš„4ä¸ªåˆ†åˆ«è¡¨ç¤º2ä¸ªappçš„task containerå’ŒApplicationMasterï¼‰.4. NodeManagerå‘å„ä¸ªApplicationMasteræ±‡æŠ¥task containerçš„è¿›å±•å’ŒçŠ¶æ€.5. ApplicationMasterå‘RMæ±‡æŠ¥åº”ç”¨çš„è¿›å±•å’ŒçŠ¶æ€.6.RMå‘ç”¨æˆ·è¿”å›appçš„è¿›åº¦,çŠ¶æ€,ç»“æœ.ç”¨æˆ·ä¸€èˆ¬å¯é€šè¿‡Web UIæŸ¥çœ‹è¿™äº›.
ä¸Šé¢çš„ç¤ºæ„å›¾æ˜¯YARN çš„æ ¸å¿ƒæ¦‚å¿µ,Sparkç¨‹åºçš„è¿è¡Œç»“æ„ç¤ºæ„å›¾å’Œä¸Šé¢çš„ç¤ºæ„å›¾ç›¸åŒ.æ¯ä¸ªç»„ä»¶éƒ½å¯ä»¥è¿‘ä¼¼ä¸€æ ·çš„ç†è§£,ä¾‹å¦‚,ä¸Šé¢çš„Clientåœ¨Sparkä¸­å«Driverç¨‹åº;ResourceManageråœ¨Sparkä¸­å«Cluster Managerï¼ˆä¸ºäº†ç†è§£æ–¹ä¾¿,è®¤ä¸ºä¸€æ ·å³å¯,Sparkçš„ClusterManagerç›®å‰ä¸»è¦æœ‰YARN,Mesoså’ŒSparkè‡ªå¸¦çš„ä¸‰ç§ï¼‰ï¼›NodeManagerå°±æ˜¯Sparkä¸­çš„Worker Node.
SparkåŸºæœ¬æ¦‚å¿µ ä¸Šå›¾ä¸­çš„clientç¨‹åºåœ¨Sparkä¸­å³Driverç¨‹åº.Driverå°±æ˜¯æˆ‘ä»¬ç¼–å†™Sparkç¨‹åºappçš„ä¸»è¦éƒ¨åˆ†,åŒ…æ‹¬SparkContextçš„åˆ›å»ºå’Œå…³é—­ä»¥åŠè®¡ç®—ä»»åŠ¡ï¼ˆTaskï¼‰çš„è®¡åˆ’ï¼ˆPlanning,åŒ…æ‹¬æ•°æ®æ•°æ®,è½¬æ¢,è¾“å‡º,æŒä¹…åŒ–ç­‰).SparkContextè´Ÿè´£å’ŒCluster Manageré€šä¿¡,è¿›è¡Œèµ„æºç”³è¯·,ä»»åŠ¡çš„åˆ†é…å’Œç›‘æ§.ä¸€èˆ¬è®¤ä¸ºSparkContextä»£è¡¨Driver. ClusterManagerï¼šå°±æ˜¯ä¸Šé¢è¯´çš„ä¸‰ç§-Standalone,YARN,Mesos. ï¼·orkerNode: é›†ç¾¤ä¸­è¿è¡Œappä»£ç çš„èŠ‚ç‚¹,ä¹Ÿå°±æ˜¯ä¸Šå›¾ä¸­YARNçš„NodeManagerèŠ‚ç‚¹.ä¸€ä¸ªèŠ‚ç‚¹è¿è¡Œä¸€ä¸ª/å¤šä¸ªexecutor. Executorï¼šappè¿è¡Œåœ¨workerèŠ‚ç‚¹çš„ä¸€ä¸ªè¿›ç¨‹,è¿›ç¨‹è´Ÿè´£æ‰§è¡Œtaskçš„planning.Spark On YARN ä¸­è¿™ä¸ªè¿›ç¨‹å«CoarseGrainedExecutorBackend.æ¯ä¸ªè¿›ç¨‹èƒ½å¹¶è¡Œæ‰§è¡Œçš„taskæ•°é‡å–å†³äºåˆ†é…ç»™å®ƒçš„CPUä¸ªæ•°äº†.ä¸‹å›¾æ˜¯ä¸€ä¸ªSparkç¨‹åºé›†ç¾¤æ¦‚è§ˆå›¾,å’Œä¸Šå›¾å¾ˆç›¸ä¼¼. ä»”ç»†å¯¹æ¯”ä¸Šé¢ä¸¤ä¸ªç¤ºæ„å›¾,åœ¨YARNçš„ç»“æ„ç¤ºæ„å›¾ä¸­,ResourceManagerä¸ºç¨‹åºåœ¨æŸä¸ªNodeManagerä¸Šåˆ›å»ºçš„ç¬¬ä¸€ä¸ªcontainerå«ApplicationMaster,ApplicationMasterè´Ÿè´£åªæ˜¯å…¶ä»–çš„task container.åœ¨Spark On YARNæœ‰ä¸¤ç§è¿è¡Œæ¨¡å¼ï¼šclientå’Œclusteræ¨¡å¼.åœ¨clusteræ¨¡å¼ä¸‹,ç”¨æˆ·ç¼–å†™çš„driverç¨‹åºè¿è¡Œåœ¨YARNçš„ApplicationMasterçš„å†…éƒ¨.
*RDD:Sparkçš„æ ¸å¿ƒæ•°æ®ç»“æ„.åé¢è¯¦ç»†ä»‹ç»,å¯ä»¥ç®€å•çš„ç†è§£ä¸ºä¸€ä¸ªSparkç¨‹åºæ‰€æœ‰éœ€è¦å¤„ç†çš„æ•°æ®åœ¨Sparkä¸­è¢«æŠ½è±¡æˆä¸€ä¸ªRDD,æ•°æ®éœ€è¦è¢«æ‹†åˆ†åˆ†å‘åˆ°å„ä¸ªworkerå»è®¡ç®—,æ‰€ä»¥RDDæœ‰ä¸€ä¸ªåˆ†åŒºï¼ˆPartationï¼‰æ¦‚å¿µ.ä¸€èˆ¬æˆ‘ä»¬çš„æ•°æ®æ˜¯æ”¾åœ¨åˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿä¸Šçš„(e.g. HDFS),å¯ä»¥ç®€å•ç†è§£ä¸ºä¸€ä¸ªRDDåŒ…å«ä¸€æˆ–å¤šä¸ªPartation,æ¯ä¸ªPartationå¯¹åº”çš„å°±æ˜¯HDFSçš„ä¸€ä¸ªblock.å½“ç„¶,Partationä¸æ˜¯å’ŒHDFSçš„blockç»‘å®šçš„,ä½ ä¹Ÿå¯ä»¥æ‰‹åŠ¨çš„å¯¹æ•°æ®è¿›è¡Œåˆ†åŒº,å³ä½¿ä»–ä»¬åªæ˜¯å¾…å¤„ç†çš„ä¸€ä¸ªæœ¬åœ°æ–‡ä»¶æˆ–è€…ä¸€ä¸ªå°æ•°ç»„. ä¸€ä¸ªPartationåŒ…å«ä¸€åˆ°å¤šä¸ªRecord,Recordå¯ä»¥ç†è§£ä¸ºæ–‡æœ¬ä¸­çš„ä¸€è¡Œ,excelçš„ä¸€æ¡è®°å½•æˆ–è€…æ˜¯kafkaçš„ä¸€æ¡æ¶ˆæ¯. Taskï¼šRDDçš„ä¸€ä¸ªPatationå¯¹åº”ä¸€ä¸ªTask,Taskæ˜¯å•ä¸ªåˆ†åŒºä¸Šæœ€å°çš„å¤„ç†å•å…ƒ. RDD pass
SparkStreaming pass
SparkStreaming+Kafka import org.apache.kafka.clients.consumer.ConsumerRecord import org.apache.kafka.common.serialization.StringDeserializer import org.apache.spark.streaming.kafka010._ import org.apache.spark.streaming.kafka010.LocationStrategies.PreferConsistent import org.apache.spark.streaming.kafka010.ConsumerStrategies.Subscribe val kafkaParams = Map[String, Object]( "bootstrap.servers" -> "localhost:9092,anotherhost:9092", "key.deserializer" -> classOf[StringDeserializer], "value.deserializer" -> classOf[StringDeserializer], "group.id" -> "use_a_separate_group_id_for_each_stream", "auto.offset.reset" -> "latest", "enable.auto.commit" -> (false: java.lang.Boolean) ) val topics = Array("topicA", "topicB") val stream = KafkaUtils.createDirectStream[String, String]( streamingContext, PreferConsistent, Subscribe[String, String](topics, kafkaParams) ) stream.map(record => (record.key, record.value)) DStreamçš„elements:record is ConsumerRecord&lt;K,V>: A key/value pair to be received from Kafka. This consists of a topic name and a partition number, from which the record is being received and an offset that points to the record in a Kafka partition.åŒ…å«key(),offset(),partation()æ–¹æ³•ç­‰.
å½“ä¸€ä¸ªStreamingContextä¸­æœ‰å¤šä¸ªinput streamæ—¶,è®°å¾—ä¿è¯ç»™ç¨‹åºåˆ†é…äº†è¶³å¤Ÿçš„èµ„æºï¼ˆç‰¹åˆ«æ˜¯coreçš„æ•°é‡,å¿…é¡»å¤§äºè¾“å…¥æºçš„æ•°é‡ï¼‰. æœ¬åœ°æ‰§è¡Œç¨‹åºæ—¶,ä¸è¦ä½¿ç”¨â€œlocalâ€ or â€œlocal[1]â€ as the master URL,streamingç¨‹åºè‡³å°‘éœ€è¦ä¸¤ä¸ªthread,ä¸€ä¸ªæ¥å—æ•°æ®,ä¸€ä¸ªå¤„ç†æ•°æ®.ç›´æ¥ä½¿ç”¨local[n],n>è¾“å…¥æºä¸ªæ•°. DStream å’ŒRDDä¸€æ ·æ”¯æŒå„ç§transå’Œaction DStream is batches of RDDs. å¸¸è§é”™è¯¯ æ•°æ®åº“(mysql redis)è¿æ¥çš„å¯åºåˆ—åŒ–é—®é¢˜ dstream.foreachRDD { rdd => val connection = createNewConnection() // executed at the driver rdd.foreach { record => connection.send(record) // executed at the worker } } // ä¸Šé¢çš„å†™æ³•ä¼šå¯¼è‡´connection ä¸å¯åºåˆ—åŒ–çš„é”™è¯¯: Task not serializable // RDDçš„å‡½æ•°(map,foreach)ä¼šè¢«åºåˆ—åŒ–å‘é€åˆ°workerèŠ‚ç‚¹æ‰§è¡Œ,ä½†æ˜¯connectionæ˜¯å’Œtcpè¿æ¥,å’Œæœºå™¨ç»‘å®šçš„,æ— æ³•åºåˆ—åŒ– dstream.foreachRDD { rdd => rdd.foreach { record => // on worker node val connection = createNewConnection() // ç»™æ¯ä¸ªrecordå¤„ç†æ—¶æ–°å»ºä¸€ä¸ªè¿æ¥,ä¼šå¯¼è‡´ä¸¥é‡çš„æ•°æ®åº“è¿æ¥æ€§èƒ½é—®é¢˜ connection.send(record) connection.close() } } // æ›´å¥½çš„æ–¹å¼æ˜¯ç»™æ¯ä¸ªpartationæ–°å»ºä¸€ä¸ªè¿æ¥ dstream.foreachRDD { rdd => rdd.foreachPartition { partitionOfRecords => val connection = createNewConnection() partitionOfRecords.foreach(record => connection.send(record)) connection.close() } } // æœ€å¥½çš„æ–¹æ³•æ˜¯ç»´æŠ¤ä¸€ä¸ªé™æ€çº¿ç¨‹æ± ï¼š [ConnectionPool](https://github.com/RedisLabs/spark-redis/blob/master/src/main/scala/com/redislabs/provider/redis/ConnectionPool.scala) // then use in partition dstream.foreachRDD { rdd => rdd.foreachPartition { partitionOfRecords => // ConnectionPool is a static, lazily initialized pool of connections val connection = ConnectionPool.getConnection() partitionOfRecords.foreach(record => connection.send(record)) ConnectionPool.returnConnection(connection) // return to the pool for future reuse } } // Note that the connections in the pool should be lazily created on demand and timed out if not used for a while. // This achieves the most efficient sending of data to external systems. // ç¤ºä¾‹ case class RedisCluster(clusterHosts: String, password: String) extends Serializable { def this(conf: SparkConf) { this( conf.get("spark.redis.host", Protocol.DEFAULT_HOST), conf.get("spark.redis.auth", null) ) } /** * * @return use for JedisCluster or JedisPool */ def toSet(): java.util.Set[HostAndPort] = { val nodes: mutable.Set[HostAndPort] = mutable.Set() for (host_port &lt;- clusterHosts.split(",")) { val hp = host_port print(hp) nodes += HostAndPort.from(host_port) } nodes.asJava } } object RedisClusterUtils extends Serializable { @transient private lazy val pools: ConcurrentHashMap[RedisCluster, JedisCluster] = new ConcurrentHashMap[RedisCluster, JedisCluster]() /** * è·å–ä¸€ä¸ªJedisCluster * @param rc * @return */ def connect(rc: RedisCluster): JedisCluster = { pools.getOrElseUpdate(rc, { val poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(250) poolConfig.setMaxIdle(32) poolConfig.setTestOnBorrow(false) poolConfig.setTestOnReturn(false) poolConfig.setTestWhileIdle(false) poolConfig.setNumTestsPerEvictionRun(-1) val jedisCluster = new JedisCluster(rc.toSet(), 3000, 3000, 5, rc.password, poolConfig) jedisCluster }) } /** * æŸ¥è¯¢å¸ç§å¯¹åº”æ±‡ç‡ * @param jedisCluster ç›®æ ‡redis * @param ccyCd å¸ç§ä»£ç  * @return æŠ˜ç¾å…ƒæ±‡ç‡ */ def getCcyRatio(jedisCluster: JedisCluster, ccyCd:String): Double ={ val res = jedisCluster.get("CCY:"+ccyCd) res.split(":")(2).toDouble } } å‚è€ƒ
Design Patterns for using foreachRDD
Redis on Spark:Task not serializable
How to create connection(s) to a Datasource in Spark Streaming for Lookups
DStreamçš„RDDåˆ†åŒºæ•°æ˜¯ç”±topicåˆ†åŒºæ•°ç›¸åŒçš„. æœ€ä½³å®è·µ</content></entry><entry><title>å•å…ƒæµ‹è¯•å¦‚ä½•Mockæœ‰å‚æ•°çš„voidæ–¹æ³•</title><url>https://zhimoe.github.io/post/how-test-void-method-with-parameter/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>java</tag><tag>test</tag></tags><content type="html"> æµ‹è¯•ä¸­å¦‚æœé‡åˆ°è¢«æµ‹è¯•æ–¹æ³•è°ƒç”¨voidæ–¹æ³•ï¼Œåœ¨Mockitoä¸­æ”¹å¦‚ä½•å¤„ç†?
å‡è®¾æœ‰å¦‚ä¸‹çš„æœåŠ¡ä¾èµ–ï¼š
@Service class DepositSvc { @Autowired private AccountSvc accSvc; public List&lt;Account> dps(String user) { List&lt;Account> accounts = new ArrayList(); List&lt;Account> banks = getBanks(); accSvc.addLinkedAccounts(user, accounts, banks);//accountsè¢«æ”¹åŠ¨äº†å¦‚ä½•mock? return accounts; } } @Service class AccountSvc { @Autowired private RestClient restClient; public void addLinkedAccounts(String user, List&lt;Account> accounts, List&lt;Account> banks) { acc = restClient.getAcc(user); accounts.add(acc); } } è¿™é‡Œçš„AccountSvcåªæ˜¯æä¾›äº†ä¸€ä¸ªvoidæ–¹æ³•å¤„ç†äº†å…¥å‚accounts,è™½ç„¶ä¿®æ”¹å…¥å‚æ˜¯è¢«æˆ‘æ‰€ä¸é½¿çš„,ä½†æ˜¯æœ‰æ—¶æ”¹å†™è¿™ç±»æ–¹æ³•æŒºéº»çƒ¦çš„,ç‰¹åˆ«å¦‚æœæ–¹æ³•ä¿®æ”¹äº†ä¸¤ä¸ªå…¥å‚çš„è¯.
è¿™ç§æƒ…å†µä¸‹å¦‚ä½•æµ‹è¯•DepositSvc.dpsæ–¹æ³•å‘¢? mockitoçš„ doAnswerå°±æ˜¯ç”¨äºæ¨¡æ‹Ÿvoidæ–¹æ³•å›è°ƒçš„.
class DepositSvcTest { @InjectMocks private DepositSvc depositSvc; @Mock private AccountSvc accountSvc; void test_dps() { // ... arrange // mock void method with arguments doAnswer((invocation) -> { Object[] args = invocation.getArguments(); List&lt;Account> accounts = (List&lt;Account>) args[1]; //è¿™é‡Œå¯ä»¥æ‹¿åˆ°å…¥å‚ accounts.add(new Account(911); //ä¿®æ”¹å…¥å‚ return null; }).when(accountSvc).addLinkedAccounts(any(), anyList(), anyList()); // ...assert } }</content></entry><entry><title>æ‰“è™</title><url>https://zhimoe.github.io/about/</url><categories/><tags/><content type="html"> A programmer, use Java/Scala/Rust/Python/Javascript.
Write user stories in daily job.
Customize programming fonts for fun.
email: me#zhi.moe</content></entry><entry><title>java generic</title><url>https://zhimoe.github.io/post/java-generic/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>java</tag><tag>code</tag></tags><content type="html"> æ³›å‹ // ç±» class Tuple&lt;T, S> { private T first; private S second; } // æ³›å‹æ–¹æ³•ä¹Ÿå¯åœ¨éæ³›å‹ç±»é‡Œé¢ class ArrayAlg { public static &lt;T> T getMiddle(T... a) { return a[a.length / 2]; } } String middle = ArrayAlg.&lt;String>getMiddle("]ohnM, "Q.n, "Public");// right,&lt;String>å¯ä»¥çœç•¥ String middle = GenericCls.getMiddle("hello",0,null);// error // Errr:(7, 45) java: ä¸å…¼å®¹çš„ç±»å‹: æ¨æ–­ç±»å‹ä¸ç¬¦åˆä¸Šé™ // æ¨æ–­: java.lang.Object&amp;java.io.Serializable&amp;java.lang.Comparable&lt;? extends java.lang.Object&amp;java.io.Serializable&amp;java.lang.Comparable&lt;?>> // ä¸Šé™: java.lang.String,java.lang.Object ç±»å‹é™å®š public static &lt;T extends Comparable> T min(T a) // å¦‚æœå¤šä¸ªç±»å‹,åˆ™ï¼šT extends Comparable &amp; Serializable // åªèƒ½æœ‰ä¸€ä¸ªç±»,ä¸”ç±»å¿…é¡»ç´§è·Ÿextends,ä½†æ˜¯å¯ä»¥æœ‰å¤šä¸ªæ¥å£ ç±»å‹æ“¦é™¤ //Tuple&lt;T,S>åœ¨è™šæ‹Ÿæœºå˜ä¸º class Tuple { private Object first;//å½“è°ƒç”¨getFirstæ—¶,åˆ™å‘ç”Ÿå¼ºåˆ¶è½¬æ¢ private Object second; } //æ³›å‹æ–¹æ³•åŒæ ·æœ‰æ“¦é™¤ public static &lt;T extends Comparable> T min(T a) // => public static Comparable min(Comparable a) çº¦æŸ ä¸èƒ½ç”¨åŸºæœ¬ç±»å‹å®ä¾‹åŒ–æ³›å‹,Pair&lt;double>ä¸å…è®¸ è¿è¡Œæ—¶å‚æ•°ç±»å‹æ£€æŸ¥åªèƒ½æ£€æŸ¥åŸå§‹ç±»å‹ if (a instanceof Pair&lt;String>) // Error if (a instanceof Pair&lt;T>) // Error Pair&lt;String> p = (Pair&lt;String>) a; //warning ä¸èƒ½åˆ›å»ºå‚æ•°åŒ–ç±»å‹çš„æ•°ç»„ Pair&lt;String>[] table = new Pair&lt;String>[10]; // Error Pair&lt;String>[] table; //å£°æ˜æ˜¯åˆæ³•çš„,åªæ˜¯æ— æ³•å®ä¾‹åŒ– å€ŸåŠ©@SafeVarargså‚æ•°åŒ–ç±»å‹çš„æ•°ç»„ @SafeVarargs public static &lt;T> void addAll(Collection&lt;T> coll, T... ts) Classç±»æœ¬èº«æ˜¯æ³›å‹. ä¾‹å¦‚,String.daSS æ˜¯ä¸€ä¸ª Class çš„å®ä¾‹ï¼ˆäº‹å®ä¸Š,å®ƒæ˜¯å”¯ä¸€çš„å®ä¾‹.) å› æ­¤,makePair æ–¹æ³•èƒ½å¤Ÿæ¨æ–­å‡º pair çš„ç±»å‹ æ³›å‹ç±»çš„é™æ€ä¸Šä¸‹æ–‡ä¸­ç±»å‹å˜é‡æ— æ•ˆ public class Singleton&lt;T> { private static T singlelnstance; // Error public static T getSinglelnstance{// Error if (singleinstance == null) {//construct new instance of T return singlelnstance; } } } ä¸èƒ½æŠ›å‡ºæˆ–æ•è·æ³›å‹ç±»çš„å®ä¾‹ public class Problem&lt;T> extends Exception { /* . . . */ } // Error can't extend Throwable æ³›å‹æ“¦é™¤çš„æ–¹æ³•å†²çª public class Pair&lt;T> { T first; T second; public boolean equals(T value) { //error å’ŒObject.equalså†²çª return first.equals(value) &amp;&amp; second, equals(value); } } æ³›å‹ç»§æ‰¿ class Employee class Manager extends Employee //Pair&lt;Employee> å’ŒPair&lt;Manager> æ²¡ç”¨ä»»ä½•ç»§æ‰¿å…³ç³» é€šé…ç¬¦ å’Œ PECS Pair&lt;? extends Employeeã€‰ Pair&lt;? super Manager åå°„å’Œæ³›å‹</content></entry><entry><title>IO-Java-Stream-Write-Reader</title><url>https://zhimoe.github.io/post/io-java-stream-write-reader/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>java</tag><tag>code</tag></tags><content type="html"> ä¸Šæ¬¡æ€»ç»“äº†javaä¸­ä¸åŒè¯»å†™æ–‡ä»¶çš„æ–¹æ³•,è¿™æ¬¡æ€»ç»“ä¸€ä¸‹åŸºæœ¬çš„IOæµ.ç½‘ä¸Šçš„æ€»ç»“å¤§éƒ¨åˆ†æ˜¯ä»¥Streamå’ŒReaderã€Writeræ¥ä»‹ç»çš„.è¿™æ¬¡ä»å°è£…å±‚æ¬¡æ¥ä»‹ç».
æ¦‚è§ˆ é¦–å…ˆç†è§£è®¡ç®—æœºæ–‡ä»¶æ ¼å¼éƒ½æ˜¯äºŒè¿›åˆ¶æ•°æ®ï¼Œä¾‹å¦‚æ–‡æœ¬ï¼Œå›¾ç‰‡ï¼Œè§†é¢‘ï¼ŒéŸ³é¢‘ç­‰ï¼Œä½†æ˜¯æ–‡æœ¬éå¸¸ç‰¹æ®Šï¼Œæ‰€ä»¥å•ç‹¬æœ‰ä¸€ç±»å°è£…è®¾è®¡ã€‚
å¯¹äºéæ–‡æœ¬ç±»çš„æ–‡ä»¶ï¼Œä¸€èˆ¬æ˜¯è¯»å–å­—èŠ‚(stream)ï¼Œè€Œå¯¹äºæ–‡æœ¬ç±»æ–‡ä»¶ï¼Œåˆ™å¯ä»¥è¯»å–å­—ç¬¦(reader)
å½“ç„¶ï¼Œæ–‡æœ¬æ–‡ä»¶ä¹Ÿå¯ä»¥ä½¿ç”¨inputstreamè¯»å–åå†è½¬æ¢Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8);
stream é¦–å…ˆæ˜¯byteæµ,æ¯æ¬¡read()è¯»å–8 bits,å¹¶ç”¨ä¸€ä¸ªintçš„ä½å…«ä½ä¿å­˜ï¼š
FileInputStream in = null; FileOutputStream out = null; try { in = new FileInputStream("xanadu.txt"); out = new FileOutputStream("outagain.txt"); int c; while ((c = in.read()) != -1) { out.write(c); } } finally { if (in != null) { in.close(); } if (out != null) { out.close(); } } byteæµæ˜¯å¾ˆåŸºç¡€çš„æµ,æ¥ä¸‹æ¥æ˜¯å­—ç¬¦æµ,ä½¿ç”¨intçš„ä½16ä½ä¿å­˜è¯»å–å†…å®¹,ä¸€ä¸ªæ±‰å­—,ä½¿ç”¨ä¸Šé¢é‚£ä¸ªå­—èŠ‚æµ,éœ€è¦è¯»å–2æ¬¡,ä½¿ç”¨ä¸‹é¢çš„å­—ç¬¦æµ,åªç”¨ä¸€æ¬¡.å…¶å®èƒŒåè¿˜æ˜¯ä¸€ä¸ªæ¡¥æ¥
å…·ä½“çš„å¯¹è±¡ä½“ç°ï¼š
FileReader extemds InputStreamReader,
FileWriter extends OutputStreamWriter
InputStreamReader:å­—èŠ‚åˆ°å­—ç¬¦çš„æ¡¥æ¢
OutputStreamWriter:å­—ç¬¦åˆ°å­—èŠ‚çš„æ¡¥æ¢ï¼š
FileReader inputReader = null; FileWriter outputStream = null; try { inputReader = new FileReader("xanadu.txt"); outputStream = new FileWriter("characteroutput.txt"); int c; while ((c = inputReader.read()) != -1) { outputStream.write(c); } } finally { if (inputReader != null) { inputReader.close(); } if (outputStream != null) { outputStream.close(); } } ByteArrayInputStreamã€StringBufferInputStreamã€FileInputStream æ˜¯ä¸‰ç§åŸºæœ¬çš„ä»‹è´¨æµ,å®ƒä»¬åˆ†åˆ«ä»Byte æ•°ç»„ã€StringBufferã€å’Œæœ¬åœ°æ–‡ä»¶ä¸­è¯»å–æ•°æ®.StringBufferInputStream å·²ç»è¢«Deprecated,è®¾è®¡é”™è¯¯,åªæ˜¯ä¸ºäº†å…¼å®¹.
File I/Oç°åœ¨å·²ç»ä¸æ¨èä½¿ç”¨äº†,æ¨ènio2çš„PathåŠå…¶å·¥å…·ç±»Files,Paths;
Path å®˜æ–¹æ•™ç¨‹
ObjectInputStream å’Œæ‰€æœ‰FilterInputStream çš„å­ç±»éƒ½æ˜¯è£…é¥°æµï¼ˆè£…é¥°å™¨æ¨¡å¼çš„ä¸»è§’ï¼‰
æ³¨æ„ï¼šOutputStreamå­ç±»ä¸­æ²¡æœ‰StringBufferä¸ºç›®çš„åœ°çš„. ObjectOutputStream å’Œæ‰€æœ‰FilterOutputStream çš„å­ç±»éƒ½æ˜¯è£…é¥°æµ.
å‡ ä¸ªç‰¹æ®Šçš„ç±»ï¼š
PushbackInputStream çš„åŠŸèƒ½æ˜¯æŸ¥çœ‹æœ€åä¸€ä¸ªå­—èŠ‚,ä¸æ»¡æ„å°±æ”¾å…¥ç¼“å†²åŒº.ä¸»è¦ç”¨åœ¨ç¼–è¯‘å™¨çš„è¯­æ³•ã€è¯æ³•åˆ†æéƒ¨åˆ†.è¾“å‡ºéƒ¨åˆ†çš„BufferedOutputStream å‡ ä¹å®ç°ç›¸è¿‘çš„åŠŸèƒ½.
PrintStream ä¹Ÿå¯ä»¥è®¤ä¸ºæ˜¯ä¸€ä¸ªè¾…åŠ©å·¥å…·.ä¸»è¦å¯ä»¥å‘å…¶ä»–è¾“å‡ºæµ,æˆ–è€…FileInputStream å†™å…¥æ•°æ®,æœ¬èº«å†…éƒ¨å®ç°è¿˜æ˜¯å¸¦ç¼“å†²çš„.æœ¬è´¨ä¸Šæ˜¯å¯¹å…¶å®ƒæµçš„ç»¼åˆè¿ç”¨çš„ä¸€ä¸ªå·¥å…·è€Œå·².ä¸€æ ·å¯ä»¥è¸¢å‡ºIO åŒ…ï¼System.out å’ŒSystem.err å°±æ˜¯PrintStream çš„å®ä¾‹ï¼ System.inæ˜¯InputStreamçš„å®ä¾‹ï¼
ä½ æ°¸è¿œä¸åº”è¯¥new PrintStream,è¯·ç”¨PrintWriter
reader writer CharReaderã€StringReader æ˜¯ä¸¤ç§åŸºæœ¬çš„ä»‹è´¨æµ,å®ƒä»¬åˆ†åˆ«å°†Char æ•°ç»„ã€Stringä¸­è¯»å–æ•°æ®.PipedReader æ˜¯ä»ä¸å…¶å®ƒçº¿ç¨‹å…±ç”¨çš„ç®¡é“ä¸­è¯»å–æ•°æ®.
BufferedReader å¾ˆæ˜æ˜¾å°±æ˜¯ä¸€ä¸ªè£…é¥°å™¨,å®ƒå’Œå…¶å­ç±»è´Ÿè´£è£…é¥°å…¶å®ƒReader å¯¹è±¡.
FilterReader æ˜¯æ‰€æœ‰è‡ªå®šä¹‰å…·ä½“è£…é¥°æµçš„çˆ¶ç±»,å…¶å­ç±»PushbackReader å¯¹Reader å¯¹è±¡è¿›è¡Œè£…é¥°,ä¼šå¢åŠ ä¸€ä¸ªè¡Œå·.
InputStreamReader æ˜¯ä¸€ä¸ªè¿æ¥å­—èŠ‚æµå’Œå­—ç¬¦æµçš„æ¡¥æ¢,å®ƒå°†å­—èŠ‚æµè½¬å˜ä¸ºå­—ç¬¦æµ.FileReader å¯ä»¥è¯´æ˜¯ä¸€ä¸ªè¾¾åˆ°æ­¤åŠŸèƒ½ã€å¸¸ç”¨çš„å·¥å…·ç±»,åœ¨å…¶æºä»£ç ä¸­æ˜æ˜¾ä½¿ç”¨äº†å°†FileInputStream è½¬å˜ä¸ºReader çš„æ–¹æ³•.æˆ‘ä»¬å¯ä»¥ä»è¿™ä¸ªç±»ä¸­å¾—åˆ°ä¸€å®šçš„æŠ€å·§.Reader ä¸­å„ä¸ªç±»çš„ç”¨é€”å’Œä½¿ç”¨æ–¹æ³•åŸºæœ¬å’ŒInputStream ä¸­çš„ç±»ä½¿ç”¨ä¸€è‡´.åé¢ä¼šæœ‰Reader ä¸InputStream çš„å¯¹åº”å…³ç³».
OutputStreamWriter æ˜¯OutputStream åˆ°Writer è½¬æ¢çš„æ¡¥æ¢,å®ƒçš„å­ç±»FileWriter å…¶å®å°±æ˜¯ä¸€ä¸ªå®ç°æ­¤åŠŸèƒ½çš„å…·ä½“ç±»ï¼ˆå…·ä½“å¯ä»¥ç ”ç©¶ä¸€SourceCodeï¼‰.åŠŸèƒ½å’Œä½¿ç”¨å’ŒOutputStream æå…¶ç±»ä¼¼,åé¢ä¼šæœ‰å®ƒä»¬çš„å¯¹åº”å›¾.
PrintWriter å’ŒPrintStream æå…¶ç±»ä¼¼,åŠŸèƒ½å’Œä½¿ç”¨ä¹Ÿéå¸¸ç›¸ä¼¼.ä½†æ˜¯è¿˜æ˜¯æœ‰ä¸åŒçš„,PrintStream prints to an OutputStream, and PrintWriter prints to a Writer.
ä½ æ°¸è¿œä¸åº”è¯¥new PrintStream,è¯·ç”¨PrintWriter
PrintStream stream = new PrintStream(outputStream); //With the PrintWriter you can however pass an OutputStreamWriter with a specific encoding. PrintWriter writer = new PrintWriter(new OutputStreamWriter(outputStream, "UTF-8")); RandomAccessFileç±» è¯¥å¯¹è±¡å¹¶ä¸æ˜¯æµä½“ç³»ä¸­çš„ä¸€å‘˜,å…¶å°è£…äº†å­—èŠ‚æµ,åŒæ—¶è¿˜å°è£…äº†ä¸€ä¸ªç¼“å†²åŒºï¼ˆå­—ç¬¦æ•°ç»„ï¼‰,é€šè¿‡å†…éƒ¨çš„æŒ‡é’ˆæ¥æ“ä½œå­—ç¬¦æ•°ç»„ä¸­çš„æ•°æ®. è¯¥å¯¹è±¡ç‰¹ç‚¹ï¼š
è¯¥å¯¹è±¡åªèƒ½æ“ä½œæ–‡ä»¶,æ‰€ä»¥æ„é€ å‡½æ•°æ¥æ”¶ä¸¤ç§ç±»å‹çš„å‚æ•°ï¼ša.å­—ç¬¦ä¸²æ–‡ä»¶è·¯å¾„ï¼›b.Fileå¯¹è±¡.
è¯¥å¯¹è±¡æ—¢å¯ä»¥å¯¹æ–‡ä»¶è¿›è¡Œè¯»æ“ä½œ,ä¹Ÿèƒ½è¿›è¡Œå†™æ“ä½œ,åœ¨è¿›è¡Œå¯¹è±¡å®ä¾‹åŒ–æ—¶å¯æŒ‡å®šæ“ä½œæ¨¡å¼(r,rw)
æ³¨æ„ï¼šè¯¥å¯¹è±¡åœ¨å®ä¾‹åŒ–æ—¶,å¦‚æœè¦æ“ä½œçš„æ–‡ä»¶ä¸å­˜åœ¨,ä¼šè‡ªåŠ¨åˆ›å»ºï¼›å¦‚æœæ–‡ä»¶å­˜åœ¨,å†™æ•°æ®æœªæŒ‡å®šä½ç½®,ä¼šä»å¤´å¼€å§‹å†™,å³è¦†ç›–åŸæœ‰çš„å†…å®¹. å¯ä»¥ç”¨äºå¤šçº¿ç¨‹ä¸‹è½½æˆ–å¤šä¸ªçº¿ç¨‹åŒæ—¶å†™æ•°æ®åˆ°æ–‡ä»¶.
Scanning and formatting The scanner API breaks input into individual tokens associated with bits of data,The formatting API assembles data into nicely formatted, human-readable form.
formatting
int i = 2; double r = Math.sqrt(i); System.out.format("The square root of %d is %f.%n", i, r); Scanner s = new Scanner(new BufferedReader(new FileReader("xanadu.txt"))); By default, a scanner uses white space to separate tokens. also,u can set :
s.useDelimiter(",\\s*");
I/O from commandline You might expect the Standard Streams to be character streams, but, for historical reasons, they are byte streams. System.out and System.err are defined as PrintStream objects. Although it is technically a byte stream, PrintStream utilizes an internal character stream object to emulate many of the features of character streams.(ï¼ï¼ï¼å¦ˆçš„,è€å­å¼€å§‹å°±å›°æƒ‘å¾ˆä¹…äº†,ä¸€ç›´ä¸æ˜ç™½System.outæ€ä¹ˆå¯ä»¥ç›´æ¥æ‰“å°å‡ºä¸­æ–‡.)
By contrast, System.in is a byte stream with no character stream features. To use Standard Input as a character stream, wrap System.in in InputStreamReader.
InputStreamReader cin = new InputStreamReader(System.in);
jdk1.5å¼€å§‹è¯»å†™æ§åˆ¶å°ä»¥å‰å¸¸ç”¨çš„æ˜¯Scannerï¼š
Scanner scanner = new Scanner(System.in); scanner.nextLine(); ä» JDK1.6å¼€å§‹,åŸºæœ¬ç±»åº“ä¸­å¢åŠ äº†java.io.Console ç±»,ç”¨äºè·å¾—ä¸å½“å‰ Java è™šæ‹Ÿæœºå…³è”çš„åŸºäºå­—ç¬¦çš„æ§åˆ¶å°è®¾å¤‡.åœ¨çº¯å­—ç¬¦çš„æ§åˆ¶å°ç•Œé¢ä¸‹,å¯ä»¥æ›´åŠ æ–¹ä¾¿åœ°è¯»å–æ•°æ®.
Console console = System.console(); if (console == null) { throw new IllegalStateException("ä¸èƒ½ä½¿ç”¨æ§åˆ¶å°"); } return console.readLine(prompt); Data Streams Data streams support binary I/O of primitive data type values (boolean, char, byte, short, int, long, float, and double) as well as String values. All data streams implement either the DataInput interface or the DataOutput interface. This section focuses on the most widely-used implementations of these interfaces, DataInputStream and DataOutputStream.</content></entry><entry><title>Java 6/7/8ä¸­æ–‡ä»¶è¯»å†™</title><url>https://zhimoe.github.io/post/io-java-6-7-8-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>java</tag><tag>code</tag></tags><content type="html"> å¦‚ä½•åœ¨Javaä¸­è¯»å†™æ–‡ä»¶,è¿™é‡Œä¿ç•™Java6/7ç‰ˆæœ¬,ä½†æ˜¯ä½ æ°¸è¿œä¸åº”è¯¥ä½¿ç”¨å®ƒä»¬,ä¼˜å…ˆä½¿ç”¨Path,Files,Pathsä¸‰ä¸ªç±».
èµ„æ–™ï¼šReading and writing text files
Java8æœ€ä½³å®è·µ ä¸è¦ç”¨Fileå¯¹è±¡,æ”¹ç”¨Pathå¯¹è±¡,è¯¥å¯¹è±¡æ—¢è¡¨ç¤ºæ–‡ä»¶è·¯å¾„,ä¹Ÿè¡¨ç¤ºæ–‡ä»¶æ–‡æœ¬ï¼ˆåº”è¯¥è®¤ä¸ºæ–‡ä»¶ä¹Ÿæ˜¯è·¯å¾„çš„ä¸€éƒ¨åˆ†ï¼‰,å¯¹äºä»¥å‰çš„File,å¯ä»¥File.toPath()å¾—åˆ°ä¸€ä¸ªPathå¯¹è±¡.
Filesæ˜¯ä¸€ä¸ªé™æ€ç±»,æ“ä½œæ–‡ä»¶å†…å®¹.Pathsæ˜¯é™æ€å·¥å…·ç±»,æ“ä½œæ–‡ä»¶è·¯å¾„,ä¾‹å¦‚æ‹¼æ¥æ–‡ä»¶è·¯å¾„,ä»¥å‰è¦ä½¿ç”¨å¹³å°æ— å…³çš„åˆ†éš”ç¬¦è¡¨ç¤ºï¼šFile.pathSeparator, File.separator.
ä¾‹å¦‚,æ„å»ºä¸€ä¸ªæ–‡ä»¶å¯¹è±¡:Path path = Paths.get("~/test/", "foo", "bar", "a.txt");
read file to string in java 6/7/8 package angus.java.interview; import java.io.BufferedReader; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Paths; public class FileToStringJava678 { public static void main(String[] args) throws IOException { // How to read file into String before Java 7 InputStream is = new FileInputStream("filetoStringjava678.txt"); BufferedReader buf = new BufferedReader(new InputStreamReader(is)); String line = buf.readLine(); StringBuilder sb = new StringBuilder(); while (line != null) { sb.append(line).append("\n"); line = buf.readLine(); } String fileAsString = sb.toString(); System.out.println("Contents (before Java 7) : " + fileAsString); // Reading file into Stirng in one line in JDK 7 with using proper character encoding String fileString = new String(Files.readAllBytes(Paths.get("filetoStringjava678.txt")), StandardCharsets.UTF_8); System.out.println("Contents (Java 7 with character encoding ) : " + fileString); //java 7 æŒ‰è¡Œè¯»å– BufferedReader br = new BufferedReader(new FileReader(file)); String line; while((line = br.readLine()) != null) { // do something with line. } //java 8 æŒ‰è¡Œè¯»å– String fileName = "c:/lines.txt"; try (Stream&lt;String> stream = Files.lines(Paths.get(fileName))) { stream.forEach(System.out::println);//or other thing you do with stream } catch (IOException e) { e.printStackTrace(); } // It's even easier in Java 8 Files.lines(Paths.get("filetoStringjava678.txt"), StandardCharsets.UTF_8).forEach(System.out::println); } } java 8 file io demo public class Java8IO { public static void main(String[] args) throws IOException { //è¯»å–æ‰€æœ‰å­—èŠ‚ï¼š Path path = Paths.get("alice.txt"); String content = new String(Files.readAllBytes(path), StandardCharsets.UTF_8); System.out.println("Characters: " + content.length()); // è¯»å–æ‰€æœ‰è¡Œï¼š List&lt;String> lines = Files.readAllLines(path, StandardCharsets.UTF_8); System.out.println("Lines: " + lines.size()); // JAVA 8 å»¶è¿Ÿå¤„ç†ï¼š try (Stream&lt;String> lineStream = Files.lines(path, StandardCharsets.UTF_8)) { System.out.println("Average line length: " + lineStream.mapToInt(String::length).average().orElse(0)); } // æŒ‰å•è¯è¯»å–ï¼š try (Scanner in = new Scanner(path, "UTF-8")) { in.useDelimiter("\\PL+");//ï¼Ÿ int words = 0; while (in.hasNext()) { in.next(); words++; } System.out.println("Words: " + words); } // è¯»å–ä¸€ä¸ªç½‘é¡µï¼š URL url = new URL("https://horstmann.com/index.html"); try (BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()))) { Stream&lt;String> lineStream = reader.lines();////!!!! BufferedReader TO Stream System.out.println("Average line length: " + lineStream.mapToInt(String::length).average().orElse(0)); } // PrintWriter å‘æ–‡æœ¬å†™æ–‡ä»¶ï¼š path = Paths.get("hello.txt"); try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(path, StandardCharsets.UTF_8))) { out.println("Hello"); } // Files.writeå‘æ–‡æœ¬å†™æ–‡ä»¶ï¼š content = "World\n"; Files.write(path, content.getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND); // å¤šè¡Œå†™å…¥ String fileName = "file.txt"; Path path = Paths.get("file1.txt"); List&lt;String> list = new ArrayList&lt;>(); try (Stream&lt;String> lines = Files.lines(Paths.get(fileName))) { lines.forEach(list::add); Files.write(path, list, StandardCharsets.UTF_8); } catch (IOException e) { e.printStackTrace(); } // æ‰“å°é”™è¯¯æ ˆï¼š StringWriter writer = new StringWriter(); Throwable throwable = new IllegalStateException(); throwable.printStackTrace(new PrintWriter(writer)); String stackTrace = writer.toString(); System.out.println("Stack trace: " + stackTrace); // è¾“å…¥æµä¿å­˜åˆ°æ–‡ä»¶ï¼š Files.copy(inputStream,filepath,StandardCopyOption.REPLACE_EXISTING); // ç›´æ¥å°†urlä¸­çš„pdfä¿å­˜ä¸‹æ¥ï¼š // é€‚ç”¨äºä»»ä½•äºŒè¿›åˆ¶æ–‡ä»¶ï¼š URL url = new URL("http://www.cninfo.com.cn/1202417936.PDF"); try (InputStream in = new BufferedInputStream(url.openStream())) { Files.copy(in, Paths.get(url.getFile().substring(1)),StandardCopyOption.REPLACE_EXISTING); } // url.getFile().substring(1)å»æ‰èµ·å§‹åœ°æ–œæ ç¬¦ // copy()æœ‰ä¸‰ç§å½¢å¼ // è¿˜æœ‰ä¸€ç§æ–¹å¼ç”¨äºjdk7ä¹‹å‰ï¼š URL website = new URL("XXX.pdf"); ReadableByteChannel rbc = Channels.newChannel(website.openStream()); FileOutputStream fos = new FileOutputStream(url.getFile().substring(1)); fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE); // FileChannelçš„æŠ½è±¡æ–¹æ³•abstract long transferFrom(ReadableByteChannel src, long position, long count) } }</content></entry><entry><title>Java AOP example</title><url>https://zhimoe.github.io/post/java-aop-example/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>java</tag><tag>aop</tag></tags><content type="html"> Java AOP: æ‰¾åˆ°ä¸€ä¸ªæœ€ç®€å•çš„ä»‹ç»,ä¸æ€ä¹ˆæƒ³ç¿»è¯‘,ç›´æ¥çœ‹åŸæ–‡å§:
A Simple Introduction to AOP
æé†’ä¸ªç‚¹,ä½¿ç”¨æ³¨è§£çš„æ–¹å¼å†™åˆ‡é¢æ—¶,å¢åŠ äº†ä¸€ä¸ªç©ºæ–¹æ³•,å³ï¼š
class Test{ @Pointcut("execution(* org.bk.inventory.service.*.*(..))") public void serviceMethods(){ //... } } åœ¨ä½¿ç”¨xmlé…ç½®çš„è¯,å°±ä¸éœ€è¦è¿™ä¸ªæ–¹æ³•äº†,serviceMethodsæ–¹æ³•åæ˜¯åé¢é…ç½®åˆ‡ç‚¹çš„å¼•ç”¨.
å¦‚æœä¸æƒ³å¼•å…¥springçš„è¯,å¯ä»¥ç›´æ¥ä½¿ç”¨aspectjæˆ–è€…jboss aop.</content></entry><entry><title>Java-==-and-equals</title><url>https://zhimoe.github.io/post/java--and-equal/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>java</tag><tag>code</tag></tags><content type="html"> samples code and notes on java == and equals
/** * samples for == and equal() * @author zhimoe * */ class TestObj { // the class for test == and equal() } public class EqualAndCompare { public static void main(String[] args) { TestObj obj1 = new TestObj(); TestObj obj2 = new TestObj(); TestObj obj3 = obj1; System.out.println(obj1 == obj2);// false , // == Compares references, not values System.out.println(obj1 == obj3);// true System.out.println(obj1.equals(obj2));// false, // equal() method is derived from java.lang.Object, if not override,nor // in superclass,then equal behave as same as == // Always remember to override hashCode if you override equals so as not // to "break the contract". // As per the API, the result returned from the hashCode() method for // two objects must be the same if their equals methods shows that they // are equivalent. The converse is not necessarily true. String s1 = "haha";// constant pool String s2 = new String("haha");// defined in ?heap System.out.println(s1 == s2);// false ,== Compares references, not // values, there is a exception for // static field in class, static String // in class == and equal both always // return *true* // for more infomation,see : // http://stackoverflow.com/questions/7520432/what-is-the-difference-between-vs-equals-in-java System.out.println(s1.equals(s2)); // true compare the // value String s3 = s2.intern();// find the same value String in constant pool System.out.println(s1 == s3);// true int i1 = 2;// primitive type has no equal() method Integer i3 = Integer.valueOf(2); System.out.println(i1 == i3);// true, i3 automatic unboxing into int; System.out.println(i3.equals(i1));// auto boxing into Integer Integer i2 = 2; System.out.println(i3.compareTo(i2)); } /* * Comparable interface, a.compareTo(b) return -1ï¼šless,0:equal,1:greater. 0 * should always be returned for objects when the .equals() comparisons * return true. All Java classes that have a natural ordering implement this * (String, Double, BigInteger, ...). * * * Comparator interface: is a util for compare two instance,then you can use * the comparator to sort array and other things * */ }</content></entry><entry><title>Javac-çº¿ç¨‹ä¸ä»»åŠ¡</title><url>https://zhimoe.github.io/post/java-concurrency-1-thread/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>java</tag><tag>å¹¶å‘</tag></tags><content type="html"> åŸºæœ¬æ¦‚å¿µ çº¿ç¨‹ï¼šä»»åŠ¡æ‰§è¡Œçš„ç¯å¢ƒï¼Œå¯ä»¥ç†è§£ä¸ºä¼ é€å¸¦ã€‚æ³¨æ„ä»»åŠ¡å¿…é¡»åœ¨çº¿ç¨‹ä¸Šé¢è¢«æ‰§è¡Œã€‚
ä»»åŠ¡ï¼š Runnable/Callableçš„å®ç°ï¼Œå¯ä»¥ç†è§£ä¸ºä¼ é€å¸¦ä¸Šé¢çš„å·¥åºã€‚
èµ„æºï¼šçº¿ç¨‹åœ¨å¤„ç†ä»»åŠ¡å…·ä½“å·¥åºæ—¶éœ€è¦ä½¿ç”¨çš„å¯¹è±¡ï¼Œä¾‹å¦‚ä¿¡å·é‡ï¼Œé”ï¼Œå¹¶å‘é›†åˆã€‚éœ€è¦æ³¨æ„ï¼Œä»»åŠ¡æœ¬èº«æè¿°ä¹Ÿæ˜¯ä¸€ä¸ªå¯¹è±¡ï¼ˆå³Runnable/Callable å­ç±»å®ä¾‹ï¼‰ï¼Œæ‰€ä»¥åœ¨Runnableä»£ç é‡Œé¢ä½ ä¼šçœ‹åˆ° synchronized(this)çš„ç”¨æ³•ï¼Œå°±æ˜¯æŠŠä»»åŠ¡æè¿°æœ¬èº«å½“ä½œä¸€ä¸ªèµ„æºï¼Œç”šè‡³Threadå†…éƒ¨ä¹Ÿå¯ä»¥å°†å½“å‰å¯¹è±¡å½“åšèµ„æºã€‚
ä»»åŠ¡ å¤šçº¿ç¨‹ç¼–ç¨‹çš„æ ¸å¿ƒå…ƒç´ å°±æ˜¯ä»»åŠ¡ï¼Œä»»åŠ¡æ˜¯ç‹¬ç«‹çš„æ´»åŠ¨ï¼Œä¸ä¾èµ–å…¶ä»–ä»»åŠ¡çš„çŠ¶æ€ã€ç»“æœã€ä»¥åŠè¾¹ç•Œæ•ˆåº”ã€‚ å®šä¹‰ä»»åŠ¡çš„å†…å®¹ä½¿ç”¨Runnableå’ŒCallable.
Runnable æ¥å£è¡¨ç¤ºæ²¡æœ‰è¿”å›çš„ä¸€ä¸ªè¿‡ç¨‹ï¼ˆprocedureï¼‰ï¼Œæ²¡æœ‰å—æ£€å¼‚å¸¸ï¼›
Callable æ¥å£çš„callæ–¹æ³•ä¼šè¿”å›ä¸€ä¸ªç»“æœï¼Œå¹¶æœ‰å¯èƒ½æŠ›å‡ºå—æ£€å¼‚å¸¸ã€‚å¦‚æœè¦è¡¨ç¤ºæ²¡æœ‰è¿”å›å€¼,å¯ä»¥ä½¿ç”¨Callable
ï¼Œä½†æ˜¯ä¸é¼“åŠ±ä½¿ç”¨è¿™ä¸ªä»£æ›¿Runnableï¼Œå½“ä¸€ä¸ªä»»åŠ¡å†…å®¹æ²¡æœ‰è¿”å›å€¼,åªæ˜¯åˆ©ç”¨å‰¯ä½œç”¨æ—¶,åº”è¯¥ä¼˜å…ˆä½¿ç”¨Runable,ä½¿å¾—å«ä¹‰æ¸…æ™°,å¹¶ä¸”JDKä¸­ScheduledExecutorServiceä¹Ÿæœ‰åªèƒ½æ¥æ”¶Runableçš„æ–¹æ³•.
Futureæ¥å£æè¿°äº†ä»»åŠ¡çš„ç”Ÿå‘½å‘¨æœŸ,å¹¶æä¾›æ–¹æ³•è·å¾—ä»»åŠ¡æ‰§è¡Œçš„ç»“æœ.è¯¥æ¥å£æœ‰ä¸€ä¸ªå®ç°ç±»ï¼šFutureTask.è¯¥ç±»çš„å®ä¾‹ä¸€å®šå’Œä¸€ä¸ªå…·ä½“ä»»åŠ¡ç›¸å…³.ExecutorServiceæ‰€æœ‰çš„submitæ–¹æ³•éƒ½ä¼šè¿”å›ä¸€ä¸ªFutureå®ä¾‹.ä½ ä¹Ÿå¯ä»¥ç›´æ¥é€šè¿‡FutureTaskæ„é€ å‡½æ•°å°†Runnable/Callableå¯¹è±¡æ„å»ºæˆä¸€ä¸ªFutureTaskå®ä¾‹ï¼Œè¯¥å®ä¾‹å°†ç®¡ç†è¯¥ä»»åŠ¡çš„ç”Ÿå‘½å‘¨æœŸã€‚
æ³¨æ„ï¼ŒFutureTask å®ç°äº†Runnableå’ŒFutureï¼ˆé€šè¿‡å®ç°RunnableFutureæ¥å£ï¼‰,æ‰€ä»¥æ—¢å¯ä»¥ä½¿ç”¨ExecutorService,ä¹Ÿå¯ä»¥ä½¿ç”¨Threadæ‰§è¡ŒFutureTaskä»»åŠ¡å†…å®¹.
// FutureTaskæ¥å£å…³ç³» interface RunnableFuture&lt;V> extends Runnable, Future&lt;V> public class FutureTask&lt;V> implements RunnableFuture&lt;V> çº¿ç¨‹Thread åˆ›å»ºä¸€ä¸ªçº¿ç¨‹çš„æ–¹æ³•æ˜¯new Thread()ï¼Œä½†æ˜¯å‘çº¿ç¨‹æäº¤ä»»åŠ¡çš„æ–¹å¼æœ‰ä¸¤ç§ï¼šä¸€æ˜¯ç›´æ¥ç»§æ‰¿Threadå°†ä»»åŠ¡ç¼–ç åœ¨è‡ªå®šä¹‰Threadçš„runæ–¹æ³•é‡Œé¢ï¼›äºŒæ˜¯å°†Runnableå®ä¾‹ä¼ é€’ç»™Threadæ„é€ å‡½æ•°ï¼ŒåŒºåˆ«åªä¸è¿‡æ˜¯å¦å°†ä»»åŠ¡ç»‘å®šåœ¨çº¿ç¨‹å®ä¾‹ä¸Šè€Œå·²,ç¬¬äºŒç§æ–¹å¼æ›´çµæ´»å®ç°äº†çº¿ç¨‹ä¸ä»»åŠ¡çš„è§£è€¦ï¼Œæƒè´£åˆ†æ˜ã€‚
å¯åŠ¨çº¿ç¨‹ä½¿ç”¨ t.start()ï¼Œ æ³¨æ„ï¼Œå¦‚æœæ˜¯è°ƒç”¨t.run()æ˜¯åœ¨å½“å‰çº¿ç¨‹ä¸­æ‰§è¡Œä»»åŠ¡ï¼Œä¸æ˜¯æ–°çº¿ç¨‹ã€‚
çº¿ç¨‹çš„ç”Ÿå‘½å‘¨æœŸ
è¯¦ç»†è¯´æ˜å‚è€ƒJavaå¹¶å‘ç¼–ç¨‹
Thread.joinæ–¹æ³• å½“è°ƒç”¨t.joinæ—¶ï¼Œ è°ƒç”¨çº¿ç¨‹ï¼ˆcalling threadï¼‰ä¼šæš‚åœï¼Œä¸€ç›´åˆ°çº¿ç¨‹tç»ˆæ­¢æˆ–è€…æŠ›å‡ºä¸€ä¸ªInterruptedExceptionã€‚
The join() method may also return if the referenced thread was interrupted. In this case, the join method throws an InterruptedException. ExecutorService æ‰§è¡Œå™¨æ¡†æ¶,rootæ¥å£æ˜¯Executor,åªæœ‰ä¸€ä¸ªexecuteæ–¹æ³•æ‰§è¡Œrunnableå®ä¾‹.æ›´å¸¸ç”¨æ˜¯å­æ¥å£ExecutorService,é™¤äº†å¯ä»¥æ‰§è¡Œrunnable,callable,è¿˜å¯ä»¥invokeä¸€ä¸ªcallableé›†åˆï¼š
&lt;T> List&lt;Future&lt;T>> invokeAll(Collection&lt;? extends Callable&lt;T>> tasks) &lt;T> T invokeAny(Collection&lt;? extends Callable&lt;T>> tasks) &lt;T> Future&lt;T> submit(Callable&lt;T> task) Future&lt;?> submit(Runnable task) ScheduledExecutorService The ScheduledExecutorService interface supplements the methods of its parent ExecutorService with schedule, which
executes a Runnable or Callable task after a specified delay. In addition, the interface defines scheduleAtFixedRate and
scheduleWithFixedDelay, which executes specified tasks repeatedly, at defined intervals.
scheduleAtFixedRate: ç¬¬ä¸€æ¬¡æ˜¯initialDelay åæ‰§è¡Œ,ç¬¬äºŒæ¬¡æ˜¯initialDelay + 1 * period åæ‰§è¡Œ,ç±»æ¨.
scheduleWithFixedDelay: æ˜¯å‰é¢ä»»åŠ¡æ‰§è¡Œç»“æŸåå¼€å§‹è®¡ç®—é—´éš”è®¡æ—¶.
ä¸¤ä¸ªæ–¹æ³•éƒ½ä¸ä¼šå¹¶å‘æ‰§è¡Œä»»åŠ¡,ç‰¹åˆ«æ˜¯ç¬¬ä¸€ä¸ªæ–¹æ³•,å¦‚æœä»»åŠ¡æ—¶é—´æ¯”å‚æ•°ä¸­ç­‰å¾…æ—¶é—´periodé•¿,é‚£ä¹ˆåªä¼šå»¶æœŸæ‰§è¡Œ.å¯¹äºç¬¬äºŒä¸ªæ–¹æ³•,æœ¬æ¥å°±æ˜¯è¦ç­‰å‰é¢ç»“æŸæ‰æ‰§è¡Œ,æ‰€ä»¥æ²¡æœ‰è¿™ä¸ªé—®é¢˜.ä¸¤ä¸ªæ–¹æ³•é‡åˆ°å¼‚å¸¸,é‚£ä¹ˆåé¢ä»»åŠ¡ä¹Ÿä¸ä¼šæ‰§è¡Œ,å› ä¸ºä»»åŠ¡æ˜¯é‡å¤çš„,åé¢ä¹Ÿä¼šé‡åˆ°å¼‚å¸¸.å‘¨æœŸä»»åŠ¡å¯ä»¥å–æ¶ˆ,æˆ–è€…é‡åˆ°æ‰§è¡Œå™¨ç»ˆç»“æ‰ç»“æŸ.
çº¿ç¨‹æ± å¦‚ä½•å®ç°å¤ç”¨çš„ å…¶å®éå¸¸ç®€å• å°±æ˜¯Thread Workerçš„runWorker()æ–¹æ³•ä¸­æœ‰ä¸€ä¸ªwhileå¾ªç¯ä¸åœè·å–taskå¹¶è°ƒç”¨task.runæ–¹æ³•ã€‚
åé¢å•å¼€ä¸€ç¯‡ã€‚
CompletionService å¦‚æœæœ‰å¤šä¸ªä»»åŠ¡,é‚£ä¹ˆExecutorServiceåªèƒ½ä¸åœçš„è½®è¯¢Futureçœ‹æ˜¯å¦æœ‰ä»»åŠ¡ç»“æŸ,å¹¶å–å¾—ç»“æœ.CompletionServiceåˆ™æ˜¯å¦å¤–æ˜¯è‡ªåŠ¨çš„å‘Šè¯‰ä½ é‚£äº›ä»»åŠ¡ç»“æœå·²ç»å‡†å¤‡å¥½.æ³¨æ„æ„é€ æ–¹æ³•éœ€è¦ä¸€ä¸ªExecutorService
# ç†è§£ ExecutorService = incoming queue + worker threads CompletionService = incoming queue + worker threads + output queue CompletionServiceå‚è€ƒ
ExecutorService executor = Executors.newFixedThreadPool(numberOfThreadsInThePool); CompletionService&lt;String> completionService = new ExecutorCompletionService&lt;String>(executor); for (final String num: nums) { completionService.submit(new Task(num)); //Task is Callable } try { for (int t = 0, n = nums.size(); t &lt; n; t++) { Future&lt;String> f = completionService.take(); System.out.print(f.get()); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } catch (ExecutionException e) { Thread.currentThread().interrupt(); } finally { if (executor != null) { executor.shutdownNow(); } } å‚è€ƒä¹¦ç±ï¼š Doug Lea ã€ŠConcurrent Programming in Javaã€‹ 2004
Brian Goetz ã€Šjava concurrency in practiceã€‹ 2007
Venkat ã€ŠProgramming concurrency on the JVMã€‹</content></entry><entry><title>Javaå¹¶å‘2-åŒæ­¥ä¸é”</title><url>https://zhimoe.github.io/post/java-concurrency-2-control/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>java</tag><tag>å¹¶å‘</tag></tags><content type="html"> Object.wait/notify/notifyAll è¿™ä¸‰ä¸ªæ–¹æ³•æ˜¯åœ¨class Object ä¸Šé¢çš„ï¼Œä¹Ÿå°±æ˜¯æ‰€æœ‰å¯¹è±¡éƒ½æœ‰è¿™ä¸ªæ–¹æ³•ã€‚è¿™é‡Œå¯¹è±¡å°±æ˜¯ä¸Šé¢ç±»æ¯”çš„èµ„æº,å¯ä»¥å½“æˆä¸€ä¸ªä¿¡å·é‡ã€‚
Object.wait() to suspend a threadï¼ˆç­‰ä»·äºsem.wait()ï¼‰ã€‚å°†å½“å‰çº¿ç¨‹æš‚åœå¹¶é‡Šæ”¾å½“å‰å¯¹è±¡é”ï¼Œç›´åˆ°å…¶ä»–çº¿ç¨‹è°ƒç”¨äº†å½“å‰å¯¹è±¡çš„notify/notifyAllæ–¹æ³•ã€‚
Object.notify() to wake a thread upï¼ˆç­‰ä»·sem.signal()ï¼‰ã€‚å”¤é†’ä¸€ä¸ªåœ¨ç­‰å¾…å½“å‰å¯¹è±¡é”çš„çº¿ç¨‹ã€‚
ä»¥å‰ç”¨wait/notifyçš„åœ°æ–¹,ç°åœ¨å¯ä»¥ç”¨CyclicBarrierå’ŒCountDownLatchåŒæ­¥å·¥å…·ä»£æ›¿
waitæ–¹æ³•ä½¿ç”¨æ¨¡æ¿:
synchronized (obj) { while (condition does not hold){ // è¿™é‡Œå³ä½¿çº¿ç¨‹è¢«è™šå‡å”¤é†’ï¼Œæ¡ä»¶è¿˜æ˜¯ä¸æ»¡è¶³ï¼Œåˆ™ç»§ç»­wait obj.wait(); } //... Perform action appropriate to condition } ä¸ºä»€ä¹ˆ wait æ–¹æ³•å¿…é¡»åœ¨ synchronized ä¿æŠ¤çš„åŒæ­¥ä»£ç ä¸­ä½¿ç”¨ï¼Ÿ å› ä¸ºéœ€è¦ä¿è¯whileåˆ¤æ–­å’Œwaitä¸¤ä¸ªæ“ä½œæ˜¯ä¸€ä¸ªåŸå­æ“ä½œã€‚
ä¸¤ä¸ªçº¿ç¨‹äº¤æ›¿æ‰“å°A/B
public static void main(String[] args) { PrintTask pt = new PrintTask("A"); new Thread(pt::print).start(); new Thread(pt::print).start(); } static class PrintTask { private String currentChar; PrintTask(String initialChar) { this.currentChar = initialChar; } public void print() { synchronized (this) { while (true) { System.out.println(Thread.currentThread().getId() +" "+currentChar); if ("A".equals(currentChar)) { currentChar = "B"; } else { currentChar = "A"; } try { this.notifyAll(); this.wait(); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } } synchronized å’Œ volatile volatile æ¯”è¾ƒç®€å•ï¼Œå¯ä»¥ç†è§£ä¸ºå°†ä¸€ä¸ªå˜é‡å¼ºåˆ¶åŒæ­¥ç»™æ‰€æœ‰çº¿ç¨‹å¯è§ï¼Œä½†æ˜¯ä¸èƒ½è§£å†³å¹¶å‘å†™çš„é—®é¢˜ã€‚
javaçš„æ¯ä¸ªå¯¹è±¡éƒ½æœ‰å†…åœ¨é”ï¼ˆæˆ–è€…å«ç›‘è§†å™¨é”ï¼Œintrinsic lock or monitor lockï¼‰ï¼Œæ¶‰åŠä¸¤ä¸ªJVMæŒ‡ä»¤ï¼šmonitorenterã€monitorexitã€‚
synchronized methodå’Œsynchronized blockçš„åŒºåˆ«ï¼š
å¦‚æœæ˜¯synchronized(this),é‚£ä¹ˆå’Œsynchronized æ–¹æ³•æ²¡æœ‰ä»»ä½•åŒºåˆ«,é”å®šå¯¹è±¡éƒ½æ˜¯æ–¹æ³•æ‰€åœ¨çš„å¯¹è±¡.
ä½†æ˜¯synchronized blockå¯ä»¥é”å®šå…¶ä»–å¯¹è±¡,è€Œä¸”synchronized blockçš„èŒƒå›´æ˜¯å¯ä»¥æ§åˆ¶æ›´çµæ´»,synchronized æ–¹æ³•çš„è¾¹ç•Œåªèƒ½æ˜¯æ•´ä¸ªæ–¹æ³•
ä½¿ç”¨ReentrantLockåœºæ™¯ï¼š
éœ€è¦ä»¥ä¸‹é«˜çº§ç‰¹æ€§æ—¶ ï¼š å¯å®šæ—¶çš„,å¯è½®è¯¢çš„,å¯ä¸­æ–­çš„é”,å…¬å¹³é˜Ÿåˆ—,éå—ç»“æ„.
Synchronization vs Lock-stackoverflow
Semaphore å¯ä»¥ç†è§£ä¸ºèµ„æºçš„è®¸å¯è¯æ•°é‡ã€‚
sem.acquire(2): è·å–ä¸¤ä¸ªè®¸å¯è¯ã€‚
sem.release() é‡Šæ”¾èµ„æºçš„ä¸€ä¸ªè®¸å¯è¯ã€‚
ä¿¡å·é‡éå¸¸æœ‰ç”¨ï¼Œä¹Ÿæ˜¯åŸºç¡€ï¼ŒåŸºäºä¿¡å·é‡ï¼Œå¯ä»¥æ„å»ºå‡ºå¾ˆå¤šå…¶ä»–çš„åŒæ­¥å·¥å…·: turnstileå’Œrendezvousï¼Œbarrierï¼Œmutexï¼ŒMultiplex
CountDownLatch CountDownLatchæ˜¯ç®¡ç†ä¸€ç»„çº¿ç¨‹å’Œä¸€ä¸ªä¸»çº¿ç¨‹çš„å…ˆå.ä¸»çº¿ç¨‹waitåå°±é˜»å¡,ç›´åˆ°æ‰€æœ‰çš„CountDownLatchè°ƒç”¨countDownåä¸»çº¿ç¨‹æ¥ç€å¼€å§‹.
package angus.intrview.concurrent; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; public class CountDownLatchTest { // è¿™ä¸ªæ–¹æ³•å°†å¯åŠ¨å¤šä¸ªä»»åŠ¡,å¹¶è®©å®ƒä»¬åŒæ—¶æ‰§è¡Œ,è®¡ç®—å®Œæˆçš„æ—¶é—´ public long timer(int taskNums) throws InterruptedException { CountDownLatch startLatch = new CountDownLatch(1); CountDownLatch finishLatch = new CountDownLatch(taskNums); for (int i = 0; i &lt; taskNums; i++) { Task task = new Task(startLatch, finishLatch, i); new Thread(task).start(); } long start = System.nanoTime(); startLatch.countDown();// å‡†å¤‡å¥½çº¿ç¨‹åå¼€å§‹åŒæ—¶å¯åŠ¨æ‰€æœ‰ä»»åŠ¡ finishLatch.await();// ç­‰å¾…ä»»åŠ¡å®Œæˆ long end = System.nanoTime(); return end - start; } public static void main(String[] args) throws InterruptedException { CountDownLatchTest ct = new CountDownLatchTest(); long time = ct.timer(100); System.out.println(TimeUnit.NANOSECONDS.toSeconds(time) + " SENCODS"); } } class Task implements Runnable { CountDownLatch startLatch; CountDownLatch finishLatch; int time; Task(CountDownLatch startLatch, CountDownLatch finishLatch, int time) { this.startLatch = startLatch; this.finishLatch = finishLatch; this.time = time; } @Override public void run() { try { startLatch.await();// ç­‰å¾…ä¸»çº¿ç¨‹é€šçŸ¥ä»»åŠ¡å¼€å§‹ System.out.println("doing the task!"); Thread.sleep(time * 100); // æ¨¡æ‹Ÿä»»åŠ¡è¿‡ç¨‹ } catch (InterruptedException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } finally { System.out.println("task done"); finishLatch.countDown();// å‘Šè¯‰ä¸»çº¿ç¨‹ä»»åŠ¡å®Œæˆ } } } CyclicBarrier Exchanger Lock</content></entry><entry><title>Javaå¹¶å‘3-ThreadLocal</title><url>https://zhimoe.github.io/post/java-concurrency-3-threadlocal/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>java</tag><tag>å¹¶å‘</tag></tags><content type="html"> åœ¨é€šå¸¸çš„ä¸šåŠ¡å¼€å‘ä¸­ï¼ŒThreadLocal æœ‰ä¸¤ç§å…¸å‹çš„ä½¿ç”¨åœºæ™¯ã€‚
åœºæ™¯1ï¼ŒThreadLocal ç”¨ä½œä¿å­˜æ¯ä¸ªçº¿ç¨‹ç‹¬äº«çš„å¯¹è±¡ï¼Œä¸ºæ¯ä¸ªçº¿ç¨‹éƒ½åˆ›å»ºä¸€ä¸ªå‰¯æœ¬ï¼Œè¿™æ ·æ¯ä¸ªçº¿ç¨‹éƒ½å¯ä»¥ä¿®æ”¹è‡ªå·±æ‰€æ‹¥æœ‰çš„å‰¯æœ¬, è€Œä¸ä¼šå½±å“å…¶ä»–çº¿ç¨‹çš„å‰¯æœ¬ï¼Œç¡®ä¿äº†çº¿ç¨‹å®‰å…¨ã€‚
åœºæ™¯2ï¼ŒThreadLocal ç”¨ä½œæ¯ä¸ªçº¿ç¨‹å†…éœ€è¦ç‹¬ç«‹ä¿å­˜ä¿¡æ¯ï¼Œä»¥ä¾¿ä¾›å…¶ä»–æ–¹æ³•æ›´æ–¹ä¾¿åœ°è·å–è¯¥ä¿¡æ¯çš„åœºæ™¯ã€‚æ¯ä¸ªçº¿ç¨‹è·å–åˆ°çš„ä¿¡æ¯å¯èƒ½éƒ½æ˜¯ä¸ä¸€æ ·çš„ï¼Œå‰é¢æ‰§è¡Œçš„æ–¹æ³•ä¿å­˜äº†ä¿¡æ¯åï¼Œåç»­æ–¹æ³•å¯ä»¥é€šè¿‡ ThreadLocal ç›´æ¥è·å–åˆ°ï¼Œé¿å…äº†ä¼ å‚ï¼Œç±»ä¼¼äºå…¨å±€å˜é‡çš„æ¦‚å¿µã€‚
åœºæ™¯1ï¼š ä¿å­˜çº¿ç¨‹ä¸å®‰å…¨çš„å·¥å…·ç±» æ³¨æ„ï¼šå®é™…å¼€å‘ä¸­ä½¿ç”¨DateTimeFormatter ä»£æ›¿ SimpleDateFormat.
import java.text.SimpleDateFormat; import java.util.Random; public class ThreadLocalExample implements Runnable{ // SimpleDateFormat is not thread-safe, so give one to each thread private static final ThreadLocal&lt;SimpleDateFormat> formatter = new ThreadLocal&lt;SimpleDateFormat>(){ @Override protected SimpleDateFormat initialValue() { return new SimpleDateFormat("yyyyMMdd HHmm"); } }; public static void main(String[] args) throws InterruptedException { ThreadLocalExample obj = new ThreadLocalExample(); for(int i=0 ; i&lt;10; i++){ Thread t = new Thread(obj, ""+i); Thread.sleep(new Random().nextInt(1000)); t.start(); } } @Override public void run() { System.out.println("Thread Name= "+Thread.currentThread().getName()+" default Formatter = "+formatter.get().toPattern()); try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } //formatter pattern is changed here by thread, but it won't reflect to other threads formatter.set(new SimpleDateFormat()); System.out.println("Thread Name= "+Thread.currentThread().getName()+" formatter = "+formatter.get().toPattern()); } } åœºæ™¯2ï¼šä¸åŒçº¿ç¨‹ä¿å­˜ç‹¬ç«‹ä¿¡æ¯ ä¾‹å¦‚éœ€è¦è®°å½•mysqlçš„SQLæ‰§è¡Œè€—æ—¶ä»¥åŠå…¶ä»–ç›¸å…³ä¿¡æ¯
public class MysqlQueryInterceptor implements com.mysql.cj.interceptors.QueryInterceptor { private final ThreadLocal&lt;LocalDateTime> startTimeHolder = new ThreadLocal&lt;>(); @Override public &lt;T extends Resultset> T preProcess(Supplier&lt;String> supplier, Query query) { startTimeHolder.set(LocalDateTime.now()); return null; } } ä¸Šé¢çš„ThreadLocalä¹Ÿå¯ä»¥ä½¿ç”¨slf4jçš„MDC(Mapped Diagnostic Context)ã€‚</content></entry><entry><title>JavaåŠ¨æ€ä»£ç†</title><url>https://zhimoe.github.io/post/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>java</tag><tag>code</tag></tags><content type="html"> å¥½æ–‡ Java åŠ¨æ€ä»£ç†æœºåˆ¶åˆ†æåŠæ‰©å±•
æ›´æ·±å…¥çš„ä¸€ç¯‡:
javaè®¾è®¡æ¨¡å¼-åŠ¨æ€ä»£ç†æ¨¡å¼
ä¼˜åŠ¿ ç›¸æ¯” é™æ€ä»£ç†,åŠ¨æ€ä»£ç†å…·æœ‰æ›´å¼ºçš„ çµæ´»æ€§,å› ä¸ºå®ƒä¸ç”¨åœ¨æˆ‘ä»¬è®¾è®¡å®ç°çš„æ—¶å€™å°±æŒ‡å®š æŸä¸€ä¸ªä»£ç†ç±»æ¥ä»£ç†å“ªä¸€ä¸ªè¢«ä»£ç†å¯¹è±¡,æˆ‘ä»¬å¯ä»¥æŠŠè¿™ç§æŒ‡å®šå»¶è¿Ÿåˆ°ç¨‹åºè¿è¡Œæ—¶ç”± JVMæ¥å®ç°.
å®ä¾‹ åŠ¨æ€ä»£ç†ç±»æ¥å£,æ¥å£è§„èŒƒæ–¹æ³•.
package angus.interview.proxy; public interface Subject { public void request(); } éœ€è¦è¢«ä»£ç†çš„çœŸå®çš„ç±»:
package angus.interview.proxy; public class SubjectImpl implements Subject { @Override public void request() { System.out.println(" subject request"); } } å…ˆåˆ›å»ºä¸€ä¸ªä»£ç†ç±».ç„¶ååˆ©ç”¨åå°„åˆ›å»ºä¸€ä¸ªç”¨çœŸå®ç±»åŠ è½½å™¨åˆ›å»ºçš„ä¸€ä¸ªå¯¹è±¡.è¯¥å¯¹è±¡è°ƒç”¨requestæ–¹æ³•å®é™…ä¸Šè°ƒç”¨çš„æ˜¯ä»£ç†ç±»çš„invokeæ–¹æ³•.
package angus.interview.proxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class DynamicProxy implements InvocationHandler { private Object target; public Object bind(Object target) { this.target = target; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); // è¦ç»‘å®šæ¥å£this(è¿™æ˜¯ä¸€ä¸ªç¼ºé™·,cglibå¼¥è¡¥äº†è¿™ä¸€ç¼ºé™·) } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println("------------------before------------------"); Object result = method.invoke(target, args); System.out.println("-------------------after------------------"); return result; } } static void main(){ DynamicProxy proxy = new DynamicProxy(); Subject subject= proxy.bind(SubjectImpl); subject.request(); } å’Œé™æ€ä»£ç†æ¨¡å¼æ¯”è¾ƒçš„å¥½å¤„
åœ¨é™æ€ä»£ç†æ¨¡å¼æ—¶,ä¸€ä¸ªçœŸå®è§’è‰²å¿…é¡»å¯¹åº”ä¸€ä¸ªä»£ç†è§’è‰²,å¦‚æœå¤§é‡ä½¿ç”¨ä¼šå¯¼è‡´ç±»çš„æ€¥å‰§è†¨èƒ€;è€ŒåŠ¨æ€ä»£ç†åˆ™ä¸ä¼šæœ‰è¿™ä¸ªé—®é¢˜,æˆ‘ä»¬å°†æ¥å£ä¸­çš„æ–¹æ³•å§”æ‰˜ç»™invokeæ–¹æ³•,å¹¶åœ¨invokeä¸­å®ç°æ‹¦æˆª.
æºç åˆ†æ å‚è€ƒ:http://rejoy.iteye.com/blog/1627405 ä¸»è¦åŸæ¥:ç”Ÿæˆäº†ä¸€ä¸ªä»£ç†ç±»çš„classæ–‡ä»¶. Proxy.newProInstance()æ–¹æ³•
public static Object newProxyInstance(ClassLoader loader,Class&lt;?>[] interfaces,InvocationHandler h) throws IllegalArgumentException { if (h == null) { throw new NullPointerException(); } final Class&lt;?>[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) { checkProxyAccess(Reflection.getCallerClass(), loader, intfs); } // è¿™é‡Œæ˜¯ç”Ÿæˆclassçš„åœ°æ–¹ Class&lt;?> cl = getProxyClass0(loader, intfs); // ä½¿ç”¨æˆ‘ä»¬å®ç°çš„InvocationHandlerä½œä¸ºå‚æ•°è°ƒç”¨æ„é€ æ–¹æ³•æ¥è·å¾—ä»£ç†ç±»çš„å®ä¾‹ try { final Constructor&lt;?> cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (sm != null &amp;&amp; ProxyAccessHelper.needsNewInstanceCheck(cl)) { return AccessController.doPrivileged(new PrivilegedAction&lt;Object>() { public Object run() { return newInstance(cons, ih); } }); } else { return newInstance(cons, ih); } } catch (NoSuchMethodException e) { throw new InternalError(e.toString()); } } å…¶ä¸­newInstanceåªæ˜¯è°ƒç”¨Constructor.newInstanceæ¥æ„é€ ç›¸åº”çš„ä»£ç†ç±»å®ä¾‹,è¿™é‡Œé‡ç‚¹æ˜¯çœ‹getProxyClass0è¿™ä¸ªæ–¹æ³•çš„å®ç°:
private static Class&lt;?> getProxyClass0(ClassLoader loader, Class&lt;?>... interfaces) { // ä»£ç†çš„æ¥å£æ•°é‡ä¸èƒ½è¶…è¿‡65535,è¿™æ˜¯classæ–‡ä»¶æ ¼å¼å†³å®šçš„ if (interfaces.length > 65535) { throw new IllegalArgumentException("interface limit exceeded"); } // JDKå¯¹ä»£ç†è¿›è¡Œäº†ç¼“å­˜,å¦‚æœå·²ç»å­˜åœ¨ç›¸åº”çš„ä»£ç†ç±»,åˆ™ç›´æ¥è¿”å›,å¦åˆ™æ‰ä¼šé€šè¿‡ProxyClassFactoryæ¥åˆ›å»ºä»£ç† return proxyClassCache.get(loader, interfaces); } å…¶ä¸­ä»£ç†ç¼“å­˜æ˜¯ä½¿ç”¨WeakCacheå®ç°çš„,å¦‚ä¸‹
private static final WeakCache&lt;ClassLoader, Class&lt;?>[], Class&lt;?>> proxyClassCache = new WeakCache&lt;>(new KeyFactory(), new ProxyClassFactory()); å…·ä½“çš„ç¼“å­˜é€»è¾‘è¿™é‡Œæš‚ä¸å…³å¿ƒ,åªéœ€è¦å…³å¿ƒProxyClassFactoryæ˜¯å¦‚ä½•ç”Ÿæˆä»£ç†ç±»çš„,ProxyClassFactoryæ˜¯Proxyçš„ä¸€ä¸ªé™æ€å†…éƒ¨ç±»,å®ç°äº†WeakCacheçš„å†…éƒ¨æ¥å£BiFunctionçš„applyæ–¹æ³•:
private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?>[], Class&lt;?>> { // æ‰€æœ‰ä»£ç†ç±»åå­—çš„å‰ç¼€ private static final String proxyClassNamePrefix = "$Proxy"; // ç”¨äºç”Ÿæˆä»£ç†ç±»åå­—çš„è®¡æ•°å™¨ private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?> apply(ClassLoader loader, Class&lt;?>[] interfaces) { // çœç•¥éªŒè¯ä»£ç†æ¥å£çš„ä»£ç â€¦â€¦ String proxyPkg = null; // ç”Ÿæˆçš„ä»£ç†ç±»çš„åŒ…å // å¯¹äºéå…¬å…±æ¥å£,ä»£ç†ç±»çš„åŒ…åä¸æ¥å£çš„ç›¸åŒ for (Class&lt;?> intf : interfaces) { int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) { String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? "" : name.substring(0, n + 1)); if (proxyPkg == null) { proxyPkg = pkg; } else if (!pkg.equals(proxyPkg)) { throw new IllegalArgumentException( "non-public interfaces from different packages"); } } } // å¯¹äºå…¬å…±æ¥å£çš„åŒ…å,é»˜è®¤ä¸ºcom.sun.proxy[æºç ](http://hg.openjdk.java.net/jdk6/jdk6/jdk/rev/695dd7ceb9e3) if (proxyPkg == null) { proxyPkg = ReflectUtil.PROXY_PACKAGE + "."; } // è·å–è®¡æ•° long num = nextUniqueNumber.getAndIncrement(); // é»˜è®¤æƒ…å†µä¸‹,ä»£ç†ç±»çš„å®Œå…¨é™å®šåä¸º:com.sun.proxy.$Proxy0,com.sun.proxy.$Proxy1â€¦â€¦ä¾æ¬¡é€’å¢ String proxyName = proxyPkg + proxyClassNamePrefix + num; // è¿™é‡Œæ‰æ˜¯çœŸæ­£çš„ç”Ÿæˆä»£ç†ç±»çš„å­—èŠ‚ç çš„åœ°æ–¹ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces); try { // æ ¹æ®äºŒè¿›åˆ¶å­—èŠ‚ç è¿”å›ç›¸åº”çš„Classå®ä¾‹ return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); } catch (ClassFormatError e) { throw new IllegalArgumentException(e.toString()); } } } ProxyGeneratoræ˜¯sun.miscåŒ…ä¸­çš„ç±»,å®ƒæ²¡æœ‰å¼€æº,ä½†æ˜¯å¯ä»¥åç¼–è¯‘æ¥ä¸€æ¢ç©¶ç«Ÿ:
public static byte[] generateProxyClass(final String var0, Class[] var1) { ProxyGenerator var2 = new ProxyGenerator(var0, var1); final byte[] var3 = var2.generateClassFile(); // è¿™é‡Œæ ¹æ®å‚æ•°é…ç½®,å†³å®šæ˜¯å¦æŠŠç”Ÿæˆçš„å­—èŠ‚ç ï¼ˆ.classæ–‡ä»¶ï¼‰ä¿å­˜åˆ°æœ¬åœ°ç£ç›˜, //æˆ‘ä»¬å¯ä»¥é€šè¿‡æŠŠç›¸åº”çš„classæ–‡ä»¶ä¿å­˜åˆ°æœ¬åœ°,å†åç¼–è¯‘æ¥çœ‹çœ‹å…·ä½“çš„å®ç°,è¿™æ ·æ›´ç›´è§‚ if(saveGeneratedFiles) { AccessController.doPrivileged(new PrivilegedAction() { public Void run() { try { FileOutputStream var1 = new FileOutputStream(ProxyGenerator.dotToSlash(var0) + ".class"); var1.write(var3); var1.close(); return null; } catch (IOException var2) { throw new InternalError("I/O exception saving generated file: " + var2); } } }); } return var3; } saveGeneratedFilesè¿™ä¸ªå±æ€§çš„å€¼ä»å“ªé‡Œæ¥å‘¢:
private static final boolean saveGeneratedFiles = ((Boolean)AccessController.doPrivileged( new GetBooleanAction("sun.misc.ProxyGenerator.saveGeneratedFiles"))).booleanValue(); GetBooleanActionå®é™…ä¸Šæ˜¯è°ƒç”¨Boolean.getBoolean(propName)æ¥è·å¾—çš„,è€ŒBoolean.getBoolean(propName)è°ƒç”¨äº†System.getProperty(name),æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è®¾ç½®sun.misc.ProxyGenerator.saveGeneratedFilesè¿™ä¸ªç³»ç»Ÿå±æ€§ä¸ºtrueæ¥æŠŠç”Ÿæˆçš„classä¿å­˜åˆ°æœ¬åœ°æ–‡ä»¶æ¥æŸ¥çœ‹.
åç¼–è¯‘classæ–‡ä»¶
è‡ªå·±åˆ›å»ºæ–‡ä»¶å†™å…¥ç”Ÿæˆçš„åŠ¨æ€ä»£ç†ç±»:
package angus.interview.proxy; import java.io.FileOutputStream; import java.io.IOException; import sun.misc.ProxyGenerator; @SuppressWarnings("restriction") public class ProxyGeneratorUtils { public static void writeProxyClassToHardDisk(String path) { // è·å–ä»£ç†ç±»çš„å­—èŠ‚ç  byte[] classFile = ProxyGenerator.generateProxyClass("$Proxy11", SubjectImpl.class.getInterfaces()); FileOutputStream out = null; try { out = new FileOutputStream(path); out.write(classFile); out.flush(); } catch (Exception e) { e.printStackTrace(); } finally { try { out.close(); } catch (IOException e) { e.printStackTrace(); } } } } æµ‹è¯•æˆ‘ä»¬çš„å·¥å…·ç±»:
package angus.interview.proxy; public class TestProxy { public static void main(String[] args) { System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true"); DynamicProxy proxy = new DynamicProxy(); Subject sproxy = (Subject) proxy.bind(new SubjectImpl()); sproxy.request(); ProxyGeneratorUtils.writeProxyClassToHardDisk("$Proxy11.class"); } } åˆ·æ–°ç›®å½•,å¾—åˆ°ä¸€ä¸ª$Proxy11.class,åç¼–è¯‘ä½¿ç”¨Java Decompiler,GUIå‚»ç“œå¼,æ”¯æŒæœ€æ–°è¯­æ³•,ç¼–è¯‘æ…¢,æ•ˆæœå¥½:
å¯ä»¥çœ‹åˆ° $Proxy11ç»§æ‰¿Proxy,å¹¶å®ç°äº†Subject,åŒæ—¶æˆ‘ä»¬å†™çš„é‚£ä¸ªInvocationHandlerçš„å­ç±»DynamicProxyä¹Ÿè¢«ä¼ é€’è¿›å»äº†.
é‡ç‚¹çœ‹requestæ–¹æ³•çš„ä»£ç ,åªæœ‰ä¸€è¡Œ this.h.invoke(this, m3, null);å…¶ä¸­hçš„å¼•ç”¨å°±æ˜¯DynamicProxy.
m3å°±æ˜¯ m3 = Class.forName("angus.interview.proxy.Subject").getMethod("request", new Class[0]);
import angus.interview.proxy.Subject; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; public final class $Proxy11 extends Proxy implements Subject { private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy11(InvocationHandler paramInvocationHandler) { super(paramInvocationHandler); } public final boolean equals(Object paramObject) { try { return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue(); } catch (Error|RuntimeException localError) { throw localError; } catch (Throwable localThrowable) { throw new UndeclaredThrowableException(localThrowable); } } public final String toString() { try { return (String)this.h.invoke(this, m2, null); } catch (Error|RuntimeException localError) { throw localError; } catch (Throwable localThrowable) { throw new UndeclaredThrowableException(localThrowable); } } public final void request() { try { this.h.invoke(this, m3, null); return; } catch (Error|RuntimeException localError) { throw localError; } catch (Throwable localThrowable) { throw new UndeclaredThrowableException(localThrowable); } } public final int hashCode() { try { return ((Integer)this.h.invoke(this, m0, null)).intValue(); } catch (Error|RuntimeException localError) { throw localError; } catch (Throwable localThrowable) { throw new UndeclaredThrowableException(localThrowable); } } static { try { m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] { Class.forName("java.lang.Object") }); m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]); m3 = Class.forName("angus.interview.proxy.Subject").getMethod("request", new Class[0]); m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]); return; } catch (NoSuchMethodException localNoSuchMethodException) { throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); } catch (ClassNotFoundException localClassNotFoundException) { throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); } } }</content></entry><entry><title>Javaæ³¨è§£å’Œæ³¨è§£å¤„ç†å™¨</title><url>https://zhimoe.github.io/post/java-annotation-processing/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>java</tag><tag>code</tag></tags><content type="html"> æ³¨è§£å¤„ç† æ³¨è§£æ˜¯jdk1.5å‡ºç°çš„,ä½†æ˜¯è‡ªå®šä¹‰å¤„ç†æ³¨è§£çš„åŠŸèƒ½æ˜¯1.6æ‰æœ‰çš„.Elementç­‰å…³äºæ³¨è§£æºç æŠ½è±¡çš„æ”¯æŒç±»éƒ½æ˜¯1.6å‡ºç°çš„.
å…³äºæ³¨è§£çš„å®šä¹‰å°±ä¸è¯´äº†,ä¸»è¦è¯´è¯´æ³¨è§£å¤„ç†
æœ¬æ–‡æ ¹æ®ä»¥ä¸‹èµ„æ–™å¹¶è¿›è¡Œéƒ¨åˆ†ä¿®æ”¹ï¼š
JavaAnnotationProcessing
åŸºæœ¬çŸ¥è¯† annotation processing integrated into javac compiler
â€“ since Java 6.0; known as pluggable annotation processing
â€“ compiler automatically searches for annotation processors
â€“ unless disabled with -proc:none option for javac
â€“ processors can be specified explicitly with -processor option for javac or -cp processor.jar,processor.jar include /META-INF/service/javax.annotation.processing.Processor file and your processor decalared in file;
implement a processor class
â€“ must implement Processor interface
â€“ typically derived from AbstractProcessor
â€“ new package javax.annotation.processing
åŒæ—¶è‡ªå®šä¹‰æ³¨è§£å¤„ç†å™¨éœ€è¦æŒ‡å®šæ³¨è§£é€‰é¡¹ï¼š specify supported annotation + options
â€“ by means of annotations:
@SupportedAnnotationTypes
@SupportedOptions
@SupportedSourceVersion
ç¼–è¯‘å™¨ç¼–è¯‘æºç æ˜¯ä¼šæœ‰å¾ˆå¤šè½®(round)ï¼š
1st roundï¼šç¼–è¯‘å™¨å¾—åˆ°æ‰€æœ‰çš„æ³¨è§£-è·å–æ‰€æœ‰çš„æ³¨è§£å¤„ç†å™¨-è¿›è¡Œmatchå¹¶process,å¦‚æœåŒ¹é…çš„å¤„ç†å™¨ä¸­processæ–¹æ³•çš„è¿”å›å€¼æ˜¯true,è¡¨ç¤ºè¯¥æ³¨è§£è¢« claim,ä¸å†æŸ¥è¯¢å…¶ä»–å¤„ç†å™¨.å¦‚æœæ˜¯false,æ¥ç€æŸ¥è¯¢åŒ¹é…å¤„ç†å™¨å¤„ç†,æ‰€ä»¥æ³¨è§£å¤„ç†å™¨åœ¨META-INF/services/javax.annotation.processing.Processorå£°æ˜é¡ºåºæ˜¯æœ‰å…³ç³»çš„&ndash; æ‰€æœ‰çš„æ³¨è§£éƒ½è¢«claimå,æ³¨è§£å¤„ç†å®Œæˆ.
å¦‚æœæ³¨è§£å¤„ç†å™¨äº§ç”Ÿæ–°çš„javaæ–‡ä»¶,é‚£ä¹ˆæ–°çš„ä¸€è½®å¤„ç†å¼€å§‹,å‰é¢è¢«è°ƒç”¨çš„é‚£äº›å¤„ç†å™¨åˆè¢«è°ƒç”¨,ç›´åˆ°æ²¡æœ‰javaæ–‡ä»¶äº§ç”Ÿ.
æœ€åä¸€è½®åˆè¦è°ƒç”¨ä¸€éæ‰€æœ‰å¤„ç†å™¨,å®Œæˆä»–ä»¬çš„å„è‡ªå·¥ä½œ.
æœ€æœ€å,ç¼–è¯‘å™¨ç¼–è¯‘æºç å’Œæ³¨è§£å¤„ç†å™¨ç”Ÿæˆçš„æºç .
è¿˜æœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„ç±»AbstractProcessorï¼š æœ‰ä¸€ä¸ªå¼•ç”¨processingEnv æä¾›äº†ä¸¤ä¸ªé‡è¦å·¥å…·ç±»ï¼š
â€“ Filer for creation of new source, class, or auxiliary files
â€“ Messager to report errors, warnings, and other notices
æ­¤å¤–,ä¸€ä¸ªäº§ç”Ÿjavaæ–‡ä»¶çš„é‡è¦æ–¹æ³•ï¼š
FileObject sourceFile = processingEnv.getFiler().createSourceFile(beanClassName); process() method takes 2 arguments: Set&lt;? extends TypeElement> annotations â€“ the annotation types requested to be processed â€“ subset of the supported annotations RoundEnvironment roundenv â€“ environment for information about the current and prior round â€“ supplies elements annotated with a given annotation or all root elements in the source ä¸€ä¸ªè‡ªå®šä¹‰çš„æ³¨è§£å¤„ç†å™¨æ ¼å¼å¦‚ä¸‹ï¼š
@SupportedAnnotationTypes({"Property"}) @SupportedSourceVersion(SourceVersion.RELEASE_6) public class PropertyAnnotationProcessor extends AbstractProcessor { public boolean process(Set&lt;? extends TypeElement> annotations, RoundEnvironment env) { // process the source file elements using the mirror API } } jdk1.6 å¯¹æ³¨è§£çš„å¤„ç†æ”¯æŒå»ºç«‹åœ¨å¯¹æºç çš„æŠ½è±¡,Elementæ˜¯javax.lang.model.*ä¸­å®šä¹‰çš„,å„ç§Elementæ˜¯å¯¹æºç æŠ½è±¡æ•°æ®ç»“æ„,å¦‚ï¼š
package com.example; // PackageElement public class Foo { // TypeElement private int a; // VariableElement private Foo other; // VariableElement public Foo () {} // ExecuteableElement } TypeElementä¸èƒ½æä¾›çˆ¶ç±»çš„ä¿¡æ¯,å¦‚æœéœ€è¦è¿™äº›ä¿¡æ¯,éœ€è¦ä»Elementä¸­å¾—åˆ°TypeMirror.TypeMirror::element.asType()
å®ä¾‹ï¼š åŠ¨æ‰‹å†™æ³¨è§£å¤„ç†å™¨ï¼š3ä¸ªç±»,ä¸€ä¸ªå®šä¹‰æ³¨è§£Comparator.java,ä¸€ä¸ªä½¿ç”¨æ³¨è§£çš„ç±»Name.java,ä¸€ä¸ªå¤„ç†æ³¨è§£MyProcessor.java.
æˆ‘å°†å®šä¹‰ä¸€ä¸ªæ³¨è§£@Comparator,ä½¿ç”¨åœ¨æ–¹æ³•ä¸Š,è¢«æ³¨é‡Šçš„æ–¹æ³•èƒ½å¤Ÿè¿”å›ä¸€ä¸ªComparator.
ä¸€ä¸ªæ³¨è§£å¤„ç†å™¨,è§£ææ‰€æœ‰è¢«æ³¨é‡Šçš„æ–¹æ³•,ä¸ºæ¯ä¸€ä¸ªæ–¹æ³•äº§ç”Ÿä¸€ä¸ªComparatorç±».
ï¼ï¼ï¼æ³¨æ„,è¿™é‡Œçš„å†…å®¹å’Œè¿æ¥ä¸­èµ„æ–™çš„å·²ç»ä¸ä¸€æ ·äº†,èµ„æ–™é‡Œç»™çš„processæ–¹æ³•å¹¶ä¸èƒ½äº§ç”Ÿæ¯”è¾ƒå™¨ç±».
ç»™å‡ºæ³¨è§£å®šä¹‰å‰çœ‹çœ‹æ³¨è§£æ€ä¹ˆä½¿ç”¨ï¼š
// ./Name.java // ./ è¡¨ç¤ºå½“å‰å‘½ä»¤è¡Œæ–‡ä»¶å¤¹,åé¢æ‰€æœ‰çš„javcå‘½ä»¤éƒ½ä»¥è¿™ä¸ªæ–‡ä»¶å¤¹ä¸ºå‡† package java.interview.annotation; public class Name { private final String first; private final String last; public Name(String f, String l) { first = f; last = l; } @Comparator("NameByFirstNameComparator") public int compareToByFirstName(Name other) { if (this == other) return 0; int result; if ((result = this.first.compareTo(other.first)) != 0) return result; return this.last.compareTo(other.last); } } å…¶ä¸­è¢«æ³¨è§£æ³¨é‡Šçš„æ–¹æ³•å°†äº§ç”Ÿä¸€ä¸ªNameByFirstNameComparator.javaæ–‡ä»¶ï¼š
// ./angus/initerview/annotation/NameByFirstNameComparator.java public class NameByFirstNameComparator implements java.util.Comparator&lt;Name> { public int compare(Name o1, Name o2) { return o1.compareToByFirstName(o2); } public boolean equals(Object other) { return this.getClass() == other.getClass(); } } æˆ‘ä»¬å®šä¹‰æ³¨è§£ï¼š
// ./Comparator.java package angus.interview.annotation; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Documented @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Comparator { String value(); } æ¥ä¸‹æ¥å®šä¹‰æˆ‘ä»¬çš„æ³¨è§£å¤„ç†å™¨,æœ‰è¯¦ç»†æ³¨è§£,ç‰¹åˆ«æ³¨æ„generateæºç ä¸­çš„ç©ºæ ¼å’Œåˆ†å·ä¸è¦å¼„ä¸¢äº†ï¼š
package angus.interview.annotation; import java.io.IOException; import java.io.PrintWriter; import java.util.Set; import javax.annotation.processing.AbstractProcessor; import javax.annotation.processing.RoundEnvironment; import javax.annotation.processing.SupportedAnnotationTypes; import javax.annotation.processing.SupportedSourceVersion; import javax.lang.model.SourceVersion; import javax.lang.model.element.Element; import javax.lang.model.element.ExecutableElement; import javax.lang.model.element.TypeElement; import javax.lang.model.type.PrimitiveType; import javax.lang.model.type.TypeKind; import javax.lang.model.type.TypeMirror; import javax.tools.Diagnostic; import javax.tools.FileObject; @SupportedAnnotationTypes({ "angus.interview.annotation.Comparator" }) @SupportedSourceVersion(SourceVersion.RELEASE_8) public class MyProcessor extends AbstractProcessor { @Override public boolean process(Set&lt;? extends TypeElement> annotations, RoundEnvironment roundEnv) { for( final Element element: roundEnv.getElementsAnnotatedWith( Comparator.class ) ) { if(element instanceof ExecutableElement){ ExecutableElement m = (ExecutableElement) element; TypeElement className = (TypeElement)m.getEnclosingElement(); Comparator a = m.getAnnotation(Comparator.class); if (a != null) { TypeMirror returnType = m.getReturnType(); if (!(returnType instanceof PrimitiveType) || ((PrimitiveType) returnType).getKind() != TypeKind.INT) { processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "@Comparator can only be applied to methods that return int"); continue; } // prepare for java file generation // t m a mean ? String comparatorClassName = a.value(); String comparetoMethodName = m.getSimpleName().toString(); String theProcessedClassesName = className.getQualifiedName().toString(); try { writeComparatorFile(theProcessedClassesName, comparatorClassName, comparetoMethodName); } catch (IOException e) { e.printStackTrace(); } } } } return true;// claimed now,no need next processor } /* * * public class NameByFirstNameComparator implements java.util.Comparator&lt;Name> { * public int compare(Name o1, Nameo2) { return o1.compareToByFirstName(o2); } * * public boolean equals(Object other) { return this.getClass() == other.getClass(); } } */ //!!!careful with spaces and ";"!!! private void writeComparatorFile(String fullClassName, String comparatorClassName, String compareToMethodName) throws IOException { int i = fullClassName.lastIndexOf("."); String packageName = fullClassName.substring(0, i); FileObject sourceFile = processingEnv.getFiler().createSourceFile(packageName + "." + comparatorClassName); if (sourceFile == null) { System.out.println("create source file failed"); } PrintWriter out = new PrintWriter(sourceFile.openWriter()); if (i > 0) { out.println("package " + packageName + ";"); } String parametrizedType = fullClassName.substring(i + 1);//!! out.println( "public class " + comparatorClassName + " implements java.util.Comparator&lt;" + parametrizedType + "> {"); out.println(); out.println("public int compare( " + parametrizedType + " o1 , " + parametrizedType + " o2 ){"); out.println("return o1." + compareToMethodName + "(o2);"); out.println("}"); out.println(); out.println(); out.println("public boolean equals(Object other) {"); out.println("return this.getClass() == other.getClass();"); out.println("}"); out.println("}"); out.close(); } } æµ‹è¯•å¤„ç†å™¨ ä¸¤ç§æ–¹æ³•,
ä¸€ç§æ˜¯ä½¿ç”¨ -cpï¼š
åœ¨é¡¹ç›®çš„æ ¹ç›®å½•ä¸­ï¼ˆpom.xmlåŒçº§ç›®å½•ï¼‰æ–°å»ºMETA-INFæ–‡ä»¶å¤¹,å¹¶åœ¨é‡Œé¢æ–°å»ºservicesæ–‡ä»¶å¤¹,å†åœ¨é‡Œé¢æ–°å»ºä¸€ä¸ªæ–‡ä»¶ javax.annotation.processing.Processor,å¹¶åœ¨è¯¥æ–‡ä»¶ä¸­æ³¨å†Œæˆ‘ä»¬çš„å¤„ç†å™¨,ç¬¬ä¸€è¡Œå†™å…¥ï¼šangus.interview.annotation.MyProcessor.
ç„¶åç”¨eclipseå°†é¡¹ç›®exportå¾—åˆ°ä¸€ä¸ªjaråŒ…,jarå¿…é¡»åŒ…å«targetæ–‡ä»¶å¤¹ï¼ˆå¤„ç†å™¨classæ–‡ä»¶ï¼‰å’ŒMETA-INFæ–‡ä»¶å¤¹ï¼ˆæ³¨å†Œå¤„ç†å™¨ï¼‰.è¿™é‡Œå°†jaråŒ…å‘½åä¸ºprocess.jar. å¤åˆ¶jaråŒ…åˆ°Name.javaç›®å½•ä¸­,å¹¶åœ¨è¯¥ç›®å½•æ‰“å¼€ç»ˆç«¯,è¾“å…¥ï¼š
javac -cp process.jar Name.java
å°†ä¼šå¾—åˆ°Name.classæ–‡ä»¶å’Œä¸€ä¸ªangusæ–‡ä»¶å¤¹,æœ€é‡Œé¢æ˜¯NameByFirstNameComparator.javaå’ŒNameByFirstNameComparator.class.
æ‰“å¼€NameByFirstNameComparator.java,å‘ç°å†…å®¹å’Œä¸Šé¢ç»™å‡ºçš„ä¸€æ¨¡ä¸€æ ·.
ç¬¬äºŒç§æ–¹æ³•æ˜¯ä½¿ç”¨-processorå‚æ•°,ä½†æ˜¯è¿˜æ²¡ææ‡‚MyProcessor.classåº”è¯¥æ”¾åœ¨å“ªé‡Œ.æš‚æ—¶å…ˆåˆ°è¿™.</content></entry><entry><title>å•ä¾‹æ¨¡å¼å’Œåºåˆ—åŒ–</title><url>https://zhimoe.github.io/post/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>java</tag><tag>code</tag></tags><content type="html"> Javaå•ä¾‹æ¨¡å¼çš„å„ç§å†™æ³•å’Œåºåˆ—åŒ–
å‚è€ƒèµ„æ–™
é¥±æ±‰å¼ public class Singleton { private static Singleton instance = null private Singleton (){} public static Singleton getInstance() { if(instance == null) instance = new Singleton(); return instance; } } //é¥±æ±‰å¼,ä½¿ç”¨æ—¶åˆ›å»º é¥¿æ±‰å¼ //åŠ è½½æ—¶åˆ›å»ºå¯¹è±¡ static public class Singleton { private Singleton instance = null; static { instance = new Singleton(); } private Singleton (){} public static Singleton getInstance() { return this.instance; } } é™æ€å†…éƒ¨ç±» public class Singleton { private Singleton (){} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } //è¿™ä¸ªæ¯”è¾ƒå¥½,çº¿ç¨‹å®‰å…¨,ä¹Ÿè¾¾åˆ°äº†å»¶è¿ŸåŠ è½½æ•ˆæœ. æšä¸¾ç±» //è¿™ä¸ªæ˜¯æœ€å¥½çš„ è¿™ç§æ–¹å¼æ˜¯Effective Javaä½œè€…Josh Bloch æå€¡çš„æ–¹å¼,å®ƒä¸ä»…èƒ½é¿å…å¤šçº¿ç¨‹åŒæ­¥é—®é¢˜,è€Œä¸”è¿˜èƒ½é˜²æ­¢ååºåˆ—åŒ–é‡æ–°åˆ›å»ºæ–°çš„å¯¹è±¡,å¯è°“æ˜¯å¾ˆåšå¼ºçš„å£å’å•Š public enum Singleton { INSTANCE; public void whateverMethod() { } } è®¿é—®è¿™ä¸ªå•ä¾‹ Singleton.INSTANCE åŒé‡æ ¡éªŒé” å…¶å®æ˜¯ä¸å®‰å…¨çš„,å¤šçº¿ç¨‹å¼€é”€å¾ˆå¤§,ç”šè‡³æ­»é”.åŸå› åœ¨äºæŒ‡ä»¤é‡æ’åº.
public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } åºåˆ—åŒ– ä½¿ç”¨é™æ€å†…éƒ¨ç±»ä¸¾ä¾‹,åªè¦æä¾›ä¸€ä¸ªreadResolveæ–¹æ³•
public class Singleton { private Singleton (){} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } private Object readResolve() throws ObjectStreamException{ return SingletonHolder.INSTANCE; } } æ— è®ºæ˜¯å®ç°Serializableæ¥å£,æˆ–æ˜¯Externalizableæ¥å£,å½“ä»I/Oæµä¸­è¯»å–å¯¹è±¡æ—¶,readResolve()æ–¹æ³•éƒ½ä¼šè¢«è°ƒç”¨åˆ°.å®é™…ä¸Šå°±æ˜¯ç”¨readResolve()ä¸­è¿”å›çš„å¯¹è±¡ç›´æ¥æ›¿æ¢åœ¨ååºåˆ—åŒ–è¿‡ç¨‹ä¸­åˆ›å»ºçš„å¯¹è±¡,è€Œè¢«åˆ›å»ºçš„å¯¹è±¡åˆ™ä¼šè¢«åƒåœ¾å›æ”¶æ‰.</content></entry><entry><title>ç†è§£Gradle buildè„šæœ¬ç»“æ„ä¸è¯­æ³•</title><url>https://zhimoe.github.io/post/understanding-gradle-buildscript/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>groovy</tag><tag>gradle</tag></tags><content type="html"> åœ¨çœ‹è¿™ä¸ªä¹‹å‰,å¸Œæœ›ä½ æœ‰ç”¨antæˆ–è€…mavençš„ä½¿ç”¨ç»éªŒ,è¿˜æœ‰,å¯¹groovyçš„è¯­æ³•æœ‰ä¸€ä¸ªç®€å•çš„äº†è§£,ä¸æ‡‚ä¹Ÿæ²¡å…³ç³»,ä¸‹é¢ä¼šä»‹ç».
ç†è§£gradleæ–‡ä»¶çš„å‰ææ˜¯ç†è§£ä¸€ä¸ªé‡è¦çš„groovyæ¦‚å¿µ:closure
closure ä¸€ä¸ªclosureæ˜¯ä¸€ä¸ªå®šä¹‰åœ¨groovyæ–‡ä»¶ä¸­çš„{}ä»£ç å—,è¿™ä¸ªä»£ç å—ç±»ä¼¼jsä¸­çš„åŒ¿åå‡½æ•°,å®ƒå¯ä»¥è¢«èµ‹å€¼ç»™å˜é‡,å¯ä»¥è¢«è°ƒç”¨,å¯ä»¥æ¥æ”¶å‚æ•°,è¿˜å¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’ç»™åˆ«çš„å‡½æ•°.
closureä¸­æœ€é‡è¦çš„ä¸¤ä¸ªæ¦‚å¿µæ˜¯å§”æ‰˜å¯¹è±¡å’Œä½œä¸ºå‚æ•°ä¼ é€’çš„è¯­æ³•æ ¼å¼ï¼ˆç†è§£gradleæ–‡ä»¶å¾ˆé‡è¦ï¼‰.
groovyæ–¹æ³•è°ƒç”¨æ‹¬å·çš„çœç•¥ groovyæä¾›éå¸¸ä¼˜é›…çš„æ–¹æ³•è°ƒç”¨æ ¼å¼,æ€»ç»“èµ·æ¥æ˜¯:
//å¯ä»¥çœç•¥å‚æ•°æ‹¬å·,å¹¶ä¸”é“¾å¼è°ƒç”¨ // equivalent to: turn(left).then(right) turn left then right //groovyæ•°å­—å¯ä»¥ç›´æ¥è½¬æ¢æˆå­—ç¬¦ä¸² // equivalent to: take(2.pills).of(chloroquinine).after(6.hours) take 2.pills of chloroquinine after 6.hours //ä¸¤ä¸ªå‚æ•°ç”¨é€—å·éš”å¼€ // equivalent to: paint(wall).with(red, green).and(yellow) paint wall with red, green and yellow //å‘½åå‚æ•°ç”¨å†’å· // with named parameters too // equivalent to: check(that: margarita).tastes(good) check that: margarita tastes good //é—­åŒ…ä½œä¸ºå‚æ•°ä¹Ÿå¯ä»¥çœç•¥æ‹¬å· // with closures as parameters // equivalent to: given({}).when({}).then({}) given { } when { } then { } //æ²¡æœ‰å‚æ•°çš„æ–¹æ³•å¿…é¡»æœ‰æ‹¬å· // equivalent to: select(all).unique().from(names) select all unique() from names //å¦‚æœè°ƒç”¨é“¾å…ƒç´ ä¸ºå¥‡æ•°,é‚£ä¹ˆæœ€åä¸€ä¸ªå…ƒç´ æ˜¯å‰é¢æ–¹æ³•é“¾è¿”å›å¯¹è±¡çš„å±æ€§ //cookies æ˜¯take(3)è¿”å›å€¼çš„ä¸€ä¸ªå±æ€§ // equivalent to: take(3).cookies // and also this: take(3).getCookies() take 3 cookies ä¸Šé¢è°ƒç”¨çš„æ ¼å¼æ˜¯dslçš„åŸºç¡€.ä¹Ÿæ˜¯çœ‹æ‡‚gradleæ–‡ä»¶æ ¼å¼çš„åŸºç¡€.
è®©æˆ‘ä»¬å†æ·±å…¥ä¸€ç‚¹,ä¸Šé¢è®²çš„æ˜¯è°ƒç”¨æ ¼å¼,é‚£ä¹ˆæ€ä¹ˆåˆ›å»ºè¿™ç§å¯ä»¥é“¾å¼è°ƒç”¨çš„æ–¹æ³•å‘¢ï¼Ÿ
groovyå’Œscalaçš„æ–¹æ³•è¿”å›å€¼ä¸éœ€è¦return,æœ€åä¸€è¡Œå°±æ˜¯è¿”å›å€¼. closureæ˜¯ä¸€ä¸ªåŒ¿åå‡½æ•°,æ ¼å¼{ [closureParameters -> ] statements },é»˜è®¤è‡ªå¸¦ä¸€ä¸ªåä¸ºitçš„å‚æ•°,æ‰€ä»¥åªæ¥å—ä¸€ä¸ªå‚æ•°æ—¶å¯ä»¥çœç•¥->. closureå¯ä»¥è®¿é—®scopeï¼ˆä½œç”¨åŸŸï¼‰å†…ä»»ä½•å˜é‡.å¹¶ä¸”è¿™ä¸ªscopeæ˜¯å¯ä»¥é€šè¿‡å§”æ‰˜æ¥æ”¹å˜çš„. groovyä¸­Mapå¯¹è±¡çš„valueå¦‚æœæ˜¯closure,é‚£ä¹ˆå¯ä»¥æ¥ç€è°ƒç”¨:mapp.keyy({closure}) æœ‰äº†ä¸Šé¢çš„åŸºç¡€,æˆ‘ä»¬çœ‹ä¸€ä¸ªç®€å•çš„ä¾‹å­: //å°†closureèµ‹å€¼ç»™ä¸€ä¸ªå˜é‡,è¿™ä¸ªclosureæ¥æ”¶ä¸€ä¸ªå‚æ•°,å‚æ•°åæ˜¯é»˜è®¤çš„,it show = { println it } square_root = { Math.sqrt(it) } //ä¸ºäº†å®¹æ˜“ç†è§£,æˆ‘å°†å‚æ•°çš„typeéƒ½æ·»åŠ ä¸Šäº†, //pleaseæ–¹æ³•éœ€è¦ä¸€ä¸ªclosure,æ¥ç€è¿”å›ä¸€ä¸ªmap,mapçš„keyæ˜¯the,valueæ˜¯ä¸€ä¸ªclosure, //è¿™ä¸ªclosureæ¥æ”¶ä¸€ä¸ªclosure,å¹¶è¿”å›ä¸€ä¸ªmap,è¿™ä¸ªmapçš„ofçš„valueåˆæ˜¯ä¸€ä¸ªclosure(ä¸è¦æ™•äº†) //æœ€åä¸€ä¸ªclosureæ¥æ”¶ä¸€ä¸ªå‚æ•°n. def please(Closure action) { [the: { Closure what -> [of: { n -> action(what(n)) }] }] } //è°ƒç”¨: // ç­‰ä»·: please(show).the(square_root).of(100) please show the square_root of 100 // ==> 10.0 æ€»ç»“ä¸€ä¸‹å°±æ˜¯,å°†ä½ éœ€è¦çš„æ“ä½œå°è£…æˆä¸€ä¸ªclosure,ç»™ä¸€ä¸ªç›´è§‚çš„å‘½å,ä¿è¯æ•´ä¸ªDSLè°ƒç”¨è¯­å¥æœ‰è¯­ä¹‰,å®šä¹‰è¿”å›ä¸€ä¸ªmapçš„å‡½æ•°ä½œä¸ºå…¥å£,mapçš„keyæ˜¯æ–¹æ³•å,valueæ˜¯closure,è¿™æ ·å¯ä»¥åœ¨keyåé¢ä¼ é€’ä¸€ä¸ªclosureæ¥ç€è°ƒç”¨è¿™ä¸ªvalue.
å§”æ‰˜å¯¹è±¡ gradleè„šæœ¬æ˜¯ä¸€ä¸ªé…ç½®è„šæœ¬,ç±»ä¼¼mavenä¸­pom.xmlæ–‡ä»¶,ä¸è¿‡gradleè„šæœ¬æ›´ä¸ºå¼ºå¤§,å› ä¸º.gradleæ–‡ä»¶å°±æ˜¯groovyæ–‡ä»¶,æ‰€ä»¥è¿˜å¯ä»¥åœ¨è„šæœ¬é‡Œé¢ç›´æ¥å®šä¹‰groovyå¯¹è±¡è®©è„šæœ¬ä½¿ç”¨.
å§”æ‰˜å¯¹è±¡å°±æ˜¯ä¸€ä¸ªgroovyå¯¹è±¡,ç”¨æ¥æ‰§è¡Œgradleæ„å»ºè„šæœ¬ä¸­çš„closure.
as a build script executes, it configures an object of type Project. This object is called the delegate object of the script. The following table shows the delegate for each type of Gradle script. ä¸‰ç§ä¸åŒçš„gradleè„šæœ¬å¯¹åº”çš„å§”æ‰˜å¯¹è±¡ Build scriptï¼ˆbuild.gradleï¼‰ ->Project Init script ->Gradle Settings script(setting.gradle) ->Settings æ„å»ºä¸­çš„æ¯ä¸€ä¸ªproject,Gradleéƒ½ä¼šåˆ›å»ºä¸€ä¸ªProjectå¯¹è±¡,å¹¶å°†è¿™ä¸ªå¯¹è±¡ä¸æ„å»ºè„šæœ¬ç›¸å…³è”.
Projectå¯¹è±¡ä¸build.gradleæ˜¯ä¸€å¯¹ä¸€çš„å…³ç³».
Gradleçš„è„šæœ¬æ˜¯é…ç½®è„šæœ¬,å½“è„šæœ¬æ‰§è¡Œæ—¶,å®ƒæ˜¯åœ¨é…ç½®æŸä¸€ä¸ªç‰¹æ®Šç±»å‹çš„å¯¹è±¡.æ¯”å¦‚ä¸€ä¸ªæ„å»ºè„šæœ¬çš„æ‰§è¡Œ,å®ƒå°±æ˜¯åœ¨é…ç½®ä¸€ä¸ªProjectç±»å‹çš„å¯¹è±¡.è¿™ä¸ªå¯¹è±¡å«åšè„šæœ¬çš„ä»£ç†å¯¹è±¡.
å§”æ‰˜æœ‰ä¸ªé‡è¦çš„æ¦‚å¿µå°±æ˜¯scope,æŒ‡closureçš„å˜é‡å¼•ç”¨èŒƒå›´:æœ‰æ—¶å˜é‡ä¸åœ¨å½“å‰scopeä¸­,ä½†æ˜¯å¯ä»¥é€šè¿‡å§”æ‰˜,æ”¹å˜closureçš„å§”æ‰˜å¯¹è±¡,è¿™æ ·å°±æ‹¥æœ‰äº†å§”æ‰˜è€…çš„scope,ä»è€Œå¯ä»¥åœ¨closureä¸­ä½¿ç”¨å§”æ‰˜è€…çš„å˜é‡.
å…³äºgroovy closure çš„å§”æ‰˜æœ‰ä¸‰ä¸ªé‡è¦å±æ€§
â€¢ this: refers to the instance of the class that the closure was defined in. â€¢ owner: is the same as this, unless the closure was defined inside another closure in which case the owner refers to the outer closure. â€¢ delegate: is the same as owner. But, it is the only one that can be programmatically changed, and it is the one that makes Groovy closures really powerful. the closure itself will be checked first, followed by the closure's this scope, then the closure's owner, then its delegate. However, Groovy is so flexible this strategy can be changed. Every closure has a property called resolvedStrategy. This can be set to: â€¢ Closure.OWNER_FIRST â€¢ Closure.DELEGATE_FIRST â€¢ Closure.OWNER_ONLY â€¢ Closure.DELEGATE_ONLY æ¥è‡ª &lt;https://dzone.com/articles/groovy-closures-owner-delegate> gradleæ˜¯dslè§£æå·¥å…·,æ˜¯å¯¹groovyè¯­æ³•çš„æ‰©å±•,build.gradleå¯ä»¥ç†è§£ä¸ºå°±æ˜¯ä¸€ä¸ª.groovyæ–‡ä»¶,gradleä¼šè§£æè¿™ä¸ªæ–‡ä»¶,å‘ç°é‡Œé¢çš„closure,å¹¶å°†è¿™äº›closureå§”æ‰˜ç»™ä¸€ä¸ªå¯¹è±¡å»æ‰§è¡Œ.
gradleå°†groovyçš„å§”æ‰˜æœºåˆ¶å‘æŒ¥åˆ°æè‡´,è¦ç†è§£gradleå†…éƒ¨,å°±è¦ç†è§£closureçš„å§”æ‰˜ï¼
closureä½œä¸ºå‚æ•°ä¼ é€’ å°†closureä½œä¸ºå‚æ•°ä¼ é€’çš„æ–¹æ³•æœ‰å¤šç§:
//method accepts 1 parameter - closure myMethod(myClosure) //if method accepts only 1 parameter - parentheses can be omitted myMethod myClosure //I can create in-line closure myMethod {println 'Hello World'} //method accepts 2 parameters myMethod(arg1, myClosure) //or the same as '4', but closure is in-line myMethod(arg1, { println 'Hello World' }) //if last parameter is closure - it can be moved out of parentheses myMethod(arg1) { println 'Hello World' } æ³¨æ„ç¬¬ä¸‰ç§å’Œæœ€åä¸€ç§è°ƒç”¨æ–¹å¼,æ˜¯ä¸æ˜¯å’Œgradleæ–‡ä»¶ä¸­å¾ˆçœ¼ç†Ÿï¼Ÿåªä¸è¿‡åœ¨gradleè„šæœ¬ä¸­å‡ºç°çš„closureæ›´åŠ å¤æ‚,å› ä¸ºæœ‰closureåµŒå¥—ï¼ï¼ï¼ä½†æ˜¯ä¸‡å˜ä¸ç¦»å…¶å®—.ä¸‹é¢æˆ‘ä»¬ä¼šä»‹ç»åµŒå¥—ä¸è¿‡æ˜¯å§”æ‰˜é“¾çš„è¡¨ç°.
çœ‹ä¸€ä¸ªè„šæœ¬ä»£ç :
buildscript { repositories { jcenter() } dependencies { classpath 'com.android.tools.build:gradle:1.2.3' } } buildscriptæ˜¯ä¸€ä¸ªæ–¹æ³•,æ¥æ”¶ä¸€ä¸ªclosure.è‡³äºè¿™ä¸ªæ–¹æ³•åœ¨å“ª,å¯ä»¥å®šä¹‰åœ¨ä»»ä½•åœ°æ–¹,ä½†æ˜¯å¯ä»¥è‚¯å®šçš„æ˜¯,è¿™ä¸ªæ–¹æ³•ä¸€å®šèƒ½å¤Ÿè¢«Projectå¯¹è±¡è°ƒç”¨.
å› ä¸ºbuild.gradleè„šæœ¬å°±æ˜¯å§”æ‰˜ç»™Projectå¯¹è±¡æ‰§è¡Œçš„.äº‹å®ä¸Š,Projectå¯¹è±¡ä¹Ÿä¸æ˜¯äº²è‡ªæ‰§è¡Œè¿™ä¸ªæ–¹æ³•,è€Œæ˜¯å§”æ‰˜ç»™ScriptHandleræ‰§è¡Œ.
è¿™é‡Œ,æˆ‘ä»¬ScriptHandlerå¯¹è±¡ä¼šæœç´¢åˆ°ä¸¤ä¸ªé…ç½®closure:repositorieså’Œdependencies.æˆ‘ä»¬å¯ä»¥åœ¨ScriptHandler apiä¸­æœç´¢åˆ°è¿™ä¸¤ä¸ªæ–¹æ³•.ä»apiä¸­æˆ‘ä»¬åˆå‘ç°:
ä¼ é€’ç»™dependenciesçš„closureåˆè¢«å§”æ‰˜ç»™äº†DependencyHandlerå¯¹è±¡&hellip;&hellip;. è¿™å°±æ˜¯å§”æ‰˜é“¾.
ScriptHandler api
Project api
æ³¨æ„:è¿™é‡Œbuildscript {&hellip;}æ•´ä½“ç§°ä¸ºä¸€ä¸ª script block. è„šæœ¬å—å°±æ˜¯ä¸€ä¸ªæ¥å—closureå‚æ•°çš„æ–¹æ³•è°ƒç”¨.è¿˜æœ‰çš„æ–¹æ³•æ˜¯ä¸æ¥å—closureçš„,é‚£äº›ç§°ä¸ºstatementï¼ˆçœ‹ä¸‹é¢è§£é‡Šï¼‰.
A script block is a method call which takes a closure as a parameter
æ’ä»¶ å…ˆçœ‹çœ‹æ„å»ºè„šæœ¬çš„æ„æˆ:
A build script is made up of zero or more statements and script blocks. Statements can include method calls, property assignments, and local variable definitions. A script block is a method call which takes a closure as a parameter. The closure is treated as a configuration closure which configures some delegate object as it executes.
å°±æ˜¯è¯´è„šæœ¬æœ‰ä¸¤ç§å†…å®¹:script blockå’Œstatement.
Projectæ¥å£é¢„å…ˆå®šä¹‰äº†å‡ ä¸ªblock:
allprojects { } Configures this project and each of its sub-projects. artifacts { } Configures the published artifacts for this project. buildscript { } Configures the build script classpath for this project. configurations { } Configures the dependency configurations for this project. dependencies { } Configures the dependencies for this project. repositories { } Configures the repositories for this project. sourceSets { } Configures the source sets of this project. subprojects { } Configures the sub-projects of this project. publishing { } Configures the PublishingExtension added by the publishing plugin. è¿™äº›closureå‚æ•°åŸºæœ¬éƒ½æ˜¯å§”æ‰˜ç»™å…¶ä»–å¯¹è±¡æ‰§è¡Œçš„.
å¯ä»¥çœ‹åˆ°,Projectå¯¹è±¡çš„æ–¹æ³•æ˜¯æœ‰é™è€Œä¸”é€šç”¨çš„.çœŸæ­£æœ‰ç”¨çš„æ˜¯æ’ä»¶,gradleçš„å¾ˆå¤šåŠŸèƒ½ä¹Ÿæ˜¯é€šè¿‡å®˜æ–¹å†™çš„æ’ä»¶æä¾›çš„.
å¦‚æœä½ çœ‹åˆ°ä¸€ä¸ªé¡¶çº§å±‚çš„something { ... }block,ä½†æ˜¯åœ¨Projectæºç ä¸­æ²¡æœ‰æ‰¾åˆ°something blockçš„ä»»ä½•ä¿¡æ¯.é‚£ä¹ˆè¿™ä¸ªæ–¹æ³•å°±æ˜¯é€šè¿‡æ’ä»¶æä¾›çš„.gradleè‡ªå¸¦å¾ˆå¤šæ’ä»¶,åƒjava,eclipse,groovy,androidç­‰.
çœ‹ä¸€ä¸ªå®é™…çš„ä¾‹å­:
åœ¨androidå¼€å‘ä¸­çš„æ„å»ºè„šæœ¬:
apply plugin: 'com.android.application' android { compileSdkVersion 22 buildToolsVersion "22.0.1" defaultConfig { applicationId "com.trickyandroid.testapp" minSdkVersion 16 targetSdkVersion 22 versionCode 1 versionName "1.0" } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } } è¿™é‡Œ,å‡ºç°äº†android{},Projectå¯¹è±¡å¹¶æ²¡æœ‰è¿™ä¸ªscript block.æ‰€ä»¥,è¿™å…¶å®æ˜¯ç”±æ’ä»¶æä¾›çš„block.æˆ‘ä»¬æ‰¾åˆ°com.android.applicationå…¥å£ä»£ç 
extension = project.extensions.create('android', AppExtension, this, (ProjectInternal) project, instantiator, buildTypeContainer, productFlavorContainer, signingConfigContainer) setDefaultConfig(extension.defaultConfig, extension.sourceSetsContainer) extensionsæ˜¯ä¸€ä¸ªExtensionContainerå®ä¾‹,å…¶ä¸­create API:
&lt;T> T create(String name, Class&lt;T> type, Object... constructionArguments)
è¿™é‡Œå°±åˆ›å»ºäº†ä¸€ä¸ªandroidå±æ€§,æ˜¯ä¸€ä¸ªAppExtensionå¯¹è±¡,æˆ‘ä»¬åœ¨è„šæœ¬ä¸­æä¾›ç»™android blockçš„{}å…¶å®æ˜¯é…ç½®äº†ä¸€ä¸ªAppExtensionå¯¹è±¡.æˆ‘ä»¬å¯ä»¥åœ¨AppExtensionä¸­æ‰¾åˆ°compileSdkVersionç­‰å±æ€§.
æ‰€ä»¥,æ’ä»¶æ‰©å±•çš„Projectå¯¹è±¡,æä¾›äº†å¾ˆå¤šæ–¹æ³•,è¿™æ ·,å¯ä»¥åœ¨è„šæœ¬ä¸­ä½¿ç”¨æ’ä»¶å®šä¹‰çš„æ–¹æ³•ï¼ˆscript blockï¼‰äº†.
ä¸€ä¸ªæ’ä»¶å°±æ˜¯å®ç°å®ç°äº†org.gradle.api.Pluginæ¥å£çš„groovyç±».
æˆ‘ä»¬çœ‹æ€ä¹ˆå†™ä¸€ä¸ªæ’ä»¶:
//build.gradle apply plugin: GreetingPlugin //è¿™é‡Œæä¾›closure æ¥é…ç½®æ’ä»¶æä¾›çš„greeting script block greeting { message = 'Hi' greeter = 'Gradle' } class GreetingPlugin implements Plugin&lt;Project> { void apply(Project project) {//æ³¨æ„æˆ‘ä»¬æ˜¯å¦‚æœæ‰©å±•Projectå¯¹è±¡çš„,é€šè¿‡extensionså¯¹è±¡åˆ›å»ºä¸€ä¸ªscript block:greeting,è€Œè¿™ä¸ªblockå…³è”çš„æ˜¯ä¸€ä¸ªå¯¹è±¡ project.extensions.create("greeting", GreetingPluginExtension) project.task('hello') &lt;&lt; { //æ³¨æ„æˆ‘ä»¬æ˜¯å¦‚ä½•ä½¿ç”¨greetingçš„,æ²¡æœ‰é€šè¿‡extensioins println "${project.greeting.message} from ${project.greeting.greeter}" } } } class GreetingPluginExtension { String message String greeter } /* project.task('hello') &lt;&lt; { println "${project.greeting.message} from ${project.greeting.greeter}" } ä½¿ç”¨äº†é‡è½½æ“ä½œç¬¦,ç­‰ä»·: project.task('hello').leftShift({ println "${project.greeting.message} from ${project.greeting.greeter}" }) */ å®˜æ–¹æ–‡æ¡£:å¦‚ä½•è‡ªå·±å†™ä¸€ä¸ªæ’ä»¶
#####å‚è€ƒ:
gradle-tip-2
Gradleæ·±å…¥ä¸å®æˆ˜ï¼ˆå…­ï¼‰Gradleçš„èƒŒåæ˜¯ä»€ä¹ˆï¼Ÿ
DSLè¯­æ³• gradleä½¿ç”¨çš„åŸºäºgroovyä¸­çš„DSLè¯­æ³•,æ‰€è°“çš„dsl,å°±æ˜¯åŸºäºgroovyå‘æ˜çš„æ–°çš„â€œç¼–ç¨‹è¯­è¨€â€,gradle dslæ˜¯groovyçš„è¶…é›†,å°±æ˜¯ä½ å¯ä»¥å®Œå…¨ä½¿ç”¨groovyçš„è¯­æ³•,ä½†æ˜¯ä½ è¿˜æ˜¯ä¼šçœ‹åˆ°å¾ˆå¤šä¸æ˜¯groovyè¯­æ³•,è¿™æ—¶ä¸è¦å›°æƒ‘,è¿™äº›è¯­æ³•ä¸è¿‡æ˜¯gradleåˆ©ç”¨groovyæä¾›çš„å…ƒç¼–ç¨‹èƒ½åŠ›æä¾›çš„æ–°è¯­æ³•.
ä»¥æ–°å»ºtaskçš„è¯­æ³•ä¸ºä¾‹,åœ¨Project APIä¸­æœ‰å››ä¸ªé‡è½½å½¢å¼:
Task task(String name, Closure configureClosure); Task task(Map&lt;String, ?> args, String name, Closure configureClosure); Task task(Map&lt;String, ?> args, String name) throws InvalidUserDataException; Task task(String name) throws InvalidUserDataException; ä½†æ˜¯ä½ ä¼šçœ‹åˆ°è¿™æ ·çš„è°ƒç”¨æ–¹å¼:
task intro(dependsOn: hello) { doLast { println "I'm Gradle" } } è¿™æ˜¯dsl,å…·ä½“çš„è§£ææ–¹å¼åœ¨TaskDefinitionScriptTransformer
å…·ä½“è§æˆ‘åœ¨sfçš„æé—®gradle task method syntax in build.gradle
more tips gradle-tips</content></entry><entry><title>é¢è¯•é¢˜-ç±»åŠ è½½è¿‡ç¨‹å’Œå­ç±»é‡å†™çˆ¶ç±»æ–¹æ³•çš„è°ƒç”¨</title><url>https://zhimoe.github.io/post/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%92%8C%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>java</tag><tag>code</tag></tags><content type="html"> æœ€è¿‘éå¸¸ç«çš„ä¸€é“æºç¨‹é¢è¯•é¢˜Java
public class Base { private String baseName = "base"; public Base() { callName(); } public void callName() { System.out.println(baseName); } static class Sub extends Base { private String baseName = "sub"; public void callName() { System.out.println(baseName); } } public static void main(String[] args) { Base b = new Sub(); // è¾“å‡ºï¼Ÿ } } æˆ‘çš„ç†è§£ï¼š
å…ˆç†è§£ä¸¤ä¸ªæ–¹æ³•:
class çš„(clinit)æ–¹æ³•å’Œ(init)æ–¹æ³•ä¸åŒï¼šè¿™ä¸¤ä¸ªæ–¹æ³•ä¸€ä¸ªæ˜¯è™šæ‹Ÿæœºåœ¨è£…è½½ä¸€ä¸ªç±»åˆå§‹åŒ–çš„æ—¶å€™è°ƒç”¨çš„ï¼ˆ&lt;clinit>ï¼‰.å¦ä¸€ä¸ªæ˜¯åœ¨ç±»å®ä¾‹åŒ–æ—¶è°ƒç”¨çš„ï¼ˆ&lt;init>ï¼‰.
åœ¨åŠ è½½ç±»æ—¶éœ€è¦ç±»çš„åˆå§‹åŒ–,JVMå¯¹åº”çš„å­—èŠ‚ç æ–¹æ³•æ˜¯&lt;clinit>,è¿™ä¸ªæ–¹æ³•ä¼šåˆå§‹åŒ–staticå˜é‡å’Œæ‰§è¡Œstatic{}ä»£ç å—,æŒ‰æºç å®šä¹‰çš„é¡ºåºæ‰§è¡Œ.æ³¨æ„ï¼šå¦‚æœstatic{}ä»£ç å—ä¸­å¼•ç”¨äº†static å˜é‡,é‚£ä¹ˆä¸€å®šè¦ä½¿ç”¨ä¹‹å‰å®šä¹‰staticå˜é‡.ideä¼šæç¤ºçš„.
è¿™æ—¶,classçš„å…¶ä»–æˆå‘˜å˜é‡å’Œæ–¹æ³•éƒ½æ²¡æœ‰è¢«æ‰§è¡Œ.å˜é‡çš„å†…å­˜éƒ½å·²ç»åˆ†é…,å€¼ä¸ºnullæˆ–è€…0ï¼ˆåŸºæœ¬ç±»å‹ï¼‰,false(å¸ƒå°”ç±»å‹).
å½“åˆ›å»ºä¸€ä¸ªç±»çš„å®ä¾‹æ—¶,æ­¤æ—¶ä¼šè°ƒç”¨&lt;init>æ–¹æ³•,è¿™ä¸ªæ–¹æ³•ä¼šåˆå§‹åŒ–éstaticå˜é‡å’Œæ‰§è¡Œ{}ä»£ç å—.æ³¨æ„,è¿™ä¸¤ä¸ªä¹Ÿæ˜¯æŒ‰æºç é¡ºåºæ‰§è¡Œçš„.æ‰€ä»¥ä»£ç å—å¦‚æœè¦ä½¿ç”¨éstaticå˜é‡,ä¸€å®šè¦å…ˆå®šä¹‰.åŒæ ·ideä¸€èˆ¬ä¼šæç¤ºçš„.ä½†æ˜¯è¦æ˜ç™½è¿™ä¸ªé¡ºåº.
ä»¥ä¸Šè¯´çš„æ‰§è¡Œé¡ºåºé€šè¿‡eclipseè°ƒè¯•å¯ä»¥ç¡®å®šæ˜¯æ­£ç¡®çš„.
æ‰€ä»¥ç»„åˆèµ·æ¥ åˆ›å»ºä¸€ä¸ªç±»çš„å®ä¾‹å¯¹è±¡éœ€è¦ä¸‹é¢çš„é¡ºåºï¼š
çˆ¶ç±»P staticä»£ç å—å’Œstaticå˜é‡åˆå§‹åŒ– -> å­ç±»S staticä»£ç å—å’Œstaticå˜é‡åˆå§‹åŒ– -> çˆ¶ç±»P éstaticä»£ç å—å’Œéstaticå˜é‡åˆå§‹åŒ– -> çˆ¶ç±»Pæ„é€ å‡½æ•° -> å­ç±»Séstaticä»£ç å—å’Œéstaticå˜é‡åˆå§‹åŒ– -> å­ç±»Sæ„é€ å‡½æ•° å›åˆ°é¢è¯•é¢˜ï¼šæˆ‘ä»¬çœ‹çœ‹åˆ›å»ºä¸€ä¸ªå®ä¾‹å¯¹è±¡çš„è°ƒç”¨æ ˆï¼š
å¯ä»¥çœ‹åˆ°ä¾æ¬¡è¿›å…¥16, 8, 21è¡Œä»£ç :
16è¡Œï¼š static class Sub extends Base
8è¡Œï¼š callName();//Base()æ„é€ å‡½æ•°ä¸­
21è¡Œï¼š System.out.println (baseName) ;//Subçš„callName()
æ ¹æ®å‰é¢çš„åˆ†æ,è¿™ä¸ªç±»æ²¡æœ‰staticä»£ç å—å’Œstaticå˜é‡,ä¹Ÿæ²¡æœ‰ä»£ç å—.æ‰€ä»¥ç¬¬ä¸€ä¸ªæ‰§è¡Œçš„æ˜¯çˆ¶ç±»éé™æ€æˆå‘˜çš„base=&ldquo;base&rdquo;;æ¥ç€æ‰§è¡Œæ„é€ å‡½æ•°Base();è¿™é‡Œåˆ°äº†é­”æ³•çš„ä¸€æ­¥,è°ƒç”¨çš„callName()æ˜¯å­ç±»ï¼ˆ21è¡Œï¼‰çš„æ–¹æ³•.è¿™ä¸ªè¡Œä¸ºå°±æ˜¯åŠ¨æ€å•åˆ†æ´¾.è¯¦ç»†èµ„æ–™çœ‹æœ€å.ç”±äºå­ç±»çš„éstaticå˜é‡åˆå§‹åŒ–æ²¡æœ‰å®Œæˆ,æ‰€æœ‰å­ç±»ä¸­çš„baseå˜é‡æ˜¯null.è¾“å‡ºä¹Ÿæ˜¯null.
ï¼ï¼ï¼æ‰€ä»¥,ä¸è¦å†æ„é€ å‡½æ•°ä¸­è°ƒç”¨å¯èƒ½ä¼šè¢«å­ç±»è¦†ç›–çš„æ–¹æ³•.
æœ‰çš„é¢è¯•é¢˜ä¼šå‡ºç°é™·é˜±:åœ¨è°ƒç”¨callName()æ–¹æ³•æ”¹ä¸ºthis.callName(). å…¶å®éƒ½æ˜¯ä¸€æ ·çš„.åœ¨è°ƒç”¨Baseæ„é€ å‡½æ•°æ—¶æ²¡æœ‰Baseçš„å®ä¾‹å¯¹è±¡,è°ƒç”¨è€…å…¶å®è¿˜æ˜¯Base$Subè¿™ä¸ªç±».
è¿˜æœ‰ä¸€ä¸ªè¿›é˜¶ç‰ˆï¼š
public class Basic { public void add(int i) { System.out.println("Basic add"); } public Basic() { add('a'); } public static void main(String[] args) { Basic a = new A(); B b = new B(); } } class A extends Basic { public void add(int i) { System.out.println("A add"); } } class B extends Basic { public void add(char i) { System.out.println("B add"); } } ä¸ä»…è€ƒå¯Ÿå•åˆ†æ´¾,è¿˜æœ‰é‡è½½çš„é™æ€å¤šåˆ†æ´¾. è¿›é˜¶ç‰ˆé—®é¢˜çš„è§£é‡Šéœ€ä»¥ä¸‹çŸ¥è¯†ç‚¹-javaçš„é™æ€åˆ†æ´¾å’ŒåŠ¨æ€å•åˆ†æ´¾.
CSDN-ç±»åŠ è½½æœºåˆ¶-æ·±å…¥javaè™šæ‹Ÿæœº è¯»ä¹¦ç¬”è®°
æ–¹æ³•åˆ†æ´¾
é‡è½½æ˜¯é™æ€å¤šåˆ†æ´¾,ç¼–è¯‘æ—¶æœŸç¡®å®š.
è¦†ç›–æ˜¯åŠ¨æ€å•åˆ†æ´¾,è¿è¡Œæ—¶é€šè¿‡å®é™…ç±»å‹ç»‘å®š.
é™æ€å¤šåˆ†æ´¾: æ‰€æœ‰ä¾èµ–é™æ€ç±»å‹æ¥å®šä½æ–¹æ³•æ‰§è¡Œç‰ˆæœ¬çš„åˆ†æ´¾è¿‡ç¨‹å°±å«åšé™æ€åˆ†æ´¾,é™æ€åˆ†æ´¾æœ€å…¸å‹çš„åº”ç”¨å°±æ˜¯æ–¹æ³•é‡è½½.
åŠ¨æ€å•åˆ†æ´¾: æ ¹æ®è¿è¡ŒæœŸå®é™…ç±»å‹ç¡®å®šæ–¹æ³•æ‰§è¡Œç‰ˆæœ¬çš„åˆ†æ´¾è¿‡ç¨‹å«åšåŠ¨æ€åˆ†æ´¾,åŠ¨æ€åˆ†æ´¾æœ€å…¸å‹çš„åº”ç”¨å°±æ˜¯æ–¹æ³•é‡å†™.
åŒæ—¶ç†è§£:åŠ¨æ€å•åˆ†æ´¾å°±æ˜¯å¤šæ€,javaçš„é¢å‘æ¥å£ç¼–ç¨‹çš„æ ¹åŸºå°±æ˜¯å¤šæ€.</content></entry><entry><title>Javaæ–°æ‰‹å¦‚ä½•å­¦ä¹ SpringMVCæ¡†æ¶</title><url>https://zhimoe.github.io/post/how-do-newbie-learn-spring/</url><categories><category>ç¼–ç¨‹</category></categories><tags><tag>code</tag><tag>spring</tag><tag>java</tag></tags><content type="html"> çŸ¥ä¹å›ç­”å¤‡ä»½,åŸç­”æ¡ˆå†™äº15å¹´.
6,404 äººèµåŒäº†è¯¥å›ç­”
4å¹´ä¹‹åæ„Ÿè§‰è‡ªå·±å½“å¹´å†™çš„çœŸå¥½.O(âˆ©_âˆ©)Oå“ˆå“ˆ~
è¯„è®ºé‡Œé¢æœ‰äººå†™åˆ°ç°åœ¨éƒ½ç”¨spring boot,ä¸ªäººè§‰å¾—boot åªè¦ææ¸…æ¥šä¸€ä¸ªautoconfigå°±æ‡‚äº†å°åŠäº†.
å­¦ä¹ æ¡†æ¶çš„åŒæ—¶è¿˜æ˜¯éœ€è¦é’ˆå¯¹æ€§åœ°æ·±å…¥å­¦ä¹ ä¸€äº›JavaåŸºç¡€,ä¾‹å¦‚åå°„,CDI, JDBC,Classç±»å’ŒMySQL ä»¥åŠ httpï¼ˆnginxçš„ä½¿ç”¨ï¼‰.æ±‚ç²¾ä¸æ±‚å¤š,æ–°æ‰‹ä¹Ÿä¸è¦æä»€ä¹ˆmongodb,etcd,zkè¿™äº›,æœ‰äº†å‰é¢çš„åŸºç¡€,åé¢ä¸Šæ‰‹ä½¿ç”¨æ–°ä¸œè¥¿ä¼šå¾ˆå¿«çš„. ä¸¾ä¸ªä¾‹å­,å¾ˆå¤šäººå­¦ä¹ mybatisçš„ä½¿ç”¨,ä½†æ˜¯JDBCåªä¼šä¸€ä¸ªClass.forName+Statement,æ˜¾ç„¶ä¹Ÿä¸çŸ¥é“mybatisçš„å¥½å¤„å’Œåº•å±‚çš„.
è¿˜æ˜¯è¦å¤šå†™,ä¸è¦å¤åˆ¶,å•ä¸ªé¡¹ç›®å»æ‰å¤åˆ¶ä»£ç è¿˜æœ‰5000è¡Œçš„è¯,å…¶å®å°±èƒ½å¤Ÿç†è§£åˆ°è¯¾æœ¬ä¸Šçš„â€œé«˜å†…èš,ä½è€¦åˆâ€æ˜¯ä»€ä¹ˆæ„æ€äº†.
&mdash;&mdash;&mdash;&mdash;&ndash;åŸå›ç­”&mdash;&mdash;&mdash;&mdash;&ndash;
1 æƒ³è¯´è¯´è‡ªå·±Springçš„å­¦ä¹ è·¯ç¨‹.è¯¾ä½™è‡ªå­¦Springå°†è¿‘ä¸€å¹´äº†,è¿˜æ˜¯ä¸å¾—å…¶é“.èµ·åˆæ˜¯å»å¹´ï¼ˆ14å¹´ï¼‰æš‘å‡å­¦ä¹ äº†ä¸€ä¸‹JSP,å¹¶æ²¡æœ‰æ·±å…¥ç†è§£,æ‰€ä»¥å¯¼è‡´å­¦ä¹ Springæ—¶å¯¹ç€ä¹¦æœ¬å†™ä¸€äº›demo,æ„Ÿè§‰è‡ªå·±ç†è§£äº†,å…¶å®å¹¶ä¸çŸ¥é“å†…éƒ¨æ—¶ä»€ä¹ˆåŸç†,å‡ºäº†é—®é¢˜ä¸åœçš„ç™¾åº¦,ä¸€ä¸ªå°é—®é¢˜å¥½å‡ å¤©è§£å†³ä¸äº†.
å­¦ä¹ ä¸€ç§æ¡†æ¶æœ€å…ˆéœ€è¦çŸ¥é“çš„æ˜¯ä¸ºä»€ä¹ˆéœ€è¦ä½¿ç”¨è¿™ä¸ªæ¡†æ¶,ä»»ä½•ä¸€ä¸ªæ¡†æ¶çš„å‘æ˜éƒ½æ˜¯ä¸ºäº†è§£å†³ç¼–ç¨‹ä¸­çš„ä¸€äº›ç—›ç‚¹,æ‰“å¼€ä»»ä½•ä¸€æœ¬hibernateæˆ–è€…å…¶ä»–æ¡†æ¶çš„å…¥é—¨ä¹¦,ç¬¬ä¸€ç« éƒ½æ˜¯ä»‹ç»æ¡†æ¶çš„ç†å¿µå’Œä¼˜åŠ¿.å¦‚æœéœ€è¦ç†è§£è¿™äº›ç†å¿µå’Œä¼˜åŠ¿,é‚£ä¹ˆä½ éœ€è¦çŸ¥é“ä¸ä½¿ç”¨è¿™ä¸ªæ¡†æ¶ä¹‹å‰æ˜¯æ€ä¹ˆå¤„ç†çš„,æ‰èƒ½çŸ¥é“æ¡†æ¶åšäº†ä¸€äº›ä»€ä¹ˆäº‹æƒ….
é’ˆå¯¹Springçš„å­¦ä¹ ,ç¬¬ä¸€æ­¥å°±æ˜¯äº†è§£æ²¡æœ‰springå’Œstrutsæ¡†æ¶ä¹‹å‰çš„Java webæ˜¯å¦‚ä½•å¼€å‘çš„.ä½ ä¼šçŸ¥é“é‚£æ—¶å€™ä½¿ç”¨JSPå’ŒServlet.ç„¶åä½ å°±çŸ¥é“,Servletæ˜¯ä¸€ä¸ªè§„èŒƒ,é‚£åœ¨Springé‡Œé¢,Servletå»å“ªäº†ï¼Ÿ è¿™æ—¶å€™ä½ çŸ¥é“äº†DispatchServlet.ç„¶åä½ ä¼šäº†è§£åˆ°IoCå’ŒAOP.
å¾ˆå¤šæ–°çš„æŠ€æœ¯åªä¸è¿‡æ˜¯å¼•å…¥äº†æ–°çš„ç¼–ç¨‹å…ƒç´ å¯¹åŸæ¥æŠ€æœ¯è¿›è¡Œäº†å°è£….
2 å…¶å®Java Webå¼€å‘,springä¸æ˜¯ç¬¬ä¸€æ­¥,é¦–å…ˆéœ€è¦ç†è§£çš„æ˜¯ HTTPåè®®. chromeçš„DevToolså’Œcurl,postmanè¦æœ‰åŸºæœ¬ä½¿ç”¨.
è¿˜è¦çŸ¥é“æœåŠ¡å™¨å‘é€ç»™æµè§ˆå™¨çš„å“åº”æ˜¯æ²¡æœ‰æ²¡æœ‰JS,CSSå’Œå›¾ç‰‡ç­‰å¤–éƒ¨èµ„æºçš„,æµè§ˆå™¨åœ¨è§£æå“åº”æ—¶æ‰ä¼šå†æ¬¡è¯·æ±‚è¿™äº›èµ„æº,è¿™é‡Œä¼šå‡ºç°ä¸€äº›é™æ€èµ„æºè¯·æ±‚ä¸åˆ°çš„é—®é¢˜,SpringMVCæ˜¯æ€ä¹ˆé…ç½®çš„ï¼Ÿè¿˜æœ‰chromeå¹¶å‘è¯·æ±‚æ•°é‡é™åˆ¶,å¦‚ä½•åˆå¹¶é›ªç¢§å›¾æé«˜ç½‘é¡µåŠ è½½é€Ÿåº¦ç­‰çŸ¥è¯†ç‚¹,å±äºhttpçŸ¥è¯†äº†.
æ¥ä¸‹æ¥,å­¦ä¹ Servletå’ŒJSP.è¿™ä¸ªæ­¥éª¤ä¸æ˜¯å¯ä»¥è·³è¿‡çš„,ç°åœ¨æµè¡Œçš„æ¡†æ¶Spring MVCå’ŒStruts2å…¶å®éƒ½æ˜¯åŸºäºServletçš„,åªæœ‰æ·±å…¥ç†è§£äº†Servletæ‰èƒ½ç†è§£åé¢çš„æ–°æŠ€æœ¯.
ä¸‹é¢å‡ ä¸ªçŸ¥è¯†ç‚¹å¯ä»¥æ£€æµ‹ä½ æ˜¯å¦ç†è§£äº†Servletï¼š
1ã€ä»€ä¹ˆæ˜¯ServletContext,å’Œtomcatç­‰webå®¹å™¨çš„å…³ç³»æ—¶ä»€ä¹ˆï¼ŸServlet å·¥ä½œåŸç†è§£æ
ç®€å•çš„è¯´,æˆ‘ä»¬åœ¨æµè§ˆå™¨ç‚¹å‡»é“¾æ¥å’ŒæŒ‰é’®äº§ç”Ÿçš„æ¶ˆæ¯ä¸æ˜¯å‘é€ç»™Servletçš„,è€Œæ˜¯å‘é€ç»™webå®¹å™¨çš„(åœ¨JSPå‡ºç°ä¹‹å‰,webå®¹å™¨ä¹Ÿå«Servletå®¹å™¨),webå®¹å™¨æ¥æ”¶æ¶ˆæ¯åä¸çŸ¥é“æ€ä¹ˆå¤„ç†,è½¬äº¤ç»™æˆ‘ä»¬ç¼–å†™çš„Servletå¤„ç†,é‚£ä¹ˆwebå®¹å™¨æ€ä¹ˆå’ŒServletäº¤æµå‘¢ï¼Ÿäºæ˜¯å°±å‡ºç°äº†Servletæ¥å£,æ¥å£æ˜¯å®šä¹‰ä¸€ç§è§„èŒƒçš„è‰¯å¥½è¡¨è¾¾å½¢å¼. åªè¦æˆ‘ä»¬ç¼–å†™çš„Javaç±»ç¬¦åˆServletè§„èŒƒ,é‚£ä¹ˆå°±èƒ½è¢«Webå®¹å™¨è¯†åˆ«å¹¶è¢«å®¹å™¨ç®¡ç†.
2ã€ä»€ä¹ˆæ˜¯Sessionï¼ŸSessionåœ¨å®é™…å·¥ç¨‹ä¸­çš„åº”ç”¨åœºæ™¯.ä»¥åŠ@SessionAttributeæ³¨è§£çš„å±€é™æ€§.
3ã€JSPæ˜¯é¢å‘æœåŠ¡å™¨çš„,å®ƒå¹¶ä¸çŸ¥é“æµè§ˆå™¨æ˜¯ä»€ä¹ˆé¬¼,æ˜¯æˆ‘ä»¬åœ¨å†™JSPæ—¶é¢„è®¾å®¢æˆ·ç«¯æ˜¯æµè§ˆå™¨,JSPå°±æ˜¯ä¸€ä¸ªServlet.JSPçš„å¸¸ç”¨å¯¹è±¡å’ŒæŒ‡ä»¤.
4ã€JSPçš„ä¸­æ–‡ç¼–ç ä¹±ç æœ‰å‡ ç§æƒ…å†µï¼Ÿå„è‡ªçš„è§£å†³æ–¹æ³•ï¼Ÿæç¤ºï¼š JSPæ–‡ä»¶çš„ç¼–ç ,æµè§ˆå™¨çš„è§£æç¼–ç ,GETè¯·æ±‚çš„ç¼–ç ,POSTçš„ç¼–ç .
5ã€Servletæ˜¯ä¸€ç§æ¥å£è§„èŒƒ,å…¶ä¸­è¯·æ±‚å’Œå“åº”æ˜¯Servletå®¹å™¨é€šè¿‡å‘æ–¹æ³•çš„å‚æ•°èµ‹å€¼HttpServletRequestæˆ–è€…HttpServletResponseä¼ é€’çš„.åœ¨Struts1é‡Œé¢,å°†doGet()æ–¹æ³•é‡Œçš„å“åº”ç§»åˆ°è¿”å›å€¼é‡Œ.åœ¨Struts2é‡Œåˆ™:
åœ¨Controllerä¸­å½»åº•æœç»å¼•å…¥HttpServletRequestæˆ–è€…HttpServletResponseè¿™æ ·çš„åŸç”ŸServletå¯¹è±¡.
åŒæ—¶å°†è¯·æ±‚å‚æ•°å’Œå“åº”æ•°æ®éƒ½ä»å“åº”æ–¹æ³•ä¸­å‰¥ç¦»åˆ°äº†Controllerä¸­çš„å±æ€§å˜é‡.
è¿™æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„æŠ€æœ¯æ”¹é€ ,ä¹Ÿé€ æˆäº†Struts2çš„ç››è¡Œ.Spring MVCèµ°çš„æ˜¯ä¸­é—´è·¯çº¿,Springçš„2.0.8ä¹‹å‰çš„ç‰ˆæœ¬ç”šè‡³ç›´æ¥ä½¿ç”¨Servletçš„doGetçš„.Spring MVCç°åœ¨å¼€å§‹æµè¡Œä¸»è¦è¿˜æ˜¯å› ä¸ºSchema xmlçš„ç²¾ç®€å’ŒåŸºäºæ³¨è§£çš„é…ç½®.æ‰€ä»¥è¿™é‡Œå‡ºç°äº†æ–°çš„çŸ¥è¯†ç‚¹ï¼šSchema Based XMLçš„ç›¸å…³çŸ¥è¯†å’ŒJava5å¼•å…¥çš„æ³¨è§£åŸç†.
ä¹¦ç±ï¼šæ¨èè®¸ä»¤æ³¢çš„ä¹¦ã€Šæ·±å…¥åˆ†æJava WebæŠ€æœ¯å†…å¹•(ä¿®è®¢ç‰ˆ)ã€‹å’Œè®¡æ–‡æŸ¯çš„ã€Šæ·±å…¥ç†è§£springæŠ€æœ¯å†…å¹•ã€‹,ç‰¹åˆ«æ˜¯ç¬¬äºŒæœ¬,å¯¹springçš„åˆ†æå¾ˆæ˜¯å½»åº•.</content></entry><entry><title>ä½ çš„åŠæ­¥ï¼Œæˆ‘çš„å¤©æ¶¯</title><url>https://zhimoe.github.io/post/hanamitsuki-movie-review/</url><categories><category>éšæƒ³</category></categories><tags><tag>qqç©ºé—´</tag></tags><content type="html"> å¥½ä¹…æ²¡çœ‹è¿‡çˆ±æƒ…ç”µå½±äº†ï¼Œå½“ã€Šå±±æ¥‚æ ‘ã€‹èµšå°½çœ¼æ³ªæ—¶æˆ‘æ²¡æœ‰çœ‹ï¼Œå½“ã€Šé‚£äº›å¹´ã€‹çº¢éä¸¤å²¸æ—¶ï¼Œæˆ‘æ²¡æœ‰çœ‹ã€‚å› ä¸ºæ²¡æœ‰é€‰æ‹©ï¼Œçœ‹äº†è¿™éƒ¨ç”µå½±ã€‚
ã€ŠHANAMITSUKIã€‹æ˜¯è¿™ä¸ªåå­—ï¼Œä¸­æ–‡åæ˜¯å«ã€ŠèŠ±æ°´æœ¨ã€‹ã€‚
æˆ‘åŠªåŠ›æƒ³è®°èµ·å½“ä¸­é‚£æ®µè®©æˆ‘çœ¼çœ¶æ¹¿æ¶¦çš„ç‰‡æ®µï¼Œå´æš‚æ—¶ç©ºç™½ã€‚é‚£äº›è®°ä½çš„ç‰‡æ®µæ°¸è¿œéƒ½æ˜¯å¥³ä¸»è§’é‚£æ¸©æƒ…çš„è„¸åºå’Œç”·ä¸»äººå…¬çš„çœ‰å¤´ç´§é”ï¼Œè¿˜æœ‰é‚£äº›é£˜é€¸çš„èŠ±ç“£ï¼Œå­¤ç‹¬å®ˆæœ›çš„ç¯å¡”ï¼Œè”šè“çš„å¤©ç©ºå’Œæµ·æ´‹ï¼Œç—›è‹¦çš„æ³ªæ°´å’Œå¹¸ç¦çš„æ³ªæ»´ã€‚
ç‰‡ä¸­æ‰€æ¶‰åŠåˆ°çš„äº²æƒ…å‹æƒ…çˆ±æƒ…ï¼Œæˆ‘æ˜¯æƒ³è§£é‡Šéƒ½è§£é‡Šä¸æ¸…çš„ï¼Œæµ“æµ“çš„åŒ–ä¸å¼€ï¼Œæš–æš–çš„è®©äººçªç„¶è§‰å¾—è¯¥åçœè‡ªå·±å»çæƒœè‡ªå·±èº«è¾¹çš„äº†å—ã€‚æˆ–è€…åæ€æˆ‘èº«è¾¹æœ‰é‚£ä¹ˆç±»ä¼¼çš„æ„ŸåŠ¨å—ï¼Œåº”è¯¥åšä¸ªè®©åˆ«äººä¹Ÿæ„Ÿåˆ°æ¸©é¦¨çš„äººå§ã€‚æ„ŸåŠ¨äº†ï¼Œå°±æ˜¯éƒ¨å¥½ç”µå½±ï¼Œè§‰å¾—æœ‰è¶£ä¹Ÿæ˜¯éƒ¨å¥½ç”µå½±ï¼Œæ”¶è·äº†ç†è§£äº†ï¼Œå¥¹å°±å€¼å¾—å»è¢«äººä»¬çŸ¥é“ã€‚
ç°åœ¨çœ‹åˆ°å¦‚æ­¤çš„æƒ…èŠ‚ï¼Œè‡ªå·±çš„å¿ƒå°±ä¼šæŠ½ç—›ï¼Œä»¥å‰æå°‘è¿™æ ·çš„ï¼Œä¹Ÿè®¸æ˜¯æ¯”ä»¥å‰åˆé©¶è¿‡äº†ä¸€äº›å¹´å²ï¼Œå…¶å®å¿ƒé‡Œå¾ˆä¸æ„¿æ„æ‰¿è®¤çš„è¯å°±æ˜¯â€œå°èµ„â€â€œå¤šæ„å–„æ„Ÿâ€ï¼Œå°±æ˜¯æˆ–è®¸æœ‰çš„æ—¶å€™å°±æ˜¯ä¸€ç§å…±é¸£ï¼Œç„¶åæ˜¯æ‰€è°“çš„å®£æ³„ã€‚å¿ƒç—›ï¼Œçœ¼çœ¶æ¹¿äº†ï¼Œè¿™å°±æ˜¯æ–¹å¼ä¸é€”å¾„ã€‚
ç”µå½±ï¼Œæ˜¯äºŒåå››æ ¼çš„çœŸå®ã€‚ æ•…äº‹é‡Œçš„æƒ…èŠ‚ä¸åœåœ°è®©äººæƒ³åˆ°è‡ªå·±ã€‚çˆ±æƒ…ï¼Œéœ€è¦é¢å¯¹çš„å¤ªå¤šã€‚æ‚¬æ®Šçš„ç”Ÿæ´»ç¯å¢ƒï¼Œä¸åŒçš„ç”Ÿæ´»è¯é¢˜ï¼Œé•¿é•¿çš„è·ç¦»ï¼Œæ¸ºèŒ«ä¸æ¸…çš„æœªæ¥ï¼Œè¯ºè¨€ï¼Œåœ¨è¿™äº›é¢å‰æ˜¯å¤šä¹ˆè‹ç™½æ— åŠ›ï¼ç°å®å¦‚æ­¤ç°å®ï¼Œå¦‚æœçº¯ä¸€æ²¡æœ‰ç‰ºç‰²ï¼Œæ•…äº‹ä¼šæ˜¯æ€æ ·çš„å‘¢ï¼Ÿç”µå½±é‡Œç¾å¥½çš„ç»“å±€è¢«è‡ªå·±å¿ƒé‡Œçš„ä¸€ä¸ªå‡è®¾å‡»çš„ç²‰ç¢ã€‚ ä¸€æ®µçœŸçˆ±ï¼Œç”¨å°½åå¹´æ‰èµ°åœ¨ä¸€èµ·ï¼Œç»ˆç©¶ç»™æ‰€æœ‰äººä»¥å¸Œæœ›å’Œé¼“åŠ±ã€‚åˆ›ä½œè€…æœ€å¤§çš„å¹¸ç¦æ˜¯å¯ä»¥è®©ç”µå½±ä¸åƒç°å®é‚£æ ·åˆ°å¤„é—æ†¾ï¼Œè§‚èµè€…æœ€å¤§çš„å¿«ä¹å°±æ˜¯ç”¨çœ¼ç›æ‘¸ä¸€æ‘¸è‡ªå·±çš„ç†æƒ³ï¼ï¼æˆ–æ˜¯æœ‰å…³çˆ±æƒ…çš„ï¼Œæˆ–æ˜¯æœ‰å…³äº‹ä¸šçš„ã€‚
ç”µå½±ï¼Œé£æ™¯ï¼Œæƒ³æ‰€æƒ³ï¼Œæ€ç»ªæ— è¾¹æ— é™…ã€‚å¤šæƒ³ä¹Ÿèƒ½è¿œç¦»å–§åš£å‡¡ä¿—æ‚äº‹ï¼Œæš‚æ—¶æ²‰æµ¸åœ¨ç¾å¥½å½“ä¸­ã€‚
ç¬¬äºŒéå¿«è¿›çœ‹äº†ä¸€éï¼Œå½“å¹³æ³½å›åˆ°æ—¥æœ¬,å¯¹ç€æ”¾ä¸‹æ‰‹ä¸­çš„æ´»æ¥æ¬¢è¿å¥¹çš„æ¯äº²ä¸€ç¬‘çš„é‚£ä¸ªç”»é¢æˆ‘ç»™æˆªäº†ä¸‹æ¥ã€‚é‚£æ˜¯æ€æ ·çš„ä¸€ç§ç¹åè½ï¼Œå§‹å¾—äººç”Ÿä¹‹ä¹‰ã€‚æœ€åçš„æœ€åï¼Œä¸€åˆ‡è¿˜æ˜¯å›åˆ°äº†èµ·ç‚¹ï¼Œè€Œæˆ‘ä»¬å·²ç»ä¸æ˜¯é‚£ä¸ªæ›¾ç»çš„äººäº†ï¼Œå†ç»åƒè¾›ä¸‡è‹¦ï¼Œæˆ‘ä»¬æ›´åŠ çæƒœã€‚
æ–°çš„ä¸€å¹´ï¼Œæˆ‘æƒ³å¯¹å±å¹•å‰çš„ä½ è¯´ï¼Œåœ¨å¯»æ‰¾å¹¸ç¦çš„è·¯ä¸Šï¼Œå‹‡æ•¢åœ°å»äº‰å–æ¸´æœ›çš„ï¼Œæ›´è¦çæƒœæ‹¥æœ‰çš„ï¼Œåœ¨è¿™ä¸ªæ›²æŠ˜çš„äººç”Ÿè·¯ä¸Šï¼Œé”™è¿‡ï¼Œå°±å’Œç›¸é‡ä¸€æ ·çš„å¶ç„¶ã€‚ç›¸ä¿¡çˆ±ï¼Œå› ä¸ºï¼Œç¾å¥½çš„ï¼Œä¹Ÿæ˜¯æ˜“ç¢çš„ã€‚
å¾ˆå–œæ¬¢å­™ç‡•èµ„çš„â€œé‡è§â€ï¼Œä¸ä»…å› ä¸ºå£°éŸ³ï¼Œè¿˜ä¸ºæ­Œè¯ã€‚
å¬è§ å†¬å¤©çš„ç¦»å¼€ æˆ‘åœ¨æŸå¹´æŸæœˆ é†’è¿‡æ¥ æˆ‘æƒ³ æˆ‘ç­‰ æˆ‘æœŸå¾… æœªæ¥å´ä¸èƒ½ç†æ™ºå®‰æ’ é˜´å¤© å‚æ™š è½¦çª—å¤– æœªæ¥æœ‰ä¸€ä¸ªäººåœ¨ç­‰å¾… å‘å·¦ å‘å³ å‘å‰çœ‹ çˆ±è¦æ‹å‡ ä¸ªå¼¯æ‰æ¥ æˆ‘é‡è§è° ä¼šæœ‰æ€æ ·çš„å¯¹ç™½ æˆ‘ç­‰çš„äºº ä»–åœ¨å¤šè¿œçš„æœªæ¥ æˆ‘å¬è§é£æ¥è‡ªåœ°é“å’Œäººæµ· æˆ‘æ’ç€é˜Ÿ æ‹¿ç€çˆ±çš„å·ç ç‰Œ é˜´å¤© å‚æ™š è½¦çª—å¤– æœªæ¥æœ‰ä¸€ä¸ªäººåœ¨ç­‰å¾… å‘å·¦ å‘å³ å‘å‰çœ‹ çˆ±è¦æ‹å‡ ä¸ªå¼¯æ‰æ¥ æˆ‘é‡è§è° ä¼šæœ‰æ€æ ·çš„å¯¹ç™½ æˆ‘ç­‰çš„äºº ä»–åœ¨å¤šè¿œçš„æœªæ¥ æˆ‘å¬è§é£æ¥è‡ªåœ°é“å’Œäººæµ· æˆ‘æ’ç€é˜Ÿ æ‹¿ç€çˆ±çš„å·ç ç‰Œ æˆ‘å¾€å‰é£ é£è¿‡ä¸€ç‰‡æ—¶é—´æµ· æˆ‘ä»¬ä¹Ÿå¸¸åœ¨çˆ±æƒ…é‡Œå—ä¼¤å®³ æˆ‘çœ‹ç€è·¯ æ¢¦çš„å…¥å£æœ‰ç‚¹çª„ æˆ‘é‡è§ä½ æ˜¯æœ€ç¾çš„æ„å¤– ç»ˆæœ‰ä¸€å¤© æˆ‘çš„è°œåº•ä¼šæ­å¼€</content></entry><entry><title>å†™åœ¨2012å²æœ«</title><url>https://zhimoe.github.io/post/goodbye-2012/</url><categories><category>éšæƒ³</category></categories><tags><tag>qqç©ºé—´</tag></tags><content type="html"> æ—¶å…‰å¦‚æ°´ï¼Œå“—å•¦å•¦åˆæ˜¯ä¸€å¹´ï¼› å²æœˆå¦‚æ­Œï¼Œå”å“©å“©å”±ä¸æˆè°ƒã€‚ å»å¹´å…‰æ£èŠ‚å†™äº†ç‚¹æ„Ÿæ…¨ï¼Œæœ€åæ˜¯â€œè¿™ä»ç„¶è¿˜æ˜¯æœ€å¥½çš„å¹´ä»£ï¼Œå´ä¹Ÿæ˜¯æœ€åçš„å¹´ä»£ã€‚2011å¹´çš„å†¬å¤©ï¼Œè™½ç„¶é˜³å…‰å¾ˆå¥½ï¼Œä½†é£è¿˜æ˜¯æœ‰äº›å†·ï¼Œæ„¿ä¸å›å…±å‹‰ï¼Œä½†å†·æš–è‡ªçŸ¥ã€‚â€
äº‹å®æ˜¯2012ï¼Œå†¬å¤©æ›´å†·ã€‚
è¿™ä¼šå„¿åç€å›æƒ³ä»Šå¹´ä¸€å¹´ï¼Œå‘ç°å¯¹ä¸ŠåŠå¹´çš„è®°å¿†æ˜¯ä¸€ç‰‡ç©ºç™½ã€‚æ‰€æœ‰çš„è®°å¿†æ˜¯ä»æš‘å‡å›å®¶å¼€å§‹çš„ã€‚äº‹å…ˆæ²¡æœ‰è¯´ï¼Œå‡ºè½¦ç«™æ—¶å‘äº†ä¸€æ¡çŸ­ä¿¡ï¼Œäº”åˆ†é’Ÿåæœ±æ¥æ¥æˆ‘ï¼Œæ¯æ¬¡æ”¾å‡éƒ½æ˜¯å¦‚æ­¤ã€‚ç¬¬äºŒå¤©è¿˜æ²¡èµ·åºŠï¼Œå¾å·²ç»å†’é›¨åˆ°è½¦ç«™æ¥æˆ‘ï¼Œæœ€åå†’é›¨å»ä»–å®¶ä½äº†ä¸€æ™šã€‚æˆ‘è¿™ä¸ªæœ‹å‹ï¼Œä¸€ä¸ªå­¦æœŸé‡Œç”µè¯éƒ½å¾ˆå°‘æ‰“ä¸€ä¸ªï¼Œå’Œä»–ä»¬ä¹Ÿæ²¡æœ‰å…±åŒçš„å…´è¶£çˆ±å¥½ï¼Œå´åœ¨ä¸€èµ·å³ä½¿ä¸è¯´è¯ä¹Ÿä¸è§‰å¾—å°´å°¬ã€‚
åœ¨å®¶é‡Œçš„äºŒåå‡ å¤©ï¼Œå¦ˆå¦ˆå˜ç€èŠ±æ ·åœ°åšé¥­èœï¼Œæˆ‘æ²¡é•¿èƒ–ï¼Œå¥¹è‡ªå·±å´é•¿äº†å‡ æ–¤ã€‚
å‡æœŸåªå‡ºå»ç©äº†ä¸€æ¬¡ï¼Œå’Œå¾å»æ¨å®¶ç©äº†ä¸€å¤©ï¼Œæ™šä¸Šä¸‰ä¸ªäººçœ‹å¥¥è¿ä¼šï¼Œç„¶åä¸‰ä¸ªæ¨ªç€èººåœ¨åºŠä¸Šå¬ä»–ä»¬è¯´å’Œå¥³å‹è®¤è¯†çš„æ•…äº‹ï¼ŒèŠå¤§å­¦ç”Ÿæ´»ï¼Œå¿«ä¸¤ç‚¹æ‰ç¡ç€ã€‚ç¬¬äºŒå¤©è¿˜æ˜¯ä¸‹é›¨ï¼Œä¸‰ä¸ªäººèººåœ¨åºŠä¸Šçœ‹ç”µè§†ï¼Œæ²¡æœ‰å¤šè¯´ä¸€å¥ï¼›ä¸‹åˆå†’é›¨å»æ°´åº“ç©ã€‚
ç„¶åå°±æ˜¯é’å²›å®ä¹ ã€‚æ¯å¤©éƒ½æ˜¯ç™½å¤©åè½¦çœ‹å†›èˆ°çœ‹æ½œè‰‡ï¼Œæ™šä¸Šåƒçƒ§çƒ¤å’Œæ‰å•¤ã€‚
è¿˜è®°å¾—ç©¿ç€è£¤è¡©ï¼Œè¶¿ç€æ‹–é‹å»çœ‹æµ·åº•ä¸–ç•Œçš„å¿ƒæƒ…ï¼› ä¸ºé˜¿å…‰é¥¯è¡Œé‚£ä¸ªæ™šä¸Šå–å¾—æ”¾çºµï¼› å°è±¡æœ€æ·±åˆ»çš„è¿˜æ˜¯é»„å²›çš„é£å…‰â€”â€”æ²¿ç€æµ·å²¸å…¬è·¯ï¼Œçœ‹åˆ°çš„æ˜¯é£æ ¼å„å¼‚çš„åˆ«å¢…ï¼Œæ•°ä¸æ¸…çš„é«˜å°”å¤«çƒåœºï¼Œæ¼«å±±éé‡çš„æ¡ƒæ ‘ï¼Œè“Šéƒçš„æ ‘æ—ï¼Œæ€ªçŸ³å¶™å³‹çš„å¤§ç å±±ï¼Œçº¯æœ´çš„å°æ¸”æ‘ï¼›è¿˜æœ‰é‚£è…¥å‘³çš„æµ·é£â€¦ä¸€åˆ‡éƒ½æ˜¯é‚£ä¹ˆæ–°ï¼Œé‚£ä¹ˆç¾ã€‚
å¼€å­¦åï¼Œå¹³é™äº†ã€‚è§†åŠ›æ€¥å‰§ä¸‹é™ï¼Œä»¥è‡´æ— æ³•æ­£å¸¸çœ‹ä¹¦ã€‚å†™å‘¨è®°çš„ä¹ æƒ¯ä¹Ÿæ–­äº†ï¼Œæ¯æ¯æƒ³å¥½äº†ï¼Œå´åˆè§‰å¾—æ²¡æœ‰å¿…è¦äº†ã€‚æˆ–è®¸åšçš„æœ€æœ‰æ„ä¹‰çš„ä¸€ä»¶äº‹å°±æ˜¯é”»ç‚¼å§ï¼Œèº«ä½“ç»“å®äº†å¾ˆå¤šã€‚
2012 ï¼Œæœ«æ—¥æ²¡æœ‰åˆ°æ¥ï¼Œæ˜å¤©è¿˜åœ¨è”“å»¶ï¼Œæ¸©æš–æ„ŸåŠ¨å¾ˆå¤šï¼Œä¸é¡ºçš„äº‹æƒ…æ›´å¤šã€‚2013ï¼Œä½†æ„¿è¿æ°”å¥½ä¸€äº›ã€‚
2013ï¼Œåœ¨è¡°è€ä¸­æˆç†Ÿï¼Œç”¨ä¼ªè£…çš„åšå¼ºå»æ„ŸæŸ“ç”Ÿæ´»ã€‚
è¾æ—§è¿æ–°çš„æ—¶åˆ»ï¼Œæ‘˜æŠ„è¥¿ç­ç‰™è¯—äººåŠ è¥¿äºšÂ·æ´›å°”å¡çš„è¯—å¥ï¼Œä½œä¸ºæˆ‘ä»¬å¹´å¤ä¸€å¹´çš„æ–°å¹´è®¸æ„¿çš„ç†ç”±ï¼šâ€œå› ä¸ºæˆ‘ä»¬æƒ³è¦æ¯å¤©åƒçš„é¢åŒ…ï¼Œæƒ³è¦æ¡¤æœ¨çš„èŠ±æœµå’Œæ°¸ä¹…çš„æ¸©å­˜ã€‚å› ä¸ºæˆ‘ä»¬è¦æ±‚å¤§åœ°çš„æ„å¿—èƒ½å¤Ÿå®ç°ï¼Œå°†å®ƒçš„æœå®åˆ†ç»™æ‰€æœ‰äººã€‚â€</content></entry><entry><title>å°åŸ</title><url>https://zhimoe.github.io/post/small-town/</url><categories><category>éšæƒ³</category></categories><tags><tag>qqç©ºé—´</tag></tags><content type="html"> æˆ‘ä¸å–œæ¬¢è¥¿å®‰ï¼Œå–œæ¬¢ä¸€ä¸ªåœ°æ–¹éœ€è¦æ—¶é—´ï¼Œè€Œæˆ‘è¿˜æ‰¾ä¸åˆ°ç†ç”±ã€‚æˆ‘ä¸å–œæ¬¢å› ä¸ºæˆ‘ä»…ä»…æ˜¯åœ¨è¿™é‡Œç”Ÿæ´»ã€‚
æˆ‘å–œæ¬¢ç‰å±±ï¼Œå› ä¸ºé‚£é‡Œæœ‰æ›¾ç»çš„æˆ‘ã€‚ä¸€ä¸ªäººèµ°åœ¨è¡—ä¸Šï¼Œå¿½ç„¶å°±è§‰å¾—è¿™ä¸€å¹•å¥½ç†Ÿæ‚‰ï¼Œåˆ†æ˜æœ‰ä¸€å¤©è‡ªå·±ä¹Ÿæ˜¯è¿™ä¹ˆèµ°ç€ï¼Œé‚£å¤©æˆ‘è¦å»å¹²ä»€ä¹ˆï¼Ÿæˆ‘å·²ç»è®°ä¸å¾—ï¼Œç”šè‡³æœ‰å¯èƒ½æ˜¯ä¸€ç§å¹»è§‰ã€‚
ä¸€ä¸ªèƒ½è®©è‡ªå·±äº§ç”Ÿå¹»è§‰çš„åœ°æ–¹ï¼Œå¿…ç„¶æ˜¯ä½ ç•™ä¸‹äº†å¤ªå¤šçš„è®°å¿†åœ¨é‚£é‡Œï¼Œç•™ä¸‹äº†å¤ªå¤šçš„ä¸èˆå’Œç‰µæŒ‚ã€‚
è¥¿å®‰æ²¡æœ‰ç»™æˆ‘ä»€ä¹ˆï¼Œæˆ–è€…è¯´è¿˜æ²¡æœ‰å‘ç”Ÿä»€ä¹ˆï¼Œå¥¹æ— éœ€ç»™æˆ‘ä»€ä¹ˆï¼Œæ˜¯æˆ‘çš„é²è½é—¯å…¥ã€‚å¤šæƒ…åœ°æƒ³èµ·äº†ç‰å±±é‚£ä¸ªå°åŸã€‚å¤šå°‘å¹´åå½“æˆ‘å›æƒ³èµ·è¥¿å®‰ä¼šä¸ä¼šä¹Ÿåƒæƒ³èµ·ç‰å±±ä¸€æ ·&ndash;äº›è®¸ç”œèœœäº›è®¸å¿§ä¼¤äº›è®¸æ»¡è¶³äº›è®¸é—æ†¾ï¼Ÿ
ç‰å±±æœ€é«˜çš„åœ°æ–¹æ˜¯å¡”å±±ï¼Œè€Œæˆ‘ç«Ÿæ²¡æœ‰ç™»è¿‡é¡¶ã€‚å¦‚æœé‚£å¤©æˆ‘æ¥è¿‡äº†ä½ é€’è¿‡æ¥å‰¥å¥½çš„ç“œå­ä»ï¼Œäº‹æƒ…ä¼šä¸ä¼šæ˜¯å¦ä¸€ç•ªæ¨¡æ ·ï¼Ÿ
â€œå®¶åœ¨æ•…æ—å´æ¥šé—´ï¼Œå†°ä¸ºæºªæ°´ç‰ä¸ºå±±â€é¢˜ç›®é—®ä½œè€…æ˜¯è°ã€‚æˆ‘æ²¡æœ‰è®°ä½è€å¸ˆç»™çš„ç­”æ¡ˆã€‚ä¸¤å¹´åæˆ‘ç«™åœ¨ä½œè€…çš„å¡‘åƒå‰ï¼Œä¸€ç›´æƒ³èµ·å½“æ—¶æ²¡æœ‰ç­”ä¸Šé—®é¢˜æ—¶ä½ åœ¨æœæˆ‘å·ç¬‘çš„ç”»é¢ã€‚
â€œå¤ªé˜³æ–œäº†ï¼ŒåŸé‡Œå¤´èµ·äº†ç‚ŠçƒŸï¼Œæ°´ä¸Šçš„çƒŸæ³¢ä¹Ÿå¸¦ä¸Šäº†çº¢å½±ã€‚è¥¿åŒ—çš„é«˜å±±ä¸€å¸¦ï¼Œæœ‰ä¸€ä¸ªå°–å³°ï¼Œæ´»åƒå€’æ’çš„ç¬”å°–ï¼Œå¤§çº¦æ˜¯æ€€ç‰å±±äº†ç½¢ï¼Ÿ"â€è¿™æ˜¯1933å¹´çš„ç‰å±±ã€‚ å½“å¹´éƒè¾¾å¤«è¯´çš„â€œå®åœ¨æ˜¯å¨å°¼æ–¯é‡Œçš„ä¸€æ¡é€šè¡¢â€çš„æ²¿æ²³ï¼Œå¦‚ä»Šè¢«æ”¹å»ºçš„åƒç”»ä¸€èˆ¬ã€‚
å¾ˆå–œæ¬¢æ²¿æ²³è·¯ï¼Œå¯†å¯†çš„æŸ³æ¡ï¼Œæ’’åœ¨æ–‘é©³çš„é˜³å…‰ï¼Œèµ°åœ¨å…¶é—´ï¼Œèƒ½è§¦æ‘¸åˆ°å¿ƒä¸­çš„æ‚²æ‚²æˆšæˆšã€‚å°±é‚£ä¹ˆé™é™åœ°çœ‹ç€é‚£äº›å‚é’“è€…ï¼Œæˆ–è€…ç«™åœ¨çŸ³æ¡Œæ—çœ‹é‚£ç¾¤è€è€…ä¸‹æ£‹ï¼Œéƒ½æ˜¯é‚£ä¹ˆè®©äººäº«å—ã€‚è¶´åœ¨æ æ†ä¸Šï¼Œæœ›ç€é‚£è¥¿æµè€Œå»çš„å†°æºªæ°´ï¼Œå¾®å‡‰çš„æƒ…ç»ªä¹Ÿä¼šéšç€æ²³é¢è¿‡æ¥çš„é£æ‘†è¡ã€‚å­¦æ ¡å—é—¨å¤–çš„ä¸€æ®µï¼Œç•™ä½äº†å¤ªå¤šä¸€ä¸­å­¦å­çš„è®°å¿†ã€‚å¤šå°‘å¹´è½»çš„èª“è¨€æ¢¦å‘€ï¼Œéƒ½å’Œé‚£é‡Œçš„éº»è¾£çƒ«æœ‰å…³ã€‚é‚£äº›çƒ­é—¹çš„å¤œæ™šï¼Œç°åœ¨è¿˜ä¼šä¸ä¼šæœ‰ï¼Ÿ
â€œçƒ­é—¹æ˜¯ä»–ä»¬çš„ã€ã€ã€â€
ç«™åœ¨é˜³å°ä¸Šï¼Œçœ‹ç€ç§¦å²­ï¼Œæƒ³åˆ°é‚£å¥â€œè¥¿åŒ—æœ›é•¿å®‰ï¼Œå¯æ€œæ— æ•°å±±â€ï¼Œç§¦å²­ç”±ä¸œå‘è¥¿èµ°ï¼Œæ— è®ºä»è¥¿åŒ—å¾€é•¿å®‰çœ‹ï¼Œè¿˜æ˜¯ä»é•¿å®‰å¾€è¥¿åŒ—çœ‹ï¼Œéƒ½æ²¡æœ‰æ¯”ç§¦å²­æ›´é«˜çš„å±±äº†ã€‚ä¸çŸ¥é“æ€ä¹ˆè§£é‡Šï¼Œè¿™é‡Œå¤ªé˜³è‡ªç„¶ä¹Ÿä¸‹å¾—æ™šï¼Œå…­ç‚¹å¤šäº†è¿˜æ˜¯çƒ­æƒ…ä¸å‡ï¼Œè®©äººè§‰å¾—ç§¦å²­æ˜¯ç«™é”™äº†ä½ç½®ï¼Œå®¤å‹è¯´è¦æ˜¯çœŸç«™åœ¨è¥¿è¾¹ï¼Œå†¬å¤©ä½ åˆè¯¥æŠ±æ€¨äº†ã€‚æˆ‘è‹¦ç¬‘ï¼Œæˆ–è®¸æ˜¯å§ï¼åæ­£æˆ‘å¯¹è‡ªå·±ä¸äº†è§£ã€‚
æœ›ç€ç§¦å²­ï¼Œæƒ³ç€ç‰å±±çš„å¡”å±±ä¸å†°æºªæ²³ï¼Œæƒ³åˆ°äº†é‚£å¥â€œæ—¥æš®ä¹¡å…³ä½•å¤„æ˜¯ï¼ŒçƒŸæ³¢æ±Ÿä¸Šä½¿äººæ„â€ã€‚</content></entry><entry><title>ä¸€ç‚¹å›å¿†</title><url>https://zhimoe.github.io/post/some-memories-about-mother/</url><categories><category>éšæƒ³</category></categories><tags><tag>qqç©ºé—´</tag></tags><content type="html"> æˆ‘æƒ³è¿™ä¸æ˜¯ä¸€ç¯‡å›å¿†ï¼Œè€Œæ˜¯å¿ƒæƒ…ã€‚é»˜å­˜è¯´æˆ‘ä»¬å¹´è½»æ—¶å¾ˆå®¹æ˜“æŠŠè‡ªå·±çš„å†™ä½œå†²åŠ¨å½“æˆä¸€ç§å†™ä½œæ‰èƒ½ã€‚æˆ‘è‡ªçŸ¥æ²¡æœ‰å¦‚æ­¤é«˜é›…çš„æ‰èƒ½ã€‚ä½†ä¹Ÿä¸æƒ³åœ¨æŸä¸€å¤©çªç„¶å‘ç°è‡ªå·±è¢«æ—¶é—´æ¨ç€å¾€å‰èµ°ã€‚é˜¿ä¸ƒè¯´é•¿æ—¶é—´çš„å¯‚å¯æ˜¯æ‰€æœ‰å†™ä½œçš„æ»¥è§ã€‚æˆ–è®¸æˆ‘çš„ç¡®æ˜¯å¯‚å¯çš„å§ï¼ä¸€ä¸ªäººèµ°åœ¨æ— äººçš„è·¯ä¸Šï¼Œå¾€äº‹å°±åœ¨è¡—è§’å¤„çœ‹è§äº†â€¦â€¦
ä¸­è€ƒåçš„ç¬¬äºŒå¤©ï¼Œæˆ‘å°±è¯´æœæ¯äº²è®©æˆ‘å»æ‰“å·¥ã€‚å¥¹åœ¨æ‹…å¿ƒä¹‹ä½™è¯•å›¾é˜»æ­¢ï¼Œå´ç”¨é”™äº†æ–¹æ³•ï¼ï¼æ€»æ˜¯æŒ–è‹¦æˆ‘ï¼šä¸€å®šæ˜¯æ²¡è€ƒå¥½å§ï¼Ÿæƒ³èº²å‡ºå»å§ï¼Ÿè¢«æ¿€å°†çš„æˆ‘æ›´åŠ åšå®šè¦å»æ‰“å·¥äº†ã€‚è¯´å®è¯è€ƒäº†ä»¥åçœŸçš„æ²¡åº•ï¼Œæ„Ÿè§‰å¾ˆä¸€èˆ¬ï¼Œè¯´ä¸å‡ºå¥½ä¹Ÿè¯´ä¸å‡ºåã€‚è€Œè¿™ç§æƒ…å†µæ˜¯æœ€æŠ˜ç£¨äººçš„ï¼Œç—›è‹¦çš„åƒéš¾äº§ã€‚ä¸­è€ƒåçš„ç¬¬ä¸‰å¤©ï¼Œæˆ‘ç‹¬è‡ªä¸€äººç™»ä¸Šäº†å»ä¸½æ°´çš„ç«è½¦ã€‚
è¿™æ˜¯æˆ‘ç¬¬ä¸€æ¬¡åç«è½¦ã€‚æ¯äº²å¸®æˆ‘ä¹°äº†è½¦ç¥¨åå°±å›å»äº†ï¼Œè€Œæˆ‘ç‹¬è‡ªç­‰äº†ä¸€ä¸ªå¤šå°æ—¶çš„è½¦ã€‚æˆ‘æƒ³æ¯äº²çš„ä¼Ÿå¤§å°±åœ¨äºè¿™æ ·æ”¾å¿ƒè€Œåˆç”¨å¿ƒåœ°å»åŸ¹å…»è‡ªå·±çš„å­©å­çš„è‡ªç«‹èƒ½åŠ›å§ï¼è™½ç„¶æœ‰æ—¶æˆ‘ä¹Ÿæ€€ç–‘æ˜¯å¦å› ä¸ºå“¥å“¥ç»§æ‰¿äº†å¥¹çš„æ‰€æœ‰ä¼˜ç§€å“è´¨ï¼Œä»å°åˆ°å¤§è®©å¥¹æ˜¯å¦‚æ­¤åœ°æ”¾å¿ƒä¸éª„å‚²ä»¥è‡´äºå¥¹è®¤ä¸ºå¥¹çš„å­©å­éƒ½åº”è¯¥æ˜¯é‚£æ ·çš„ç‹¬ç«‹è‡ªä¸»ã€‚
æˆ‘èƒŒç€ä¸ªå¤§ä¹¦åŒ…ç«™åœ¨é‚£æœ›ç€æ¯äº²çš„èƒŒå½±ï¼Œè™½ç„¶æ­£åˆåäºŒç‚¹çš„çƒˆæ—¥ä¸‹é‚£æ™ƒåŠ¨çš„ç©ºæ°”è®©èƒŒå½±æœ‰ç‚¹æ¨¡ç³Šï¼ŒåŠ ä¸Šåœ¨é‚£æ–°å»ºçš„ç«è½¦ç«™å¹¿åœºä¸Šï¼Œçœ‹ä¸Šå»èƒŒå½±æ›´åŠ æ˜¾å¾—å°äº†ï¼Œä½†é‚£ä¸€åˆ»ï¼Œæœ›ç€æ¯äº²çš„èƒŒå½±ï¼Œæˆ‘æ„Ÿåˆ°å¾ˆæ¬£æ…°ï¼Œæ˜¯çš„ï¼Œæ˜¯æ¬£æ…°ï¼Œæˆ–è€…è¯´æ˜¯æ»¡è¶³ã€‚é‚£ä¸ªæ›¾ç»ç—…å¾—åªå‰©ä¸åˆ°ä¸ƒåæ–¤çš„äººï¼Œç°åœ¨å·²ç»èƒ½å¥æ­¥å¦‚é£äº†ï¼›é‚£ä¸ªæ›¾ç»ç—…å¾—æ²¡æœ‰ä¸€æ ¹å¤´å‘çš„äººï¼Œç°åœ¨åˆæœ‰äº†ä¸€å¤´é»‘å‘ï¼Œè™½ç„¶è¿‘çœ‹æœ‰äº›è®¸é“¶ä¸ï¼›é‚£å¼ æ›¾ç»å› ä¸ºè¿›å£è¯å’Œç—…æ¯’è€Œå½»åº•å˜å½¢çš„è„¸ç°åœ¨åˆæ¢å¤å¥åº·äº†ï¼Œè™½ç„¶æœ‰ä¸€ç‚¹æµ®è‚¿â€¦ä½†ç»ˆç©¶è¿˜æ˜¯å¥åº·çš„ã€‚è¿™ä¸ªä¼Ÿå¤§çš„æ¯äº²ï¼Œæˆ–è®¸æ˜¯æ”¾ä¸ä¸‹è‡ªå·±çš„å®¶äººï¼Œåœ¨è¢«åŒ»ç”Ÿå®£å¸ƒæ— æ•‘ååˆæ´»è¿‡æ¥äº†ï¼Œé‚£ä¸€å¤©ï¼Œå’Œæ¯äº²åŒç—…æˆ¿çš„æœ‰ä¸¤ä¸ªæ‰‹æœ¯å¤±è´¥æ°¸è¿œåœ°èµ°äº†â€¦
æˆ‘æ°¸è¿œéƒ½å¿˜ä¸äº†é‚£ä¸€å¤©ï¼Œæˆ‘åœ¨ä¸Šç¬¬ä¸‰èŠ‚è¯¾æ—¶å¤§å¨˜æ¥æ‰¾æˆ‘ï¼Œæ²¡æœ‰ä¸Šè¿‡ä¸€å¤©å­¦çš„å¥¹ä¸€ç›´ç­‰åˆ°æ”¾å­¦æ‰æ•¢è¿›ç­å«æˆ‘ã€‚æˆ‘è·Ÿç€å¥¹å›å®¶ï¼Œèµ°åˆ°å°è·¯ä¸Šï¼Œå¥¹ä»¥é‚£ç§æ—äººè«ä¸å…³å¿ƒçš„è¯­æ°”è¯´ï¼šâ€œä½ å¦ˆä¸è¡Œäº†ï¼Œä»Šå¤©å°±è¦å›æ¥äº†ã€‚â€ä¸çŸ¥æ˜¯å¹´å°‘å¯¹æ­»äº¡çš„æ— çŸ¥æ— æƒ§è¿˜æ˜¯å¿«ä¸¤å¹´æ²¡æœ‰è§åˆ°æ¯äº²å·²ç»å¯¹è¿™ä¸ªæ¦‚å¿µæ²¡æœ‰å¤šå°‘æ„Ÿè§‰äº†ï¼Œå¬åˆ°è¿™å¥è¯åæˆ‘å¾ˆå®‰é™ï¼Œåªæ˜¯çªç„¶è§‰å¾—å¤©å¿«é»‘äº†ï¼Œåº”è¯¥å¿«ç‚¹å›å»ã€‚æˆ‘ä¸€è·¯å°è·‘ï¼ŒæŠŠå¤§å¨˜ç”©åœ¨åé¢ã€‚è¯¥æ€æ ·å»åŸè°…è‡ªå·±ï¼Œæ›¾ç»çš„æ— çŸ¥ä¸å¹¼ç¨šã€‚è¿‘ä¸¤å¹´é‡Œæˆ‘åªè§è¿‡æ¯äº²ä¸€é¢ï¼Œæš‘å‡é‡Œæˆ‘ç†äº†ä¸ªå…‰å¤´å»å¤–å©†å®¶ï¼Œåœ¨é‚£é‡Œæˆ‘çœ‹åˆ°äº†æ¯äº²ï¼Œå¥¹å¿ƒç–¼åœ°é—®ä¸ºä»€ä¹ˆç†å…‰å¤´ï¼Œæ˜¯ä¸æ˜¯è‡ªå·±ä¸ä¼šæ´—å¤´ï¼Ÿæˆ‘æ‰§æ‹—åœ°æ²¡æœ‰å›ç­”ï¼Œå¿ƒé‡Œæ€ä¹ˆä¹Ÿä¸æ„¿æ„æ‰¿è®¤èººåœ¨åºŠä¸Šçš„é‚£ä¸ªäººå°±æ˜¯æ¯äº²ã€‚ä¹Ÿæ˜¯åœ¨é‚£ä¸€åˆ»ï¼Œæˆ‘å‘ç°è‡ªå·±ä»¥å‰ä»æ²¡æœ‰ä»”ç»†çœ‹è¿‡æ¯äº²é‚£å¼ æ¼‚äº®çš„è„¸ï¼Œç°åœ¨ç•™ä¸‹çš„åªæ˜¯æ¨¡ç³Šçš„å›å¿†ã€‚è€Œå½“æˆ‘åœ¨å†™è¿™äº›å­—æ—¶ï¼Œæˆ‘åªèƒ½å›æƒ³èµ·ä¸€ä¸ªç”»é¢ï¼é‚£æ—¶åº”è¯¥è¿˜å…­ä¸ƒå²æ—¶ï¼Œæˆ‘å’Œæ¯äº²å»å±±ä¸Šæ‰“æŸ´ï¼Œæ¯äº²æ‰“æŸ´æ—¶æˆ‘å°±åœ¨è¾¹ä¸Šæ‰¾é¹…åµçŸ³ï¼Œæœ‰ç‰¹è‰²çš„çŸ³å¤´ã€‚åˆè®©å¥¹ç»™æˆ‘åšä¸€æŸ„æœ¨å‰‘ï¼ŒæŠŠæ‰€æœ‰çš„æ ‘å½“æˆæ•Œäººå»ç ã€‚å›å»æ—¶ï¼Œå¥¹æŒ‘ç€ä¸€æ‹…æŸ´ï¼Œæˆ‘è·Ÿåœ¨å¥¹åé¢ï¼Œå£è¢‹é‡Œè£…æ»¡äº†çŸ³å¤´ï¼Œæ‹¿ç€é•¿æœ¨å‰‘ï¼Œçªç„¶è„šä¸€æ»‘æ‘”å€’äº†ï¼Œå¥¹é©¬ä¸Šæ‰”ä¸‹æ‹…è·‘è¿‡æ¥æ‰¶æˆ‘èµ·æ¥ï¼Œå¸®æˆ‘æ“¦æ±—å¹¶è¹²ä¸‹æ¥ç¬‘ç€æŠŠæˆ‘å£è¢‹é‡Œçš„çŸ³å¤´éƒ½è£…è¿›å¥¹çš„è¢‹å­é‡Œï¼Œä¹Ÿå°±æ˜¯åœ¨é‚£ä¸€åˆ»æˆ‘çœ‹äº†çœ‹æ¯äº²çš„è„¸ï¼Œç™½çš™çš„ï¼Œé“ºæ»¡äº†ç¢ç¢çš„æ±—ç ï¼Œå¾®ç¬‘ç€è´£æ€ªæˆ‘è£…è¿™ä¹ˆå¤šçŸ³å¤´ã€‚æˆ‘æŠŠç©äº†æ³¥å·´çš„æ‰‹å¾€å¥¹è„¸ä¸Šä¸€æŠ¹æ’’è…¿å°±è·‘ï¼Œå¥¹ä¹Ÿä¸è¿½ï¼Œæ‹¿ä¸‹æ¯›å·¾ä»”ç»†åœ°æŠŠè„¸æ“¦å¹²å‡€äº†æ‰èµ·èº«ã€‚æœ€ç»ˆæˆ‘è¿˜æ˜¯æ²¡è®°ä½æ¯äº²å½“å¹´çš„æ¨¡æ ·ï¼Œåªæ˜¯æƒ³èµ·é‚£å¾®ç¬‘çš„æ„Ÿè§‰ä¾æ—§æ˜¯é‚£æ ·çš„æ¸©æš–ã€‚æœ‰æ—¶è®¿äº²æ—¶èƒ½ä»äº²å‹ä»¬çš„å£ä¸­çŸ¥é“æ¯äº²å¹´è½»æ—¶çš„ç¡®æ˜¯å¾ˆå¥½çœ‹çš„â€¦â€¦â€¦
æˆ‘å°±å°±é‚£æ ·ç«™åœ¨çƒˆæ—¥ä¸‹æœ›ç€æ¯äº²è½¬è¿‡è¡—è§’ï¼Œä¸€é¢—æ±—ç æ²¿ç€æˆ‘çš„ç«æ¯›æ»‘è¿›äº†çœ¼çœ¶ï¼Œåˆç«‹åˆ»æº¢äº†å‡ºæ¥ï¼Œé¡ºç€è„¸é¢Šæ»´åœ¨åœ°ä¸Šï¼Œè¿˜æ²¡æ¥å¾—åŠæº…å¼€å°±è¢«é‚£åšåšçš„ç°ç»™å¸å¹²äº†ï¼Œå·æˆäº†ä¸€ä¸ªæ³¥ç ã€‚
åœ¨å€™è½¦å®¤é‡Œæˆ‘çœ‹åˆ°è®¸å¤šå­¦ç”Ÿï¼Œæœ‰äº›æ˜¯æˆ‘çš„åŒå­¦ï¼Œä»–ä»¬ä¹Ÿåœ¨ç­‰è½¦ï¼Œä»–ä»¬ä¸­æœ‰çš„æ˜¯å»å®¶é•¿é‚£é‡Œç©ï¼Œæ›´å¤šçš„æ˜¯å·²ç»å†³å®šäº†ä¸è¯»ä¹¦äº†ï¼Œå‡ºå»æ‰“å·¥ï¼Œåšç”Ÿæ„ã€‚çœ‹ç€ä»–ä»¬æœ‰è¯´æœ‰ç¬‘ï¼Œæˆ‘å¿½ç„¶è§‰å¾—ä»–ä»¬æ˜¯å¹¸ç¦çš„ï¼Œå› ä¸ºä»–ä»¬å·²ç»æ¸…æ¥šäº†æ–¹å‘ï¼Œè™½ç„¶å‰é€”è‰°è¾›è€Œæ¼«é•¿ï¼Œä½†ä»–ä»¬æ˜¯é‚£æ ·çš„å¹´è½»è€Œä¹è§‚ï¼Œå°†ç”¨è‡ªå·±çš„åŒæ‰‹å»å¼€åˆ›è‡ªå·±çš„æœªæ¥ã€‚è€Œæˆ‘å‘¢ï¼Œå°±åƒä¸€åªè¢«æåœ¨ç©ºä¸­çš„é¸­å­ï¼Œä¸çŸ¥é“è¢«æ‰”ä¸‹å»æ—¶ä¸‹é¢æ˜¯æ°´è¿˜æ˜¯æ²¹ã€‚
ç«è½¦å¯åŠ¨çš„é‚£ä¸€åˆ»ï¼Œæˆ‘é€è¿‡ç»ç’ƒçœ‹ç€é™Œç”Ÿçš„ç«™å°ï¼Œå¿ƒé‡Œç¬¬ä¸€æ¬¡æœ‰äº†ä¸€ç‚¹å­¤ç‹¬æ„Ÿï¼Œé‚£è¯ºå¤§çš„ç«™å°äº¦æ˜¯ä¸€æ ·å§ï¼šç›®é€ç€ä¸€æ‰¹åˆä¸€æ‰¹çš„äººç”Ÿæ‹“è’è€…ï¼Œè§è¯ç€ä¸€åœºåˆä¸€åœºåˆ†åˆ«æ—¶çš„æ³ªé£ï¼Œè¿æ¥äº†ä¸€ç¾¤åˆä¸€ç¾¤éª„å‚²æˆ–è½é­„çš„å½’å®¢â€¦ä»–æ˜¯çŸ¥é“çš„é‚£ä¹ˆå¤šï¼Œä»–æœ‰é‚£ä¹ˆå¤šçš„æ•…äº‹å¯è®²ï¼Œå¯æ˜¯æ²¡æœ‰äººè‚¯åœä¸‹æ¥å¬ä¸€å¬ä»–çš„è¯‰è¯´ï¼Œè½¦ç«™é‡Œçš„äººæ°¸è¿œæ˜¯é‚£æ ·çš„åŒ†å¿™â€¦â€¦â€¦
2010å¹´7æœˆ</content></entry></search>